Asmc Macro Assembler (x64) Version 2.34.27  04/04/23 04:57:19 - First Pass
C:\Asmc\source\asmc\src\expans.asm
00000000                    *   _TEXT segment PARA FLAT PUBLIC 'CODE'
                            *   _TEXT ends
00000000                    *   _DATA segment PARA FLAT PUBLIC 'DATA'
                            *   _DATA ends
                            *   assume cs:flat,ds:flat,ss:flat,es:flat,fs:ERROR,gs:NOTHING
                                ; EXPANS.ASM--
                                ;
                                ; Copyright (c) The Asmc Contributors. All rights reserved.
                                ; Consult your license regarding permissions and restrictions.
                                ;
                                ; do macro expansion.
                                ;
                                ; functions:
                                ; - myltoa()         generic function which replaces ltoa()
                                ; - RunMacro         run a macro
                                ; - ExpandText       expand a source line when % operator is at pos 0
                                ; - ExpandLineItems   expand parts of a source line
                                ; - ExpandLine       expand a source line
                                ; - ExpandLiterals    expand <> or {} literals for struct initialization
                                ;

                                include asmc.inc
                              C ; ASMC.INC--
                              C ;
                              C ; Copyright (c) The Asmc Contributors. All rights reserved.
                              C ; Consult your license regarding permissions and restrictions.
                              C ;
                                include memalloc.inc
                              C ; MEMALLOC.INC--
                              C ;
                              C ; Copyright (c) The Asmc Contributors. All rights reserved.
                              C ; Consult your license regarding permissions and restrictions.
                              C ;
                              C ifndef __MEMALLOC_INC
 = 0                          C define __MEMALLOC_INC
                              C 
                              C MemAlloc    proto fastcall :uint_t
                              C MemFree     proto fastcall :ptr
                              C LclAlloc    proto fastcall :uint_t
                              C MemInit     proto
                              C MemFini     proto
                              C 
                              C LclDup      proto fastcall :string_t
                              C MemDup      proto fastcall :string_t
                              C 
                              C endif
                                include malloc.inc
                              C ifndef _INC_MALLOC
 = 0                          C define _INC_MALLOC
                              C endif
                                include parser.inc
                              C ; PARSER.INC--
                              C ;
                              C ; Copyright (c) The Asmc Contributors. All rights reserved.
                              C ; Consult your license regarding permissions and restrictions.
                              C ;
                              C ; Parser items
                              C ;
                              C ifndef __PARSER_INC
 = 0                          C define __PARSER_INC
                              C 
                              C include operands.inc
                              C ; OPERANDS.INC--
                              C ;
                              C ; Copyright (c) The Asmc Contributors. All rights reserved.
                              C ; Consult your license regarding permissions and restrictions.
                              C ;
                              C ; parser/code generator operand definitions.
                              C ; This file is included by parser.inc
                              C ;
                              C ifndef OPERANDS_H
 = 0                          C define OPERANDS_H
                              C 
                              C ; v1.96: OP_J32 (for far CALL/JMP) has been removed, now used for OP_I64.
                              C ; v2.04: 2 bits freed ( OP_CR, OP_DR and OP_TR replaced by OP_SPECREG )
                              C ; Also OP_SPECREG, OP_SRxx and OP_STxx moved just behind the other
                              C ; register operands.
                              C ; Note: register-related flags must be in bits 0-15, because register items
                              C ; in SpecialTable[] have these bits stored in a uint field (JWASMR!).
                              C 
                              C 
 = 0                          C OP_NONE		equ 0x00000000
 = 1                          C OP_R8		equ 0x00000001
 = 2                          C OP_R16		equ 0x00000002
 = 4                          C OP_R32		equ 0x00000004
 = 8                          C OP_R64		equ 0x00000008
 = 10                         C OP_XMM		equ 0x00000010
 = 20                         C OP_YMM		equ 0x00000020
 = 40                         C OP_ZMM		equ 0x00000040
 = 80                         C OP_A		equ 0x00000080 ; AL, AX, EAX, RAX registers
 = 100                        C OP_M08		equ 0x00000100
 = 200                        C OP_M16		equ 0x00000200
 = 400                        C OP_M32		equ 0x00000400
 = 800                        C OP_M64		equ 0x00000800
 = 1000                       C OP_M128		equ 0x00001000
 = 2000                       C OP_M256		equ 0x00002000
 = 4000                       C OP_M512		equ 0x00004000
 = 8000                       C OP_MMX		equ 0x00008000
 = 10000                      C OP_I8		equ 0x00010000
 = 20000                      C OP_I16		equ 0x00020000
 = 40000                      C OP_I32		equ 0x00040000
 = 80000                      C OP_I64		equ 0x00080000
 = 100000                     C OP_K		equ 0x00100000 ; Mask reg
 = 200000                     C OP_M48		equ 0x00200000
 = 400000                     C OP_M80		equ 0x00400000
 = 800000                     C OP_CL_ONLY	equ 0x00800000 ; CL register
 = 1000000                    C OP_DX_ONLY	equ 0x01000000 ; DX register
 = 2000000                    C OP_RSPEC	equ 0x02000000 ; CRx, DRx, TRx registers
 = 4000000                    C OP_SR86		equ 0x04000000 ; CS, DS, ES, SS registers
 = 8000000                    C OP_SR386	equ 0x08000000 ; FS, GS registers
 = 10000000                   C OP_ST		equ 0x10000000 ; ST0 register
 = 20000000                   C OP_ST_REG	equ 0x20000000 ; ST1-ST7 registers
 = 40000000                   C OP_I48		equ 0x40000000 ; used for immediate FAR call/jmp
                              C 
                              C ; OP_I_1, OP_I_3 and OP_I8_U aren't flags. They are
                              C ; used as values in SWITCH statements only. It's possible to
                              C ; "compress" them if room for another flag is needed
                              C 
 = 210000                     C OP_I_1		equ 0x00200000 or OP_I8
 = 410000                     C OP_I_3		equ 0x00400000 or OP_I8
 = 870000                     C OP_I8_U		equ 0x00800000 or OP_I8 or OP_I16 or OP_I32
                              C 
 = 81                         C OP_AL		equ OP_A or OP_R8
 = 82                         C OP_AX		equ OP_A or OP_R16
 = 84                         C OP_EAX		equ OP_A or OP_R32
 = 88                         C OP_RAX		equ OP_A or OP_R64
 = 2000010                    C OP_RIP		equ 16 or OP_RSPEC
 = 800001                     C OP_CL		equ OP_CL_ONLY or OP_R8
 = 1000002                    C OP_DX		equ OP_DX_ONLY or OP_R16
 = E                          C OP_RGT8		equ OP_R16 or OP_R32 or OP_R64
 = C                          C OP_RGT16	equ OP_R32 or OP_R64
 = F                          C OP_R		equ OP_R8 or OP_R16 or OP_R32 or OP_R64
 = C000000                    C OP_SR		equ OP_SR86 or OP_SR386
 = 30000000                   C OP_STI		equ OP_ST or OP_ST_REG
                              C 
 = 70000                      C OP_I		equ OP_I8 or OP_I16 or OP_I32
 = 70000                      C OP_IGE8		equ OP_I8 or OP_I16 or OP_I32
 = 60000                      C OP_IGE16	equ OP_I16 or OP_I32
 = 400F0000                   C OP_I_ANY	equ OP_I or OP_I64 or OP_I48
                              C 
 = E00                        C OP_MGT8		equ OP_M16 or OP_M32 or OP_M64
 = C00                        C OP_MGT16	equ OP_M32 or OP_M64
 = 600400                     C OP_MFPTR	equ OP_M32 or OP_M48 or OP_M80
 = 607F00                     C OP_M_ANY	equ OP_M08 or OP_M16 or OP_M32 or OP_M64 or OP_M128 or OP_M256 or OP_M512 or OP_M48 or OP_M80
 = 401F00                     C OP_M		equ OP_M08 or OP_M16 or OP_M32 or OP_M64 or OP_M80 or OP_M128
                              C 
                              C ; v2.06: items in instruction table now use OP_MS instead of OP_M
 = F00                        C OP_MS		equ OP_M08 or OP_M16 or OP_M32 or OP_M64
                              C 
                              C ; since v2.06, this is a 8-bit field. Previously it was 4-bit only.
                              C 
 = 0                          C OP3_NONE	equ 0		; must be 0, identical to OP_NONE
 = 1                          C OP3_CL		equ 1
 = 2                          C OP3_I8_U	equ 2		; this is also used for signed values (IMUL)
 = 3                          C OP3_XMM0	equ 3		; v2.01: introduced with SSE4.1
 = 4                          C OP3_I		equ 4		; v2.06: added to avoid the IMUL hack
 = 5                          C OP3_HID		equ 5		; hidden data ( CMPxxx[PD|PS|SD|SS]
                              C 
 = 3                          C OP3_XMM		equ OP3_XMM0	; for VEX encoding only
 = 3                          C OP3_YMM		equ OP3_XMM0
 = 3                          C OP3_ZMM		equ OP3_XMM0
 = 3                          C OP3_K		equ OP3_XMM0
 = 3                          C OP3_RGT16	equ OP3_XMM0
 = 3                          C OP3_R_MS	equ OP3_XMM0
                              C 
                              C endif
                              C include fixup.inc
                              C ; FIXUP.INC--
                              C ;
                              C ; Copyright (c) The Asmc Contributors. All rights reserved.
                              C ; Consult your license regarding permissions and restrictions.
                              C ;
                              C ; fixup related variables and routines
                              C ;
                              C ifndef __FIXUP_inc
 = 0                          C define __FIXUP_inc
                              C 
                              C ; RELOFF8 - RELOFF32 must be consecutive
                              C 
                              C .enum fixup_types {
                            * C fixup_types typedef sdword
 = 0                        * C FIX_VOID equ 0x0
 = 1                        * C FIX_RELOFF8 equ 0x1
 = 2                        * C FIX_RELOFF16 equ 0x2
 = 3                        * C FIX_RELOFF32 equ 0x3
 = 4                        * C FIX_OFF8 equ 0x4
 = 5                        * C FIX_OFF16 equ 0x5
 = 6                        * C FIX_OFF32 equ 0x6
 = 7                        * C FIX_OFF64 equ 0x7
 = 8                        * C FIX_SEG equ 0x8
 = 9                        * C FIX_PTR16 equ 0x9
 = A                        * C FIX_PTR32 equ 0xA
 = B                        * C FIX_HIBYTE equ 0xB
 = C                        * C FIX_OFF32_IMGREL equ 0xC
 = D                        * C FIX_OFF32_SECREL equ 0xD
 = E                        * C FIX_LAST equ 0xE
                              C 
                              C ;  OMF: nothing (7, 12, 13 can't happen)
                              C ; COFF: set bit 1, 4, 9, 10, 11
                              C ;  ELF: set bit 8, 9, 10, 11
                              C 
 = 0                          C BIN_DISALLOWED		equ 0x0000
 = 0                          C OMF_DISALLOWED		equ 0x0000
 = E12                        C COFF32_DISALLOWED	equ 0x0E12 ; exclude RELOFF8, OFF8, PTR16, PTR32, HIBYTE
 = E12                        C COFF64_DISALLOWED	equ 0x0E12 ; exclude RELOFF8, OFF8, PTR16, PTR32, HIBYTE
 = F00                        C ELF32_DISALLOWED	equ 0x0F00 ; exclude SEG, PTR16, PTR32, HIBYTE
 = F00                        C ELF64_DISALLOWED	equ 0x0F00 ; exclude SEG, PTR16, PTR32, HIBYTE
                              C 
                              C ; fixups are also used for backpatching of forward references in pass one.
                              C ; the instructions which depend on the distance are CALL, JMP, PUSH <imm>.
                              C ; OPTJ_EXPLICIT: JMP SHORT <label> or Jcc SHORT <label>, size cannot change
                              C ; OPTJ_EXTEND:	  Jcc <label> for cpu < 80386, size may change (2 -> 5/7 or 8/10)
                              C ; OPTJ_JXX:	  Jcc <label> for cpu >= 80386, size may change (2 -> 5 )
                              C ; OPTJ_CALL:	  call <label>, may become push cs, call NEAR or call FAR
                              C ; OPTJ_PUSH:	  push <label>, assumed byte, may become variable or label.
                              C 
                              C 
                              C .enum fixup_options {
                            * C fixup_options typedef sdword
 = 0                        * C OPTJ_NONE equ 0x0
 = 1                        * C OPTJ_EXPLICIT equ 0x1
 = 2                        * C OPTJ_EXTEND equ 0x2
 = 3                        * C OPTJ_JXX equ 0x3
 = 4                        * C OPTJ_CALL equ 0x4
 = 5                        * C OPTJ_PUSH equ 0x5
                              C 
 = 2                          C FX_ORGOCCURED		equ 0x02
 = 1                          C FX_LOADER_RESOLVED	equ 0x01
                              C 
00000000                      C fixup struct
00000000                      C  nextbp		ptr fixup ?	; PASS 1: linked list backpatch
00000008                      C  nextrlc	ptr fixup ?	; PASS >1: linked list relocs
00000010                      C  offs		dd ?		; symbol's offset
00000014                      C  locofs		dd ?		; location of fixup
00000018                      C  type		db ?
00000019                      C  options	db ?
0000001A                      C  union
00000000                      C   flags		dw ?
00000002                      C   struct			; the IP relative addressing needs to know
                              C 				; where the instruction ends.
00000000                      C    addbytes	db ?		; the result <end of instruction> - <fixup location> is stored here.
00000001                      C    fx_flag	db ?
                              C    ; loader_resolved db ?; : 1	; operator LROFFSET
                              C    ; orgoccured uchar_t	 : 1	; v2.04 ORG occured behind this fix
00000002                      C   ends
00000002                      C  ends
0000001C                      C  union
00000000                      C   struct
00000000                      C    frame_type	char_t ?	; frame specifier (SEG=0,GRP=1,,...)
00000001                      C    frame_datum	ushort_t ?	; additional data, usually index
00000003                      C   ends
00000000                      C   segment_var	ptr asym ?	; symbol's segment if assembly time var
00000008                      C  ends
00000024                      C  def_seg	ptr dsym ?	; segment the fixup is in - pass 1 only
0000002C                      C  sym		ptr asym ?
00000034                      C fixup ends
                              C fixup_t		typedef ptr fixup
                              C 
                              C CreateFixup	proto fastcall :ptr asym, :fixup_types, :fixup_options
                              C SetFixupFrame	proto fastcall :ptr asym, :char_t
                              C FreeFixup	proto fastcall :ptr fixup
                              C store_fixup	proto fastcall :ptr fixup, :ptr dsym, :ptr int_t
                              C BackPatch	proto fastcall :ptr asym
                              C 
                              C endif
                              C 
                              C ; define tokens for SpecialTable (registers, operators, ... )
                              C 
                              C .enum special_token {
                            * C special_token typedef sdword
 = 0                        * C T_NULL equ 0x0
                              C res macro tok, string, type, value, bytval, flags, cpu, sflags
 >                            C     @CatStr(<T_>,@SubStr(<tok>,2)),
 >                            C     endm
                              C include special.inc
                              C ;
                              C ;
                              C ; Description:	table of non-instruction reserved words:
                              C ;		- registers,
                              C ;		- predefined types
                              C ;		- operators (unary + binary),
                              C ;		- language types
                              C ;		for directives see directve.inc!
                              C ;		for instructions see instruct.inc!
                              C ;
                              C ;
                              C ; v1.96: items needn't be sorted anymore!
                              C ; The items are stored in structures of type special_item.
                              C ; If an item is inserted, moved or deleted, the project needs
                              C ; a full rebuild.
                              C ;
                              C ;
                              C ; field usage:
                              C ; type	 = RWT_ value	 SpecialTable.type   uint_8
                              C ; value	 =	flags	 SpecialTable.value  unsigned
                              C ; bytval =	value	 SpecialTable.bytval uint_8
                              C ; flags	 = RWF_ flags	 ResWordTable.flags  uint_8
                              C ; cpu	 = cpu	flags	 SpecialTable.cpu    uint_16
                              C ; sflags =		 SpecialTable.sflags unsigned
                              C ;
                              C ; for registers, the 'value' field contains OP_ flags.
                              C ; Since this field has type unsigned, it may be 16-bits wide only.
                              C ; This is no problem, since all register-related flags are in the low word.
                              C ;
                              C ; token str    type	   value    bytval    flags  cpu     sflags
                              C ;
                              C ; registers AH-BH must be consecutive, start with AH and end with BH
                              C ;
                              C res(AL,	  al,	RWT_REG,    OP_AL,	0,	 0,   P_86,    1)
 = 1                        *1C T_AL equ 0x1
                              C res(CL,	  cl,	RWT_REG,    OP_CL,	1,	 0,   P_86,    1)
 = 2                        *1C T_CL equ 0x2
                              C res(DL,	  dl,	RWT_REG,    OP_R8,	2,	 0,   P_86,    1)
 = 3                        *1C T_DL equ 0x3
                              C res(BL,	  bl,	RWT_REG,    OP_R8,	3,	 0,   P_86,    1)
 = 4                        *1C T_BL equ 0x4
                              C res(AH,	  ah,	RWT_REG,    OP_R8,	4,	 0,   P_86,    1)
 = 5                        *1C T_AH equ 0x5
                              C res(CH,	  ch,	RWT_REG,    OP_R8,	5,	 0,   P_86,    1)
 = 6                        *1C T_CH equ 0x6
                              C res(DH,	  dh,	RWT_REG,    OP_R8,	6,	 0,   P_86,    1)
 = 7                        *1C T_DH equ 0x7
                              C res(BH,	  bh,	RWT_REG,    OP_R8,	7,	 0,   P_86,    1)
 = 8                        *1C T_BH equ 0x8
                              C 
                              C res(AX,	  ax,	RWT_REG,    OP_AX,	0,	 0,   P_86,    2)
 = 9                        *1C T_AX equ 0x9
                              C res(CX,	  cx,	RWT_REG,    OP_R16,	1,	 0,   P_86,    2)
 = A                        *1C T_CX equ 0xA
                              C res(DX,	  dx,	RWT_REG,    OP_DX,	2,	 0,   P_86,    2)
 = B                        *1C T_DX equ 0xB
                              C res(BX,	  bx,	RWT_REG,    OP_R16,	3,	 0,   P_86,    SFR_IREG or 2)
 = C                        *1C T_BX equ 0xC
                              C res(SP,	  sp,	RWT_REG,    OP_R16,	4,	 0,   P_86,    2)
 = D                        *1C T_SP equ 0xD
                              C res(BP,	  bp,	RWT_REG,    OP_R16,	5,	 0,   P_86,    SFR_SSBASED or SFR_IREG or 2)
 = E                        *1C T_BP equ 0xE
                              C res(SI,	  si,	RWT_REG,    OP_R16,	6,	 0,   P_86,    SFR_IREG or 2)
 = F                        *1C T_SI equ 0xF
                              C res(DI,	  di,	RWT_REG,    OP_R16,	7,	 0,   P_86,    SFR_IREG or 2)
 = 10                       *1C T_DI equ 0x10
                              C 
                              C res(EAX,  eax,	RWT_REG,    OP_EAX,	0,	 0,   P_386,   SFR_IREG or 4)
 = 11                       *1C T_EAX equ 0x11
                              C res(ECX,  ecx,	RWT_REG,    OP_R32,	1,	 0,   P_386,   SFR_IREG or 4)
 = 12                       *1C T_ECX equ 0x12
                              C res(EDX,  edx,	RWT_REG,    OP_R32,	2,	 0,   P_386,   SFR_IREG or 4)
 = 13                       *1C T_EDX equ 0x13
                              C res(EBX,  ebx,	RWT_REG,    OP_R32,	3,	 0,   P_386,   SFR_IREG or 4)
 = 14                       *1C T_EBX equ 0x14
                              C res(ESP,  esp,	RWT_REG,    OP_R32,	4,	 0,   P_386,   SFR_SSBASED or SFR_IREG or 4)
 = 15                       *1C T_ESP equ 0x15
                              C res(EBP,  ebp,	RWT_REG,    OP_R32,	5,	 0,   P_386,   SFR_SSBASED or SFR_IREG or 4)
 = 16                       *1C T_EBP equ 0x16
                              C res(ESI,  esi,	RWT_REG,    OP_R32,	6,	 0,   P_386,   SFR_IREG or 4)
 = 17                       *1C T_ESI equ 0x17
                              C res(EDI,  edi,	RWT_REG,    OP_R32,	7,	 0,   P_386,   SFR_IREG or 4)
 = 18                       *1C T_EDI equ 0x18
                              C 
                              C ; registers ES-GS must be consecutive
                              C 
                              C res(ES,	  es,	RWT_REG,    OP_SR86,	0,	 0,   P_86,    0)
 = 19                       *1C T_ES equ 0x19
                              C res(CS,	  cs,	RWT_REG,    OP_SR86,	1,	 0,   P_86,    0)
 = 1A                       *1C T_CS equ 0x1A
                              C res(SS,	  ss,	RWT_REG,    OP_SR86,	2,	 0,   P_86,    0)
 = 1B                       *1C T_SS equ 0x1B
                              C res(DS,	  ds,	RWT_REG,    OP_SR86,	3,	 0,   P_86,    0)
 = 1C                       *1C T_DS equ 0x1C
                              C res(FS,	  fs,	RWT_REG,    OP_SR386,	4,	 0,   P_386,   0)
 = 1D                       *1C T_FS equ 0x1D
                              C res(GS,	  gs,	RWT_REG,    OP_SR386,	5,	 0,   P_386,   0)
 = 1E                       *1C T_GS equ 0x1E
                              C res(ST,	  st,	RWT_REG,    OP_ST,	0,	 0,   P_87,    10)
 = 1F                       *1C T_ST equ 0x1F
                              C 
                              C res(MM0,  mm0,	RWT_REG,    OP_MMX,	0,	 0,   P_MMX,   8)
 = 20                       *1C T_MM0 equ 0x20
                              C res(MM1,  mm1,	RWT_REG,    OP_MMX,	1,	 0,   P_MMX,   8)
 = 21                       *1C T_MM1 equ 0x21
                              C res(MM2,  mm2,	RWT_REG,    OP_MMX,	2,	 0,   P_MMX,   8)
 = 22                       *1C T_MM2 equ 0x22
                              C res(MM3,  mm3,	RWT_REG,    OP_MMX,	3,	 0,   P_MMX,   8)
 = 23                       *1C T_MM3 equ 0x23
                              C res(MM4,  mm4,	RWT_REG,    OP_MMX,	4,	 0,   P_MMX,   8)
 = 24                       *1C T_MM4 equ 0x24
                              C res(MM5,  mm5,	RWT_REG,    OP_MMX,	5,	 0,   P_MMX,   8)
 = 25                       *1C T_MM5 equ 0x25
                              C res(MM6,  mm6,	RWT_REG,    OP_MMX,	6,	 0,   P_MMX,   8)
 = 26                       *1C T_MM6 equ 0x26
                              C res(MM7,  mm7,	RWT_REG,    OP_MMX,	7,	 0,   P_MMX,   8)
 = 27                       *1C T_MM7 equ 0x27
                              C 
                              C res(XMM0, xmm0, RWT_REG,    OP_XMM,	0,	 0,   P_SSE1,  SFR_IREG or 16)
 = 28                       *1C T_XMM0 equ 0x28
                              C res(XMM1, xmm1, RWT_REG,    OP_XMM,	1,	 0,   P_SSE1,  SFR_IREG or 16)
 = 29                       *1C T_XMM1 equ 0x29
                              C res(XMM2, xmm2, RWT_REG,    OP_XMM,	2,	 0,   P_SSE1,  SFR_IREG or 16)
 = 2A                       *1C T_XMM2 equ 0x2A
                              C res(XMM3, xmm3, RWT_REG,    OP_XMM,	3,	 0,   P_SSE1,  SFR_IREG or 16)
 = 2B                       *1C T_XMM3 equ 0x2B
                              C res(XMM4, xmm4, RWT_REG,    OP_XMM,	4,	 0,   P_SSE1,  SFR_IREG or 16)
 = 2C                       *1C T_XMM4 equ 0x2C
                              C res(XMM5, xmm5, RWT_REG,    OP_XMM,	5,	 0,   P_SSE1,  SFR_IREG or 16)
 = 2D                       *1C T_XMM5 equ 0x2D
                              C res(XMM6, xmm6, RWT_REG,    OP_XMM,	6,	 0,   P_SSE1,  SFR_IREG or 16)
 = 2E                       *1C T_XMM6 equ 0x2E
                              C res(XMM7, xmm7, RWT_REG,    OP_XMM,	7,	 0,   P_SSE1,  SFR_IREG or 16)
 = 2F                       *1C T_XMM7 equ 0x2F
                              C 
                              C res(YMM0, ymm0, RWT_REG,    OP_YMM,	0,	 0,   P_AVX,   SFR_IREG or 32)
 = 30                       *1C T_YMM0 equ 0x30
                              C res(YMM1, ymm1, RWT_REG,    OP_YMM,	1,	 0,   P_AVX,   SFR_IREG or 32)
 = 31                       *1C T_YMM1 equ 0x31
                              C res(YMM2, ymm2, RWT_REG,    OP_YMM,	2,	 0,   P_AVX,   SFR_IREG or 32)
 = 32                       *1C T_YMM2 equ 0x32
                              C res(YMM3, ymm3, RWT_REG,    OP_YMM,	3,	 0,   P_AVX,   SFR_IREG or 32)
 = 33                       *1C T_YMM3 equ 0x33
                              C res(YMM4, ymm4, RWT_REG,    OP_YMM,	4,	 0,   P_AVX,   SFR_IREG or 32)
 = 34                       *1C T_YMM4 equ 0x34
                              C res(YMM5, ymm5, RWT_REG,    OP_YMM,	5,	 0,   P_AVX,   SFR_IREG or 32)
 = 35                       *1C T_YMM5 equ 0x35
                              C res(YMM6, ymm6, RWT_REG,    OP_YMM,	6,	 0,   P_AVX,   SFR_IREG or 32)
 = 36                       *1C T_YMM6 equ 0x36
                              C res(YMM7, ymm7, RWT_REG,    OP_YMM,	7,	 0,   P_AVX,   SFR_IREG or 32)
 = 37                       *1C T_YMM7 equ 0x37
                              C 
                              C res(K0,	  k0,	RWT_REG,    OP_K,	0,	 0,   P_AVX,   8)
 = 38                       *1C T_K0 equ 0x38
                              C res(K1,	  k1,	RWT_REG,    OP_K,	1,	 0,   P_AVX,   8)
 = 39                       *1C T_K1 equ 0x39
                              C res(K2,	  k2,	RWT_REG,    OP_K,	2,	 0,   P_AVX,   8)
 = 3A                       *1C T_K2 equ 0x3A
                              C res(K3,	  k3,	RWT_REG,    OP_K,	3,	 0,   P_AVX,   8)
 = 3B                       *1C T_K3 equ 0x3B
                              C res(K4,	  k4,	RWT_REG,    OP_K,	4,	 0,   P_AVX,   8)
 = 3C                       *1C T_K4 equ 0x3C
                              C res(K5,	  k5,	RWT_REG,    OP_K,	5,	 0,   P_AVX,   8)
 = 3D                       *1C T_K5 equ 0x3D
                              C res(K6,	  k6,	RWT_REG,    OP_K,	6,	 0,   P_AVX,   8)
 = 3E                       *1C T_K6 equ 0x3E
                              C res(K7,	  k7,	RWT_REG,    OP_K,	7,	 0,   P_AVX,   8)
 = 3F                       *1C T_K7 equ 0x3F
                              C 
                              C res(ZMM0, zmm0, RWT_REG,    OP_ZMM,	0,	 0,   P_AVX,   SFR_IREG or 64)
 = 40                       *1C T_ZMM0 equ 0x40
                              C res(ZMM1, zmm1, RWT_REG,    OP_ZMM,	1,	 0,   P_AVX,   SFR_IREG or 64)
 = 41                       *1C T_ZMM1 equ 0x41
                              C res(ZMM2, zmm2, RWT_REG,    OP_ZMM,	2,	 0,   P_AVX,   SFR_IREG or 64)
 = 42                       *1C T_ZMM2 equ 0x42
                              C res(ZMM3, zmm3, RWT_REG,    OP_ZMM,	3,	 0,   P_AVX,   SFR_IREG or 64)
 = 43                       *1C T_ZMM3 equ 0x43
                              C res(ZMM4, zmm4, RWT_REG,    OP_ZMM,	4,	 0,   P_AVX,   SFR_IREG or 64)
 = 44                       *1C T_ZMM4 equ 0x44
                              C res(ZMM5, zmm5, RWT_REG,    OP_ZMM,	5,	 0,   P_AVX,   SFR_IREG or 64)
 = 45                       *1C T_ZMM5 equ 0x45
                              C res(ZMM6, zmm6, RWT_REG,    OP_ZMM,	6,	 0,   P_AVX,   SFR_IREG or 64)
 = 46                       *1C T_ZMM6 equ 0x46
                              C res(ZMM7, zmm7, RWT_REG,    OP_ZMM,	7,	 0,   P_AVX,   SFR_IREG or 64)
 = 47                       *1C T_ZMM7 equ 0x47
                              C 
                              C res(CR0,  cr0,	RWT_REG,    OP_RIP,	0,	 0,   P_386,   0)
 = 48                       *1C T_CR0 equ 0x48
                              C res(CR2,  cr2,	RWT_REG,    OP_RIP,	2,	 0,   P_386,   0)
 = 49                       *1C T_CR2 equ 0x49
                              C res(CR3,  cr3,	RWT_REG,    OP_RSPEC,	3,	 0,   P_386,   0)
 = 4A                       *1C T_CR3 equ 0x4A
                              C res(CR4,  cr4,	RWT_REG,    OP_RSPEC,	4,	 0,   P_586,   0)
 = 4B                       *1C T_CR4 equ 0x4B
                              C 
                              C res(DR0,  dr0,	RWT_REG,    OP_RSPEC,	0 or 0x10,	 0,   P_386,   0)
 = 4C                       *1C T_DR0 equ 0x4C
                              C res(DR1,  dr1,	RWT_REG,    OP_RSPEC,	1 or 0x10,	 0,   P_386,   0)
 = 4D                       *1C T_DR1 equ 0x4D
                              C res(DR2,  dr2,	RWT_REG,    OP_RSPEC,	2 or 0x10,	 0,   P_386,   0)
 = 4E                       *1C T_DR2 equ 0x4E
                              C res(DR3,  dr3,	RWT_REG,    OP_RSPEC,	3 or 0x10,	 0,   P_386,   0)
 = 4F                       *1C T_DR3 equ 0x4F
                              C res(DR6,  dr6,	RWT_REG,    OP_RSPEC,	6 or 0x10,	 0,   P_386,   0)
 = 50                       *1C T_DR6 equ 0x50
                              C res(DR7,  dr7,	RWT_REG,    OP_RSPEC,	7 or 0x10,	 0,   P_386,   0)
 = 51                       *1C T_DR7 equ 0x51
                              C 
                              C ; v2.11: add RWF_IA32 to TRx registers
                              C 
                              C res(TR3,  tr3,	RWT_REG,    OP_RSPEC,	3 or 0x20,RWF_IA32,P_486, 0)
 = 52                       *1C T_TR3 equ 0x52
                              C res(TR4,  tr4,	RWT_REG,    OP_RSPEC,	4 or 0x20,RWF_IA32,P_486, 0)
 = 53                       *1C T_TR4 equ 0x53
                              C res(TR5,  tr5,	RWT_REG,    OP_RSPEC,	5 or 0x20,RWF_IA32,P_486, 0)
 = 54                       *1C T_TR5 equ 0x54
                              C res(TR6,  tr6,	RWT_REG,    OP_RSPEC,	6 or 0x20,RWF_IA32,P_386, 0)
 = 55                       *1C T_TR6 equ 0x55
                              C res(TR7,  tr7,	RWT_REG,    OP_RSPEC,	7 or 0x20,RWF_IA32,P_386, 0)
 = 56                       *1C T_TR7 equ 0x56
                              C 
                              C ; for simplicity, all x64 reserved words must be consecutive
                              C ; ( see Set64Bit() in parser.asm ).
                              C 
                              C res(SPL,  spl,	RWT_REG,    OP_R8,	4, RWF_X64,    P_64,   1)
 = 57                       *1C T_SPL equ 0x57
                              C res(BPL,  bpl,	RWT_REG,    OP_R8,	5, RWF_X64,    P_64,   1)
 = 58                       *1C T_BPL equ 0x58
                              C res(SIL,  sil,	RWT_REG,    OP_R8,	6, RWF_X64,    P_64,   1)
 = 59                       *1C T_SIL equ 0x59
                              C res(DIL,  dil,	RWT_REG,    OP_R8,	7, RWF_X64,    P_64,   1)
 = 5A                       *1C T_DIL equ 0x5A
                              C res(R8B,  r8b,	RWT_REG,    OP_R8,	8, RWF_X64,    P_64,   1)
 = 5B                       *1C T_R8B equ 0x5B
                              C res(R9B,  r9b,	RWT_REG,    OP_R8,	9, RWF_X64,    P_64,   1)
 = 5C                       *1C T_R9B equ 0x5C
                              C res(R10B, r10b, RWT_REG,    OP_R8,     10, RWF_X64,    P_64,   1)
 = 5D                       *1C T_R10B equ 0x5D
                              C res(R11B, r11b, RWT_REG,    OP_R8,     11, RWF_X64,    P_64,   1)
 = 5E                       *1C T_R11B equ 0x5E
                              C res(R12B, r12b, RWT_REG,    OP_R8,     12, RWF_X64,    P_64,   1)
 = 5F                       *1C T_R12B equ 0x5F
                              C res(R13B, r13b, RWT_REG,    OP_R8,     13, RWF_X64,    P_64,   1)
 = 60                       *1C T_R13B equ 0x60
                              C res(R14B, r14b, RWT_REG,    OP_R8,     14, RWF_X64,    P_64,   1)
 = 61                       *1C T_R14B equ 0x61
                              C res(R15B, r15b, RWT_REG,    OP_R8,     15, RWF_X64,    P_64,   1)
 = 62                       *1C T_R15B equ 0x62
                              C 
                              C res(R8W,  r8w,	RWT_REG,    OP_R16,	8, RWF_X64,    P_64,   2)
 = 63                       *1C T_R8W equ 0x63
                              C res(R9W,  r9w,	RWT_REG,    OP_R16,	9, RWF_X64,    P_64,   2)
 = 64                       *1C T_R9W equ 0x64
                              C res(R10W, r10w, RWT_REG,    OP_R16,    10, RWF_X64,    P_64,   2)
 = 65                       *1C T_R10W equ 0x65
                              C res(R11W, r11w, RWT_REG,    OP_R16,    11, RWF_X64,    P_64,   2)
 = 66                       *1C T_R11W equ 0x66
                              C res(R12W, r12w, RWT_REG,    OP_R16,    12, RWF_X64,    P_64,   2)
 = 67                       *1C T_R12W equ 0x67
                              C res(R13W, r13w, RWT_REG,    OP_R16,    13, RWF_X64,    P_64,   2)
 = 68                       *1C T_R13W equ 0x68
                              C res(R14W, r14w, RWT_REG,    OP_R16,    14, RWF_X64,    P_64,   2)
 = 69                       *1C T_R14W equ 0x69
                              C res(R15W, r15w, RWT_REG,    OP_R16,    15, RWF_X64,    P_64,   2)
 = 6A                       *1C T_R15W equ 0x6A
                              C 
                              C res(R8D,  r8d,	RWT_REG,    OP_R32,	8, RWF_X64,    P_64,   SFR_IREG or 4)
 = 6B                       *1C T_R8D equ 0x6B
                              C res(R9D,  r9d,	RWT_REG,    OP_R32,	9, RWF_X64,    P_64,   SFR_IREG or 4)
 = 6C                       *1C T_R9D equ 0x6C
                              C res(R10D, r10d, RWT_REG,    OP_R32,    10, RWF_X64,    P_64,   SFR_IREG or 4)
 = 6D                       *1C T_R10D equ 0x6D
                              C res(R11D, r11d, RWT_REG,    OP_R32,    11, RWF_X64,    P_64,   SFR_IREG or 4)
 = 6E                       *1C T_R11D equ 0x6E
                              C res(R12D, r12d, RWT_REG,    OP_R32,    12, RWF_X64,    P_64,   SFR_IREG or 4)
 = 6F                       *1C T_R12D equ 0x6F
                              C res(R13D, r13d, RWT_REG,    OP_R32,    13, RWF_X64,    P_64,   SFR_IREG or 4)
 = 70                       *1C T_R13D equ 0x70
                              C res(R14D, r14d, RWT_REG,    OP_R32,    14, RWF_X64,    P_64,   SFR_IREG or 4)
 = 71                       *1C T_R14D equ 0x71
                              C res(R15D, r15d, RWT_REG,    OP_R32,    15, RWF_X64,    P_64,   SFR_IREG or 4)
 = 72                       *1C T_R15D equ 0x72
                              C 
                              C res(RAX,  rax,	RWT_REG,    OP_RAX,	0, RWF_X64,    P_64,   SFR_IREG or 8)
 = 73                       *1C T_RAX equ 0x73
                              C res(RCX,  rcx,	RWT_REG,    OP_R64,	1, RWF_X64,    P_64,   SFR_IREG or 8)
 = 74                       *1C T_RCX equ 0x74
                              C res(RDX,  rdx,	RWT_REG,    OP_R64,	2, RWF_X64,    P_64,   SFR_IREG or 8)
 = 75                       *1C T_RDX equ 0x75
                              C res(RBX,  rbx,	RWT_REG,    OP_R64,	3, RWF_X64,    P_64,   SFR_IREG or 8)
 = 76                       *1C T_RBX equ 0x76
                              C res(RSP,  rsp,	RWT_REG,    OP_R64,	4, RWF_X64,    P_64,   SFR_SSBASED or SFR_IREG or 8)
 = 77                       *1C T_RSP equ 0x77
                              C res(RBP,  rbp,	RWT_REG,    OP_R64,	5, RWF_X64,    P_64,   SFR_SSBASED or SFR_IREG or 8)
 = 78                       *1C T_RBP equ 0x78
                              C res(RSI,  rsi,	RWT_REG,    OP_R64,	6, RWF_X64,    P_64,   SFR_IREG or 8)
 = 79                       *1C T_RSI equ 0x79
                              C res(RDI,  rdi,	RWT_REG,    OP_R64,	7, RWF_X64,    P_64,   SFR_IREG or 8)
 = 7A                       *1C T_RDI equ 0x7A
                              C res(R8,	  r8,	RWT_REG,    OP_R64,	8, RWF_X64,    P_64,   SFR_IREG or 8)
 = 7B                       *1C T_R8 equ 0x7B
                              C res(R9,	  r9,	RWT_REG,    OP_R64,	9, RWF_X64,    P_64,   SFR_IREG or 8)
 = 7C                       *1C T_R9 equ 0x7C
                              C res(R10,  r10,	RWT_REG,    OP_R64,    10, RWF_X64,    P_64,   SFR_IREG or 8)
 = 7D                       *1C T_R10 equ 0x7D
                              C res(R11,  r11,	RWT_REG,    OP_R64,    11, RWF_X64,    P_64,   SFR_IREG or 8)
 = 7E                       *1C T_R11 equ 0x7E
                              C res(R12,  r12,	RWT_REG,    OP_R64,    12, RWF_X64,    P_64,   SFR_IREG or 8)
 = 7F                       *1C T_R12 equ 0x7F
                              C res(R13,  r13,	RWT_REG,    OP_R64,    13, RWF_X64,    P_64,   SFR_IREG or 8)
 = 80                       *1C T_R13 equ 0x80
                              C res(R14,  r14,	RWT_REG,    OP_R64,    14, RWF_X64,    P_64,   SFR_IREG or 8)
 = 81                       *1C T_R14 equ 0x81
                              C res(R15,  r15,	RWT_REG,    OP_R64,    15, RWF_X64,    P_64,   SFR_IREG or 8)
 = 82                       *1C T_R15 equ 0x82
                              C 
                              C res(RIP,  rip,	RWT_REG,    OP_RIP,    16, RWF_X64,    P_64,   SFR_IREG or 8)
 = 83                       *1C T_RIP equ 0x83
                              C 
                              C res(XMM8, xmm8, RWT_REG,    OP_XMM,	8, RWF_X64,    P_64,   SFR_IREG or 16)
 = 84                       *1C T_XMM8 equ 0x84
                              C res(XMM9, xmm9, RWT_REG,    OP_XMM,	9, RWF_X64,    P_64,   SFR_IREG or 16)
 = 85                       *1C T_XMM9 equ 0x85
                              C res(XMM10,xmm10,RWT_REG,    OP_XMM,    10, RWF_X64,    P_64,   SFR_IREG or 16)
 = 86                       *1C T_XMM10 equ 0x86
                              C res(XMM11,xmm11,RWT_REG,    OP_XMM,    11, RWF_X64,    P_64,   SFR_IREG or 16)
 = 87                       *1C T_XMM11 equ 0x87
                              C res(XMM12,xmm12,RWT_REG,    OP_XMM,    12, RWF_X64,    P_64,   SFR_IREG or 16)
 = 88                       *1C T_XMM12 equ 0x88
                              C res(XMM13,xmm13,RWT_REG,    OP_XMM,    13, RWF_X64,    P_64,   SFR_IREG or 16)
 = 89                       *1C T_XMM13 equ 0x89
                              C res(XMM14,xmm14,RWT_REG,    OP_XMM,    14, RWF_X64,    P_64,   SFR_IREG or 16)
 = 8A                       *1C T_XMM14 equ 0x8A
                              C res(XMM15,xmm15,RWT_REG,    OP_XMM,    15, RWF_X64,    P_64,   SFR_IREG or 16)
 = 8B                       *1C T_XMM15 equ 0x8B
                              C res(XMM16,xmm16,RWT_REG,    OP_XMM,    16, RWF_X64,    P_64,   SFR_IREG or 16)
 = 8C                       *1C T_XMM16 equ 0x8C
                              C res(XMM17,xmm17,RWT_REG,    OP_XMM,    17, RWF_X64,    P_64,   SFR_IREG or 16)
 = 8D                       *1C T_XMM17 equ 0x8D
                              C res(XMM18,xmm18,RWT_REG,    OP_XMM,    18, RWF_X64,    P_64,   SFR_IREG or 16)
 = 8E                       *1C T_XMM18 equ 0x8E
                              C res(XMM19,xmm19,RWT_REG,    OP_XMM,    19, RWF_X64,    P_64,   SFR_IREG or 16)
 = 8F                       *1C T_XMM19 equ 0x8F
                              C res(XMM20,xmm20,RWT_REG,    OP_XMM,    20, RWF_X64,    P_64,   SFR_IREG or 16)
 = 90                       *1C T_XMM20 equ 0x90
                              C res(XMM21,xmm21,RWT_REG,    OP_XMM,    21, RWF_X64,    P_64,   SFR_IREG or 16)
 = 91                       *1C T_XMM21 equ 0x91
                              C res(XMM22,xmm22,RWT_REG,    OP_XMM,    22, RWF_X64,    P_64,   SFR_IREG or 16)
 = 92                       *1C T_XMM22 equ 0x92
                              C res(XMM23,xmm23,RWT_REG,    OP_XMM,    23, RWF_X64,    P_64,   SFR_IREG or 16)
 = 93                       *1C T_XMM23 equ 0x93
                              C res(XMM24,xmm24,RWT_REG,    OP_XMM,    24, RWF_X64,    P_64,   SFR_IREG or 16)
 = 94                       *1C T_XMM24 equ 0x94
                              C res(XMM25,xmm25,RWT_REG,    OP_XMM,    25, RWF_X64,    P_64,   SFR_IREG or 16)
 = 95                       *1C T_XMM25 equ 0x95
                              C res(XMM26,xmm26,RWT_REG,    OP_XMM,    26, RWF_X64,    P_64,   SFR_IREG or 16)
 = 96                       *1C T_XMM26 equ 0x96
                              C res(XMM27,xmm27,RWT_REG,    OP_XMM,    27, RWF_X64,    P_64,   SFR_IREG or 16)
 = 97                       *1C T_XMM27 equ 0x97
                              C res(XMM28,xmm28,RWT_REG,    OP_XMM,    28, RWF_X64,    P_64,   SFR_IREG or 16)
 = 98                       *1C T_XMM28 equ 0x98
                              C res(XMM29,xmm29,RWT_REG,    OP_XMM,    29, RWF_X64,    P_64,   SFR_IREG or 16)
 = 99                       *1C T_XMM29 equ 0x99
                              C res(XMM30,xmm30,RWT_REG,    OP_XMM,    30, RWF_X64,    P_64,   SFR_IREG or 16)
 = 9A                       *1C T_XMM30 equ 0x9A
                              C res(XMM31,xmm31,RWT_REG,    OP_XMM,    31, RWF_X64,    P_64,   SFR_IREG or 16)
 = 9B                       *1C T_XMM31 equ 0x9B
                              C 
                              C res(YMM8, ymm8, RWT_REG,    OP_YMM,	8, RWF_X64,    P_AVX or P_64,  SFR_IREG or 32)
 = 9C                       *1C T_YMM8 equ 0x9C
                              C res(YMM9, ymm9, RWT_REG,    OP_YMM,	9, RWF_X64,    P_AVX or P_64,  SFR_IREG or 32)
 = 9D                       *1C T_YMM9 equ 0x9D
                              C res(YMM10,ymm10,RWT_REG,    OP_YMM,    10, RWF_X64,    P_AVX or P_64,  SFR_IREG or 32)
 = 9E                       *1C T_YMM10 equ 0x9E
                              C res(YMM11,ymm11,RWT_REG,    OP_YMM,    11, RWF_X64,    P_AVX or P_64,  SFR_IREG or 32)
 = 9F                       *1C T_YMM11 equ 0x9F
                              C res(YMM12,ymm12,RWT_REG,    OP_YMM,    12, RWF_X64,    P_AVX or P_64,  SFR_IREG or 32)
 = A0                       *1C T_YMM12 equ 0xA0
                              C res(YMM13,ymm13,RWT_REG,    OP_YMM,    13, RWF_X64,    P_AVX or P_64,  SFR_IREG or 32)
 = A1                       *1C T_YMM13 equ 0xA1
                              C res(YMM14,ymm14,RWT_REG,    OP_YMM,    14, RWF_X64,    P_AVX or P_64,  SFR_IREG or 32)
 = A2                       *1C T_YMM14 equ 0xA2
                              C res(YMM15,ymm15,RWT_REG,    OP_YMM,    15, RWF_X64,    P_AVX or P_64,  SFR_IREG or 32)
 = A3                       *1C T_YMM15 equ 0xA3
                              C res(YMM16,ymm16,RWT_REG,    OP_YMM,    16, RWF_X64,    P_AVX or P_64,  SFR_IREG or 32)
 = A4                       *1C T_YMM16 equ 0xA4
                              C res(YMM17,ymm17,RWT_REG,    OP_YMM,    17, RWF_X64,    P_AVX or P_64,  SFR_IREG or 32)
 = A5                       *1C T_YMM17 equ 0xA5
                              C res(YMM18,ymm18,RWT_REG,    OP_YMM,    18, RWF_X64,    P_AVX or P_64,  SFR_IREG or 32)
 = A6                       *1C T_YMM18 equ 0xA6
                              C res(YMM19,ymm19,RWT_REG,    OP_YMM,    19, RWF_X64,    P_AVX or P_64,  SFR_IREG or 32)
 = A7                       *1C T_YMM19 equ 0xA7
                              C res(YMM20,ymm20,RWT_REG,    OP_YMM,    20, RWF_X64,    P_AVX or P_64,  SFR_IREG or 32)
 = A8                       *1C T_YMM20 equ 0xA8
                              C res(YMM21,ymm21,RWT_REG,    OP_YMM,    21, RWF_X64,    P_AVX or P_64,  SFR_IREG or 32)
 = A9                       *1C T_YMM21 equ 0xA9
                              C res(YMM22,ymm22,RWT_REG,    OP_YMM,    22, RWF_X64,    P_AVX or P_64,  SFR_IREG or 32)
 = AA                       *1C T_YMM22 equ 0xAA
                              C res(YMM23,ymm23,RWT_REG,    OP_YMM,    23, RWF_X64,    P_AVX or P_64,  SFR_IREG or 32)
 = AB                       *1C T_YMM23 equ 0xAB
                              C res(YMM24,ymm24,RWT_REG,    OP_YMM,    24, RWF_X64,    P_AVX or P_64,  SFR_IREG or 32)
 = AC                       *1C T_YMM24 equ 0xAC
                              C res(YMM25,ymm25,RWT_REG,    OP_YMM,    25, RWF_X64,    P_AVX or P_64,  SFR_IREG or 32)
 = AD                       *1C T_YMM25 equ 0xAD
                              C res(YMM26,ymm26,RWT_REG,    OP_YMM,    26, RWF_X64,    P_AVX or P_64,  SFR_IREG or 32)
 = AE                       *1C T_YMM26 equ 0xAE
                              C res(YMM27,ymm27,RWT_REG,    OP_YMM,    27, RWF_X64,    P_AVX or P_64,  SFR_IREG or 32)
 = AF                       *1C T_YMM27 equ 0xAF
                              C res(YMM28,ymm28,RWT_REG,    OP_YMM,    28, RWF_X64,    P_AVX or P_64,  SFR_IREG or 32)
 = B0                       *1C T_YMM28 equ 0xB0
                              C res(YMM29,ymm29,RWT_REG,    OP_YMM,    29, RWF_X64,    P_AVX or P_64,  SFR_IREG or 32)
 = B1                       *1C T_YMM29 equ 0xB1
                              C res(YMM30,ymm30,RWT_REG,    OP_YMM,    30, RWF_X64,    P_AVX or P_64,  SFR_IREG or 32)
 = B2                       *1C T_YMM30 equ 0xB2
                              C res(YMM31,ymm31,RWT_REG,    OP_YMM,    31, RWF_X64,    P_AVX or P_64,  SFR_IREG or 32)
 = B3                       *1C T_YMM31 equ 0xB3
                              C 
                              C res(ZMM8, zmm8, RWT_REG,    OP_ZMM,	8, RWF_X64,    P_AVX or P_64,  SFR_IREG or 64)
 = B4                       *1C T_ZMM8 equ 0xB4
                              C res(ZMM9, zmm9, RWT_REG,    OP_ZMM,	9, RWF_X64,    P_AVX or P_64,  SFR_IREG or 64)
 = B5                       *1C T_ZMM9 equ 0xB5
                              C res(ZMM10,zmm10,RWT_REG,    OP_ZMM,    10, RWF_X64,    P_AVX or P_64,  SFR_IREG or 64)
 = B6                       *1C T_ZMM10 equ 0xB6
                              C res(ZMM11,zmm11,RWT_REG,    OP_ZMM,    11, RWF_X64,    P_AVX or P_64,  SFR_IREG or 64)
 = B7                       *1C T_ZMM11 equ 0xB7
                              C res(ZMM12,zmm12,RWT_REG,    OP_ZMM,    12, RWF_X64,    P_AVX or P_64,  SFR_IREG or 64)
 = B8                       *1C T_ZMM12 equ 0xB8
                              C res(ZMM13,zmm13,RWT_REG,    OP_ZMM,    13, RWF_X64,    P_AVX or P_64,  SFR_IREG or 64)
 = B9                       *1C T_ZMM13 equ 0xB9
                              C res(ZMM14,zmm14,RWT_REG,    OP_ZMM,    14, RWF_X64,    P_AVX or P_64,  SFR_IREG or 64)
 = BA                       *1C T_ZMM14 equ 0xBA
                              C res(ZMM15,zmm15,RWT_REG,    OP_ZMM,    15, RWF_X64,    P_AVX or P_64,  SFR_IREG or 64)
 = BB                       *1C T_ZMM15 equ 0xBB
                              C res(ZMM16,zmm16,RWT_REG,    OP_ZMM,    16, RWF_X64,    P_AVX or P_64,  SFR_IREG or 64)
 = BC                       *1C T_ZMM16 equ 0xBC
                              C res(ZMM17,zmm17,RWT_REG,    OP_ZMM,    17, RWF_X64,    P_AVX or P_64,  SFR_IREG or 64)
 = BD                       *1C T_ZMM17 equ 0xBD
                              C res(ZMM18,zmm18,RWT_REG,    OP_ZMM,    18, RWF_X64,    P_AVX or P_64,  SFR_IREG or 64)
 = BE                       *1C T_ZMM18 equ 0xBE
                              C res(ZMM19,zmm19,RWT_REG,    OP_ZMM,    19, RWF_X64,    P_AVX or P_64,  SFR_IREG or 64)
 = BF                       *1C T_ZMM19 equ 0xBF
                              C res(ZMM20,zmm20,RWT_REG,    OP_ZMM,    20, RWF_X64,    P_AVX or P_64,  SFR_IREG or 64)
 = C0                       *1C T_ZMM20 equ 0xC0
                              C res(ZMM21,zmm21,RWT_REG,    OP_ZMM,    21, RWF_X64,    P_AVX or P_64,  SFR_IREG or 64)
 = C1                       *1C T_ZMM21 equ 0xC1
                              C res(ZMM22,zmm22,RWT_REG,    OP_ZMM,    22, RWF_X64,    P_AVX or P_64,  SFR_IREG or 64)
 = C2                       *1C T_ZMM22 equ 0xC2
                              C res(ZMM23,zmm23,RWT_REG,    OP_ZMM,    23, RWF_X64,    P_AVX or P_64,  SFR_IREG or 64)
 = C3                       *1C T_ZMM23 equ 0xC3
                              C res(ZMM24,zmm24,RWT_REG,    OP_ZMM,    24, RWF_X64,    P_AVX or P_64,  SFR_IREG or 64)
 = C4                       *1C T_ZMM24 equ 0xC4
                              C res(ZMM25,zmm25,RWT_REG,    OP_ZMM,    25, RWF_X64,    P_AVX or P_64,  SFR_IREG or 64)
 = C5                       *1C T_ZMM25 equ 0xC5
                              C res(ZMM26,zmm26,RWT_REG,    OP_ZMM,    26, RWF_X64,    P_AVX or P_64,  SFR_IREG or 64)
 = C6                       *1C T_ZMM26 equ 0xC6
                              C res(ZMM27,zmm27,RWT_REG,    OP_ZMM,    27, RWF_X64,    P_AVX or P_64,  SFR_IREG or 64)
 = C7                       *1C T_ZMM27 equ 0xC7
                              C res(ZMM28,zmm28,RWT_REG,    OP_ZMM,    28, RWF_X64,    P_AVX or P_64,  SFR_IREG or 64)
 = C8                       *1C T_ZMM28 equ 0xC8
                              C res(ZMM29,zmm29,RWT_REG,    OP_ZMM,    29, RWF_X64,    P_AVX or P_64,  SFR_IREG or 64)
 = C9                       *1C T_ZMM29 equ 0xC9
                              C res(ZMM30,zmm30,RWT_REG,    OP_ZMM,    30, RWF_X64,    P_AVX or P_64,  SFR_IREG or 64)
 = CA                       *1C T_ZMM30 equ 0xCA
                              C res(ZMM31,zmm31,RWT_REG,    OP_ZMM,    31, RWF_X64,    P_AVX or P_64,  SFR_IREG or 64)
 = CB                       *1C T_ZMM31 equ 0xCB
                              C 
                              C res(CR8,    cr8,     RWT_REG,	 OP_RSPEC,  8,	  RWF_X64, P_64,    0)
 = CC                       *1C T_CR8 equ 0xCC
                              C 
                              C ; predefined types. BYTE must be first!
                              C ; token	   str	    type	value	   bytval   flags cpu	  sflags
                              C 
                              C res(BYTE,   byte,    RWT_STYPE,	 0,	    MT_BYTE,	0, P_86,    USE_EMPTY)
 = CD                       *1C T_BYTE equ 0xCD
                              C res(SBYTE,  sbyte,   RWT_STYPE,	 0,	    MT_SBYTE,	0, P_86,    USE_EMPTY)
 = CE                       *1C T_SBYTE equ 0xCE
                              C res(WORD,   word,    RWT_STYPE,	 0,	    MT_WORD,	0, P_86,    USE_EMPTY)
 = CF                       *1C T_WORD equ 0xCF
                              C res(SWORD,  sword,   RWT_STYPE,	 0,	    MT_SWORD,	0, P_86,    USE_EMPTY)
 = D0                       *1C T_SWORD equ 0xD0
                              C res(REAL2,  real2,   RWT_STYPE,	 0,	    MT_REAL2,	0, P_86,    USE_EMPTY)
 = D1                       *1C T_REAL2 equ 0xD1
                              C res(DWORD,  dword,   RWT_STYPE,	 0,	    MT_DWORD,	0, P_86,    USE_EMPTY)
 = D2                       *1C T_DWORD equ 0xD2
                              C res(SDWORD, sdword,  RWT_STYPE,	 0,	    MT_SDWORD,	0, P_86,    USE_EMPTY)
 = D3                       *1C T_SDWORD equ 0xD3
                              C res(REAL4,  real4,   RWT_STYPE,	 0,	    MT_REAL4,	0, P_86,    USE_EMPTY)
 = D4                       *1C T_REAL4 equ 0xD4
                              C res(FWORD,  fword,   RWT_STYPE,	 0,	    MT_FWORD,	0, P_86,    USE_EMPTY)
 = D5                       *1C T_FWORD equ 0xD5
                              C res(QWORD,  qword,   RWT_STYPE,	 0,	    MT_QWORD,	0, P_86,    USE_EMPTY)
 = D6                       *1C T_QWORD equ 0xD6
                              C res(SQWORD, sqword,  RWT_STYPE,	 0,	    MT_SQWORD,	0, P_86,    USE_EMPTY)
 = D7                       *1C T_SQWORD equ 0xD7
                              C res(REAL8,  real8,   RWT_STYPE,	 0,	    MT_REAL8,	0, P_86,    USE_EMPTY)
 = D8                       *1C T_REAL8 equ 0xD8
                              C res(TBYTE,  tbyte,   RWT_STYPE,	 0,	    MT_TBYTE,	0, P_86,    USE_EMPTY)
 = D9                       *1C T_TBYTE equ 0xD9
                              C res(REAL10, real10,  RWT_STYPE,	 0,	    MT_REAL10,	0, P_86,    USE_EMPTY)
 = DA                       *1C T_REAL10 equ 0xDA
                              C res(OWORD,  oword,   RWT_STYPE,	 0,	    MT_OWORD,	0, P_86,    USE_EMPTY)
 = DB                       *1C T_OWORD equ 0xDB
                              C res(REAL16, real16,  RWT_STYPE,	 0,	    MT_REAL16,	0, P_86,    USE_EMPTY)
 = DC                       *1C T_REAL16 equ 0xDC
                              C res(YWORD,  yword,   RWT_STYPE,	 0,	    MT_YMMWORD, 0, P_AVX,   USE_EMPTY)
 = DD                       *1C T_YWORD equ 0xDD
                              C res(ZWORD,  zword,   RWT_STYPE,	 0,	    MT_ZMMWORD, 0, P_AVX,   USE_EMPTY)
 = DE                       *1C T_ZWORD equ 0xDE
                              C res(YMMWORD,ymmword, RWT_STYPE,	 0,	    MT_YMMWORD, 0, P_AVX,   USE_EMPTY)
 = DF                       *1C T_YMMWORD equ 0xDF
                              C res(ZMMWORD,zmmword, RWT_STYPE,	 0,	    MT_ZMMWORD, 0, P_AVX,   USE_EMPTY)
 = E0                       *1C T_ZMMWORD equ 0xE0
                              C 
                              C ; NEAR must be first, FAR32 must be last, all contiguous
                              C 
                              C res(NEAR,   near,    RWT_STYPE,	 0,	    MT_NEAR,	0, P_86,    USE_EMPTY)
 = E1                       *1C T_NEAR equ 0xE1
                              C res(FAR,    far,     RWT_STYPE,	 0,	    MT_FAR,	0, P_86,    USE_EMPTY)
 = E2                       *1C T_FAR equ 0xE2
                              C res(NEAR16, near16,  RWT_STYPE,	 0,	    MT_NEAR,	0, P_386,   USE16)
 = E3                       *1C T_NEAR16 equ 0xE3
                              C res(NEAR32, near32,  RWT_STYPE,	 0,	    MT_NEAR,	0, P_386,   USE32)
 = E4                       *1C T_NEAR32 equ 0xE4
                              C res(FAR16,  far16,   RWT_STYPE,	 0,	    MT_FAR,	0, P_386,   USE16)
 = E5                       *1C T_FAR16 equ 0xE5
                              C res(FAR32,  far32,   RWT_STYPE,	 0,	    MT_FAR,	0, P_386,   USE32)
 = E6                       *1C T_FAR32 equ 0xE6
                              C res(MMWORD, mmword,  RWT_STYPE,	 0,	    MT_QWORD,	0, P_586 or P_MMX, USE_EMPTY)
 = E7                       *1C T_MMWORD equ 0xE7
                              C res(XMMWORD,xmmword, RWT_STYPE,	 0,	    MT_OWORD,	0, P_686 or P_SSE1, USE_EMPTY)
 = E8                       *1C T_XMMWORD equ 0xE8
                              C 
                              C ; unary operators. bytval contains priority
                              C ; token	 str	       type	     value   bytval flags cpu  sflags
                              C 
                              C res(DOT_TYPE,	.type,	      RWT_UNARY_OP, AT_ALL,    14,  0,	 P_86,	UOT_DOT_TYPE )
 = E9                       *1C T_DOT_TYPE equ 0xE9
                              C res(DOT_HIGH,	.high,	      RWT_UNARY_OP, AT_TLN,	6,  0,	 P_86,	UOT_DOT_HIGH )
 = EA                       *1C T_DOT_HIGH equ 0xEA
                              C res(HIGH32,	high32,	      RWT_UNARY_OP, AT_CONST  or  AT_FLOAT, 6,	0,	  P_86,	 UOT_HIGH32 )
 = EB                       *1C T_HIGH32 equ 0xEB
                              C res(HIGHWORD,	highword,     RWT_UNARY_OP, AT_CONST,	6,  0,	 P_86,	UOT_HIGHWORD  )
 = EC                       *1C T_HIGHWORD equ 0xEC
                              C 
                              C ; v2.10: changed AT_TLN to AT_LABEL
                              C 
                              C res(IMAGEREL,	imagerel,     RWT_UNARY_OP, AT_LABEL,	5,  0,	 P_86,	UOT_IMAGEREL  )
 = ED                       *1C T_IMAGEREL equ 0xED
                              C res(DOT_LENGTH, .length,      RWT_UNARY_OP, AT_LF,	3,  0,	 P_86,	UOT_DOT_LENGTH )
 = EE                       *1C T_DOT_LENGTH equ 0xEE
                              C res(LENGTHOF,	lengthof,     RWT_UNARY_OP, AT_LF,	3,  0,	 P_86,	UOT_LENGTHOF  )
 = EF                       *1C T_LENGTHOF equ 0xEF
                              C res(DOT_LOW,	.low,	      RWT_UNARY_OP, AT_TLN,	6,  0,	 P_86,	UOT_DOT_LOW   )
 = F0                       *1C T_DOT_LOW equ 0xF0
                              C res(LOW32,	low32,	      RWT_UNARY_OP, AT_TLN or AT_FLOAT,6,0,P_86,UOT_LOW32 )
 = F1                       *1C T_LOW32 equ 0xF1
                              C res(LOWWORD,	lowword,      RWT_UNARY_OP, AT_TLN,	6,  0,	 P_86,	UOT_LOWWORD   )
 = F2                       *1C T_LOWWORD equ 0xF2
                              C res(LROFFSET,	lroffset,     RWT_UNARY_OP, AT_LFN,	5,  0,	 P_86,	UOT_LROFFSET  )
 = F3                       *1C T_LROFFSET equ 0xF3
                              C res(DOT_MASK,	.mask,	      RWT_UNARY_OP, AT_TBF,	3,  0,	 P_86,	UOT_DOT_MASK  )
 = F4                       *1C T_DOT_MASK equ 0xF4
                              C res(OFFSET,	offset,	      RWT_UNARY_OP, AT_TLFN,	5,  0,	 P_86,	UOT_OFFSET    )
 = F5                       *1C T_OFFSET equ 0xF5
                              C res(OPATTR,	opattr,	      RWT_UNARY_OP, AT_ALL,    14,  0,	 P_86,	UOT_OPATTR    )
 = F6                       *1C T_OPATTR equ 0xF6
                              C res(SECTIONREL, sectionrel,   RWT_UNARY_OP, AT_LABEL,	5,  0,	 P_86,	UOT_SECTIONREL)
 = F7                       *1C T_SECTIONREL equ 0xF7
                              C res(SEG,	seg,	      RWT_UNARY_OP, AT_LABEL,	5,  0,	 P_86,	UOT_SEG	      )
 = F8                       *1C T_SEG equ 0xF8
                              C res(SHORT,	short,	      RWT_UNARY_OP, AT_LABEL,  14,  0,	 P_86,	UOT_SHORT )
 = F9                       *1C T_SHORT equ 0xF9
                              C res(DOT_SIZE,	.size,	      RWT_UNARY_OP, AT_TLF,	3,  0,	 P_86,	UOT_DOT_SIZE  )
 = FA                       *1C T_DOT_SIZE equ 0xFA
                              C res(SIZEOF,	sizeof,	      RWT_UNARY_OP, AT_TLF,	3,  0,	 P_86,	UOT_SIZEOF    )
 = FB                       *1C T_SIZEOF equ 0xFB
                              C res(DOT_THIS,	.this,	      RWT_UNARY_OP, AT_TYPE,	5,  0,	 P_86,	UOT_DOT_THIS  )
 = FC                       *1C T_DOT_THIS equ 0xFC
                              C res(TYPEOF,	typeof,	      RWT_UNARY_OP, AT_ALL,	5,  0,	 P_86,	UOT_TYPEOF    )
 = FD                       *1C T_TYPEOF equ 0xFD
                              C res(DOT_WIDTH,	.width,	      RWT_UNARY_OP, AT_TBF,	3,  0,	 P_86,	UOT_DOT_WIDTH )
 = FE                       *1C T_DOT_WIDTH equ 0xFE
                              C res(HIGH64,	high64,	      RWT_UNARY_OP, AT_CONST or AT_FLOAT,6,0,P_64,UOT_HIGH64 )
 = FF                       *1C T_HIGH64 equ 0xFF
                              C res(LOW64,	low64,	      RWT_UNARY_OP, AT_TLN or AT_FLOAT,6,0,P_64,UOT_LOW64 )
 = 100                      *1C T_LOW64 equ 0x100
                              C res(SQRT,	sqrt,	      RWT_UNARY_OP, AT_FLOAT,	6,  0,	 P_86,	UOT_SQRT )
 = 101                      *1C T_SQRT equ 0x101
                              C 
                              C ; binary operators. bytval contains priority
                              C ;
                              C ; token	 str	 type		  value	 bytval flags cpu      sflags
                              C 
                              C res(EQ,		eq,	      RWT_BINARY_OP, 0, 10, 0, P_86, 0 )
 = 102                      *1C T_EQ equ 0x102
                              C res(NE,		ne,	      RWT_BINARY_OP, 0, 10, 0, P_86, 0 )
 = 103                      *1C T_NE equ 0x103
                              C res(GE,		ge,	      RWT_BINARY_OP, 0, 10, 0, P_86, 0 )
 = 104                      *1C T_GE equ 0x104
                              C res(GT,		gt,	      RWT_BINARY_OP, 0, 10, 0, P_86, 0 )
 = 105                      *1C T_GT equ 0x105
                              C res(LE,		le,	      RWT_BINARY_OP, 0, 10, 0, P_86, 0 )
 = 106                      *1C T_LE equ 0x106
                              C res(LT,		lt,	      RWT_BINARY_OP, 0, 10, 0, P_86, 0 )
 = 107                      *1C T_LT equ 0x107
                              C res(MOD,	mod,	      RWT_BINARY_OP, 0,	 8, 0, P_86, 0 )
 = 108                      *1C T_MOD equ 0x108
                              C res(PTR,	ptr,	      RWT_BINARY_OP, 0,	 4, 0, P_86, 0 )
 = 109                      *1C T_PTR equ 0x109
                              C res(DEFINED,	defined,      RWT_BINARY_OP, 0, 11, 0, P_86, 0 )
 = 10A                      *1C T_DEFINED equ 0x10A
                              C 
                              C ; DUP is also a binary operator, but must be handled differently.
                              C 
                              C res(DUP,	dup,	      RWT_RES_ID, 0, 0, 0, P_86, 0)
 = 10B                      *1C T_DUP equ 0x10B
                              C res(ADDR,	addr,	      RWT_RES_ID, 0, 0, 0, P_86, 0)
 = 10C                      *1C T_ADDR equ 0x10C
                              C res(FLAT,	flat,	      RWT_RES_ID, 0, 0, 0, P_86, 0)
 = 10D                      *1C T_FLAT equ 0x10D
                              C res(VARARG,	vararg,	      RWT_RES_ID, 0, 0, 0, P_86, 0)
 = 10E                      *1C T_VARARG equ 0x10E
                              C res(FRAME,	frame,	      RWT_RES_ID, 0, 0, RWF_X64, P_64, 0)
 = 10F                      *1C T_FRAME equ 0x10F
                              C 
                              C ; languages, must be in this order!
                              C ; token	     str	  type	     value bytval	 flags	   cpu	sflags
                              C 
                              C res(CCALL,	ccall,	      RWT_RES_ID, 0, LANG_C,	      0, P_86, 0)
 = 110                      *1C T_CCALL equ 0x110
                              C res(SYSCALL,	syscall,      RWT_RES_ID, 0, LANG_SYSCALL,    0, P_86, 0)
 = 111                      *1C T_SYSCALL equ 0x111
                              C res(STDCALL,	stdcall,      RWT_RES_ID, 0, LANG_STDCALL,    0, P_86, 0)
 = 112                      *1C T_STDCALL equ 0x112
                              C res(PASCAL,	pascal,	      RWT_RES_ID, 0, LANG_PASCAL,     0, P_86, 0)
 = 113                      *1C T_PASCAL equ 0x113
                              C res(FORTRAN,	fortran,      RWT_RES_ID, 0, LANG_FORTRAN,    0, P_86, 0)
 = 114                      *1C T_FORTRAN equ 0x114
                              C res(BASIC,	basic,	      RWT_RES_ID, 0, LANG_BASIC,      0, P_86, 0)
 = 115                      *1C T_BASIC equ 0x115
                              C res(FASTCALL,	fastcall,     RWT_RES_ID, 0, LANG_FASTCALL,   0, P_86, 0)
 = 116                      *1C T_FASTCALL equ 0x116
                              C res(VECTORCALL, vectorcall,   RWT_RES_ID, 0, LANG_VECTORCALL, 0, P_64, 0)
 = 117                      *1C T_VECTORCALL equ 0x117
                              C res(WATCALL,	watcall,      RWT_RES_ID, 0, LANG_WATCALL,    0, P_86, 0)
 = 118                      *1C T_WATCALL equ 0x118
                              C undef res
                              C ; define tokens for SpecialTable (directives)
                              C res macro token, string, value, bytval, flags, cpu, sflags
 >                            C     @CatStr(<T_>,@SubStr(<token>,2)),
 >                            C     endm
                              C include directve.inc
                              C ; DIRECTVE.INC--
                              C ;
                              C ; Copyright (c) The Asmc Contributors. All rights reserved.
                              C ; Consult your license regarding permissions and restrictions.
                              C ;
                              C 
                              C ifndef ASMC64
                              C 
                              C res(DOT_8086, .8086, 0, DRT_CPU, 0, P_86, P_86)
 = 119                      *1C T_DOT_8086 equ 0x119
                              C res(DOT_186,  .186,  0, DRT_CPU, 0, P_86, P_186)
 = 11A                      *1C T_DOT_186 equ 0x11A
                              C res(DOT_286,  .286,  0, DRT_CPU, 0, P_86, P_286)
 = 11B                      *1C T_DOT_286 equ 0x11B
                              C res(DOT_286C, .286c, 0, DRT_CPU, 0, P_86, P_286)
 = 11C                      *1C T_DOT_286C equ 0x11C
                              C res(DOT_286P, .286p, 0, DRT_CPU, 0, P_86, P_286p)
 = 11D                      *1C T_DOT_286P equ 0x11D
                              C res(DOT_386,  .386,  0, DRT_CPU, 0, P_86, P_386)
 = 11E                      *1C T_DOT_386 equ 0x11E
                              C res(DOT_386C, .386c, 0, DRT_CPU, 0, P_86, P_386)
 = 11F                      *1C T_DOT_386C equ 0x11F
                              C res(DOT_386P, .386p, 0, DRT_CPU, 0, P_86, P_386p)
 = 120                      *1C T_DOT_386P equ 0x120
                              C res(DOT_486,  .486,  0, DRT_CPU, 0, P_86, P_486)
 = 121                      *1C T_DOT_486 equ 0x121
                              C res(DOT_486P, .486p, 0, DRT_CPU, 0, P_86, P_486p)
 = 122                      *1C T_DOT_486P equ 0x122
                              C res(DOT_586,  .586,  0, DRT_CPU, 0, P_86, P_586)
 = 123                      *1C T_DOT_586 equ 0x123
                              C res(DOT_586P, .586p, 0, DRT_CPU, 0, P_86, P_586p)
 = 124                      *1C T_DOT_586P equ 0x124
                              C res(DOT_686,  .686,  0, DRT_CPU, 0, P_86, P_686)
 = 125                      *1C T_DOT_686 equ 0x125
                              C res(DOT_686P, .686p, 0, DRT_CPU, 0, P_86, P_686p)
 = 126                      *1C T_DOT_686P equ 0x126
                              C res(DOT_K3D,  .k3d,  0, DRT_CPU, 0, P_586, P_K3D or P_MMX)
 = 127                      *1C T_DOT_K3D equ 0x127
                              C res(DOT_MMX,  .mmx,  0, DRT_CPU, 0, P_586, P_MMX)
 = 128                      *1C T_DOT_MMX equ 0x128
                              C res(DOT_XMM,  .xmm,  0, DRT_CPU, 0, P_686, P_MMX or P_SSEALL)
 = 129                      *1C T_DOT_XMM equ 0x129
                              C res(DOT_X64,  .x64,  0, DRT_CPU, 0, P_86, P_64)
 = 12A                      *1C T_DOT_X64 equ 0x12A
                              C res(DOT_X64P, .x64p, 0, DRT_CPU, 0, P_86, P_64p)
 = 12B                      *1C T_DOT_X64P equ 0x12B
                              C res(DOT_8087, .8087, 0, DRT_CPU, 0, P_86, P_87)
 = 12C                      *1C T_DOT_8087 equ 0x12C
                              C res(DOT_287,  .287,  0, DRT_CPU, 0, P_86, P_287)
 = 12D                      *1C T_DOT_287 equ 0x12D
                              C res(DOT_387,  .387,  0, DRT_CPU, 0, P_86, P_387)
 = 12E                      *1C T_DOT_387 equ 0x12E
                              C res(DOT_NO87, .no87, 0, DRT_CPU, 0, P_86, P_NO87)
 = 12F                      *1C T_DOT_NO87 equ 0x12F
                              C 
                              C endif
                              C 
                              C res(DOT_CREF,	    .cref,	 0, DRT_LISTING, 0, P_86, 0)
 = 130                      *1C T_DOT_CREF equ 0x130
                              C res(DOT_LFCOND,	    .lfcond,	 0, DRT_LISTING, 0, P_86, 0)
 = 131                      *1C T_DOT_LFCOND equ 0x131
                              C res(DOT_LIST,	    .list,	 0, DRT_LISTING, 0, P_86, 0)
 = 132                      *1C T_DOT_LIST equ 0x132
                              C res(DOT_LISTALL,    .listall,	 0, DRT_LISTING, 0, P_86, 0)
 = 133                      *1C T_DOT_LISTALL equ 0x133
                              C res(DOT_LISTIF,	    .listif,	 0, DRT_LISTING, 0, P_86, 0)
 = 134                      *1C T_DOT_LISTIF equ 0x134
                              C res(DOT_NOCREF,	    .nocref,	 DF_NOEXPAND, DRT_LISTING, 0, P_86, 0)
 = 135                      *1C T_DOT_NOCREF equ 0x135
                              C res(DOT_NOLIST,	    .nolist,	 0, DRT_LISTING, 0, P_86, 0)
 = 136                      *1C T_DOT_NOLIST equ 0x136
                              C res(DOT_NOLISTIF,   .nolistif,	 0, DRT_LISTING, 0, P_86, 0)
 = 137                      *1C T_DOT_NOLISTIF equ 0x137
                              C res(DOT_SFCOND,	    .sfcond,	 0, DRT_LISTING, 0, P_86, 0)
 = 138                      *1C T_DOT_SFCOND equ 0x138
                              C res(DOT_TFCOND,	    .tfcond,	 0, DRT_LISTING, 0, P_86, 0)
 = 139                      *1C T_DOT_TFCOND equ 0x139
                              C res(DOT_XCREF,	    .xcref,	 DF_NOEXPAND, DRT_LISTING, 0, P_86, 0)
 = 13A                      *1C T_DOT_XCREF equ 0x13A
                              C res(DOT_XLIST,	    .xlist,	 0, DRT_LISTING, 0, P_86, 0)
 = 13B                      *1C T_DOT_XLIST equ 0x13B
                              C res(DOT_PAGE,	    .page,	 0, DRT_LISTING, 0, P_86, 0)
 = 13C                      *1C T_DOT_PAGE equ 0x13C
                              C res(DOT_SUBTITLE,   .subtitle,	 0, DRT_LISTING, 0, P_86, 0)
 = 13D                      *1C T_DOT_SUBTITLE equ 0x13D
                              C res(DOT_SUBTTL,	    .subttl,	 0, DRT_LISTING, 0, P_86, 0)
 = 13E                      *1C T_DOT_SUBTTL equ 0x13E
                              C res(DOT_TITLE,	    .title,	 0, DRT_LISTING, 0, P_86, 0)
 = 13F                      *1C T_DOT_TITLE equ 0x13F
                              C res(DOT_LISTMACRO,  .listmacro,	 0, DRT_LISTMAC, 0, P_86, LM_LISTMACRO)
 = 140                      *1C T_DOT_LISTMACRO equ 0x140
                              C res(DOT_LISTMACROALL, .listmacroall, 0, DRT_LISTMAC, 0, P_86, LM_LISTMACROALL)
 = 141                      *1C T_DOT_LISTMACROALL equ 0x141
                              C res(DOT_NOLISTMACRO, .nolistmacro, 0, DRT_LISTMAC, 0, P_86, LM_NOLISTMACRO)
 = 142                      *1C T_DOT_NOLISTMACRO equ 0x142
                              C res(DOT_XALL,	    .xall,	 0, DRT_LISTMAC, 0, P_86, LM_LISTMACRO)
 = 143                      *1C T_DOT_XALL equ 0x143
                              C res(DOT_LALL,	    .lall,	 0, DRT_LISTMAC, 0, P_86, LM_LISTMACROALL)
 = 144                      *1C T_DOT_LALL equ 0x144
                              C res(DOT_SALL,	    .sall,	 0, DRT_LISTMAC, 0, P_86, LM_NOLISTMACRO)
 = 145                      *1C T_DOT_SALL equ 0x145
                              C res(DOT_ALPHA,	    .alpha,	 0, DRT_SEGORDER, 0, P_86, SEGORDER_ALPHA)
 = 146                      *1C T_DOT_ALPHA equ 0x146
                              C ifndef ASMC64
                              C res(DOT_DOSSEG,	    .dosseg,	 0, DRT_SEGORDER, 0, P_86, SEGORDER_DOSSEG)
 = 147                      *1C T_DOT_DOSSEG equ 0x147
                              C endif
                              C res(DOT_SEQ,	    .seq,	 0, DRT_SEGORDER, 0, P_86, SEGORDER_SEQ)
 = 148                      *1C T_DOT_SEQ equ 0x148
                              C ifndef ASMC64
                              C res(DOSSEG,	    dosseg,	 0, DRT_SEGORDER, 0, P_86, SEGORDER_DOSSEG)
 = 149                      *1C T_DOSSEG equ 0x149
                              C endif
                              C res(DOT_CODE,	    .code,	 DF_NOSTRUC or DF_PROC or DF_CGEN, DRT_SIMSEG, 0, P_86, 0)
 = 14A                      *1C T_DOT_CODE equ 0x14A
                              C ifndef ASMC64
                              C res(DOT_STACK,	    .stack,	 DF_NOSTRUC or DF_PROC or DF_CGEN, DRT_SIMSEG, 0, P_86, 1)
 = 14B                      *1C T_DOT_STACK equ 0x14B
                              C endif
                              C res(DOT_DATA,	    .data,	 DF_NOSTRUC or DF_PROC or DF_CGEN, DRT_SIMSEG, 0, P_86, 2)
 = 14C                      *1C T_DOT_DATA equ 0x14C
                              C res(DOT_DATA_UN,    .data?,	 DF_NOSTRUC or DF_PROC or DF_CGEN, DRT_SIMSEG, 0, P_86, 3)
 = 14D                      *1C T_DOT_DATA_UN equ 0x14D
                              C ifndef ASMC64
                              C res(DOT_FARDATA,    .fardata,	 DF_NOSTRUC or DF_PROC or DF_CGEN, DRT_SIMSEG, 0, P_86, 4)
 = 14E                      *1C T_DOT_FARDATA equ 0x14E
                              C res(DOT_FARDATA_UN, .fardata?,	 DF_NOSTRUC or DF_PROC or DF_CGEN, DRT_SIMSEG, 0, P_86, 5)
 = 14F                      *1C T_DOT_FARDATA_UN equ 0x14F
                              C endif
                              C res(DOT_CONST,	    .const,	 DF_NOSTRUC or DF_PROC or DF_CGEN, DRT_SIMSEG, 0, P_86, 6)
 = 150                      *1C T_DOT_CONST equ 0x150
                              C res(DOT_IF,	    .if,	 DF_CGEN or DF_CEXPR or DF_NOSTRUC or DF_STORE or DF_PROC, DRT_HLLSTART, 0, P_86, 0)
 = 151                      *1C T_DOT_IF equ 0x151
                              C res(DOT_REPEAT,	    .repeat,	 DF_CGEN or DF_NOSTRUC or DF_STORE or DF_PROC, DRT_HLLSTART, 0, P_86, 0)
 = 152                      *1C T_DOT_REPEAT equ 0x152
                              C res(DOT_WHILE,	    .while,	 DF_CGEN or DF_CEXPR or DF_NOSTRUC or DF_STORE or DF_PROC, DRT_HLLSTART, 0, P_86, 0)
 = 153                      *1C T_DOT_WHILE equ 0x153
                              C res(DOT_BREAK,	    .break,	 DF_CGEN, DRT_HLLEXIT, 0, P_86, 0)
 = 154                      *1C T_DOT_BREAK equ 0x154
                              C res(DOT_CONTINUE,   .continue,	 DF_CGEN, DRT_HLLEXIT, 0, P_86, 0)
 = 155                      *1C T_DOT_CONTINUE equ 0x155
                              C res(DOT_ELSE,	    .else,	 DF_CGEN, DRT_HLLEXIT, 0, P_86, 0)
 = 156                      *1C T_DOT_ELSE equ 0x156
                              C res(DOT_ELSEIF,	    .elseif,	 DF_CGEN or DF_CEXPR, DRT_HLLEXIT, 0, P_86, 0)
 = 157                      *1C T_DOT_ELSEIF equ 0x157
                              C res(DOT_ENDIF,	    .endif,	 DF_CGEN, DRT_HLLEND, 0, P_86, 0)
 = 158                      *1C T_DOT_ENDIF equ 0x158
                              C res(DOT_ENDW,	    .endw,	 DF_CGEN, DRT_HLLEND, 0, P_86, 0)
 = 159                      *1C T_DOT_ENDW equ 0x159
                              C res(DOT_UNTIL,	    .until,	 DF_CGEN or DF_CEXPR, DRT_HLLEND, 0, P_86, 0)
 = 15A                      *1C T_DOT_UNTIL equ 0x15A
                              C res(DOT_UNTILCXZ,   .untilcxz,	 DF_CGEN or DF_CEXPR, DRT_HLLEND, 0, P_86, 0)
 = 15B                      *1C T_DOT_UNTILCXZ equ 0x15B
                              C 
                              C res(DOT_IFA,	    .ifa,	 DF_CGEN or DF_CEXPR or DF_NOSTRUC or DF_STORE or DF_PROC, DRT_HLLSTART, 0, P_86, 0)
 = 15C                      *1C T_DOT_IFA equ 0x15C
                              C res(DOT_IFG,	    .ifg,	 DF_CGEN or DF_CEXPR or DF_NOSTRUC or DF_STORE or DF_PROC, DRT_HLLSTART, 0, P_86, 0)
 = 15D                      *1C T_DOT_IFG equ 0x15D
                              C res(DOT_IFL,	    .ifl,	 DF_CGEN or DF_CEXPR or DF_NOSTRUC or DF_STORE or DF_PROC, DRT_HLLSTART, 0, P_86, 0)
 = 15E                      *1C T_DOT_IFL equ 0x15E
                              C res(DOT_IFO,	    .ifo,	 DF_CGEN or DF_CEXPR or DF_NOSTRUC or DF_STORE or DF_PROC, DRT_HLLSTART, 0, P_86, 0)
 = 15F                      *1C T_DOT_IFO equ 0x15F
                              C res(DOT_IFP,	    .ifp,	 DF_CGEN or DF_CEXPR or DF_NOSTRUC or DF_STORE or DF_PROC, DRT_HLLSTART, 0, P_86, 0)
 = 160                      *1C T_DOT_IFP equ 0x160
                              C res(DOT_IFZ,	    .ifz,	 DF_CGEN or DF_CEXPR or DF_NOSTRUC or DF_STORE or DF_PROC, DRT_HLLSTART, 0, P_86, 0)
 = 161                      *1C T_DOT_IFZ equ 0x161
                              C res(DOT_IFNA,	    .ifna,	 DF_CGEN or DF_CEXPR or DF_NOSTRUC or DF_STORE or DF_PROC, DRT_HLLSTART, 0, P_86, 0)
 = 162                      *1C T_DOT_IFNA equ 0x162
                              C res(DOT_IFNB,	    .ifnb,	 DF_CGEN or DF_CEXPR or DF_NOSTRUC or DF_STORE or DF_PROC, DRT_HLLSTART, 0, P_86, 0)
 = 163                      *1C T_DOT_IFNB equ 0x163
                              C res(DOT_IFNC,	    .ifnc,	 DF_CGEN or DF_CEXPR or DF_NOSTRUC or DF_STORE or DF_PROC, DRT_HLLSTART, 0, P_86, 0)
 = 164                      *1C T_DOT_IFNC equ 0x164
                              C res(DOT_IFNG,	    .ifng,	 DF_CGEN or DF_CEXPR or DF_NOSTRUC or DF_STORE or DF_PROC, DRT_HLLSTART, 0, P_86, 0)
 = 165                      *1C T_DOT_IFNG equ 0x165
                              C res(DOT_IFNL,	    .ifnl,	 DF_CGEN or DF_CEXPR or DF_NOSTRUC or DF_STORE or DF_PROC, DRT_HLLSTART, 0, P_86, 0)
 = 166                      *1C T_DOT_IFNL equ 0x166
                              C res(DOT_IFNO,	    .ifno,	 DF_CGEN or DF_CEXPR or DF_NOSTRUC or DF_STORE or DF_PROC, DRT_HLLSTART, 0, P_86, 0)
 = 167                      *1C T_DOT_IFNO equ 0x167
                              C res(DOT_IFNP,	    .ifnp,	 DF_CGEN or DF_CEXPR or DF_NOSTRUC or DF_STORE or DF_PROC, DRT_HLLSTART, 0, P_86, 0)
 = 168                      *1C T_DOT_IFNP equ 0x168
                              C res(DOT_IFNS,	    .ifns,	 DF_CGEN or DF_CEXPR or DF_NOSTRUC or DF_STORE or DF_PROC, DRT_HLLSTART, 0, P_86, 0)
 = 169                      *1C T_DOT_IFNS equ 0x169
                              C res(DOT_IFNZ,	    .ifnz,	 DF_CGEN or DF_CEXPR or DF_NOSTRUC or DF_STORE or DF_PROC, DRT_HLLSTART, 0, P_86, 0)
 = 16A                      *1C T_DOT_IFNZ equ 0x16A
                              C res(DOT_IFB,	    .ifb,	 DF_CGEN or DF_CEXPR or DF_NOSTRUC or DF_STORE or DF_PROC, DRT_HLLSTART, 0, P_86, 0)
 = 16B                      *1C T_DOT_IFB equ 0x16B
                              C res(DOT_IFC,	    .ifc,	 DF_CGEN or DF_CEXPR or DF_NOSTRUC or DF_STORE or DF_PROC, DRT_HLLSTART, 0, P_86, 0)
 = 16C                      *1C T_DOT_IFC equ 0x16C
                              C res(DOT_IFS,	    .ifs,	 DF_CGEN or DF_CEXPR or DF_NOSTRUC or DF_STORE or DF_PROC, DRT_HLLSTART, 0, P_86, 0)
 = 16D                      *1C T_DOT_IFS equ 0x16D
                              C res(DOT_IFW,	    .ifw,	 DF_CGEN or DF_CEXPR or DF_NOSTRUC or DF_STORE or DF_PROC, DRT_HLLSTART, 0, P_86, 0)
 = 16E                      *1C T_DOT_IFW equ 0x16E
                              C res(DOT_IFD,	    .ifd,	 DF_CGEN or DF_CEXPR or DF_NOSTRUC or DF_STORE or DF_PROC, DRT_HLLSTART, 0, P_86, 0)
 = 16F                      *1C T_DOT_IFD equ 0x16F
                              C res(DOT_IFSB,	    .ifsb,	 DF_CGEN or DF_CEXPR or DF_NOSTRUC or DF_STORE or DF_PROC, DRT_HLLSTART, 0, P_86, 0)
 = 170                      *1C T_DOT_IFSB equ 0x170
                              C res(DOT_IFSW,	    .ifsw,	 DF_CGEN or DF_CEXPR or DF_NOSTRUC or DF_STORE or DF_PROC, DRT_HLLSTART, 0, P_86, 0)
 = 171                      *1C T_DOT_IFSW equ 0x171
                              C res(DOT_IFSD,	    .ifsd,	 DF_CGEN or DF_CEXPR or DF_NOSTRUC or DF_STORE or DF_PROC, DRT_HLLSTART, 0, P_86, 0)
 = 172                      *1C T_DOT_IFSD equ 0x172
                              C 
                              C res(DOT_ELSEIFS,    .elseifs,	 DF_CGEN or DF_CEXPR, DRT_HLLEXIT, 0, P_86, 0)
 = 173                      *1C T_DOT_ELSEIFS equ 0x173
                              C res(DOT_ELSEIFD,    .elseifd,	 DF_CGEN or DF_CEXPR, DRT_HLLEXIT, 0, P_64, 0)
 = 174                      *1C T_DOT_ELSEIFD equ 0x174
                              C res(DOT_ELSEIFSD,   .elseifsd,	 DF_CGEN or DF_CEXPR, DRT_HLLEXIT, 0, P_64, 0)
 = 175                      *1C T_DOT_ELSEIFSD equ 0x175
                              C 
                              C res(DOT_WHILEA,	    .whilea,	 DF_CGEN or DF_CEXPR or DF_NOSTRUC or DF_STORE or DF_PROC, DRT_HLLSTART, 0, P_86, 0)
 = 176                      *1C T_DOT_WHILEA equ 0x176
                              C res(DOT_WHILEG,	    .whileg,	 DF_CGEN or DF_CEXPR or DF_NOSTRUC or DF_STORE or DF_PROC, DRT_HLLSTART, 0, P_86, 0)
 = 177                      *1C T_DOT_WHILEG equ 0x177
                              C res(DOT_WHILEL,	    .whilel,	 DF_CGEN or DF_CEXPR or DF_NOSTRUC or DF_STORE or DF_PROC, DRT_HLLSTART, 0, P_86, 0)
 = 178                      *1C T_DOT_WHILEL equ 0x178
                              C res(DOT_WHILEO,	    .whileo,	 DF_CGEN or DF_CEXPR or DF_NOSTRUC or DF_STORE or DF_PROC, DRT_HLLSTART, 0, P_86, 0)
 = 179                      *1C T_DOT_WHILEO equ 0x179
                              C res(DOT_WHILEP,	    .whilep,	 DF_CGEN or DF_CEXPR or DF_NOSTRUC or DF_STORE or DF_PROC, DRT_HLLSTART, 0, P_86, 0)
 = 17A                      *1C T_DOT_WHILEP equ 0x17A
                              C res(DOT_WHILEZ,	    .whilez,	 DF_CGEN or DF_CEXPR or DF_NOSTRUC or DF_STORE or DF_PROC, DRT_HLLSTART, 0, P_86, 0)
 = 17B                      *1C T_DOT_WHILEZ equ 0x17B
                              C res(DOT_WHILENA,    .whilena,	 DF_CGEN or DF_CEXPR or DF_NOSTRUC or DF_STORE or DF_PROC, DRT_HLLSTART, 0, P_86, 0)
 = 17C                      *1C T_DOT_WHILENA equ 0x17C
                              C res(DOT_WHILENB,    .whilenb,	 DF_CGEN or DF_CEXPR or DF_NOSTRUC or DF_STORE or DF_PROC, DRT_HLLSTART, 0, P_86, 0)
 = 17D                      *1C T_DOT_WHILENB equ 0x17D
                              C res(DOT_WHILENG,    .whileng,	 DF_CGEN or DF_CEXPR or DF_NOSTRUC or DF_STORE or DF_PROC, DRT_HLLSTART, 0, P_86, 0)
 = 17E                      *1C T_DOT_WHILENG equ 0x17E
                              C res(DOT_WHILENL,    .whilenl,	 DF_CGEN or DF_CEXPR or DF_NOSTRUC or DF_STORE or DF_PROC, DRT_HLLSTART, 0, P_86, 0)
 = 17F                      *1C T_DOT_WHILENL equ 0x17F
                              C res(DOT_WHILENO,    .whileno,	 DF_CGEN or DF_CEXPR or DF_NOSTRUC or DF_STORE or DF_PROC, DRT_HLLSTART, 0, P_86, 0)
 = 180                      *1C T_DOT_WHILENO equ 0x180
                              C res(DOT_WHILENP,    .whilenp,	 DF_CGEN or DF_CEXPR or DF_NOSTRUC or DF_STORE or DF_PROC, DRT_HLLSTART, 0, P_86, 0)
 = 181                      *1C T_DOT_WHILENP equ 0x181
                              C res(DOT_WHILENS,    .whilens,	 DF_CGEN or DF_CEXPR or DF_NOSTRUC or DF_STORE or DF_PROC, DRT_HLLSTART, 0, P_86, 0)
 = 182                      *1C T_DOT_WHILENS equ 0x182
                              C res(DOT_WHILENZ,    .whilenz,	 DF_CGEN or DF_CEXPR or DF_NOSTRUC or DF_STORE or DF_PROC, DRT_HLLSTART, 0, P_86, 0)
 = 183                      *1C T_DOT_WHILENZ equ 0x183
                              C res(DOT_WHILEB,	    .whileb,	 DF_CGEN or DF_CEXPR or DF_NOSTRUC or DF_STORE or DF_PROC, DRT_HLLSTART, 0, P_86, 0)
 = 184                      *1C T_DOT_WHILEB equ 0x184
                              C res(DOT_WHILES,	    .whiles,	 DF_CGEN or DF_CEXPR or DF_NOSTRUC or DF_STORE or DF_PROC, DRT_HLLSTART, 0, P_86, 0)
 = 185                      *1C T_DOT_WHILES equ 0x185
                              C res(DOT_WHILEW,	    .whilew,	 DF_CGEN or DF_CEXPR or DF_NOSTRUC or DF_STORE or DF_PROC, DRT_HLLSTART, 0, P_86, 0)
 = 186                      *1C T_DOT_WHILEW equ 0x186
                              C res(DOT_WHILED,	    .whiled,	 DF_CGEN or DF_CEXPR or DF_NOSTRUC or DF_STORE or DF_PROC, DRT_HLLSTART, 0, P_86, 0)
 = 187                      *1C T_DOT_WHILED equ 0x187
                              C res(DOT_WHILESB,    .whilesb,	 DF_CGEN or DF_CEXPR or DF_NOSTRUC or DF_STORE or DF_PROC, DRT_HLLSTART, 0, P_86, 0)
 = 188                      *1C T_DOT_WHILESB equ 0x188
                              C res(DOT_WHILESW,    .whilesw,	 DF_CGEN or DF_CEXPR or DF_NOSTRUC or DF_STORE or DF_PROC, DRT_HLLSTART, 0, P_86, 0)
 = 189                      *1C T_DOT_WHILESW equ 0x189
                              C res(DOT_WHILESD,    .whilesd,	 DF_CGEN or DF_CEXPR or DF_NOSTRUC or DF_STORE or DF_PROC, DRT_HLLSTART, 0, P_86, 0)
 = 18A                      *1C T_DOT_WHILESD equ 0x18A
                              C 
                              C res(DOT_UNTILA,	    .untila,	 DF_CGEN or DF_CEXPR, DRT_HLLEND, 0, P_86, 0)
 = 18B                      *1C T_DOT_UNTILA equ 0x18B
                              C res(DOT_UNTILG,	    .untilg,	 DF_CGEN or DF_CEXPR, DRT_HLLEND, 0, P_86, 0)
 = 18C                      *1C T_DOT_UNTILG equ 0x18C
                              C res(DOT_UNTILL,	    .untill,	 DF_CGEN or DF_CEXPR, DRT_HLLEND, 0, P_86, 0)
 = 18D                      *1C T_DOT_UNTILL equ 0x18D
                              C res(DOT_UNTILO,	    .untilo,	 DF_CGEN or DF_CEXPR, DRT_HLLEND, 0, P_86, 0)
 = 18E                      *1C T_DOT_UNTILO equ 0x18E
                              C res(DOT_UNTILP,	    .untilp,	 DF_CGEN or DF_CEXPR, DRT_HLLEND, 0, P_86, 0)
 = 18F                      *1C T_DOT_UNTILP equ 0x18F
                              C res(DOT_UNTILZ,	    .untilz,	 DF_CGEN or DF_CEXPR, DRT_HLLEND, 0, P_86, 0)
 = 190                      *1C T_DOT_UNTILZ equ 0x190
                              C res(DOT_UNTILNA,    .untilna,	 DF_CGEN or DF_CEXPR, DRT_HLLEND, 0, P_86, 0)
 = 191                      *1C T_DOT_UNTILNA equ 0x191
                              C res(DOT_UNTILNB,    .untilnb,	 DF_CGEN or DF_CEXPR, DRT_HLLEND, 0, P_86, 0)
 = 192                      *1C T_DOT_UNTILNB equ 0x192
                              C res(DOT_UNTILNG,    .untilng,	 DF_CGEN or DF_CEXPR, DRT_HLLEND, 0, P_86, 0)
 = 193                      *1C T_DOT_UNTILNG equ 0x193
                              C res(DOT_UNTILNL,    .untilnl,	 DF_CGEN or DF_CEXPR, DRT_HLLEND, 0, P_86, 0)
 = 194                      *1C T_DOT_UNTILNL equ 0x194
                              C res(DOT_UNTILNO,    .untilno,	 DF_CGEN or DF_CEXPR, DRT_HLLEND, 0, P_86, 0)
 = 195                      *1C T_DOT_UNTILNO equ 0x195
                              C res(DOT_UNTILNP,    .untilnp,	 DF_CGEN or DF_CEXPR, DRT_HLLEND, 0, P_86, 0)
 = 196                      *1C T_DOT_UNTILNP equ 0x196
                              C res(DOT_UNTILNS,    .untilns,	 DF_CGEN or DF_CEXPR, DRT_HLLEND, 0, P_86, 0)
 = 197                      *1C T_DOT_UNTILNS equ 0x197
                              C res(DOT_UNTILNZ,    .untilnz,	 DF_CGEN or DF_CEXPR, DRT_HLLEND, 0, P_86, 0)
 = 198                      *1C T_DOT_UNTILNZ equ 0x198
                              C res(DOT_UNTILB,	    .untilb,	 DF_CGEN or DF_CEXPR, DRT_HLLEND, 0, P_86, 0)
 = 199                      *1C T_DOT_UNTILB equ 0x199
                              C res(DOT_UNTILS,	    .untils,	 DF_CGEN or DF_CEXPR, DRT_HLLEND, 0, P_86, 0)
 = 19A                      *1C T_DOT_UNTILS equ 0x19A
                              C res(DOT_UNTILW,	    .untilw,	 DF_CGEN or DF_CEXPR, DRT_HLLEND, 0, P_86, 0)
 = 19B                      *1C T_DOT_UNTILW equ 0x19B
                              C res(DOT_UNTILD,	    .untild,	 DF_CGEN or DF_CEXPR, DRT_HLLEND, 0, P_86, 0)
 = 19C                      *1C T_DOT_UNTILD equ 0x19C
                              C res(DOT_UNTILSB,    .untilsb,	 DF_CGEN or DF_CEXPR, DRT_HLLEND, 0, P_86, 0)
 = 19D                      *1C T_DOT_UNTILSB equ 0x19D
                              C res(DOT_UNTILSW,    .untilsw,	 DF_CGEN or DF_CEXPR, DRT_HLLEND, 0, P_86, 0)
 = 19E                      *1C T_DOT_UNTILSW equ 0x19E
                              C res(DOT_UNTILSD,    .untilsd,	 DF_CGEN or DF_CEXPR, DRT_HLLEND, 0, P_86, 0)
 = 19F                      *1C T_DOT_UNTILSD equ 0x19F
                              C 
                              C res(DOT_ASSERT,	    .assert,	 DF_CGEN or DF_CEXPR or DF_NOSTRUC or DF_STORE or DF_PROC, DRT_ASSERT, 0, P_86, 0)
 = 1A0                      *1C T_DOT_ASSERT equ 0x1A0
                              C res(DOT_ASSERTB,    .assertb,	 DF_CGEN or DF_CEXPR or DF_NOSTRUC or DF_STORE or DF_PROC, DRT_ASSERT, 0, P_86, 0)
 = 1A1                      *1C T_DOT_ASSERTB equ 0x1A1
                              C res(DOT_ASSERTW,    .assertw,	 DF_CGEN or DF_CEXPR or DF_NOSTRUC or DF_STORE or DF_PROC, DRT_ASSERT, 0, P_86, 0)
 = 1A2                      *1C T_DOT_ASSERTW equ 0x1A2
                              C res(DOT_ASSERTD,    .assertd,	 DF_CGEN or DF_CEXPR or DF_NOSTRUC or DF_STORE or DF_PROC, DRT_ASSERT, 0, P_86, 0)
 = 1A3                      *1C T_DOT_ASSERTD equ 0x1A3
                              C 
                              C res(DOT_FOR,	    .for,	 DF_CGEN or DF_CEXPR or DF_NOSTRUC or DF_STORE or DF_PROC, DRT_HLLFOR, 0, P_86, 0)
 = 1A4                      *1C T_DOT_FOR equ 0x1A4
                              C res(DOT_FORS,	    .fors,	 DF_CGEN or DF_CEXPR or DF_NOSTRUC or DF_STORE or DF_PROC, DRT_HLLFOR, 0, P_86, 0)
 = 1A5                      *1C T_DOT_FORS equ 0x1A5
                              C res(DOT_ENDF,	    .endf,	 DF_CGEN, DRT_HLLFOR, 0, P_86, 0)
 = 1A6                      *1C T_DOT_ENDF equ 0x1A6
                              C 
                              C res(UNDEF,	    undef,	 DF_NOEXPAND or DF_NOCONCAT, DRT_UNDEF, 0, P_86, 0)
 = 1A7                      *1C T_UNDEF equ 0x1A7
                              C res(DOT_CLASS,	    .class,	 DF_CGEN or DF_CEXPR or DF_NOSTRUC or DF_STORE or DF_PROC, DRT_CLASS, 0, P_86, 0)
 = 1A8                      *1C T_DOT_CLASS equ 0x1A8
                              C res(DOT_COMDEF,	    .comdef,	 DF_CGEN or DF_CEXPR or DF_NOSTRUC or DF_STORE or DF_PROC, DRT_CLASS, 0, P_86, 0)
 = 1A9                      *1C T_DOT_COMDEF equ 0x1A9
                              C res(DOT_TEMPLATE,   .template,	 DF_CGEN or DF_CEXPR or DF_NOSTRUC or DF_STORE or DF_PROC, DRT_CLASS, 0, P_86, 0)
 = 1AA                      *1C T_DOT_TEMPLATE equ 0x1AA
                              C res(DOT_OPERATOR,   .operator,	 DF_LABEL,						   DRT_CLASS, 0, P_86, 0)
 = 1AB                      *1C T_DOT_OPERATOR equ 0x1AB
                              C res(DOT_INLINE,	    .inline,	 DF_LABEL,						   DRT_CLASS, 0, P_86, 0)
 = 1AC                      *1C T_DOT_INLINE equ 0x1AC
                              C res(DOT_STATIC,	    .static,	 DF_LABEL,						   DRT_CLASS, 0, P_86, 0)
 = 1AD                      *1C T_DOT_STATIC equ 0x1AD
                              C res(DOT_ENDS,	    .ends,	 DF_CGEN, DRT_CLASS,  0, P_86, 0)
 = 1AE                      *1C T_DOT_ENDS equ 0x1AE
                              C res(RETM,	    retm,	 DF_STRPARM, DRT_MACINT, 0, P_86, 0)
 = 1AF                      *1C T_RETM equ 0x1AF
                              C res(DOT_NEW,	    .new,	 DF_CGEN or DF_CEXPR or DF_NOSTRUC or DF_STORE or DF_PROC, DRT_NEW, 0, P_86, 0)
 = 1B0                      *1C T_DOT_NEW equ 0x1B0
                              C res(DOT_ENUM,	    .enum,	 DF_CGEN or DF_CEXPR or DF_NOSTRUC or DF_STORE or DF_PROC or DF_NOCONCAT, DRT_ENUM, 0, P_86, 0)
 = 1B1                      *1C T_DOT_ENUM equ 0x1B1
                              C res(DOT_ENUMT,	    .enumt,	 DF_CGEN or DF_CEXPR or DF_NOSTRUC or DF_STORE or DF_PROC or DF_NOCONCAT, DRT_ENUM, 0, P_86, 0)
 = 1B2                      *1C T_DOT_ENUMT equ 0x1B2
                              C res(DOT_NAMESPACE,  .namespace,	 DF_CGEN or DF_CEXPR or DF_NOSTRUC or DF_STORE or DF_PROC or DF_NOCONCAT, DRT_NAMESPACE, 0, P_86, 0)
 = 1B3                      *1C T_DOT_NAMESPACE equ 0x1B3
                              C res(DOT_ENDN,	    .endn,	 0, DRT_NAMESPACE, 0, P_86, 0)
 = 1B4                      *1C T_DOT_ENDN equ 0x1B4
                              C 
                              C res(DOT_SWITCH,	    .switch,	 DF_CGEN or DF_CEXPR or DF_NOSTRUC or DF_STORE or DF_PROC, DRT_SWITCH, 0, P_86, 0)
 = 1B5                      *1C T_DOT_SWITCH equ 0x1B5
                              C res(DOT_CASE,	    .case,	 DF_CGEN or DF_CEXPR, DRT_SWITCH, 0, P_86, 0)
 = 1B6                      *1C T_DOT_CASE equ 0x1B6
                              C res(DOT_ENDC,	    .endc,	 DF_CGEN, DRT_SWITCH, 0, P_86, 0)
 = 1B7                      *1C T_DOT_ENDC equ 0x1B7
                              C res(DOT_GOTOSW,	    .gotosw,	 DF_CGEN, DRT_SWITCH, 0, P_86, 0)
 = 1B8                      *1C T_DOT_GOTOSW equ 0x1B8
                              C res(DOT_DEFAULT,    .default,	 DF_CGEN or DF_CEXPR, DRT_SWITCH, 0, P_86, 0)
 = 1B9                      *1C T_DOT_DEFAULT equ 0x1B9
                              C res(DOT_ENDSW,	    .endsw,	 DF_CGEN, DRT_SWITCH, 0, P_86, 0)
 = 1BA                      *1C T_DOT_ENDSW equ 0x1BA
                              C res(DOT_RETURN,	    .return,	 DF_CGEN or DF_CEXPR or DF_NOSTRUC or DF_STORE or DF_PROC, DRT_RETURN, 0, P_86, 0)
 = 1BB                      *1C T_DOT_RETURN equ 0x1BB
                              C res(DOT_PRAGMA,	    .pragma,	 DF_CGEN or DF_CEXPR or DF_NOSTRUC or DF_STORE or DF_PROC, DRT_PRAGMA, 0, P_86, 0)
 = 1BC                      *1C T_DOT_PRAGMA equ 0x1BC
                              C 
                              C ifndef ASMC64
                              C 
                              C res(DOT_EXIT,	    .exit,	 DF_CGEN or DF_STORE, DRT_STARTEXIT, 0, P_86, 0)
 = 1BD                      *1C T_DOT_EXIT equ 0x1BD
                              C res(DOT_STARTUP,    .startup,	 DF_CGEN or DF_STORE, DRT_STARTEXIT, 0, P_86, 0)
 = 1BE                      *1C T_DOT_STARTUP equ 0x1BE
                              C res(DOT_MODEL,	    .model,	 DF_CGEN, DRT_MODEL, 0, P_86, 0)
 = 1BF                      *1C T_DOT_MODEL equ 0x1BF
                              C 
                              C endif
                              C 
                              C res(DOT_RADIX,	    .radix,	 0, DRT_RADIX, 0, P_86, 0)
 = 1C0                      *1C T_DOT_RADIX equ 0x1C0
                              C res(DOT_SAFESEH,    .safeseh,	 0, DRT_SAFESEH, RWF_IA32, P_386, 0)
 = 1C1                      *1C T_DOT_SAFESEH equ 0x1C1
                              C res(DOT_ERR,	    .err,	 DF_STRPARM or DF_STORE, DRT_ERRDIR, 0, P_86, 0)
 = 1C2                      *1C T_DOT_ERR equ 0x1C2
                              C res(DOT_ERR1,	    .err1,	 DF_STRPARM or DF_STORE, DRT_ERRDIR, 0, P_86, CC_PASS1)
 = 1C3                      *1C T_DOT_ERR1 equ 0x1C3
                              C res(DOT_ERR2,	    .err2,	 DF_STRPARM or DF_STORE, DRT_ERRDIR, 0, P_86, CC_PASS2)
 = 1C4                      *1C T_DOT_ERR2 equ 0x1C4
                              C res(DOT_ERRE,	    .erre,	 DF_STORE, DRT_ERRDIR, 0, P_86, CC_NUMARG)
 = 1C5                      *1C T_DOT_ERRE equ 0x1C5
                              C res(DOT_ERRNZ,	    .errnz,	 DF_STORE, DRT_ERRDIR, 0, P_86, CC_NUMARG)
 = 1C6                      *1C T_DOT_ERRNZ equ 0x1C6
                              C res(DOT_ERRDIF,	    .errdif,	 DF_STRPARM or DF_STORE, DRT_ERRDIR, 0, P_86, CC_LITARG)
 = 1C7                      *1C T_DOT_ERRDIF equ 0x1C7
                              C res(DOT_ERRDIFI,    .errdifi,	 DF_STRPARM or DF_STORE, DRT_ERRDIR, 0, P_86, CC_LITARG)
 = 1C8                      *1C T_DOT_ERRDIFI equ 0x1C8
                              C res(DOT_ERRIDN,	    .erridn,	 DF_STRPARM or DF_STORE, DRT_ERRDIR, 0, P_86, CC_LITARG)
 = 1C9                      *1C T_DOT_ERRIDN equ 0x1C9
                              C res(DOT_ERRIDNI,    .erridni,	 DF_STRPARM or DF_STORE, DRT_ERRDIR, 0, P_86, CC_LITARG)
 = 1CA                      *1C T_DOT_ERRIDNI equ 0x1CA
                              C res(DOT_ERRB,	    .errb,	 DF_STRPARM or DF_STORE, DRT_ERRDIR, 0, P_86, CC_BLKARG)
 = 1CB                      *1C T_DOT_ERRB equ 0x1CB
                              C res(DOT_ERRNB,	    .errnb,	 DF_STRPARM or DF_STORE, DRT_ERRDIR, 0, P_86, CC_BLKARG)
 = 1CC                      *1C T_DOT_ERRNB equ 0x1CC
                              C res(DOT_ERRDEF,	    .errdef,	 DF_STRPARM or DF_STORE, DRT_ERRDIR, 0, P_86, CC_SYMARG)
 = 1CD                      *1C T_DOT_ERRDEF equ 0x1CD
                              C res(DOT_ERRNDEF,    .errndef,	 DF_STRPARM or DF_STORE, DRT_ERRDIR, 0, P_86, CC_SYMARG)
 = 1CE                      *1C T_DOT_ERRNDEF equ 0x1CE
                              C res(COMMENT,	    comment,	 0, DRT_CONDDIR, 0, P_86, 0)
 = 1CF                      *1C T_COMMENT equ 0x1CF
                              C res(IF,		    if,		 0, DRT_CONDDIR, 0, P_86, CC_NUMARG)
 = 1D0                      *1C T_IF equ 0x1D0
                              C res(IFE,	    ife,	 0, DRT_CONDDIR, 0, P_86, CC_NUMARG)
 = 1D1                      *1C T_IFE equ 0x1D1
                              C res(IF1,	    if1,	 0, DRT_CONDDIR, 0, P_86, CC_PASS1)
 = 1D2                      *1C T_IF1 equ 0x1D2
                              C res(IF2,	    if2,	 0, DRT_CONDDIR, 0, P_86, CC_PASS2)
 = 1D3                      *1C T_IF2 equ 0x1D3
                              C res(IFDIF,	    ifdif,	 DF_STRPARM, DRT_CONDDIR, 0, P_86, CC_LITARG)
 = 1D4                      *1C T_IFDIF equ 0x1D4
                              C res(IFDIFI,	    ifdifi,	 DF_STRPARM, DRT_CONDDIR, 0, P_86, CC_LITARG)
 = 1D5                      *1C T_IFDIFI equ 0x1D5
                              C res(IFIDN,	    ifidn,	 DF_STRPARM, DRT_CONDDIR, 0, P_86, CC_LITARG)
 = 1D6                      *1C T_IFIDN equ 0x1D6
                              C res(IFIDNI,	    ifidni,	 DF_STRPARM, DRT_CONDDIR, 0, P_86, CC_LITARG)
 = 1D7                      *1C T_IFIDNI equ 0x1D7
                              C res(IFB,	    ifb,	 DF_STRPARM, DRT_CONDDIR, 0, P_86, CC_BLKARG)
 = 1D8                      *1C T_IFB equ 0x1D8
                              C res(IFNB,	    ifnb,	 DF_STRPARM, DRT_CONDDIR, 0, P_86, CC_BLKARG)
 = 1D9                      *1C T_IFNB equ 0x1D9
                              C res(IFDEF,	    ifdef,	 DF_NOEXPAND, DRT_CONDDIR, 0, P_86, CC_SYMARG)
 = 1DA                      *1C T_IFDEF equ 0x1DA
                              C res(IFNDEF,	    ifndef,	 DF_NOEXPAND, DRT_CONDDIR, 0, P_86, CC_SYMARG)
 = 1DB                      *1C T_IFNDEF equ 0x1DB
                              C res(ELSE,	    else,	 0, DRT_CONDDIR, 0, P_86, 0)
 = 1DC                      *1C T_ELSE equ 0x1DC
                              C res(ELSEIF,	    elseif,	 0, DRT_CONDDIR, 0, P_86, CC_NUMARG)
 = 1DD                      *1C T_ELSEIF equ 0x1DD
                              C res(ELSEIFE,	    elseife,	 0, DRT_CONDDIR, 0, P_86, CC_NUMARG)
 = 1DE                      *1C T_ELSEIFE equ 0x1DE
                              C res(ELSEIF1,	    elseif1,	 0, DRT_CONDDIR, 0, P_86, CC_PASS1)
 = 1DF                      *1C T_ELSEIF1 equ 0x1DF
                              C res(ELSEIF2,	    elseif2,	 0, DRT_CONDDIR, 0, P_86, CC_PASS2)
 = 1E0                      *1C T_ELSEIF2 equ 0x1E0
                              C res(ELSEIFDIF,	    elseifdif,	 DF_STRPARM, DRT_CONDDIR, 0, P_86, CC_LITARG)
 = 1E1                      *1C T_ELSEIFDIF equ 0x1E1
                              C res(ELSEIFDIFI,	    elseifdifi,	 DF_STRPARM, DRT_CONDDIR, 0, P_86, CC_LITARG)
 = 1E2                      *1C T_ELSEIFDIFI equ 0x1E2
                              C res(ELSEIFIDN,	    elseifidn,	 DF_STRPARM, DRT_CONDDIR, 0, P_86, CC_LITARG)
 = 1E3                      *1C T_ELSEIFIDN equ 0x1E3
                              C res(ELSEIFIDNI,	    elseifidni,	 DF_STRPARM, DRT_CONDDIR, 0, P_86, CC_LITARG)
 = 1E4                      *1C T_ELSEIFIDNI equ 0x1E4
                              C res(ELSEIFB,	    elseifb,	 DF_STRPARM, DRT_CONDDIR, 0, P_86, CC_BLKARG)
 = 1E5                      *1C T_ELSEIFB equ 0x1E5
                              C res(ELSEIFNB,	    elseifnb,	 DF_STRPARM, DRT_CONDDIR, 0, P_86, CC_BLKARG)
 = 1E6                      *1C T_ELSEIFNB equ 0x1E6
                              C res(ELSEIFDEF,	    elseifdef,	 DF_NOEXPAND, DRT_CONDDIR, 0, P_86, CC_SYMARG)
 = 1E7                      *1C T_ELSEIFDEF equ 0x1E7
                              C res(ELSEIFNDEF,	    elseifndef,	 DF_NOEXPAND, DRT_CONDDIR, 0, P_86, CC_SYMARG)
 = 1E8                      *1C T_ELSEIFNDEF equ 0x1E8
                              C res(ENDIF,	    endif,	 0, DRT_CONDDIR, 0, P_86, 0)
 = 1E9                      *1C T_ENDIF equ 0x1E9
                              C res(FOR,	    for,	 DF_NOEXPAND, DRT_LOOPDIR, 0, P_86, 0)
 = 1EA                      *1C T_FOR equ 0x1EA
                              C res(FORC,	    forc,	 DF_NOEXPAND, DRT_LOOPDIR, 0, P_86, 0)
 = 1EB                      *1C T_FORC equ 0x1EB
                              C res(IRP,	    irp,	 0, DRT_LOOPDIR, 0, P_86, 0)
 = 1EC                      *1C T_IRP equ 0x1EC
                              C res(IRPC,	    irpc,	 0, DRT_LOOPDIR, 0, P_86, 0)
 = 1ED                      *1C T_IRPC equ 0x1ED
                              C res(REPEAT,	    repeat,	 0, DRT_LOOPDIR, 0, P_86, 0)
 = 1EE                      *1C T_REPEAT equ 0x1EE
                              C res(REPT,	    rept,	 0, DRT_LOOPDIR, 0, P_86, 0)
 = 1EF                      *1C T_REPT equ 0x1EF
                              C res(WHILE,	    while,	 0, DRT_LOOPDIR, 0, P_86, 0)
 = 1F0                      *1C T_WHILE equ 0x1F0
                              C res(MACRO,	    macro,	 DF_LABEL, DRT_MACRO, 0, P_86, 0)
 = 1F1                      *1C T_MACRO equ 0x1F1
                              C res(EXITM,	    exitm,	 DF_STRPARM, DRT_MACINT, 0, P_86, 0)
 = 1F2                      *1C T_EXITM equ 0x1F2
                              C res(ENDM,	    endm,	 0, DRT_MACINT, 0, P_86, 0)
 = 1F3                      *1C T_ENDM equ 0x1F3
                              C res(GOTO,	    goto,	 0, DRT_MACINT, 0, P_86, 0)
 = 1F4                      *1C T_GOTO equ 0x1F4
                              C res(PURGE,	    purge,	 0, DRT_PURGE, 0, P_86, 0)
 = 1F5                      *1C T_PURGE equ 0x1F5
                              C res(INCLUDE,	    include,	 DF_NOEXPAND or DF_NOCONCAT, DRT_INCLUDE,0, P_86, 0)
 = 1F6                      *1C T_INCLUDE equ 0x1F6
                              C res(TEXTEQU,	    textequ,	 DF_STRPARM or DF_LABEL, DRT_CATSTR, 0, P_86, 0)
 = 1F7                      *1C T_TEXTEQU equ 0x1F7
                              C res(CATSTR,	    catstr,	 DF_STRPARM or DF_LABEL, DRT_CATSTR, 0, P_86, 0)
 = 1F8                      *1C T_CATSTR equ 0x1F8
                              C res(SUBSTR,	    substr,	 DF_STRPARM or DF_LABEL, DRT_SUBSTR, 0, P_86, 0)
 = 1F9                      *1C T_SUBSTR equ 0x1F9
                              C res(INSTR,	    instr,	 DF_STRPARM or DF_LABEL, DRT_INSTR, 0, P_86, 0)
 = 1FA                      *1C T_INSTR equ 0x1FA
                              C res(SIZESTR,	    sizestr,	 DF_STRPARM or DF_LABEL, DRT_SIZESTR, 0, P_86, 0)
 = 1FB                      *1C T_SIZESTR equ 0x1FB
                              C res(DB,		    db,		 DF_LABEL, DRT_DATADIR, 0, P_86, T_BYTE)
 = 1FC                      *1C T_DB equ 0x1FC
                              C res(DW,		    dw,		 DF_LABEL, DRT_DATADIR, 0, P_86, T_WORD )
 = 1FD                      *1C T_DW equ 0x1FD
                              C res(DD,		    dd,		 DF_LABEL, DRT_DATADIR, 0, P_86, T_DWORD)
 = 1FE                      *1C T_DD equ 0x1FE
                              C res(DF,		    df,		 DF_LABEL, DRT_DATADIR, 0, P_86, T_FWORD)
 = 1FF                      *1C T_DF equ 0x1FF
                              C res(DQ,		    dq,		 DF_LABEL, DRT_DATADIR, 0, P_86, T_QWORD)
 = 200                      *1C T_DQ equ 0x200
                              C res(DT,		    dt,		 DF_LABEL, DRT_DATADIR, 0, P_86, T_TBYTE)
 = 201                      *1C T_DT equ 0x201
                              C res(DOT_ALLOCSTACK, .allocstack, 0, DRT_EXCFRAME, RWF_X64, P_64, 0)
 = 202                      *1C T_DOT_ALLOCSTACK equ 0x202
                              C res(DOT_ENDPROLOG,  .endprolog,	 0, DRT_EXCFRAME, RWF_X64, P_64, 0)
 = 203                      *1C T_DOT_ENDPROLOG equ 0x203
                              C res(DOT_PUSHFRAME,  .pushframe,	 0, DRT_EXCFRAME, RWF_X64, P_64, 0)
 = 204                      *1C T_DOT_PUSHFRAME equ 0x204
                              C res(DOT_PUSHREG,    .pushreg,	 0, DRT_EXCFRAME, RWF_X64, P_64, 0)
 = 205                      *1C T_DOT_PUSHREG equ 0x205
                              C res(DOT_SAVEREG,    .savereg,	 0, DRT_EXCFRAME, RWF_X64, P_64, 0)
 = 206                      *1C T_DOT_SAVEREG equ 0x206
                              C res(DOT_SAVEXMM128, .savexmm128, 0, DRT_EXCFRAME, RWF_X64, P_64, 0)
 = 207                      *1C T_DOT_SAVEXMM128 equ 0x207
                              C res(DOT_SETFRAME,   .setframe,	 0, DRT_EXCFRAME, RWF_X64, P_64, 0)
 = 208                      *1C T_DOT_SETFRAME equ 0x208
                              C res(STRUC,	    struc,	 DF_LABEL, DRT_STRUCT, 0, P_86, 0)
 = 209                      *1C T_STRUC equ 0x209
                              C res(STRUCT,	    struct,	 DF_LABEL, DRT_STRUCT, 0, P_86, 0)
 = 20A                      *1C T_STRUCT equ 0x20A
                              C res(UNION,	    union,	 DF_LABEL, DRT_STRUCT, 0, P_86, 0)
 = 20B                      *1C T_UNION equ 0x20B
                              C res(TYPEDEF,	    typedef,	 DF_LABEL, DRT_TYPEDEF,0, P_86, 0)
 = 20C                      *1C T_TYPEDEF equ 0x20C
                              C res(RECORD,	    record,	 DF_LABEL, DRT_RECORD, 0, P_86, 0)
 = 20D                      *1C T_RECORD equ 0x20D
                              C res(COMM,	    comm,	 0, DRT_COMM, 0, P_86, 0)
 = 20E                      *1C T_COMM equ 0x20E
                              C res(EXTERN,	    extern,	 0, DRT_EXTERN, 0, P_86, 0)
 = 20F                      *1C T_EXTERN equ 0x20F
                              C res(EXTRN,	    extrn,	 0, DRT_EXTERN, 0, P_86, 0)
 = 210                      *1C T_EXTRN equ 0x210
                              C res(EXTERNDEF,	    externdef,	 0, DRT_EXTERNDEF, 0, P_86, 0)
 = 211                      *1C T_EXTERNDEF equ 0x211
                              C res(PUBLIC,	    public,	 0, DRT_PUBLIC, 0, P_86, 0)
 = 212                      *1C T_PUBLIC equ 0x212
                              C res(PROTO,	    proto,	 DF_LABEL, DRT_PROTO, 0, P_86, 0)
 = 213                      *1C T_PROTO equ 0x213
                              C res(PROC,	    proc,	 DF_CGEN or DF_LABEL or DF_NOSTRUC or DF_STORE, DRT_PROC, 0, P_86, 0)
 = 214                      *1C T_PROC equ 0x214
                              C res(ENDP,	    endp,	 DF_LABEL or DF_NOSTRUC, DRT_ENDP, 0, P_86, 0)
 = 215                      *1C T_ENDP equ 0x215
                              C res(LOCAL,	    local,	 0, DRT_LOCAL, 0, P_86, 0)
 = 216                      *1C T_LOCAL equ 0x216
                              C res(LABEL,	    label,	 DF_LABEL or DF_NOSTRUC or DF_STORE, DRT_LABEL, 0, P_86, 0)
 = 217                      *1C T_LABEL equ 0x217
                              C res(INVOKE,	    invoke,	 DF_CGEN or DF_NOSTRUC or DF_PROC or DF_STORE, DRT_INVOKE, 0, P_86, 0)
 = 218                      *1C T_INVOKE equ 0x218
                              C res(ORG,	    org,	 0, DRT_ORG, 0, P_86, 0)
 = 219                      *1C T_ORG equ 0x219
                              C res(ALIGN,	    align,	 0, DRT_ALIGN, 0, P_86, 0)
 = 21A                      *1C T_ALIGN equ 0x21A
                              C res(EVEN,	    even,	 0, DRT_ALIGN, 0, P_86, 0)
 = 21B                      *1C T_EVEN equ 0x21B
                              C res(SEGMENT,	    segment,	 DF_LABEL or DF_NOSTRUC or DF_PROC,DRT_SEGMENT, 0,  P_86, 0)
 = 21C                      *1C T_SEGMENT equ 0x21C
                              C res(ENDS,	    ends,	 DF_LABEL, DRT_ENDS, 0, P_86, 0)
 = 21D                      *1C T_ENDS equ 0x21D
                              C res(GROUP,	    group,	 DF_LABEL, DRT_GROUP, 0, P_86, 0)
 = 21E                      *1C T_GROUP equ 0x21E
                              C res(ASSUME,	    assume,	 0, DRT_ASSUME, 0, P_86, 0)
 = 21F                      *1C T_ASSUME equ 0x21F
                              C res(ALIAS,	    alias,	 0, DRT_ALIAS, 0, P_86, 0)
 = 220                      *1C T_ALIAS equ 0x220
                              C res(ECHO,	    echo,	 DF_NOEXPAND or DF_NOCONCAT, DRT_ECHO, 0, P_86, 0)
 = 221                      *1C T_ECHO equ 0x221
                              C res(END,	    end,	 DF_CGEN or DF_NOSTRUC or DF_STORE, DRT_END, 0, P_86, 0)
 = 222                      *1C T_END equ 0x222
                              C res(EQU,	    equ,	 DF_STRPARM or DF_LABEL, DRT_EQU, 0, P_86, 0)
 = 223                      *1C T_EQU equ 0x223
                              C res(DEFINE,	    define,	 DF_STRPARM or DF_LABEL, DRT_EQU, 0, P_86, 0)
 = 224                      *1C T_DEFINE equ 0x224
                              C res(INCBIN,	    incbin,	 DF_NOSTRUC or DF_PROC or DF_STORE, DRT_INCBIN, 0, P_86, 0)
 = 225                      *1C T_INCBIN equ 0x225
                              C res(INCLUDELIB,	    includelib,	 DF_NOCONCAT, DRT_INCLIB, 0, P_86, 0)
 = 226                      *1C T_INCLUDELIB equ 0x226
                              C res(DOT_NAME,	    .name,	 0, DRT_DOT_NAME, 0, P_86, 0)
 = 227                      *1C T_DOT_NAME equ 0x227
                              C res(OPTION,	    option,	 0, DRT_OPTION, 0, P_86, 0)
 = 228                      *1C T_OPTION equ 0x228
                              C res(POPCONTEXT,	    popcontext,	 0, DRT_CONTEXT, 0, P_86, 0)
 = 229                      *1C T_POPCONTEXT equ 0x229
                              C res(PUSHCONTEXT,    pushcontext, 0, DRT_CONTEXT, 0, P_86, 0)
 = 22A                      *1C T_PUSHCONTEXT equ 0x22A
                              C 
                              C undef res
 = 22B                      * C SPECIAL_LAST equ 0x22B
                              C 
                              C insa macro tok, string, opcls, byte1_info, op_dir, rm_info, opcode, rm_byte, cpu, prefix, evex
 >                            C     @CatStr(<T_>,@SubStr(<tok>,2)),
 >                            C     endm
                              C insx macro tok, string, opcls, byte1_info, op_dir, rm_info, opcode, rm_byte, cpu, prefix, evex, flgs
 >                            C     @CatStr(<T_>,@SubStr(<tok>,2)),
 >                            C     endm
                              C insv macro tok, string, opcls, byte1_info, op_dir, rm_info, opcode, rm_byte, cpu, prefix, evex, flgs, rex
 >                            C     @CatStr(<T_>,@SubStr(<tok>,2)),
 >                            C     endm
                              C insn macro tok, suffix, opcls, byte1_info, op_dir, rm_info, opcode, rm_byte, cpu, prefix, evex
 >                            C     endm
                              C insm macro tok, suffix, opcls, byte1_info, op_dir, rm_info, opcode, rm_byte, cpu, prefix, evex
 >                            C     endm
                              C avxins macro op, tok, string, cpu, flgs
 >                            C     @CatStr(<T_>,@SubStr(<tok>,1)),
 >                            C     endm
                              C OpCls macro op1, op2, op3
 >                            C     exitm<OPC_&op1&&op2&&op3&>
 >                            C     endm
                              C .enum instr_token {
                            * C instr_token typedef sdword
 = 22A                      * C INS_FIRST_1 equ 0x22A
                              C include instruct.inc
                              C ; INSTRUCT.INC--
                              C ;
                              C ; Copyright (c) The Asmc Contributors. All rights reserved.
                              C ; Consult your license regarding permissions and restrictions.
                              C ;
                              C ; Description: table of instructions. Other reserved words see special.h
                              C ;
                              C ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                              C ;
                              C ; The order of items for an opcode (ins + insn) is IMPORTANT!
                              C ; And op1 has a higher precedence than op2.
                              C ; operands with type OP_A should be before OP_Rx & OP_R
                              C ; operands with type OP_M should follow OP_Mx
                              C ; operands with type OP_R should follow OP_Rx
                              C ; operands with type OP_I should follow OP_Ix
                              C ;
                              C ;
                              C ; v1.96: the table needn't be sorted anymore, but
                              C ; "additional" (=insn) entries must still be located after the
                              C ; main (=ins) entry. These entries must have a <suffix> so that <tok> +
                              C ; <suffix> gives a unique identifier.
                              C ;
                              C ;
                              C ; branch instructions
                              C ; there are some macros in codegen.h which rely on the order of the
                              C ; branch tokens. To satisfy those make sure:
                              C ; - the branch instructions are in order CALL, JMP, Jcc, JeCXZ, LOOPcc
                              C ; - no other instruction between these
                              C ;
                              C ;
                              C ; (tok, (suffix), op1-3, b1_inf, op_dir, rm_inf, opcode, rm_byte, cpu, prefix
                              C ;
                              C 
                              C insa(CALL, call, OpCls( I16, NONE, NONE  ), 0,      0, no_RM,  0xE8, 0x00, P_86,  0,0)
 = 22B                      *1C T_CALL equ 0x22B
                              C 
                              C ; start entries for FAR call
                              C 
                              C insa(JMP, jmp, OpCls( I8,   NONE,  NONE  ), 0,      0, no_RM,  0xEB, 0x00, P_86,  0,0)
 = 22C                      *1C T_JMP equ 0x22C
                              C 
                              C ; entries for FAR jmp
                              C 
                              C 
                              C ; for conditional jumps, the SHORT version must always be first!
                              C 
                              C insa(JA,  ja,  OpCls( I8, NONE, NONE ), 0,    0, no_RM, 0x77, 0x00, P_86, 0,0)
 = 22D                      *1C T_JA equ 0x22D
                              C insa(JAE, jae, OpCls( I8, NONE, NONE ), 0,    0, no_RM, 0x73, 0x00, P_86, 0,0)
 = 22E                      *1C T_JAE equ 0x22E
                              C insa(JB,  jb,  OpCls( I8, NONE, NONE ), 0,    0, no_RM, 0x72, 0x00, P_86, 0,0)
 = 22F                      *1C T_JB equ 0x22F
                              C insa(JBE, jbe, OpCls( I8, NONE, NONE ), 0,    0, no_RM, 0x76, 0x00, P_86, 0,0)
 = 230                      *1C T_JBE equ 0x230
                              C insa(JC,  jc,  OpCls( I8, NONE, NONE ), 0,    0, no_RM, 0x72, 0x00, P_86, 0,0)
 = 231                      *1C T_JC equ 0x231
                              C insa(JE,  je,  OpCls( I8, NONE, NONE ), 0,    0, no_RM, 0x74, 0x00, P_86, 0,0)
 = 232                      *1C T_JE equ 0x232
                              C insa(JG,  jg,  OpCls( I8, NONE, NONE ), 0,    0, no_RM, 0x7F, 0x00, P_86, 0,0)
 = 233                      *1C T_JG equ 0x233
                              C insa(JGE, jge, OpCls( I8, NONE, NONE ), 0,    0, no_RM, 0x7D, 0x00, P_86, 0,0)
 = 234                      *1C T_JGE equ 0x234
                              C insa(JL,  jl,  OpCls( I8, NONE, NONE ), 0,    0, no_RM, 0x7C, 0x00, P_86, 0,0)
 = 235                      *1C T_JL equ 0x235
                              C insa(JLE, jle, OpCls( I8, NONE, NONE ), 0,    0, no_RM, 0x7E, 0x00, P_86, 0,0)
 = 236                      *1C T_JLE equ 0x236
                              C insa(JNA, jna, OpCls( I8, NONE, NONE ), 0,    0, no_RM, 0x76, 0x00, P_86, 0,0)
 = 237                      *1C T_JNA equ 0x237
                              C insa(JNAE,jnae,OpCls( I8, NONE, NONE ), 0,    0, no_RM, 0x72, 0x00, P_86, 0,0)
 = 238                      *1C T_JNAE equ 0x238
                              C insa(JNB, jnb, OpCls( I8, NONE, NONE ), 0,    0, no_RM, 0x73, 0x00, P_86, 0,0)
 = 239                      *1C T_JNB equ 0x239
                              C insa(JNBE,jnbe,OpCls( I8, NONE, NONE ), 0,    0, no_RM, 0x77, 0x00, P_86, 0,0)
 = 23A                      *1C T_JNBE equ 0x23A
                              C insa(JNC, jnc, OpCls( I8, NONE, NONE ), 0,    0, no_RM, 0x73, 0x00, P_86, 0,0)
 = 23B                      *1C T_JNC equ 0x23B
                              C insa(JNE, jne, OpCls( I8, NONE, NONE ), 0,    0, no_RM, 0x75, 0x00, P_86, 0,0)
 = 23C                      *1C T_JNE equ 0x23C
                              C insa(JNG, jng, OpCls( I8, NONE, NONE ), 0,    0, no_RM, 0x7E, 0x00, P_86, 0,0)
 = 23D                      *1C T_JNG equ 0x23D
                              C insa(JNGE,jnge,OpCls( I8, NONE, NONE ), 0,    0, no_RM, 0x7C, 0x00, P_86, 0,0)
 = 23E                      *1C T_JNGE equ 0x23E
                              C insa(JNL, jnl, OpCls( I8, NONE, NONE ), 0,    0, no_RM, 0x7D, 0x00, P_86, 0,0)
 = 23F                      *1C T_JNL equ 0x23F
                              C insa(JNLE,jnle,OpCls( I8, NONE, NONE ), 0,    0, no_RM, 0x7F, 0x00, P_86, 0,0)
 = 240                      *1C T_JNLE equ 0x240
                              C insa(JNO, jno, OpCls( I8, NONE, NONE ), 0,    0, no_RM, 0x71, 0x00, P_86, 0,0)
 = 241                      *1C T_JNO equ 0x241
                              C insa(JNP, jnp, OpCls( I8, NONE, NONE ), 0,    0, no_RM, 0x7B, 0x00, P_86, 0,0)
 = 242                      *1C T_JNP equ 0x242
                              C insa(JNS, jns, OpCls( I8, NONE, NONE ), 0,    0, no_RM, 0x79, 0x00, P_86, 0,0)
 = 243                      *1C T_JNS equ 0x243
                              C insa(JNZ, jnz, OpCls( I8, NONE, NONE ), 0,    0, no_RM, 0x75, 0x00, P_86, 0,0)
 = 244                      *1C T_JNZ equ 0x244
                              C insa(JO,  jo,  OpCls( I8, NONE, NONE ), 0,    0, no_RM, 0x70, 0x00, P_86, 0,0)
 = 245                      *1C T_JO equ 0x245
                              C insa(JP,  jp,  OpCls( I8, NONE, NONE ), 0,    0, no_RM, 0x7A, 0x00, P_86, 0,0)
 = 246                      *1C T_JP equ 0x246
                              C insa(JPE, jpe, OpCls( I8, NONE, NONE ), 0,    0, no_RM, 0x7A, 0x00, P_86, 0,0)
 = 247                      *1C T_JPE equ 0x247
                              C insa(JPO, jpo, OpCls( I8, NONE, NONE ), 0,    0, no_RM, 0x7B, 0x00, P_86, 0,0)
 = 248                      *1C T_JPO equ 0x248
                              C insa(JS,  js,  OpCls( I8, NONE, NONE ), 0,    0, no_RM, 0x78, 0x00, P_86, 0,0)
 = 249                      *1C T_JS equ 0x249
                              C insa(JZ,  jz,  OpCls( I8, NONE, NONE ), 0,    0, no_RM, 0x74, 0x00, P_86, 0,0)
 = 24A                      *1C T_JZ equ 0x24A
                              C 
                              C insx(JCXZ,   jcxz,    OpCls( I8,   NONE,  NONE  ), F_16A,  0,  no_RM,  0xE3, 0x00, P_86,  0,0, RWF_IA32)
 = 24B                      *1C T_JCXZ equ 0x24B
                              C insa(JECXZ,  jecxz,   OpCls( I8,   NONE,  NONE  ), F_32A,  0,  no_RM,  0xE3, 0x00, P_386, 0,0)
 = 24C                      *1C T_JECXZ equ 0x24C
                              C insx(JRCXZ,  jrcxz,   OpCls( I8,   NONE,  NONE  ), 0,      0,  no_RM,  0xE3, 0x00, P_64,  0,0, RWF_X64)
 = 24D                      *1C T_JRCXZ equ 0x24D
                              C insa(LOOP,   loop,    OpCls( I8,   NONE,  NONE  ), 0,      0,  no_RM,  0xE2, 0x00, P_86,  0,0)
 = 24E                      *1C T_LOOP equ 0x24E
                              C insa(LOOPE,  loope,   OpCls( I8,   NONE,  NONE  ), 0,      0,  no_RM,  0xE1, 0x00, P_86,  0,0)
 = 24F                      *1C T_LOOPE equ 0x24F
                              C insa(LOOPZ,  loopz,   OpCls( I8,   NONE,  NONE  ), 0,      0,  no_RM,  0xE1, 0x00, P_86,  0,0)
 = 250                      *1C T_LOOPZ equ 0x250
                              C insa(LOOPNE, loopne,  OpCls( I8,   NONE,  NONE  ), 0,      0,  no_RM,  0xE0, 0x00, P_86,  0,0)
 = 251                      *1C T_LOOPNE equ 0x251
                              C insa(LOOPNZ, loopnz,  OpCls( I8,   NONE,  NONE  ), 0,      0,  no_RM,  0xE0, 0x00, P_86,  0,0)
 = 252                      *1C T_LOOPNZ equ 0x252
                              C insa(LOOPD,  loopd,   OpCls( I8,   NONE,  NONE  ), F_32A,  0,  no_RM,  0xE2, 0x00, P_386, 0,0)
 = 253                      *1C T_LOOPD equ 0x253
                              C insa(LOOPED, looped,  OpCls( I8,   NONE,  NONE  ), F_32A,  0,  no_RM,  0xE1, 0x00, P_386, 0,0)
 = 254                      *1C T_LOOPED equ 0x254
                              C insa(LOOPZD, loopzd,  OpCls( I8,   NONE,  NONE  ), F_32A,  0,  no_RM,  0xE1, 0x00, P_386, 0,0)
 = 255                      *1C T_LOOPZD equ 0x255
                              C insa(LOOPNED,loopned, OpCls( I8,   NONE,  NONE  ), F_32A,  0,  no_RM,  0xE0, 0x00, P_386, 0,0)
 = 256                      *1C T_LOOPNED equ 0x256
                              C insa(LOOPNZD,loopnzd, OpCls( I8,   NONE,  NONE  ), F_32A,  0,  no_RM,  0xE0, 0x00, P_386, 0,0)
 = 257                      *1C T_LOOPNZD equ 0x257
                              C insx(LOOPW,  loopw,   OpCls( I8,   NONE,  NONE  ), F_16A,  0,  no_RM,  0xE2, 0x00, P_86,  0,0, RWF_IA32)
 = 258                      *1C T_LOOPW equ 0x258
                              C insx(LOOPEW, loopew,  OpCls( I8,   NONE,  NONE  ), F_16A,  0,  no_RM,  0xE1, 0x00, P_86,  0,0, RWF_IA32)
 = 259                      *1C T_LOOPEW equ 0x259
                              C insx(LOOPZW, loopzw,  OpCls( I8,   NONE,  NONE  ), F_16A,  0,  no_RM,  0xE1, 0x00, P_86,  0,0, RWF_IA32)
 = 25A                      *1C T_LOOPZW equ 0x25A
                              C insx(LOOPNEW,loopnew, OpCls( I8,   NONE,  NONE  ), F_16A,  0,  no_RM,  0xE0, 0x00, P_86,  0,0, RWF_IA32)
 = 25B                      *1C T_LOOPNEW equ 0x25B
                              C insx(LOOPNZW,loopnzw, OpCls( I8,   NONE,  NONE  ), F_16A,  0,  no_RM,  0xE0, 0x00, P_86,  0,0, RWF_IA32)
 = 25C                      *1C T_LOOPNZW equ 0x25C
                              C 
                              C ; arith instructions. Masm v6 encodes operand types R,R differently
                              C ; (direction bit is NOT set). JWasm does like Masm v8+.
                              C 
                              C insa(ADD, add,    OpCls(RGT8, I8,   NONE), 0, 0, no_WDS, 0x83, 0x00, P_86, 0,0)
 = 25D                      *1C T_ADD equ 0x25D
                              C insa(OR,  or,     OpCls(RGT8, I8,   NONE), 0, 0, no_WDS, 0x83, 0x08, P_86, 0,0)
 = 25E                      *1C T_OR equ 0x25E
                              C insa(ADC, adc,    OpCls(RGT8, I8,   NONE), 0, 0, no_WDS, 0x83, 0x10, P_86, 0,0)
 = 25F                      *1C T_ADC equ 0x25F
                              C insa(SBB, sbb,    OpCls(RGT8, I8,   NONE), 0, 0, no_WDS, 0x83, 0x18, P_86, 0,0)
 = 260                      *1C T_SBB equ 0x260
                              C insa(AND, and,    OpCls(RGT8, I8,   NONE), 0, 0, no_WDS, 0x83, 0x20, P_86, 0,0)
 = 261                      *1C T_AND equ 0x261
                              C insa(SUB, sub,    OpCls(RGT8, I8,   NONE), 0, 0, no_WDS, 0x83, 0x28, P_86, 0,0)
 = 262                      *1C T_SUB equ 0x262
                              C insa(XOR, xor,    OpCls(RGT8, I8,   NONE), 0, 0, no_WDS, 0x83, 0x30, P_86, 0,0)
 = 263                      *1C T_XOR equ 0x263
                              C 
                              C insa(CMP, cmp,    OpCls(RGT8, I8,   NONE), 0, 0, no_WDS, 0x83, 0x38, P_86, 0,0)
 = 264                      *1C T_CMP equ 0x264
                              C 
                              C ; std bitshift instructions
                              C 
                              C insa(RCL, rcl, OpCls( R_MS, CL_ONLY, NONE ), 0, 0, 0, 0xD2, 0x10, P_86,  0,0)
 = 265                      *1C T_RCL equ 0x265
                              C insa(RCR, rcr, OpCls( R_MS, CL_ONLY, NONE ), 0, 0, 0, 0xD2, 0x18, P_86,  0,0)
 = 266                      *1C T_RCR equ 0x266
                              C insa(ROL, rol, OpCls( R_MS, CL_ONLY, NONE ), 0, 0, 0, 0xD2, 0x00, P_86,  0,0)
 = 267                      *1C T_ROL equ 0x267
                              C insa(ROR, ror, OpCls( R_MS, CL_ONLY, NONE ), 0, 0, 0, 0xD2, 0x08, P_86,  0,0)
 = 268                      *1C T_ROR equ 0x268
                              C insa(SAL, sal, OpCls( R_MS, CL_ONLY, NONE ), 0, 0, 0, 0xD2, 0x20, P_86,  0,0)
 = 269                      *1C T_SAL equ 0x269
                              C insa(SAR, sar, OpCls( R_MS, CL_ONLY, NONE ), 0, 0, 0, 0xD2, 0x38, P_86,  0,0)
 = 26A                      *1C T_SAR equ 0x26A
                              C insa(SHL, shl, OpCls( R_MS, CL_ONLY, NONE ), 0, 0, 0, 0xD2, 0x20, P_86,  0,0)
 = 26B                      *1C T_SHL equ 0x26B
                              C insa(SHR, shr, OpCls( R_MS, CL_ONLY, NONE ), 0, 0, 0, 0xD2, 0x28, P_86,  0,0)
 = 26C                      *1C T_SHR equ 0x26C
                              C 
                              C ; string instructions
                              C 
                              C insa(CMPS,  cmps,     OpCls( MS,       MS,         NONE ), 0,      0,  no_RM,  0xA6, 0x00, P_86,        AP_REPxx,0)
 = 26D                      *1C T_CMPS equ 0x26D
                              C insa(CMPSB, cmpsb,    OpCls( NONE,     NONE,       NONE ), 0,      0,  no_RM,  0xA6, 0x00, P_86,        AP_REPxx,0)
 = 26E                      *1C T_CMPSB equ 0x26E
                              C insa(CMPSW, cmpsw,    OpCls( NONE,     NONE,       NONE ), F_16,   0,  no_RM,  0xA7, 0x00, P_86,        AP_REPxx,0)
 = 26F                      *1C T_CMPSW equ 0x26F
                              C insa(CMPSD, cmpsd,    OpCls( NONE,     NONE,       NONE ), F_32,   0,  no_RM,  0xA7, 0x00, P_386,       AP_REPxx,0)
 = 270                      *1C T_CMPSD equ 0x270
                              C 
                              C insa(INS,   ins,      OpCls( MS,       DX_ONLY,    NONE ), 0,      0,  no_RM,  0x6C, 0x00, P_186,       AP_REP,0)
 = 271                      *1C T_INS equ 0x271
                              C insa(INSB,  insb,     OpCls( NONE,     NONE,       NONE ), 0,      0,  no_RM,  0x6C, 0x00, P_186,       AP_REP,0)
 = 272                      *1C T_INSB equ 0x272
                              C insa(INSW,  insw,     OpCls( NONE,     NONE,       NONE ), F_16,   0,  no_RM,  0x6D, 0x00, P_186,       AP_REP,0)
 = 273                      *1C T_INSW equ 0x273
                              C insa(INSD,  insd,     OpCls( NONE,     NONE,       NONE ), F_32,   0,  no_RM,  0x6D, 0x00, P_386,       AP_REP,0)
 = 274                      *1C T_INSD equ 0x274
                              C insa(LODS,  lods,     OpCls( MS,       NONE,       NONE ), 0,      0,  no_RM,  0xAC, 0x00, P_86,        AP_REP,0)
 = 275                      *1C T_LODS equ 0x275
                              C insa(LODSB, lodsb,    OpCls( NONE,     NONE,       NONE ), 0,      0,  no_RM,  0xAC, 0x00, P_86,        AP_REP,0)
 = 276                      *1C T_LODSB equ 0x276
                              C insa(LODSW, lodsw,    OpCls( NONE,     NONE,       NONE ), F_16,   0,  no_RM,  0xAD, 0x00, P_86,        AP_REP,0)
 = 277                      *1C T_LODSW equ 0x277
                              C insa(LODSD, lodsd,    OpCls( NONE,     NONE,       NONE ), F_32,   0,  no_RM,  0xAD, 0x00, P_386,       AP_REP,0)
 = 278                      *1C T_LODSD equ 0x278
                              C insa(MOVS,  movs,     OpCls( MS,       MS,         NONE ), 0,      0,  no_RM,  0xA4, 0x00, P_86,        AP_REP,0)
 = 279                      *1C T_MOVS equ 0x279
                              C insa(MOVSB, movsb,    OpCls( NONE,     NONE,       NONE ), 0,      0,  no_RM,  0xA4, 0x00, P_86,        AP_REP,0)
 = 27A                      *1C T_MOVSB equ 0x27A
                              C insa(MOVSW, movsw,    OpCls( NONE,     NONE,       NONE ), F_16,   0,  no_RM,  0xA5, 0x00, P_86,        AP_REP,0)
 = 27B                      *1C T_MOVSW equ 0x27B
                              C insa(MOVSD, movsd,    OpCls( NONE,     NONE,       NONE ), F_32,   0,  no_RM,  0xA5, 0x00, P_386,       AP_REP,0)
 = 27C                      *1C T_MOVSD equ 0x27C
                              C insa(OUTS,  outs,     OpCls( DX_ONLY,  MS,         NONE ), 0,      0,  no_RM,  0x6E, 0x00, P_186,       AP_REP,0)
 = 27D                      *1C T_OUTS equ 0x27D
                              C insa(OUTSB, outsb,    OpCls( NONE,     NONE,       NONE ), 0,      0,  no_RM,  0x6E, 0x00, P_186,       AP_REP,0)
 = 27E                      *1C T_OUTSB equ 0x27E
                              C insa(OUTSW, outsw,    OpCls( NONE,     NONE,       NONE ), F_16,   0,  no_RM,  0x6F, 0x00, P_186,       AP_REP,0)
 = 27F                      *1C T_OUTSW equ 0x27F
                              C insa(OUTSD, outsd,    OpCls( NONE,     NONE,       NONE ), F_32,   0,  no_RM,  0x6F, 0x00, P_386,       AP_REP,0)
 = 280                      *1C T_OUTSD equ 0x280
                              C insa(SCAS,  scas,     OpCls( MS,       NONE,       NONE ), 0,      0,  no_RM,  0xAE, 0x00, P_86,        AP_REPxx,0)
 = 281                      *1C T_SCAS equ 0x281
                              C insa(SCASB, scasb,    OpCls( NONE,     NONE,       NONE ), 0,      0,  no_RM,  0xAE, 0x00, P_86,        AP_REPxx,0)
 = 282                      *1C T_SCASB equ 0x282
                              C insa(SCASW, scasw,    OpCls( NONE,     NONE,       NONE ), F_16,   0,  no_RM,  0xAF, 0x00, P_86,        AP_REPxx,0)
 = 283                      *1C T_SCASW equ 0x283
                              C insa(SCASD, scasd,    OpCls( NONE,     NONE,       NONE ), F_32,   0,  no_RM,  0xAF, 0x00, P_386,       AP_REPxx,0)
 = 284                      *1C T_SCASD equ 0x284
                              C insa(STOS,  stos,     OpCls( MS,       NONE,       NONE ), 0,      0,  no_RM,  0xAA, 0x00, P_86,        AP_REP,0)
 = 285                      *1C T_STOS equ 0x285
                              C insa(STOSB, stosb,    OpCls( NONE,     NONE,       NONE ), 0,      0,  no_RM,  0xAA, 0x00, P_86,        AP_REP,0)
 = 286                      *1C T_STOSB equ 0x286
                              C insa(STOSW, stosw,    OpCls( NONE,     NONE,       NONE ), F_16,   0,  no_RM,  0xAB, 0x00, P_86,        AP_REP,0)
 = 287                      *1C T_STOSW equ 0x287
                              C insa(STOSD, stosd,    OpCls( NONE,     NONE,       NONE ), F_32,   0,  no_RM,  0xAB, 0x00, P_386,       AP_REP,0)
 = 288                      *1C T_STOSD equ 0x288
                              C 
                              C ; instructions invalid for IA32+
                              C 
                              C insx(AAA, aaa,        OpCls( NONE,     NONE,       NONE ), 0,      0,  no_RM,  0x37, 0x00, P_86,        0,0, RWF_IA32 )
 = 289                      *1C T_AAA equ 0x289
                              C insx(AAD, aad,        OpCls( NONE,     NONE,       NONE ), 0,      0,  0,      0xD5, 0x0A, P_86,        0,0, RWF_IA32 )
 = 28A                      *1C T_AAD equ 0x28A
                              C insx(AAM, aam,        OpCls( NONE,     NONE,       NONE ), 0,      0,  0,      0xD4, 0x0A, P_86,        0,0, RWF_IA32 )
 = 28B                      *1C T_AAM equ 0x28B
                              C insx(AAS, aas,        OpCls( NONE,     NONE,       NONE ), 0,      0,  no_RM,  0x3F, 0x00, P_86,        0,0, RWF_IA32 )
 = 28C                      *1C T_AAS equ 0x28C
                              C insx(DAA, daa,        OpCls( NONE,     NONE,       NONE ), 0,      0,  no_RM,  0x27, 0x00, P_86,        0,0, RWF_IA32 )
 = 28D                      *1C T_DAA equ 0x28D
                              C insx(DAS, das,        OpCls( NONE,     NONE,       NONE ), 0,      0,  no_RM,  0x2F, 0x00, P_86,        0,0, RWF_IA32 )
 = 28E                      *1C T_DAS equ 0x28E
                              C insx(LDS, lds,        OpCls( RGT8,     MFPTR,      NONE ), 0,      1,  no_WDS, 0xC5, 0x00, P_86,        0,0, RWF_IA32 )
 = 28F                      *1C T_LDS equ 0x28F
                              C insx(LES, les,        OpCls( RGT8,     MFPTR,      NONE ), 0,      1,  no_WDS, 0xC4, 0x00, P_86,        0,0, RWF_IA32 )
 = 290                      *1C T_LES equ 0x290
                              C insx(POPA,  popa,     OpCls( NONE,     NONE,       NONE ), 0,      0,  no_RM,  0x61, 0x00, P_186,       0,0, RWF_IA32 )
 = 291                      *1C T_POPA equ 0x291
                              C insx(POPAD, popad,    OpCls( NONE,     NONE,       NONE ), F_32,   0,  no_RM,  0x61, 0x00, P_386,       0,0, RWF_IA32 )
 = 292                      *1C T_POPAD equ 0x292
                              C insx(POPAW, popaw,    OpCls( NONE,     NONE,       NONE ), F_16,   0,  no_RM,  0x61, 0x00, P_186,       0,0, RWF_IA32 )
 = 293                      *1C T_POPAW equ 0x293
                              C insx(POPFD, popfd,    OpCls( NONE,     NONE,       NONE ), F_32,   0,  no_RM,  0x9D, 0x00, P_386,       0,0, RWF_IA32 )
 = 294                      *1C T_POPFD equ 0x294
                              C insx(PUSHA,  pusha,   OpCls( NONE,     NONE,       NONE ), 0,      0,  no_RM,  0x60, 0x00, P_186,       0,0, RWF_IA32 )
 = 295                      *1C T_PUSHA equ 0x295
                              C insx(PUSHAD, pushad,  OpCls( NONE,     NONE,       NONE ), F_32,   0,  no_RM,  0x60, 0x00, P_386,       0,0, RWF_IA32 )
 = 296                      *1C T_PUSHAD equ 0x296
                              C insx(PUSHAW, pushaw,  OpCls( NONE,     NONE,       NONE ), F_16,   0,  no_RM,  0x60, 0x00, P_186,       0,0, RWF_IA32 )
 = 297                      *1C T_PUSHAW equ 0x297
                              C insx(PUSHFD, pushfd,  OpCls( NONE,     NONE,       NONE ), F_32,   0,  no_RM,  0x9C, 0x00, P_386,       0,0, RWF_IA32 )
 = 298                      *1C T_PUSHFD equ 0x298
                              C insx(PUSHD,  pushd,   OpCls( I8,       NONE,       NONE ), F_32,   0,  no_RM,  0x6A, 0x00, P_386,       0,0, RWF_IA32 )
 = 299                      *1C T_PUSHD equ 0x299
                              C 
                              C ; unlike their names suggest, RETD/RETW will always create a 32-/16-bit far ret
                              C 
                              C insx(RETD, retd,      OpCls( I16,      NONE,       NONE ), F_32,   0,  no_RM,  0xCA, 0x00, P_386,       0,0, RWF_IA32 )
 = 29A                      *1C T_RETD equ 0x29A
                              C insx(RETW, retw,      OpCls( I16,      NONE,       NONE ), F_16,   0,  no_RM,  0xCA, 0x00, P_86,        0,0, RWF_IA32 )
 = 29B                      *1C T_RETW equ 0x29B
                              C 
                              C ; protected-mode instructions
                              C ; some (i.e. SMSW) also work with 32bit register as first operand, but Masm
                              C ; won't accept. to make JWasm accept, change OP_R16 to OP_RGT8
                              C 
                              C insa(ARPL, arpl,      OpCls( R16_M16,  R16,      NONE ), 0,       0,  no_WDS, 0x63, 0x00, P_286,       0,0)
 = 29C                      *1C T_ARPL equ 0x29C
                              C insa(LLDT, lldt,      OpCls( R16_M16,  NONE,     NONE ), F_0FNO66,0,  no_WDS, 0x00, 0x10, P_286p,      0,0)
 = 29D                      *1C T_LLDT equ 0x29D
                              C insa(LMSW, lmsw,      OpCls( R16_M16,  NONE,     NONE ), F_0FNO66,0,  no_WDS, 0x01, 0x30, P_286p,      0,0)
 = 29E                      *1C T_LMSW equ 0x29E
                              C insa(LTR,  ltr,       OpCls( R16_M16,  NONE,     NONE ), F_0FNO66,0,  no_WDS, 0x00, 0x18, P_286p,      0,0)
 = 29F                      *1C T_LTR equ 0x29F
                              C insa(SLDT, sldt,      OpCls( R16_M16,  NONE,     NONE ), F_0FNO66,0,  no_WDS, 0x00, 0x00, P_286,       0,0)
 = 2A0                      *1C T_SLDT equ 0x2A0
                              C insa(SMSW, smsw,      OpCls( R16_M16,  NONE,     NONE ), F_0FNO66,0,  no_WDS, 0x01, 0x20, P_286,       0,0)
 = 2A1                      *1C T_SMSW equ 0x2A1
                              C insa(STR,  str,       OpCls( R16_M16,  NONE,     NONE ), F_0FNO66,0,  no_WDS, 0x00, 0x08, P_286,       0,0)
 = 2A2                      *1C T_STR equ 0x2A2
                              C insa(VERR, verr,      OpCls( R16_M16,  NONE,     NONE ), F_0FNO66,0,  no_WDS, 0x00, 0x20, P_286,       0,0)
 = 2A3                      *1C T_VERR equ 0x2A3
                              C insa(VERW, verw,      OpCls( R16_M16,  NONE,     NONE ), F_0FNO66,0,  no_WDS, 0x00, 0x28, P_286,       0,0)
 = 2A4                      *1C T_VERW equ 0x2A4
                              C 
                              C ; one-operand register/memory instructions
                              C 
                              C insa(DIV, div,        OpCls( R,        NONE,       NONE ), 0,      0,  0,      0xF6, 0x30, P_86,        0,0)
 = 2A5                      *1C T_DIV equ 0x2A5
                              C insa(IDIV, idiv,      OpCls( R,        NONE,       NONE ), 0,      0,  0,      0xF6, 0x38, P_86,        0,0)
 = 2A6                      *1C T_IDIV equ 0x2A6
                              C insa(MUL, mul,        OpCls( R,        NONE,       NONE ), 0,      0,  0,      0xF6, 0x20, P_86,        0,0)
 = 2A7                      *1C T_MUL equ 0x2A7
                              C insa(NEG, neg,        OpCls( R,        NONE,       NONE ), 0,      0,  0,      0xF6, 0x18, P_86,        0,0)
 = 2A8                      *1C T_NEG equ 0x2A8
                              C insa(NOT, not,        OpCls( R,        NONE,       NONE ), 0,      0,  0,      0xF6, 0x10, P_86,        0,0)
 = 2A9                      *1C T_NOT equ 0x2A9
                              C 
                              C ; prefixes. must start with LOCK, end with REPZ and be consecutive
                              C 
                              C insa(LOCK,  lock,     OpCls( NONE,     NONE,       NONE ), 0,      0,  no_RM,  0xF0, 0,    P_86,        AP_LOCK,0)
 = 2AA                      *1C T_LOCK equ 0x2AA
                              C insa(REP,   rep,      OpCls( NONE,     NONE,       NONE ), 0,      0,  no_RM,  0xF3, 0,    P_86,        AP_REP,0)
 = 2AB                      *1C T_REP equ 0x2AB
                              C insa(REPE,  repe,     OpCls( NONE,     NONE,       NONE ), 0,      0,  no_RM,  0xF3, 0,    P_86,        AP_REPxx,0)
 = 2AC                      *1C T_REPE equ 0x2AC
                              C insa(REPNE, repne,    OpCls( NONE,     NONE,       NONE ), 0,      0,  no_RM,  0xF2, 0,    P_86,        AP_REPxx,0)
 = 2AD                      *1C T_REPNE equ 0x2AD
                              C insa(REPNZ, repnz,    OpCls( NONE,     NONE,       NONE ), 0,      0,  no_RM,  0xF2, 0,    P_86,        AP_REPxx,0)
 = 2AE                      *1C T_REPNZ equ 0x2AE
                              C insa(REPZ,  repz,     OpCls( NONE,     NONE,       NONE ), 0,      0,  no_RM,  0xF3, 0,    P_86,        AP_REPxx,0)
 = 2AF                      *1C T_REPZ equ 0x2AF
                              C 
                              C insa(BT, bt,          OpCls( RGT8,     RGT8,       NONE ), F_0F,   0,  no_WDS, 0xA3, 0x00, P_386,       0,0)
 = 2B0                      *1C T_BT equ 0x2B0
                              C insa(BTC, btc,        OpCls( RGT8,     RGT8,       NONE ), F_0F,   0,  no_WDS, 0xBB, 0x00, P_386,       0,0)
 = 2B1                      *1C T_BTC equ 0x2B1
                              C insa(BTR, btr,        OpCls( RGT8,     RGT8,       NONE ), F_0F,   0,  no_WDS, 0xB3, 0x00, P_386,       0,0)
 = 2B2                      *1C T_BTR equ 0x2B2
                              C insa(BTS, bts,        OpCls( RGT8,     RGT8,       NONE ), F_0F,   0,  no_WDS, 0xAB, 0x00, P_386,       0,0)
 = 2B3                      *1C T_BTS equ 0x2B3
                              C 
                              C ; set/reset flags
                              C 
                              C insa(CMC, cmc,        OpCls( NONE,     NONE,       NONE ), 0,      0,  no_RM,  0xF5, 0x00, P_86,        0,0)
 = 2B4                      *1C T_CMC equ 0x2B4
                              C insa(CLC, clc,        OpCls( NONE,     NONE,       NONE ), 0,      0,  no_RM,  0xF8, 0x00, P_86,        0,0)
 = 2B5                      *1C T_CLC equ 0x2B5
                              C insa(STC, stc,        OpCls( NONE,     NONE,       NONE ), 0,      0,  no_RM,  0xF9, 0x00, P_86,        0,0)
 = 2B6                      *1C T_STC equ 0x2B6
                              C insa(CLI, cli,        OpCls( NONE,     NONE,       NONE ), 0,      0,  no_RM,  0xFA, 0x00, P_86,        0,0)
 = 2B7                      *1C T_CLI equ 0x2B7
                              C insa(STI, sti,        OpCls( NONE,     NONE,       NONE ), 0,      0,  no_RM,  0xFB, 0x00, P_86,        0,0)
 = 2B8                      *1C T_STI equ 0x2B8
                              C insa(CLD, cld,        OpCls( NONE,     NONE,       NONE ), 0,      0,  no_RM,  0xFC, 0x00, P_86,        0,0)
 = 2B9                      *1C T_CLD equ 0x2B9
                              C insa(STD, std,        OpCls( NONE,     NONE,       NONE ), 0,      0,  no_RM,  0xFD, 0x00, P_86,        0,0)
 = 2BA                      *1C T_STD equ 0x2BA
                              C 
                              C ; INC/DEC. (hack for 64-bit in reswords.asm!)
                              C 
                              C insa(INC, inc,        OpCls( RGT8,     NONE,       NONE ), 0,      0,  R_in_OP,0x40, 0x00, P_86,        0,0)
 = 2BB                      *1C T_INC equ 0x2BB
                              C insa(DEC, dec,        OpCls( RGT8,     NONE,       NONE ), 0,      0,  R_in_OP,0x48, 0x00, P_86,        0,0)
 = 2BC                      *1C T_DEC equ 0x2BC
                              C 
                              C ; PUSH/POP (16- and 32-bit only)
                              C 
                              C insa(PUSH,  push,     OpCls( R16_R32,  NONE,       NONE ), 0,     0,  R_in_OP,0x50, 0x00, P_86,        0,0)
 = 2BD                      *1C T_PUSH equ 0x2BD
                              C insa(POP, pop,        OpCls( R16_R32,  NONE,       NONE ), 0,     0,  R_in_OP,0x58, 0x00, P_86,        0,0)
 = 2BE                      *1C T_POP equ 0x2BE
                              C insa(PUSHW,  pushw,   OpCls( I8,       NONE,       NONE ), F_16,  0,  no_RM,  0x6A, 0x00, P_186,       0,0)
 = 2BF                      *1C T_PUSHW equ 0x2BF
                              C insa(PUSHF,  pushf,   OpCls( NONE,     NONE,       NONE ), F_16,  0,  no_RM,  0x9C, 0x00, P_86,        0,0)
 = 2C0                      *1C T_PUSHF equ 0x2C0
                              C insa(POPF,  popf,     OpCls( NONE,     NONE,       NONE ), F_16,  0,  no_RM,  0x9D, 0x00, P_86,        0,0)
 = 2C1                      *1C T_POPF equ 0x2C1
                              C 
                              C insa(MOV, mov,        OpCls( A,        MS,         NONE ), 0,      1,  no_RM,  0xA0, 0x00, P_86,        0,0)
 = 2C2                      *1C T_MOV equ 0x2C2
                              C 
                              C insa(MOVBE, movbe,    OpCls( RGT8,     MGT8,       NONE ), F_0F38,  1, no_WDS, 0xF0, 0x00, P_486,       0,0)
 = 2C3                      *1C T_MOVBE equ 0x2C3
                              C 
                              C insa(BOUND_, bound,   OpCls( RGT8,     MS,         NONE ), 0,      1,  no_WDS, 0x62, 0x00, P_186,       0,0)
 = 2C4                      *1C T_BOUND_ equ 0x2C4
                              C insa(BSF, bsf,        OpCls( RGT8,     RGT8_MS,    NONE ), F_0F,   1,  no_WDS, 0xBC, 0x00, P_386,       0,0)
 = 2C5                      *1C T_BSF equ 0x2C5
                              C insa(BSR, bsr,        OpCls( RGT8,     RGT8_MS,    NONE ), F_0F,   1,  no_WDS, 0xBD, 0x00, P_386,       0,0)
 = 2C6                      *1C T_BSR equ 0x2C6
                              C insa(BSWAP, bswap,    OpCls( RGT16,    NONE,       NONE ), F_0F,   0,  R_in_OP,0xC8, 0x00, P_486,       0,0)
 = 2C7                      *1C T_BSWAP equ 0x2C7
                              C insa(CBW, cbw,        OpCls( NONE,     NONE,       NONE ), F_16,   0,  no_RM,  0x98, 0x00, P_86,        0,0)
 = 2C8                      *1C T_CBW equ 0x2C8
                              C insa(CDQ, cdq,        OpCls( NONE,     NONE,       NONE ), F_32,   0,  no_RM,  0x99, 0x00, P_386,       0,0)
 = 2C9                      *1C T_CDQ equ 0x2C9
                              C insa(CWD, cwd,        OpCls( NONE,     NONE,       NONE ), F_16,   0,  no_RM,  0x99, 0x00, P_86,        0,0)
 = 2CA                      *1C T_CWD equ 0x2CA
                              C insa(CWDE, cwde,      OpCls( NONE,     NONE,       NONE ), F_32,   0,  no_RM,  0x98, 0x00, P_386,       0,0)
 = 2CB                      *1C T_CWDE equ 0x2CB
                              C insa(CLTS, clts,      OpCls( NONE,     NONE,       NONE ), 0,      0,  0,      0x0F, 0x06, P_286p,      0,0)
 = 2CC                      *1C T_CLTS equ 0x2CC
                              C insa(CMPXCHG, cmpxchg,OpCls( R,        R,          NONE ), F_0F,   0,  0,      0xB0, 0x00, P_486,       0,0)
 = 2CD                      *1C T_CMPXCHG equ 0x2CD
                              C insa(CMPXCHG8B, cmpxchg8b, OpCls( M64, NONE,       NONE ), F_0F,   0,  0,      0xC7, 0x08, P_586,       AP_LOCK,0)
 = 2CE                      *1C T_CMPXCHG8B equ 0x2CE
                              C insa(CPUID, cpuid,    OpCls( NONE,     NONE,       NONE ), 0,      0,  0,      0x0F, 0xA2, P_586,       0,0)
 = 2CF                      *1C T_CPUID equ 0x2CF
                              C insa(ENTER, enter,    OpCls( I16,      I8_U,       NONE ), 0,      0,  no_RM,  0xC8, 0x00, P_186,       0,0)
 = 2D0                      *1C T_ENTER equ 0x2D0
                              C insa(HLT, hlt,        OpCls( NONE,     NONE,       NONE ), 0,      0,  no_RM,  0xF4, 0x00, P_86,        0,0)
 = 2D1                      *1C T_HLT equ 0x2D1
                              C insa(IMUL, imul,      OpCls( R,        NONE,       NONE ), 0,      0,  0,      0xF6, 0x28, P_86,        0,0)
 = 2D2                      *1C T_IMUL equ 0x2D2
                              C insa(IN, in,          OpCls( A,        DX_ONLY,    NONE ), 0,      0,  no_RM,  0xEC, 0x00, P_86,        0,0)
 = 2D3                      *1C T_IN equ 0x2D3
                              C insa(INT, int,        OpCls( I_3,      NONE,       NONE ), 0,      0,  no_RM,  0xCC, 0x00, P_86,        0,0)
 = 2D4                      *1C T_INT equ 0x2D4
                              C insa(INTO, into,      OpCls( NONE,     NONE,       NONE ), 0,      0,  no_RM,  0xCE, 0x00, P_86,        0,0)
 = 2D5                      *1C T_INTO equ 0x2D5
                              C insa(INVD, invd,      OpCls( NONE,     NONE,       NONE ), F_0F,   0,  no_RM,  0x08, 0x00, P_486,       0,0)
 = 2D6                      *1C T_INVD equ 0x2D6
                              C insa(INVLPG, invlpg,  OpCls( M_ANY,    NONE,       NONE ), F_0F,   0,  no_WDS, 0x01, 0x38, P_486,       0,0)
 = 2D7                      *1C T_INVLPG equ 0x2D7
                              C insa(IRET, iret,      OpCls( NONE,     NONE,       NONE ), F_16,   0,  no_RM,  0xCF, 0x00, P_86,        0,0)
 = 2D8                      *1C T_IRET equ 0x2D8
                              C insa(IRETD, iretd,    OpCls( NONE,     NONE,       NONE ), F_32,   0,  no_RM,  0xCF, 0x00, P_386,       0,0)
 = 2D9                      *1C T_IRETD equ 0x2D9
                              C 
                              C ; the F-suffix variants of IRET|IRETD are just aliases and pretty useless.
                              C ; In Masm v8+, IRETF has disappeared, but IRETDF is still there.
                              C 
                              C insa(IRETF, iretf,    OpCls( NONE,     NONE,       NONE ), F_16,   0,  no_RM,  0xCF, 0x00, P_86,        0,0)
 = 2DA                      *1C T_IRETF equ 0x2DA
                              C insa(IRETDF, iretdf,  OpCls( NONE,     NONE,       NONE ), F_32,   0,  no_RM,  0xCF, 0x00, P_386,       0,0)
 = 2DB                      *1C T_IRETDF equ 0x2DB
                              C insa(LAHF, lahf,      OpCls( NONE,     NONE,       NONE ), 0,      0,  no_RM,  0x9F, 0x00, P_86,        0,0)
 = 2DC                      *1C T_LAHF equ 0x2DC
                              C insa(LAR, lar,        OpCls( RGT8,     RGT8_MS,    NONE ), F_0F,   1,  no_WDS, 0x02, 0x00, P_286,       0,0)
 = 2DD                      *1C T_LAR equ 0x2DD
                              C insa(LSL, lsl,        OpCls( RGT8,     RGT8_MS,    NONE ), F_0F,   1,  no_WDS, 0x03, 0x00, P_286,       0,0)
 = 2DE                      *1C T_LSL equ 0x2DE
                              C insa(LEA, lea,        OpCls( RGT8,     MS,         NONE ), 0,      1,  no_WDS, 0x8D, 0x00, P_86,        0,0)
 = 2DF                      *1C T_LEA equ 0x2DF
                              C insa(LEAVE, leave,    OpCls( NONE,     NONE,       NONE ), 0,      0,  no_RM,  0xC9, 0x00, P_186,       0,0)
 = 2E0                      *1C T_LEAVE equ 0x2E0
                              C insa(LFS, lfs,        OpCls( RGT8,     MFPTR,      NONE ), F_0F,   1,  no_WDS, 0xB4, 0x00, P_386,       0,0)
 = 2E1                      *1C T_LFS equ 0x2E1
                              C insa(LGS, lgs,        OpCls( RGT8,     MFPTR,      NONE ), F_0F,   1,  no_WDS, 0xB5, 0x00, P_386,       0,0)
 = 2E2                      *1C T_LGS equ 0x2E2
                              C insa(LSS, lss,        OpCls( RGT8,     MFPTR,      NONE ), F_0F,   1,  no_WDS, 0xB2, 0x00, P_386,       0,0)
 = 2E3                      *1C T_LSS equ 0x2E3
                              C insa(LGDT, lgdt,      OpCls( M48,      NONE,       NONE ), F_0F,   0,  no_WDS, 0x01, 0x10, P_286p,      0,0)
 = 2E4                      *1C T_LGDT equ 0x2E4
                              C insa(LIDT, lidt,      OpCls( M48,      NONE,       NONE ), F_0F,   0,  no_WDS, 0x01, 0x18, P_286p,      0,0)
 = 2E5                      *1C T_LIDT equ 0x2E5
                              C insa(MOVSX, movsx,    OpCls( RGT8,     R_MS,       NONE ), F_0F,   1,  0,      0xBE, 0x00, P_386,       0,0)
 = 2E6                      *1C T_MOVSX equ 0x2E6
                              C insa(MOVZX, movzx,    OpCls( RGT8,     R_MS,       NONE ), F_0F,   1,  0,      0xB6, 0x00, P_386,       0,0)
 = 2E7                      *1C T_MOVZX equ 0x2E7
                              C insa(NOP, nop,        OpCls( NONE,     NONE,       NONE ), 0,      0,  no_RM,  0x90, 0x00, P_86,        0,0)
 = 2E8                      *1C T_NOP equ 0x2E8
                              C insa(OUT, out,        OpCls( DX_ONLY,  A,          NONE ), 0,      0,  no_RM,  0xEE, 0x00, P_86,        0,0)
 = 2E9                      *1C T_OUT equ 0x2E9
                              C 
                              C insa(RDMSR, rdmsr,    OpCls( NONE,     NONE,       NONE ), F_0F,   0,  no_RM,  0x32, 0x00, P_586,       0,0)
 = 2EA                      *1C T_RDMSR equ 0x2EA
                              C insa(RDPMC, rdpmc,    OpCls( NONE,     NONE,       NONE ), F_0F,   0,  no_RM,  0x33, 0x00, P_586,       0,0)
 = 2EB                      *1C T_RDPMC equ 0x2EB
                              C insa(RDTSC, rdtsc,    OpCls( NONE,     NONE,       NONE ), F_0F,   0,  no_RM,  0x31, 0x00, P_586,       0,0)
 = 2EC                      *1C T_RDTSC equ 0x2EC
                              C insa(RDTSCP, rdtscp,  OpCls( NONE,     NONE,       NONE ), F_0F,   0,  no_WDS, 0x01, 0xF9, P_686,       0,0)
 = 2ED                      *1C T_RDTSCP equ 0x2ED
                              C insa(RET,  ret,       OpCls( I16,      NONE,       NONE ), 0,      0,  no_RM,  0xC2, 0x00, P_86,        0,0)
 = 2EE                      *1C T_RET equ 0x2EE
                              C insa(RETN, retn,      OpCls( I16,      NONE,       NONE ), 0,      0,  no_RM,  0xC2, 0x00, P_86,        0,0)
 = 2EF                      *1C T_RETN equ 0x2EF
                              C insa(RETF, retf,      OpCls( I16,      NONE,       NONE ), 0,      0,  no_RM,  0xCA, 0x00, P_86,        0,0)
 = 2F0                      *1C T_RETF equ 0x2F0
                              C insa(RSM, rsm,        OpCls( NONE,     NONE,       NONE ), F_0F,   0,  no_RM,  0xAA, 0x00, P_586,       0,0)
 = 2F1                      *1C T_RSM equ 0x2F1
                              C insa(SAHF, sahf,      OpCls( NONE,     NONE,       NONE ), 0,      0,  no_RM,  0x9E, 0x00, P_86,        0,0)
 = 2F2                      *1C T_SAHF equ 0x2F2
                              C insa(SGDT, sgdt,      OpCls( M_ANY,    NONE,       NONE ), F_0F,   0,  no_WDS, 0x01, 0x00, P_286,       0,0)
 = 2F3                      *1C T_SGDT equ 0x2F3
                              C insa(SIDT, sidt,      OpCls( M_ANY,    NONE,       NONE ), F_0F,   0,  no_WDS, 0x01, 0x08, P_286,       0,0)
 = 2F4                      *1C T_SIDT equ 0x2F4
                              C insa(SHLD, shld,      OpCls( RGT8_MGT8,RGT8,       CL   ), F_0F,   0,  no_WDS, 0xA5, 0x00, P_386,       0,0)
 = 2F5                      *1C T_SHLD equ 0x2F5
                              C insa(SHRD, shrd,      OpCls( RGT8_MGT8,RGT8,       CL   ), F_0F,   0,  no_WDS, 0xAD, 0x00, P_386,       0,0)
 = 2F6                      *1C T_SHRD equ 0x2F6
                              C insa(SYSENTER, sysenter, OpCls( NONE,  NONE,       NONE ), F_0F,   0,  no_RM,  0x34, 0x00, P_686,       0,0)
 = 2F7                      *1C T_SYSENTER equ 0x2F7
                              C insa(SYSEXIT, sysexit,OpCls( NONE,     NONE,       NONE ), F_0F,   0,  no_RM,  0x35, 0x00, P_686p,      0,0)
 = 2F8                      *1C T_SYSEXIT equ 0x2F8
                              C insa(TEST, test,      OpCls( A,        I,          NONE ), 0,      0,  no_RM,  0xA8, 0x00, P_86,        0,0)
 = 2F9                      *1C T_TEST equ 0x2F9
                              C insa(UD2, ud2,        OpCls( NONE,     NONE,       NONE ), F_0F,   0,  no_RM,  0x0B, 0x00, P_686,       0,0)
 = 2FA                      *1C T_UD2 equ 0x2FA
                              C insa(WAIT, wait,      OpCls( NONE,     NONE,       NONE ), 0,      0,  no_RM,  0x9B, 0x00, P_86,        0,0)
 = 2FB                      *1C T_WAIT equ 0x2FB
                              C insa(WBINVD, wbinvd,  OpCls( NONE,     NONE,       NONE ), F_0F,   0,  no_RM,  0x09, 0x00, P_486,       0,0)
 = 2FC                      *1C T_WBINVD equ 0x2FC
                              C insa(WRMSR, wrmsr,    OpCls( NONE,     NONE,       NONE ), F_0F,   0,  no_RM,  0x30, 0x00, P_586,       0,0)
 = 2FD                      *1C T_WRMSR equ 0x2FD
                              C insa(XADD, xadd,      OpCls( R,        R,          NONE ), F_0F,   0,  0,      0xC0, 0x00, P_486,       0,0)
 = 2FE                      *1C T_XADD equ 0x2FE
                              C insa(XCHG, xchg,      OpCls( A,        RGT8,       NONE ), 0,      0,  R_in_OP,0x90, 0x00, P_86,        0,0)
 = 2FF                      *1C T_XCHG equ 0x2FF
                              C insa(XLAT, xlat,      OpCls( NONE,     NONE,       NONE ), 0,      0,  no_RM,  0xD7, 0x00, P_86,        0,0)
 = 300                      *1C T_XLAT equ 0x300
                              C insa(XLATB, xlatb,    OpCls( NONE,     NONE,       NONE ), 0,      0,  no_RM,  0xD7, 0x00, P_86,        0,0)
 = 301                      *1C T_XLATB equ 0x301
                              C 
                              C insa(SETA,  seta,     OpCls( R8_M08,   NONE,       NONE ), F_0F,   0,  no_WDS, 0x97, 0x00, P_386,       0,0)
 = 302                      *1C T_SETA equ 0x302
                              C insa(SETAE, setae,    OpCls( R8_M08,   NONE,       NONE ), F_0F,   0,  no_WDS, 0x93, 0x00, P_386,       0,0)
 = 303                      *1C T_SETAE equ 0x303
                              C insa(SETB,  setb,     OpCls( R8_M08,   NONE,       NONE ), F_0F,   0,  no_WDS, 0x92, 0x00, P_386,       0,0)
 = 304                      *1C T_SETB equ 0x304
                              C insa(SETBE, setbe,    OpCls( R8_M08,   NONE,       NONE ), F_0F,   0,  no_WDS, 0x96, 0x00, P_386,       0,0)
 = 305                      *1C T_SETBE equ 0x305
                              C insa(SETC,  setc,     OpCls( R8_M08,   NONE,       NONE ), F_0F,   0,  no_WDS, 0x92, 0x00, P_386,       0,0)
 = 306                      *1C T_SETC equ 0x306
                              C insa(SETE,  sete,     OpCls( R8_M08,   NONE,       NONE ), F_0F,   0,  no_WDS, 0x94, 0x00, P_386,       0,0)
 = 307                      *1C T_SETE equ 0x307
                              C insa(SETG,  setg,     OpCls( R8_M08,   NONE,       NONE ), F_0F,   0,  no_WDS, 0x9F, 0x00, P_386,       0,0)
 = 308                      *1C T_SETG equ 0x308
                              C insa(SETGE, setge,    OpCls( R8_M08,   NONE,       NONE ), F_0F,   0,  no_WDS, 0x9D, 0x00, P_386,       0,0)
 = 309                      *1C T_SETGE equ 0x309
                              C insa(SETL,  setl,     OpCls( R8_M08,   NONE,       NONE ), F_0F,   0,  no_WDS, 0x9C, 0x00, P_386,       0,0)
 = 30A                      *1C T_SETL equ 0x30A
                              C insa(SETLE, setle,    OpCls( R8_M08,   NONE,       NONE ), F_0F,   0,  no_WDS, 0x9E, 0x00, P_386,       0,0)
 = 30B                      *1C T_SETLE equ 0x30B
                              C insa(SETNA, setna,    OpCls( R8_M08,   NONE,       NONE ), F_0F,   0,  no_WDS, 0x96, 0x00, P_386,       0,0)
 = 30C                      *1C T_SETNA equ 0x30C
                              C insa(SETNAE,setnae,   OpCls( R8_M08,   NONE,       NONE ), F_0F,   0,  no_WDS, 0x92, 0x00, P_386,       0,0)
 = 30D                      *1C T_SETNAE equ 0x30D
                              C insa(SETNB, setnb,    OpCls( R8_M08,   NONE,       NONE ), F_0F,   0,  no_WDS, 0x93, 0x00, P_386,       0,0)
 = 30E                      *1C T_SETNB equ 0x30E
                              C insa(SETNBE,setnbe,   OpCls( R8_M08,   NONE,       NONE ), F_0F,   0,  no_WDS, 0x97, 0x00, P_386,       0,0)
 = 30F                      *1C T_SETNBE equ 0x30F
                              C insa(SETNC, setnc,    OpCls( R8_M08,   NONE,       NONE ), F_0F,   0,  no_WDS, 0x93, 0x00, P_386,       0,0)
 = 310                      *1C T_SETNC equ 0x310
                              C insa(SETNE, setne,    OpCls( R8_M08,   NONE,       NONE ), F_0F,   0,  no_WDS, 0x95, 0x00, P_386,       0,0)
 = 311                      *1C T_SETNE equ 0x311
                              C insa(SETNG, setng,    OpCls( R8_M08,   NONE,       NONE ), F_0F,   0,  no_WDS, 0x9E, 0x00, P_386,       0,0)
 = 312                      *1C T_SETNG equ 0x312
                              C insa(SETNGE,setnge,   OpCls( R8_M08,   NONE,       NONE ), F_0F,   0,  no_WDS, 0x9C, 0x00, P_386,       0,0)
 = 313                      *1C T_SETNGE equ 0x313
                              C insa(SETNL, setnl,    OpCls( R8_M08,   NONE,       NONE ), F_0F,   0,  no_WDS, 0x9D, 0x00, P_386,       0,0)
 = 314                      *1C T_SETNL equ 0x314
                              C insa(SETNLE,setnle,   OpCls( R8_M08,   NONE,       NONE ), F_0F,   0,  no_WDS, 0x9F, 0x00, P_386,       0,0)
 = 315                      *1C T_SETNLE equ 0x315
                              C insa(SETNO, setno,    OpCls( R8_M08,   NONE,       NONE ), F_0F,   0,  no_WDS, 0x91, 0x00, P_386,       0,0)
 = 316                      *1C T_SETNO equ 0x316
                              C insa(SETNP, setnp,    OpCls( R8_M08,   NONE,       NONE ), F_0F,   0,  no_WDS, 0x9B, 0x00, P_386,       0,0)
 = 317                      *1C T_SETNP equ 0x317
                              C insa(SETNS, setns,    OpCls( R8_M08,   NONE,       NONE ), F_0F,   0,  no_WDS, 0x99, 0x00, P_386,       0,0)
 = 318                      *1C T_SETNS equ 0x318
                              C insa(SETNZ, setnz,    OpCls( R8_M08,   NONE,       NONE ), F_0F,   0,  no_WDS, 0x95, 0x00, P_386,       0,0)
 = 319                      *1C T_SETNZ equ 0x319
                              C insa(SETO,  seto,     OpCls( R8_M08,   NONE,       NONE ), F_0F,   0,  no_WDS, 0x90, 0x00, P_386,       0,0)
 = 31A                      *1C T_SETO equ 0x31A
                              C insa(SETP,  setp,     OpCls( R8_M08,   NONE,       NONE ), F_0F,   0,  no_WDS, 0x9A, 0x00, P_386,       0,0)
 = 31B                      *1C T_SETP equ 0x31B
                              C insa(SETPE, setpe,    OpCls( R8_M08,   NONE,       NONE ), F_0F,   0,  no_WDS, 0x9A, 0x00, P_386,       0,0)
 = 31C                      *1C T_SETPE equ 0x31C
                              C insa(SETPO, setpo,    OpCls( R8_M08,   NONE,       NONE ), F_0F,   0,  no_WDS, 0x9B, 0x00, P_386,       0,0)
 = 31D                      *1C T_SETPO equ 0x31D
                              C insa(SETS,  sets,     OpCls( R8_M08,   NONE,       NONE ), F_0F,   0,  no_WDS, 0x98, 0x00, P_386,       0,0)
 = 31E                      *1C T_SETS equ 0x31E
                              C insa(SETZ,  setz,     OpCls( R8_M08,   NONE,       NONE ), F_0F,   0,  no_WDS, 0x94, 0x00, P_386,       0,0)
 = 31F                      *1C T_SETZ equ 0x31F
                              C 
                              C insa(CMOVA,   cmova,   OpCls( RGT8, R_MS, NONE ), F_0F, 1, no_WDS, 0x47, 0x00, P_686, 0,0)
 = 320                      *1C T_CMOVA equ 0x320
                              C insa(CMOVAE,  cmovae,  OpCls( RGT8, R_MS, NONE ), F_0F, 1, no_WDS, 0x43, 0x00, P_686, 0,0)
 = 321                      *1C T_CMOVAE equ 0x321
                              C insa(CMOVB,   cmovb,   OpCls( RGT8, R_MS, NONE ), F_0F, 1, no_WDS, 0x42, 0x00, P_686, 0,0)
 = 322                      *1C T_CMOVB equ 0x322
                              C insa(CMOVBE,  cmovbe,  OpCls( RGT8, R_MS, NONE ), F_0F, 1, no_WDS, 0x46, 0x00, P_686, 0,0)
 = 323                      *1C T_CMOVBE equ 0x323
                              C insa(CMOVC,   cmovc,   OpCls( RGT8, R_MS, NONE ), F_0F, 1, no_WDS, 0x42, 0x00, P_686, 0,0)
 = 324                      *1C T_CMOVC equ 0x324
                              C insa(CMOVE,   cmove,   OpCls( RGT8, R_MS, NONE ), F_0F, 1, no_WDS, 0x44, 0x00, P_686, 0,0)
 = 325                      *1C T_CMOVE equ 0x325
                              C insa(CMOVG,   cmovg,   OpCls( RGT8, R_MS, NONE ), F_0F, 1, no_WDS, 0x4F, 0x00, P_686, 0,0)
 = 326                      *1C T_CMOVG equ 0x326
                              C insa(CMOVGE,  cmovge,  OpCls( RGT8, R_MS, NONE ), F_0F, 1, no_WDS, 0x4D, 0x00, P_686, 0,0)
 = 327                      *1C T_CMOVGE equ 0x327
                              C insa(CMOVL,   cmovl,   OpCls( RGT8, R_MS, NONE ), F_0F, 1, no_WDS, 0x4C, 0x00, P_686, 0,0)
 = 328                      *1C T_CMOVL equ 0x328
                              C insa(CMOVLE,  cmovle,  OpCls( RGT8, R_MS, NONE ), F_0F, 1, no_WDS, 0x4E, 0x00, P_686, 0,0)
 = 329                      *1C T_CMOVLE equ 0x329
                              C insa(CMOVNA,  cmovna,  OpCls( RGT8, R_MS, NONE ), F_0F, 1, no_WDS, 0x46, 0x00, P_686, 0,0)
 = 32A                      *1C T_CMOVNA equ 0x32A
                              C insa(CMOVNAE, cmovnae, OpCls( RGT8, R_MS, NONE ), F_0F, 1, no_WDS, 0x42, 0x00, P_686, 0,0)
 = 32B                      *1C T_CMOVNAE equ 0x32B
                              C insa(CMOVNB,  cmovnb,  OpCls( RGT8, R_MS, NONE ), F_0F, 1, no_WDS, 0x43, 0x00, P_686, 0,0)
 = 32C                      *1C T_CMOVNB equ 0x32C
                              C insa(CMOVNBE, cmovnbe, OpCls( RGT8, R_MS, NONE ), F_0F, 1, no_WDS, 0x47, 0x00, P_686, 0,0)
 = 32D                      *1C T_CMOVNBE equ 0x32D
                              C insa(CMOVNC,  cmovnc,  OpCls( RGT8, R_MS, NONE ), F_0F, 1, no_WDS, 0x43, 0x00, P_686, 0,0)
 = 32E                      *1C T_CMOVNC equ 0x32E
                              C insa(CMOVNE,  cmovne,  OpCls( RGT8, R_MS, NONE ), F_0F, 1, no_WDS, 0x45, 0x00, P_686, 0,0)
 = 32F                      *1C T_CMOVNE equ 0x32F
                              C insa(CMOVNG,  cmovng,  OpCls( RGT8, R_MS, NONE ), F_0F, 1, no_WDS, 0x4E, 0x00, P_686, 0,0)
 = 330                      *1C T_CMOVNG equ 0x330
                              C insa(CMOVNGE, cmovnge, OpCls( RGT8, R_MS, NONE ), F_0F, 1, no_WDS, 0x4C, 0x00, P_686, 0,0)
 = 331                      *1C T_CMOVNGE equ 0x331
                              C insa(CMOVNL,  cmovnl,  OpCls( RGT8, R_MS, NONE ), F_0F, 1, no_WDS, 0x4D, 0x00, P_686, 0,0)
 = 332                      *1C T_CMOVNL equ 0x332
                              C insa(CMOVNLE, cmovnle, OpCls( RGT8, R_MS, NONE ), F_0F, 1, no_WDS, 0x4F, 0x00, P_686, 0,0)
 = 333                      *1C T_CMOVNLE equ 0x333
                              C insa(CMOVNO,  cmovno,  OpCls( RGT8, R_MS, NONE ), F_0F, 1, no_WDS, 0x41, 0x00, P_686, 0,0)
 = 334                      *1C T_CMOVNO equ 0x334
                              C insa(CMOVNP,  cmovnp,  OpCls( RGT8, R_MS, NONE ), F_0F, 1, no_WDS, 0x4B, 0x00, P_686, 0,0)
 = 335                      *1C T_CMOVNP equ 0x335
                              C insa(CMOVNS,  cmovns,  OpCls( RGT8, R_MS, NONE ), F_0F, 1, no_WDS, 0x49, 0x00, P_686, 0,0)
 = 336                      *1C T_CMOVNS equ 0x336
                              C insa(CMOVNZ,  cmovnz,  OpCls( RGT8, R_MS, NONE ), F_0F, 1, no_WDS, 0x45, 0x00, P_686, 0,0)
 = 337                      *1C T_CMOVNZ equ 0x337
                              C insa(CMOVO,   cmovo,   OpCls( RGT8, R_MS, NONE ), F_0F, 1, no_WDS, 0x40, 0x00, P_686, 0,0)
 = 338                      *1C T_CMOVO equ 0x338
                              C insa(CMOVP,   cmovp,   OpCls( RGT8, R_MS, NONE ), F_0F, 1, no_WDS, 0x4A, 0x00, P_686, 0,0)
 = 339                      *1C T_CMOVP equ 0x339
                              C insa(CMOVPE,  cmovpe,  OpCls( RGT8, R_MS, NONE ), F_0F, 1, no_WDS, 0x4A, 0x00, P_686, 0,0)
 = 33A                      *1C T_CMOVPE equ 0x33A
                              C insa(CMOVPO,  cmovpo,  OpCls( RGT8, R_MS, NONE ), F_0F, 1, no_WDS, 0x4B, 0x00, P_686, 0,0)
 = 33B                      *1C T_CMOVPO equ 0x33B
                              C insa(CMOVS,   cmovs,   OpCls( RGT8, R_MS, NONE ), F_0F, 1, no_WDS, 0x48, 0x00, P_686, 0,0)
 = 33C                      *1C T_CMOVS equ 0x33C
                              C insa(CMOVZ,   cmovz,   OpCls( RGT8, R_MS, NONE ), F_0F, 1, no_WDS, 0x44, 0x00, P_686, 0,0)
 = 33D                      *1C T_CMOVZ equ 0x33D
                              C 
                              C ; FPU opcodes
                              C 
                              C insa(FCMOVB, fcmovb,  OpCls( ST,       STI,        NONE ), 0,      0,  0,      0xDA, 0xC0, P_686,       0,0)
 = 33E                      *1C T_FCMOVB equ 0x33E
                              C insa(FCMOVBE, fcmovbe,OpCls( ST,       STI,        NONE ), 0,      0,  0,      0xDA, 0xD0, P_686,       0,0)
 = 33F                      *1C T_FCMOVBE equ 0x33F
                              C insa(FCMOVE, fcmove,  OpCls( ST,       STI,        NONE ), 0,      0,  0,      0xDA, 0xC8, P_686,       0,0)
 = 340                      *1C T_FCMOVE equ 0x340
                              C insa(FCMOVNB, fcmovnb,OpCls( ST,       STI,        NONE ), 0,      0,  0,      0xDB, 0xC0, P_686,       0,0)
 = 341                      *1C T_FCMOVNB equ 0x341
                              C insa(FCMOVNBE, fcmovnbe, OpCls( ST,    STI,        NONE ), 0,      0,  0,      0xDB, 0xD0, P_686,       0,0)
 = 342                      *1C T_FCMOVNBE equ 0x342
                              C insa(FCMOVNE, fcmovne,OpCls( ST,       STI,        NONE ), 0,      0,  0,      0xDB, 0xC8, P_686,       0,0)
 = 343                      *1C T_FCMOVNE equ 0x343
                              C insa(FCMOVNU, fcmovnu,OpCls( ST,       STI,        NONE ), 0,      0,  0,      0xDB, 0xD8, P_686,       0,0)
 = 344                      *1C T_FCMOVNU equ 0x344
                              C insa(FCMOVU, fcmovu,  OpCls( ST,       STI,        NONE ), 0,      0,  0,      0xDA, 0xD8, P_686,       0,0)
 = 345                      *1C T_FCMOVU equ 0x345
                              C 
                              C insa(FCOM, fcom,      OpCls( STI,      NONE,       NONE ), 0,      0,  0,      0xD8, 0xD0, P_87,        0,0)
 = 346                      *1C T_FCOM equ 0x346
                              C insa(FCOMP, fcomp,    OpCls( STI,      NONE,       NONE ), 0,      0,  0,      0xD8, 0xD8, P_87,        0,0)
 = 347                      *1C T_FCOMP equ 0x347
                              C insa(FCOMPP, fcompp,  OpCls( NONE,     NONE,       NONE ), 0,      0,  0,      0xDE, 0xD9, P_87,        0,0)
 = 348                      *1C T_FCOMPP equ 0x348
                              C 
                              C insa(FUCOM, fucom,    OpCls( STI,      NONE,       NONE ), 0,      0,  0,      0xDD, 0xE0, P_387,       0,0)
 = 349                      *1C T_FUCOM equ 0x349
                              C insa(FUCOMP, fucomp,  OpCls( STI,      NONE,       NONE ), 0,      0,  0,      0xDD, 0xE8, P_387,       0,0)
 = 34A                      *1C T_FUCOMP equ 0x34A
                              C insa(FUCOMPP, fucompp,OpCls( NONE,     NONE,       NONE ), 0,      0,  0,      0xDA, 0xE9, P_387,       0,0)
 = 34B                      *1C T_FUCOMPP equ 0x34B
                              C insa(FCOMI, fcomi,    OpCls( ST,       STI,        NONE ), 0,      0,  0,      0xDB, 0xF0, P_686,       0,0)
 = 34C                      *1C T_FCOMI equ 0x34C
                              C insa(FCOMIP, fcomip,  OpCls( ST,       STI,        NONE ), 0,      0,  0,      0xDF, 0xF0, P_686,       0,0)
 = 34D                      *1C T_FCOMIP equ 0x34D
                              C insa(FUCOMI, fucomi,  OpCls( ST,       STI,        NONE ), 0,      0,  0,      0xDB, 0xE8, P_686,       0,0)
 = 34E                      *1C T_FUCOMI equ 0x34E
                              C insa(FUCOMIP, fucomip,OpCls( ST,       STI,        NONE ), 0,      0,  0,      0xDF, 0xE8, P_686,       0,0)
 = 34F                      *1C T_FUCOMIP equ 0x34F
                              C 
                              C insa(FADD, fadd,      OpCls( ST,       STI,        NONE ), 0,      0,  0,      0xD8, 0xC0, P_87,        0,0)
 = 350                      *1C T_FADD equ 0x350
                              C insa(FADDP, faddp,    OpCls( STI,      ST,         NONE ), 0,      0,  0,      0xDE, 0xC0, P_87,        0,0)
 = 351                      *1C T_FADDP equ 0x351
                              C insa(FMUL, fmul,      OpCls( ST,       STI,        NONE ), 0,      0,  0,      0xD8, 0xC8, P_87,        0,0)
 = 352                      *1C T_FMUL equ 0x352
                              C insa(FMULP, fmulp,    OpCls( STI,      ST,         NONE ), 0,      0,  0,      0xDE, 0xC8, P_87,        0,0)
 = 353                      *1C T_FMULP equ 0x353
                              C 
                              C insa(FDIV, fdiv,      OpCls( ST,       STI,        NONE ), 0,      0,  0,      0xD8, 0xF0, P_87,        0,0)
 = 354                      *1C T_FDIV equ 0x354
                              C insa(FDIVP, fdivp,    OpCls( STI,      ST,         NONE ), 0,      0,  0,      0xDE, 0xF8, P_87,        0,0)
 = 355                      *1C T_FDIVP equ 0x355
                              C insa(FDIVR, fdivr,    OpCls( ST,       STI,        NONE ), 0,      0,  0,      0xD8, 0xF8, P_87,        0,0)
 = 356                      *1C T_FDIVR equ 0x356
                              C insa(FDIVRP, fdivrp,  OpCls( STI,      ST,         NONE ), 0,      0,  0,      0xDE, 0xF0, P_87,        0,0)
 = 357                      *1C T_FDIVRP equ 0x357
                              C insa(FSUB, fsub,      OpCls( ST,       STI,        NONE ), 0,      0,  0,      0xD8, 0xE0, P_87,        0,0)
 = 358                      *1C T_FSUB equ 0x358
                              C insa(FSUBP, fsubp,    OpCls( STI,      ST,         NONE ), 0,      0,  0,      0xDE, 0xE8, P_87,        0,0)
 = 359                      *1C T_FSUBP equ 0x359
                              C insa(FSUBR, fsubr,    OpCls( ST,       STI,        NONE ), 0,      0,  0,      0xD8, 0xE8, P_87,        0,0)
 = 35A                      *1C T_FSUBR equ 0x35A
                              C insa(FSUBRP, fsubrp,  OpCls( STI,      ST,         NONE ), 0,      0,  0,      0xDE, 0xE0, P_87,        0,0)
 = 35B                      *1C T_FSUBRP equ 0x35B
                              C 
                              C insa(FIADD, fiadd,    OpCls( M32,      NONE,       NONE ), 0,      0,  0,      0xDA, 0x00, P_87,        0,0)
 = 35C                      *1C T_FIADD equ 0x35C
                              C insa(FICOM, ficom,    OpCls( M32,      NONE,       NONE ), 0,      0,  0,      0xDA, 0x10, P_87,        0,0)
 = 35D                      *1C T_FICOM equ 0x35D
                              C insa(FICOMP, ficomp,  OpCls( M32,      NONE,       NONE ), 0,      0,  0,      0xDA, 0x18, P_87,        0,0)
 = 35E                      *1C T_FICOMP equ 0x35E
                              C insa(FIDIV, fidiv,    OpCls( M32,      NONE,       NONE ), 0,      0,  0,      0xDA, 0x30, P_87,        0,0)
 = 35F                      *1C T_FIDIV equ 0x35F
                              C insa(FIDIVR, fidivr,  OpCls( M32,      NONE,       NONE ), 0,      0,  0,      0xDA, 0x38, P_87,        0,0)
 = 360                      *1C T_FIDIVR equ 0x360
                              C insa(FIMUL, fimul,    OpCls( M32,      NONE,       NONE ), 0,      0,  0,      0xDA, 0x08, P_87,        0,0)
 = 361                      *1C T_FIMUL equ 0x361
                              C insa(FISUB, fisub,    OpCls( M32,      NONE,       NONE ), 0,      0,  0,      0xDA, 0x20, P_87,        0,0)
 = 362                      *1C T_FISUB equ 0x362
                              C insa(FISUBR, fisubr,  OpCls( M32,      NONE,       NONE ), 0,      0,  0,      0xDA, 0x28, P_87,        0,0)
 = 363                      *1C T_FISUBR equ 0x363
                              C 
                              C insa(FILD, fild,      OpCls( M32,      NONE,       NONE ), 0,      0,  0,      0xDB, 0x00, P_87,        0,0)
 = 364                      *1C T_FILD equ 0x364
                              C insa(FISTP, fistp,    OpCls( M32,      NONE,       NONE ), 0,      0,  0,      0xDB, 0x18, P_87,        0,0)
 = 365                      *1C T_FISTP equ 0x365
                              C insa(FIST, fist,      OpCls( M32,      NONE,       NONE ), 0,      0,  0,      0xDB, 0x10, P_87,        0,0)
 = 366                      *1C T_FIST equ 0x366
                              C 
                              C insa(FLD, fld,        OpCls( STI,      NONE,       NONE ), 0,      0,  0,      0xD9, 0xC0, P_87,        0,0)
 = 367                      *1C T_FLD equ 0x367
                              C insa(FSTP, fstp,      OpCls( STI,      NONE,       NONE ), 0,      0,  0,      0xDD, 0xD8, P_87,        0,0)
 = 368                      *1C T_FSTP equ 0x368
                              C insa(FST, fst,        OpCls( STI,      NONE,       NONE ), 0,      0,  0,      0xDD, 0xD0, P_87,        0,0)
 = 369                      *1C T_FST equ 0x369
                              C 
                              C insa(FLDENV, fldenv,  OpCls( M_ANY,    NONE,       NONE ), 0,      0,  0,      0xD9, 0x20, P_87,        0,0)
 = 36A                      *1C T_FLDENV equ 0x36A
                              C insa(FLDENVD, fldenvd,OpCls( M_ANY,    NONE,       NONE ), F_32,   0,  0,      0xD9, 0x20, P_387,       0,0)
 = 36B                      *1C T_FLDENVD equ 0x36B
                              C insa(FLDENVW, fldenvw,OpCls( M_ANY,    NONE,       NONE ), F_16,   0,  0,      0xD9, 0x20, P_87,        0,0)
 = 36C                      *1C T_FLDENVW equ 0x36C
                              C insa(FNSAVE, fnsave,  OpCls( M_ANY,    NONE,       NONE ), 0,      0,  0,      0xDD, 0x30, P_87,        AP_NO_FWAIT,0)
 = 36D                      *1C T_FNSAVE equ 0x36D
                              C insa(FNSAVED, fnsaved,OpCls( M_ANY,    NONE,       NONE ), F_32,   0,  0,      0xDD, 0x30, P_387,       AP_NO_FWAIT,0)
 = 36E                      *1C T_FNSAVED equ 0x36E
                              C insa(FNSAVEW, fnsavew,OpCls( M_ANY,    NONE,       NONE ), F_16,   0,  0,      0xDD, 0x30, P_87,        AP_NO_FWAIT,0)
 = 36F                      *1C T_FNSAVEW equ 0x36F
                              C insa(FNSTENV, fnstenv,OpCls( M_ANY,    NONE,       NONE ), 0,      0,  0,      0xD9, 0x30, P_87,        AP_NO_FWAIT,0)
 = 370                      *1C T_FNSTENV equ 0x370
                              C insa(FNSTENVD, fnstenvd, OpCls( M_ANY, NONE,       NONE ), F_32,   0,  0,      0xD9, 0x30, P_387,       AP_NO_FWAIT,0)
 = 371                      *1C T_FNSTENVD equ 0x371
                              C insa(FNSTENVW, fnstenvw, OpCls( M_ANY, NONE,       NONE ), F_16,   0,  0,      0xD9, 0x30, P_87,        AP_NO_FWAIT,0)
 = 372                      *1C T_FNSTENVW equ 0x372
                              C insa(FRSTOR, frstor,  OpCls( M_ANY,    NONE,       NONE ), 0,      0,  0,      0xDD, 0x20, P_87,        0,0)
 = 373                      *1C T_FRSTOR equ 0x373
                              C insa(FRSTORD, frstord,OpCls( M_ANY,    NONE,       NONE ), F_32,   0,  0,      0xDD, 0x20, P_387,       0,0)
 = 374                      *1C T_FRSTORD equ 0x374
                              C insa(FRSTORW, frstorw,OpCls( M_ANY,    NONE,       NONE ), F_16,   0,  0,      0xDD, 0x20, P_87,        0,0)
 = 375                      *1C T_FRSTORW equ 0x375
                              C insa(FSAVE, fsave,    OpCls( M_ANY,    NONE,       NONE ), 0,      0,  0,      0xDD, 0x30, P_87,        AP_FWAIT,0)
 = 376                      *1C T_FSAVE equ 0x376
                              C insa(FSAVED, fsaved,  OpCls( M_ANY,    NONE,       NONE ), F_32,   0,  0,      0xDD, 0x30, P_387,       AP_FWAIT,0)
 = 377                      *1C T_FSAVED equ 0x377
                              C insa(FSAVEW, fsavew,  OpCls( M_ANY,    NONE,       NONE ), F_16,   0,  0,      0xDD, 0x30, P_87,        AP_FWAIT,0)
 = 378                      *1C T_FSAVEW equ 0x378
                              C insa(FSTENV, fstenv,  OpCls( M_ANY,    NONE,       NONE ), 0,      0,  0,      0xD9, 0x30, P_87,        AP_FWAIT,0)
 = 379                      *1C T_FSTENV equ 0x379
                              C insa(FSTENVD, fstenvd,OpCls( M_ANY,    NONE,       NONE ), F_32,   0,  0,      0xD9, 0x30, P_387,       AP_FWAIT,0)
 = 37A                      *1C T_FSTENVD equ 0x37A
                              C insa(FSTENVW, fstenvw,OpCls( M_ANY,    NONE,       NONE ), F_16,   0,  0,      0xD9, 0x30, P_87,        AP_FWAIT,0)
 = 37B                      *1C T_FSTENVW equ 0x37B
                              C 
                              C insa(FLDCW, fldcw,    OpCls( M16,      NONE,       NONE ), 0,      0,  0,      0xD9, 0x28, P_87,        0,0)
 = 37C                      *1C T_FLDCW equ 0x37C
                              C insa(FNSTCW, fnstcw,  OpCls( M16,      NONE,       NONE ), 0,      0,  0,      0xD9, 0x38, P_87,        AP_NO_FWAIT,0)
 = 37D                      *1C T_FNSTCW equ 0x37D
                              C insa(FNSTSW, fnstsw,  OpCls( AX,       NONE,       NONE ), 0,      0,  no_WDS, 0xDF, 0xE0, P_287,       AP_NO_FWAIT,0)
 = 37E                      *1C T_FNSTSW equ 0x37E
                              C insa(FSTCW, fstcw,    OpCls( M16,      NONE,       NONE ), 0,      0,  0,      0xD9, 0x38, P_87,        AP_FWAIT,0)
 = 37F                      *1C T_FSTCW equ 0x37F
                              C insa(FSTSW, fstsw,    OpCls( AX,       NONE,       NONE ), 0,      0,  no_WDS, 0xDF, 0xE0, P_287,       AP_FWAIT,0)
 = 380                      *1C T_FSTSW equ 0x380
                              C 
                              C insa(FCOS, fcos,      OpCls( NONE,     NONE,       NONE ), 0,      0,  0,      0xD9, 0xFF, P_387,       0,0)
 = 381                      *1C T_FCOS equ 0x381
                              C insa(FPATAN, fpatan,  OpCls( NONE,     NONE,       NONE ), 0,      0,  0,      0xD9, 0xF3, P_87,        0,0)
 = 382                      *1C T_FPATAN equ 0x382
                              C insa(FPTAN, fptan,    OpCls( NONE,     NONE,       NONE ), 0,      0,  0,      0xD9, 0xF2, P_87,        0,0)
 = 383                      *1C T_FPTAN equ 0x383
                              C insa(FSIN, fsin,      OpCls( NONE,     NONE,       NONE ), 0,      0,  0,      0xD9, 0xFE, P_387,       0,0)
 = 384                      *1C T_FSIN equ 0x384
                              C insa(FSINCOS, fsincos,OpCls( NONE,     NONE,       NONE ), 0,      0,  0,      0xD9, 0xFB, P_387,       0,0)
 = 385                      *1C T_FSINCOS equ 0x385
                              C 
                              C insa(FINIT, finit,    OpCls( NONE,     NONE,       NONE ), 0,      0,  0,      0xDB, 0xE3, P_87,        AP_FWAIT,0)
 = 386                      *1C T_FINIT equ 0x386
                              C insa(FNINIT, fninit,  OpCls( NONE,     NONE,       NONE ), 0,      0,  0,      0xDB, 0xE3, P_87,        AP_NO_FWAIT,0)
 = 387                      *1C T_FNINIT equ 0x387
                              C insa(FDISI, fdisi,    OpCls( NONE,     NONE,       NONE ), 0,      0,  0,      0xDB, 0xE1, P_87,        AP_FWAIT,0)
 = 388                      *1C T_FDISI equ 0x388
                              C insa(FNDISI, fndisi,  OpCls( NONE,     NONE,       NONE ), 0,      0,  0,      0xDB, 0xE1, P_87,        AP_NO_FWAIT,0)
 = 389                      *1C T_FNDISI equ 0x389
                              C insa(FENI, feni,      OpCls( NONE,     NONE,       NONE ), 0,      0,  0,      0xDB, 0xE0, P_87,        AP_FWAIT,0)
 = 38A                      *1C T_FENI equ 0x38A
                              C insa(FNENI, fneni,    OpCls( NONE,     NONE,       NONE ), 0,      0,  0,      0xDB, 0xE0, P_87,        AP_NO_FWAIT,0)
 = 38B                      *1C T_FNENI equ 0x38B
                              C insa(FCLEX, fclex,    OpCls( NONE,     NONE,       NONE ), 0,      0,  0,      0xDB, 0xE2, P_87,        AP_FWAIT,0)
 = 38C                      *1C T_FCLEX equ 0x38C
                              C insa(FNCLEX, fnclex,  OpCls( NONE,     NONE,       NONE ), 0,      0,  0,      0xDB, 0xE2, P_87,        AP_NO_FWAIT,0)
 = 38D                      *1C T_FNCLEX equ 0x38D
                              C 
                              C insa(F2XM1, f2xm1,    OpCls( NONE,     NONE,       NONE ), 0,      0,  0,      0xD9, 0xF0, P_87,        0,0)
 = 38E                      *1C T_F2XM1 equ 0x38E
                              C insa(FABS, fabs,      OpCls( NONE,     NONE,       NONE ), 0,      0,  0,      0xD9, 0xE1, P_87,        0,0)
 = 38F                      *1C T_FABS equ 0x38F
                              C insa(FBLD, fbld,      OpCls( M80,      NONE,       NONE ), 0,      0,  0,      0xDF, 0x20, P_87,        0,0)
 = 390                      *1C T_FBLD equ 0x390
                              C insa(FBSTP, fbstp,    OpCls( M80,      NONE,       NONE ), 0,      0,  0,      0xDF, 0x30, P_87,        0,0)
 = 391                      *1C T_FBSTP equ 0x391
                              C insa(FCHS, fchs,      OpCls( NONE,     NONE,       NONE ), 0,      0,  0,      0xD9, 0xE0, P_87,        0,0)
 = 392                      *1C T_FCHS equ 0x392
                              C insa(FLD1, fld1,      OpCls( NONE,     NONE,       NONE ), 0,      0,  0,      0xD9, 0xE8, P_87,        0,0)
 = 393                      *1C T_FLD1 equ 0x393
                              C insa(FLDL2E, fldl2e,  OpCls( NONE,     NONE,       NONE ), 0,      0,  0,      0xD9, 0xEA, P_87,        0,0)
 = 394                      *1C T_FLDL2E equ 0x394
                              C insa(FLDL2T, fldl2t,  OpCls( NONE,     NONE,       NONE ), 0,      0,  0,      0xD9, 0xE9, P_87,        0,0)
 = 395                      *1C T_FLDL2T equ 0x395
                              C insa(FLDLG2, fldlg2,  OpCls( NONE,     NONE,       NONE ), 0,      0,  0,      0xD9, 0xEC, P_87,        0,0)
 = 396                      *1C T_FLDLG2 equ 0x396
                              C insa(FLDLN2, fldln2,  OpCls( NONE,     NONE,       NONE ), 0,      0,  0,      0xD9, 0xED, P_87,        0,0)
 = 397                      *1C T_FLDLN2 equ 0x397
                              C insa(FLDPI, fldpi,    OpCls( NONE,     NONE,       NONE ), 0,      0,  0,      0xD9, 0xEB, P_87,        0,0)
 = 398                      *1C T_FLDPI equ 0x398
                              C insa(FLDZ, fldz,      OpCls( NONE,     NONE,       NONE ), 0,      0,  0,      0xD9, 0xEE, P_87,        0,0)
 = 399                      *1C T_FLDZ equ 0x399
                              C insa(FDECSTP, fdecstp,OpCls( NONE,     NONE,       NONE ), 0,      0,  0,      0xD9, 0xF6, P_87,        0,0)
 = 39A                      *1C T_FDECSTP equ 0x39A
                              C insa(FINCSTP, fincstp,OpCls( NONE,     NONE,       NONE ), 0,      0,  0,      0xD9, 0xF7, P_87,        0,0)
 = 39B                      *1C T_FINCSTP equ 0x39B
                              C insa(FFREE, ffree,    OpCls( STI,      NONE,       NONE ), 0,      0,  0,      0xDD, 0xC0, P_87,        0,0)
 = 39C                      *1C T_FFREE equ 0x39C
                              C 
                              C ; FFREEP is undocumented (same as FFREE + POP)
                              C 
                              C insa(FFREEP, ffreep,  OpCls( STI,      NONE,       NONE ), 0,      0,  0,      0xDF, 0xC0, P_87,        0,0)
 = 39D                      *1C T_FFREEP equ 0x39D
                              C insa(FNOP, fnop,      OpCls( NONE,     NONE,       NONE ), 0,      0,  0,      0xD9, 0xD0, P_87,        0,0)
 = 39E                      *1C T_FNOP equ 0x39E
                              C insa(FPREM, fprem,    OpCls( NONE,     NONE,       NONE ), 0,      0,  0,      0xD9, 0xF8, P_87,        0,0)
 = 39F                      *1C T_FPREM equ 0x39F
                              C insa(FPREM1, fprem1,  OpCls( NONE,     NONE,       NONE ), 0,      0,  0,      0xD9, 0xF5, P_387,       0,0)
 = 3A0                      *1C T_FPREM1 equ 0x3A0
                              C insa(FRNDINT, frndint,OpCls( NONE,     NONE,       NONE ), 0,      0,  0,      0xD9, 0xFC, P_87,        0,0)
 = 3A1                      *1C T_FRNDINT equ 0x3A1
                              C insa(FSCALE, fscale,  OpCls( NONE,     NONE,       NONE ), 0,      0,  0,      0xD9, 0xFD, P_87,        0,0)
 = 3A2                      *1C T_FSCALE equ 0x3A2
                              C insa(FSETPM, fsetpm,  OpCls( NONE,     NONE,       NONE ), 0,      0,  0,      0xDB, 0xE4, P_287,       0,0)
 = 3A3                      *1C T_FSETPM equ 0x3A3
                              C insa(FSQRT, fsqrt,    OpCls( NONE,     NONE,       NONE ), 0,      0,  0,      0xD9, 0xFA, P_87,        0,0)
 = 3A4                      *1C T_FSQRT equ 0x3A4
                              C insa(FTST, ftst,      OpCls( NONE,     NONE,       NONE ), 0,      0,  0,      0xD9, 0xE4, P_87,        0,0)
 = 3A5                      *1C T_FTST equ 0x3A5
                              C insa(FWAIT, fwait,    OpCls( NONE,     NONE,       NONE ), 0,      0,  no_RM,  0x9B, 0x00, P_87,        0,0)
 = 3A6                      *1C T_FWAIT equ 0x3A6
                              C insa(FXAM, fxam,      OpCls( NONE,     NONE,       NONE ), 0,      0,  0,      0xD9, 0xE5, P_87,        0,0)
 = 3A7                      *1C T_FXAM equ 0x3A7
                              C insa(FXCH, fxch,      OpCls( STI,      NONE,       NONE ), 0,      0,  0,      0xD9, 0xC8, P_87,        0,0)
 = 3A8                      *1C T_FXCH equ 0x3A8
                              C insa(FXRSTOR, fxrstor,OpCls( M_ANY,    NONE,       NONE ), F_0F,   0,  no_WDS, 0xAE, 0x08, P_686 or P_SSE1,0,0)
 = 3A9                      *1C T_FXRSTOR equ 0x3A9
                              C insa(FXSAVE, fxsave,  OpCls( M_ANY,    NONE,       NONE ), F_0F,   0,  no_WDS, 0xAE, 0x00, P_686 or P_SSE1,0,0)
 = 3AA                      *1C T_FXSAVE equ 0x3AA
                              C insa(FXTRACT, fxtract,OpCls( NONE,     NONE,       NONE ), 0,      0,  0,      0xD9, 0xF4, P_87,        0,0)
 = 3AB                      *1C T_FXTRACT equ 0x3AB
                              C insa(FYL2X, fyl2x,    OpCls( NONE,     NONE,       NONE ), 0,      0,  0,      0xD9, 0xF1, P_87,        0,0)
 = 3AC                      *1C T_FYL2X equ 0x3AC
                              C insa(FYL2XP1, fyl2xp1,OpCls( NONE,     NONE,       NONE ), 0,      0,  0,      0xD9, 0xF9, P_87,        0,0)
 = 3AD                      *1C T_FYL2XP1 equ 0x3AD
                              C 
                              C ; MMX/SSE related opcodes (except SSE instructions CMPSD and MOVSD)
                              C 
                              C insa(EMMS, emms,      OpCls( NONE,     NONE,       NONE ), F_0F,   0,  no_RM,  0x77, 0x00, P_586 or P_MMX, 0,0)
 = 3AE                      *1C T_EMMS equ 0x3AE
                              C insa(CLFLUSH, clflush,OpCls( M_ANY,    NONE,       NONE ), F_0F,   0,  no_WDS, 0xAE, 0x38, P_686 or P_SSE2,0,0)
 = 3AF                      *1C T_CLFLUSH equ 0x3AF
                              C insa(LDMXCSR, ldmxcsr,OpCls( M32,      NONE,       NONE ), F_0F,   0,  no_WDS, 0xAE, 0x10, P_686 or P_SSE1,0,0)
 = 3B0                      *1C T_LDMXCSR equ 0x3B0
                              C insa(STMXCSR, stmxcsr,OpCls( M32,      NONE,       NONE ), F_0F,   0,  no_WDS, 0xAE, 0x18, P_686 or P_SSE1,0,0)
 = 3B1                      *1C T_STMXCSR equ 0x3B1
                              C insa(LFENCE, lfence,  OpCls( NONE,     NONE,       NONE ), F_0F,   0,  no_WDS, 0xAE, 0xE8, P_686 or P_SSE2,0,0)
 = 3B2                      *1C T_LFENCE equ 0x3B2
                              C insa(MFENCE, mfence,  OpCls( NONE,     NONE,       NONE ), F_0F,   0,  no_WDS, 0xAE, 0xF0, P_686 or P_SSE2,0,0)
 = 3B3                      *1C T_MFENCE equ 0x3B3
                              C insa(SFENCE, sfence,  OpCls( NONE,     NONE,       NONE ), F_0F,   0,  no_WDS, 0xAE, 0xF8, P_686 or P_SSE1,0,0)
 = 3B4                      *1C T_SFENCE equ 0x3B4
                              C insa(PREFETCHNTA,prefetchnta, OpCls( M_ANY, NONE,  NONE ), F_0F,   0,  no_WDS, 0x18, 0x00, P_686 or P_SSE1,0,0)
 = 3B5                      *1C T_PREFETCHNTA equ 0x3B5
                              C insa(PREFETCHT0, prefetcht0, OpCls( M_ANY, NONE,   NONE ), F_0F,   0,  no_WDS, 0x18, 0x08, P_686 or P_SSE1,0,0)
 = 3B6                      *1C T_PREFETCHT0 equ 0x3B6
                              C insa(PREFETCHT1, prefetcht1, OpCls( M_ANY, NONE,   NONE ), F_0F,   0,  no_WDS, 0x18, 0x10, P_686 or P_SSE1,0,0)
 = 3B7                      *1C T_PREFETCHT1 equ 0x3B7
                              C insa(PREFETCHT2, prefetcht2, OpCls( M_ANY, NONE,   NONE ), F_0F,   0,  no_WDS, 0x18, 0x18, P_686 or P_SSE1,0,0)
 = 3B8                      *1C T_PREFETCHT2 equ 0x3B8
                              C insa(PAUSE, pause,    OpCls( NONE,     NONE,       NONE ), F_F3,   0,  no_RM,  0x90, 0x00, P_686 or P_SSE2,0,0)
 = 3B9                      *1C T_PAUSE equ 0x3B9
                              C 
                              C insa(ADDPD, addpd, OpCls( XMM, XMM_M128_M64, NONE ), F_660F, 1, no_WDS, 0x58, 0x00, P_686 or P_SSE2, 0, 0xE0)
 = 3BA                      *1C T_ADDPD equ 0x3BA
                              C insa(ADDPS, addps, OpCls( XMM, XMM_M128_M32, NONE ), F_0F,   1, no_WDS, 0x58, 0x00, P_686 or P_SSE1, 0, 0xE0)
 = 3BB                      *1C T_ADDPS equ 0x3BB
                              C insa(ADDSD, addsd, OpCls( XMM, XMM_M64,      NONE ), F_F20F, 1, no_WDS, 0x58, 0x00, P_686 or P_SSE2, 0, 0xE0)
 = 3BC                      *1C T_ADDSD equ 0x3BC
                              C insa(ADDSS, addss, OpCls( XMM, XMM_M32,      NONE ), F_F30F, 1, no_WDS, 0x58, 0x00, P_686 or P_SSE1, 0, 0xE0)
 = 3BD                      *1C T_ADDSS equ 0x3BD
                              C insa(DIVPD, divpd, OpCls( XMM, XMM_M128_M64, NONE ), F_660F, 1, no_WDS, 0x5E, 0x00, P_686 or P_SSE2, 0, 0xE0)
 = 3BE                      *1C T_DIVPD equ 0x3BE
                              C insa(DIVPS, divps, OpCls( XMM, XMM_M128_M32, NONE ), F_0F,   1, no_WDS, 0x5E, 0x00, P_686 or P_SSE1, 0, 0xE0)
 = 3BF                      *1C T_DIVPS equ 0x3BF
                              C insa(DIVSD, divsd, OpCls( XMM, XMM_M64,      NONE ), F_F20F, 1, no_WDS, 0x5E, 0x00, P_686 or P_SSE2, 0, 0xE0)
 = 3C0                      *1C T_DIVSD equ 0x3C0
                              C insa(DIVSS, divss, OpCls( XMM, XMM_M32,      NONE ), F_F30F, 1, no_WDS, 0x5E, 0x00, P_686 or P_SSE1, 0, 0xE0)
 = 3C1                      *1C T_DIVSS equ 0x3C1
                              C insa(MAXPD, maxpd, OpCls( XMM, XMM_M128_M64, NONE ), F_660F, 1, no_WDS, 0x5F, 0x00, P_686 or P_SSE2, 0, 0xE0)
 = 3C2                      *1C T_MAXPD equ 0x3C2
                              C insa(MAXPS, maxps, OpCls( XMM, XMM_M128_M32, NONE ), F_0F,   1, no_WDS, 0x5F, 0x00, P_686 or P_SSE1, 0, 0xE0)
 = 3C3                      *1C T_MAXPS equ 0x3C3
                              C insa(MAXSD, maxsd, OpCls( XMM, XMM_M64,      NONE ), F_F20F, 1, no_WDS, 0x5F, 0x00, P_686 or P_SSE2, 0, 0xE0)
 = 3C4                      *1C T_MAXSD equ 0x3C4
                              C insa(MAXSS, maxss, OpCls( XMM, XMM_M32,      NONE ), F_F30F, 1, no_WDS, 0x5F, 0x00, P_686 or P_SSE1, 0, 0xE0)
 = 3C5                      *1C T_MAXSS equ 0x3C5
                              C insa(MINPD, minpd, OpCls( XMM, XMM_M128_M64, NONE ), F_660F, 1, no_WDS, 0x5D, 0x00, P_686 or P_SSE2, 0, 0xE0)
 = 3C6                      *1C T_MINPD equ 0x3C6
                              C insa(MINPS, minps, OpCls( XMM, XMM_M128_M32, NONE ), F_0F,   1, no_WDS, 0x5D, 0x00, P_686 or P_SSE1, 0, 0xE0)
 = 3C7                      *1C T_MINPS equ 0x3C7
                              C insa(MINSD, minsd, OpCls( XMM, XMM_M64,      NONE ), F_F20F, 1, no_WDS, 0x5D, 0x00, P_686 or P_SSE2, 0, 0xE0)
 = 3C8                      *1C T_MINSD equ 0x3C8
                              C insa(MINSS, minss, OpCls( XMM, XMM_M32,      NONE ), F_F30F, 1, no_WDS, 0x5D, 0x00, P_686 or P_SSE1, 0, 0xE0)
 = 3C9                      *1C T_MINSS equ 0x3C9
                              C insa(MULPD, mulpd, OpCls( XMM, XMM_M128_M64, NONE ), F_660F, 1, no_WDS, 0x59, 0x00, P_686 or P_SSE2, 0, 0xE0)
 = 3CA                      *1C T_MULPD equ 0x3CA
                              C insa(MULPS, mulps, OpCls( XMM, XMM_M128_M32, NONE ), F_0F,   1, no_WDS, 0x59, 0x00, P_686 or P_SSE1, 0, 0xE0)
 = 3CB                      *1C T_MULPS equ 0x3CB
                              C insa(MULSD, mulsd, OpCls( XMM, XMM_M64,      NONE ), F_F20F, 1, no_WDS, 0x59, 0x00, P_686 or P_SSE2, 0, 0xE0)
 = 3CC                      *1C T_MULSD equ 0x3CC
                              C insa(MULSS, mulss, OpCls( XMM, XMM_M32,      NONE ), F_F30F, 1, no_WDS, 0x59, 0x00, P_686 or P_SSE1, 0, 0xE0)
 = 3CD                      *1C T_MULSS equ 0x3CD
                              C insa(SQRTPD,sqrtpd,OpCls( XMM, XMM_M128_M64, NONE ), F_660F, 1, no_WDS, 0x51, 0x00, P_686 or P_SSE2, 0, 0xF0)
 = 3CE                      *1C T_SQRTPD equ 0x3CE
                              C insa(SQRTPS,sqrtps,OpCls( XMM, XMM_M128_M32, NONE ), F_0F,   1, no_WDS, 0x51, 0x00, P_686 or P_SSE1, 0, 0xF0)
 = 3CF                      *1C T_SQRTPS equ 0x3CF
                              C insa(SQRTSD,sqrtsd,OpCls( XMM, XMM_M64,      NONE ), F_F20F, 1, no_WDS, 0x51, 0x00, P_686 or P_SSE2, 0, 0xF0)
 = 3D0                      *1C T_SQRTSD equ 0x3D0
                              C insa(SQRTSS,sqrtss,OpCls( XMM, XMM_M32,      NONE ), F_F30F, 1, no_WDS, 0x51, 0x00, P_686 or P_SSE1, 0, 0xF0)
 = 3D1                      *1C T_SQRTSS equ 0x3D1
                              C insa(SUBPD, subpd, OpCls( XMM, XMM_M128_M64, NONE ), F_660F, 1, no_WDS, 0x5C, 0x00, P_686 or P_SSE2, 0, 0xE0)
 = 3D2                      *1C T_SUBPD equ 0x3D2
                              C insa(SUBPS, subps, OpCls( XMM, XMM_M128_M32, NONE ), F_0F,   1, no_WDS, 0x5C, 0x00, P_686 or P_SSE1, 0, 0xE0)
 = 3D3                      *1C T_SUBPS equ 0x3D3
                              C insa(SUBSD, subsd, OpCls( XMM, XMM_M64,      NONE ), F_F20F, 1, no_WDS, 0x5C, 0x00, P_686 or P_SSE2, 0, 0xE0)
 = 3D4                      *1C T_SUBSD equ 0x3D4
                              C insa(SUBSS, subss, OpCls( XMM, XMM_M32,      NONE ), F_F30F, 1, no_WDS, 0x5C, 0x00, P_686 or P_SSE1, 0, 0xE0)
 = 3D5                      *1C T_SUBSS equ 0x3D5
                              C 
                              C insa(CMPPD, cmppd, OpCls( XMM, XMM_M128,     I8_U ), F_660F, 1, no_WDS, 0xC2, 0x00, P_686 or P_SSE2,0,0)
 = 3D6                      *1C T_CMPPD equ 0x3D6
                              C insa(CMPPS, cmpps, OpCls( XMM, XMM_M128,     I8_U ), F_0F,   1, no_WDS, 0xC2, 0x00, P_686 or P_SSE1,0,0)
 = 3D7                      *1C T_CMPPS equ 0x3D7
                              C insa(CMPSS, cmpss, OpCls( XMM, XMM_M32,      I8_U ), F_F30F, 1, no_WDS, 0xC2, 0x00, P_686 or P_SSE1,0,0)
 = 3D8                      *1C T_CMPSS equ 0x3D8
                              C 
                              C insa(CMPEQPD,    cmpeqpd,    OpCls( XMM, XMM_M128, HID ), F_660F, 1, no_WDS, 0xC2, 0x00, P_686 or P_SSE2, 0, 0 )
 = 3D9                      *1C T_CMPEQPD equ 0x3D9
                              C insa(CMPLTPD,    cmpltpd,    OpCls( XMM, XMM_M128, HID ), F_660F, 1, no_WDS, 0xC2, 0x00, P_686 or P_SSE2, 0, 0 )
 = 3DA                      *1C T_CMPLTPD equ 0x3DA
                              C insa(CMPLEPD,    cmplepd,    OpCls( XMM, XMM_M128, HID ), F_660F, 1, no_WDS, 0xC2, 0x00, P_686 or P_SSE2, 0, 0 )
 = 3DB                      *1C T_CMPLEPD equ 0x3DB
                              C insa(CMPUNORDPD, cmpunordpd, OpCls( XMM, XMM_M128, HID ), F_660F, 1, no_WDS, 0xC2, 0x00, P_686 or P_SSE2, 0, 0 )
 = 3DC                      *1C T_CMPUNORDPD equ 0x3DC
                              C insa(CMPNEQPD,   cmpneqpd,   OpCls( XMM, XMM_M128, HID ), F_660F, 1, no_WDS, 0xC2, 0x00, P_686 or P_SSE2, 0, 0 )
 = 3DD                      *1C T_CMPNEQPD equ 0x3DD
                              C insa(CMPNLTPD,   cmpnltpd,   OpCls( XMM, XMM_M128, HID ), F_660F, 1, no_WDS, 0xC2, 0x00, P_686 or P_SSE2, 0, 0 )
 = 3DE                      *1C T_CMPNLTPD equ 0x3DE
                              C insa(CMPNLEPD,   cmpnlepd,   OpCls( XMM, XMM_M128, HID ), F_660F, 1, no_WDS, 0xC2, 0x00, P_686 or P_SSE2, 0, 0 )
 = 3DF                      *1C T_CMPNLEPD equ 0x3DF
                              C insa(CMPORDPD,   cmpordpd,   OpCls( XMM, XMM_M128, HID ), F_660F, 1, no_WDS, 0xC2, 0x00, P_686 or P_SSE2, 0, 0 )
 = 3E0                      *1C T_CMPORDPD equ 0x3E0
                              C 
                              C insa(CMPEQPS,    cmpeqps,    OpCls( XMM, XMM_M128, HID ), F_0F,   1, no_WDS, 0xC2, 0x00, P_686 or P_SSE1, 0, 0 )
 = 3E1                      *1C T_CMPEQPS equ 0x3E1
                              C insa(CMPLTPS,    cmpltps,    OpCls( XMM, XMM_M128, HID ), F_0F,   1, no_WDS, 0xC2, 0x00, P_686 or P_SSE1, 0, 0 )
 = 3E2                      *1C T_CMPLTPS equ 0x3E2
                              C insa(CMPLEPS,    cmpleps,    OpCls( XMM, XMM_M128, HID ), F_0F,   1, no_WDS, 0xC2, 0x00, P_686 or P_SSE1, 0, 0 )
 = 3E3                      *1C T_CMPLEPS equ 0x3E3
                              C insa(CMPUNORDPS, cmpunordps, OpCls( XMM, XMM_M128, HID ), F_0F,   1, no_WDS, 0xC2, 0x00, P_686 or P_SSE1, 0, 0 )
 = 3E4                      *1C T_CMPUNORDPS equ 0x3E4
                              C insa(CMPNEQPS,   cmpneqps,   OpCls( XMM, XMM_M128, HID ), F_0F,   1, no_WDS, 0xC2, 0x00, P_686 or P_SSE1, 0, 0 )
 = 3E5                      *1C T_CMPNEQPS equ 0x3E5
                              C insa(CMPNLTPS,   cmpnltps,   OpCls( XMM, XMM_M128, HID ), F_0F,   1, no_WDS, 0xC2, 0x00, P_686 or P_SSE1, 0, 0 )
 = 3E6                      *1C T_CMPNLTPS equ 0x3E6
                              C insa(CMPNLEPS,   cmpnleps,   OpCls( XMM, XMM_M128, HID ), F_0F,   1, no_WDS, 0xC2, 0x00, P_686 or P_SSE1, 0, 0 )
 = 3E7                      *1C T_CMPNLEPS equ 0x3E7
                              C insa(CMPORDPS,   cmpordps,   OpCls( XMM, XMM_M128, HID ), F_0F,   1, no_WDS, 0xC2, 0x00, P_686 or P_SSE1, 0, 0 )
 = 3E8                      *1C T_CMPORDPS equ 0x3E8
                              C 
                              C insa(CMPEQSD,    cmpeqsd,    OpCls( XMM, XMM_M64,  HID ), F_F20F, 1, no_WDS, 0xC2, 0x00, P_686 or P_SSE2, 0, 0 )
 = 3E9                      *1C T_CMPEQSD equ 0x3E9
                              C insa(CMPLTSD,    cmpltsd,    OpCls( XMM, XMM_M64,  HID ), F_F20F, 1, no_WDS, 0xC2, 0x00, P_686 or P_SSE2, 0, 0 )
 = 3EA                      *1C T_CMPLTSD equ 0x3EA
                              C insa(CMPLESD,    cmplesd,    OpCls( XMM, XMM_M64,  HID ), F_F20F, 1, no_WDS, 0xC2, 0x00, P_686 or P_SSE2, 0, 0 )
 = 3EB                      *1C T_CMPLESD equ 0x3EB
                              C insa(CMPUNORDSD, cmpunordsd, OpCls( XMM, XMM_M64,  HID ), F_F20F, 1, no_WDS, 0xC2, 0x00, P_686 or P_SSE2, 0, 0 )
 = 3EC                      *1C T_CMPUNORDSD equ 0x3EC
                              C insa(CMPNEQSD,   cmpneqsd,   OpCls( XMM, XMM_M64,  HID ), F_F20F, 1, no_WDS, 0xC2, 0x00, P_686 or P_SSE2, 0, 0 )
 = 3ED                      *1C T_CMPNEQSD equ 0x3ED
                              C insa(CMPNLTSD,   cmpnltsd,   OpCls( XMM, XMM_M64,  HID ), F_F20F, 1, no_WDS, 0xC2, 0x00, P_686 or P_SSE2, 0, 0 )
 = 3EE                      *1C T_CMPNLTSD equ 0x3EE
                              C insa(CMPNLESD,   cmpnlesd,   OpCls( XMM, XMM_M64,  HID ), F_F20F, 1, no_WDS, 0xC2, 0x00, P_686 or P_SSE2, 0, 0 )
 = 3EF                      *1C T_CMPNLESD equ 0x3EF
                              C insa(CMPORDSD,   cmpordsd,   OpCls( XMM, XMM_M64,  HID ), F_F20F, 1, no_WDS, 0xC2, 0x00, P_686 or P_SSE2, 0, 0 )
 = 3F0                      *1C T_CMPORDSD equ 0x3F0
                              C 
                              C insa(CMPEQSS,    cmpeqss,    OpCls( XMM, XMM_M32,  HID ), F_F30F, 1, no_WDS, 0xC2, 0x00, P_686 or P_SSE1, 0, 0 )
 = 3F1                      *1C T_CMPEQSS equ 0x3F1
                              C insa(CMPLTSS,    cmpltss,    OpCls( XMM, XMM_M32,  HID ), F_F30F, 1, no_WDS, 0xC2, 0x00, P_686 or P_SSE1, 0, 0 )
 = 3F2                      *1C T_CMPLTSS equ 0x3F2
                              C insa(CMPLESS,    cmpless,    OpCls( XMM, XMM_M32,  HID ), F_F30F, 1, no_WDS, 0xC2, 0x00, P_686 or P_SSE1, 0, 0 )
 = 3F3                      *1C T_CMPLESS equ 0x3F3
                              C insa(CMPUNORDSS, cmpunordss, OpCls( XMM, XMM_M32,  HID ), F_F30F, 1, no_WDS, 0xC2, 0x00, P_686 or P_SSE1, 0, 0 )
 = 3F4                      *1C T_CMPUNORDSS equ 0x3F4
                              C insa(CMPNEQSS,   cmpneqss,   OpCls( XMM, XMM_M32,  HID ), F_F30F, 1, no_WDS, 0xC2, 0x00, P_686 or P_SSE1, 0, 0 )
 = 3F5                      *1C T_CMPNEQSS equ 0x3F5
                              C insa(CMPNLTSS,   cmpnltss,   OpCls( XMM, XMM_M32,  HID ), F_F30F, 1, no_WDS, 0xC2, 0x00, P_686 or P_SSE1, 0, 0 )
 = 3F6                      *1C T_CMPNLTSS equ 0x3F6
                              C insa(CMPNLESS,   cmpnless,   OpCls( XMM, XMM_M32,  HID ), F_F30F, 1, no_WDS, 0xC2, 0x00, P_686 or P_SSE1, 0, 0 )
 = 3F7                      *1C T_CMPNLESS equ 0x3F7
                              C insa(CMPORDSS,   cmpordss,   OpCls( XMM, XMM_M32,  HID ), F_F30F, 1, no_WDS, 0xC2, 0x00, P_686 or P_SSE1, 0, 0 )
 = 3F8                      *1C T_CMPORDSS equ 0x3F8
                              C 
                              C insa(ANDNPD, andnpd,  OpCls( XMM, XMM_M128_M64, NONE ), F_660F, 1,  no_WDS, 0x55, 0x00, P_686 or P_SSE2,0,0xE0)
 = 3F9                      *1C T_ANDNPD equ 0x3F9
                              C insa(ANDNPS, andnps,  OpCls( XMM, XMM_M128, NONE ), F_0F,   1,  no_WDS, 0x55, 0x00, P_686 or P_SSE1,0,0xE0)
 = 3FA                      *1C T_ANDNPS equ 0x3FA
                              C insa(ANDPD, andpd,    OpCls( XMM, XMM_M128_M64, NONE ), F_660F, 1,  no_WDS, 0x54, 0x00, P_686 or P_SSE2,0,0xE0)
 = 3FB                      *1C T_ANDPD equ 0x3FB
                              C insa(ANDPS, andps,    OpCls( XMM, XMM_M128, NONE ), F_0F,   1,  no_WDS, 0x54, 0x00, P_686 or P_SSE1,0,0xE0)
 = 3FC                      *1C T_ANDPS equ 0x3FC
                              C insa(ORPD, orpd,      OpCls( XMM, XMM_M128_M64, NONE ), F_660F, 1,  no_WDS, 0x56, 0x00, P_686 or P_SSE2,0,0xF0)
 = 3FD                      *1C T_ORPD equ 0x3FD
                              C insa(ORPS, orps,      OpCls( XMM, XMM_M128, NONE ), F_0F,   1,  no_WDS, 0x56, 0x00, P_686 or P_SSE1,0,0xF0)
 = 3FE                      *1C T_ORPS equ 0x3FE
                              C insa(COMISD, comisd,  OpCls( XMM, XMM_M64,  NONE ), F_660F, 1,  no_WDS, 0x2F, 0x00, P_686 or P_SSE2,0,0xB0)
 = 3FF                      *1C T_COMISD equ 0x3FF
                              C insa(COMISS, comiss,  OpCls( XMM, XMM_M32,  NONE ), F_0F,   1,  no_WDS, 0x2F, 0x00, P_686 or P_SSE1,0,0xE0)
 = 400                      *1C T_COMISS equ 0x400
                              C insa(XORPD, xorpd,    OpCls( XMM, XMM_M128_M64, NONE ), F_660F, 1,  no_WDS, 0x57, 0x00, P_686 or P_SSE2,0,0xE0)
 = 401                      *1C T_XORPD equ 0x401
                              C insa(XORPS, xorps,    OpCls( XMM, XMM_M128, NONE ), F_0F,   1,  no_WDS, 0x57, 0x00, P_686 or P_SSE1,0,0xE0)
 = 402                      *1C T_XORPS equ 0x402
                              C 
                              C insa(CVTPD2PI, cvtpd2pi,   OpCls( MMX,      XMM_M128, NONE ), F_660F, 1, no_WDS, 0x2D, 0x00, P_686 or P_SSE2,0,0)
 = 403                      *1C T_CVTPD2PI equ 0x403
                              C insa(CVTPS2PI, cvtps2pi,   OpCls( MMX,      XMM_M64,  NONE ), F_0F,   1, no_WDS, 0x2D, 0x00, P_686 or P_SSE1,0,0)
 = 404                      *1C T_CVTPS2PI equ 0x404
                              C insa(CVTSD2SI, cvtsd2si,   OpCls( R32_M32,  XMM_M64,  NONE ), F_F20F, 1, no_WDS, 0x2D, 0x00, P_686 or P_SSE2,0,0xB0)
 = 405                      *1C T_CVTSD2SI equ 0x405
                              C insa(CVTSS2SI, cvtss2si,   OpCls( R32_M32,  XMM_M32,  NONE ), F_F30F, 1, no_WDS, 0x2D, 0x00, P_686 or P_SSE1,0,0xB0)
 = 406                      *1C T_CVTSS2SI equ 0x406
                              C insa(CVTPI2PD, cvtpi2pd,   OpCls( XMM,      MMX_M64,  NONE ), F_660F, 1, no_WDS, 0x2A, 0x00, P_686 or P_SSE2,0,0)
 = 407                      *1C T_CVTPI2PD equ 0x407
                              C insa(CVTPI2PS, cvtpi2ps,   OpCls( XMM,      MMX_M64,  NONE ), F_0F,   1, no_WDS, 0x2A, 0x00, P_686 or P_SSE1,0,0)
 = 408                      *1C T_CVTPI2PS equ 0x408
                              C insa(CVTSI2SD, cvtsi2sd,   OpCls( XMM,      R32_M32,  NONE ), F_F20F, 1, no_WDS, 0x2A, 0x00, P_686 or P_SSE2,0,0xE0)
 = 409                      *1C T_CVTSI2SD equ 0x409
                              C insa(CVTSI2SS, cvtsi2ss,   OpCls( XMM,      R32_M32,  NONE ), F_F30F, 1, no_WDS, 0x2A, 0x00, P_686 or P_SSE1,0,0xE0)
 = 40A                      *1C T_CVTSI2SS equ 0x40A
                              C insa(CVTTPD2PI, cvttpd2pi, OpCls( MMX,      XMM_M128, NONE ), F_660F, 1, no_WDS, 0x2C, 0x00, P_686 or P_SSE2,0,0)
 = 40B                      *1C T_CVTTPD2PI equ 0x40B
                              C insa(CVTTPS2PI, cvttps2pi, OpCls( MMX,      XMM_M64,  NONE ), F_0F,   1, no_WDS, 0x2C, 0x00, P_686 or P_SSE1,0,0)
 = 40C                      *1C T_CVTTPS2PI equ 0x40C
                              C insa(CVTTSD2SI, cvttsd2si, OpCls( R32_M32,  XMM_M64,  NONE ), F_F20F, 1, no_WDS, 0x2C, 0x00, P_686 or P_SSE2,0,0xB0)
 = 40D                      *1C T_CVTTSD2SI equ 0x40D
                              C insa(CVTTSS2SI, cvttss2si, OpCls( R32_M32,  XMM_M32,  NONE ), F_F30F, 1, no_WDS, 0x2C, 0x00, P_686 or P_SSE1,0,0xB0)
 = 40E                      *1C T_CVTTSS2SI equ 0x40E
                              C 
                              C insa(CVTDQ2PS, cvtdq2ps,   OpCls( XMM,  XMM_M128_M32, NONE ), F_0F,   1, no_WDS, 0x5B, 0x00, P_686 or P_SSE2,0,0xE0)
 = 40F                      *1C T_CVTDQ2PS equ 0x40F
                              C insa(CVTPS2DQ, cvtps2dq,   OpCls( XMM,  XMM_M128_M32, NONE ), F_660F, 1, no_WDS, 0x5B, 0x00, P_686 or P_SSE2,0,0xE0)
 = 410                      *1C T_CVTPS2DQ equ 0x410
                              C insa(CVTTPS2DQ, cvttps2dq, OpCls( XMM,  XMM_M128_M32, NONE ), F_F30F, 1, no_WDS, 0x5B, 0x00, P_686 or P_SSE2,0,0xE0)
 = 411                      *1C T_CVTTPS2DQ equ 0x411
                              C insa(CVTPD2DQ, cvtpd2dq,   OpCls( XMM,      XMM_M128, NONE ), F_F20F, 1, no_WDS, 0xE6, 0x00, P_686 or P_SSE2,0,0xE0)
 = 412                      *1C T_CVTPD2DQ equ 0x412
                              C insa(CVTDQ2PD, cvtdq2pd,   OpCls( XMM,      XMM_M64,  NONE ), F_F30F, 1, no_WDS, 0xE6, 0x00, P_686 or P_SSE2,0,0xE0)
 = 413                      *1C T_CVTDQ2PD equ 0x413
                              C insa(CVTTPD2DQ, cvttpd2dq, OpCls( XMM,      XMM_M128, NONE ), F_660F, 1, no_WDS, 0xE6, 0x00, P_686 or P_SSE2,0,0xE0)
 = 414                      *1C T_CVTTPD2DQ equ 0x414
                              C insa(CVTPD2PS, cvtpd2ps,   OpCls( XMM,      XMM_M128, NONE ), F_660F, 1, no_WDS, 0x5A, 0x00, P_686 or P_SSE2,0,0xE0)
 = 415                      *1C T_CVTPD2PS equ 0x415
                              C insa(CVTPS2PD, cvtps2pd,   OpCls( XMM,      XMM_M64,  NONE ), F_0F,   1, no_WDS, 0x5A, 0x00, P_686 or P_SSE2,0,0xE0)
 = 416                      *1C T_CVTPS2PD equ 0x416
                              C insa(CVTSD2SS, cvtsd2ss,   OpCls( XMM,      XMM_M64,  NONE ), F_F20F, 1, no_WDS, 0x5A, 0x00, P_686 or P_SSE2,0,0xE0)
 = 417                      *1C T_CVTSD2SS equ 0x417
                              C insa(CVTSS2SD, cvtss2sd,   OpCls( XMM,      XMM_M32,  NONE ), F_F30F, 1, no_WDS, 0x5A, 0x00, P_686 or P_SSE2,0,0xE0)
 = 418                      *1C T_CVTSS2SD equ 0x418
                              C insa(MASKMOVDQU, maskmovdqu, OpCls( XMM,    XMM,      NONE ), F_660F, 1, no_WDS, 0xF7, 0x00, P_686 or P_SSE2,0,0)
 = 419                      *1C T_MASKMOVDQU equ 0x419
                              C insa(MASKMOVQ, maskmovq,   OpCls( MMX,      MMX,      NONE ), F_0F,   1, no_WDS, 0xF7, 0x00, P_686 or P_SSE1,0,0)
 = 41A                      *1C T_MASKMOVQ equ 0x41A
                              C 
                              C ; Masm (ML64) uses MOVD if a 64-bit register is src,dst. Intel docs prefer MOVQ
                              C 
                              C insa(MOVD, movd,      OpCls( MMX,      RMGT16,   NONE ), F_0F,   1,  no_WDS, 0x6E, 0x00, P_586 or P_MMX, 0,0xE0)
 = 41B                      *1C T_MOVD equ 0x41B
                              C 
                              C insa(MOVQ, movq,      OpCls( MMX,      MMX_M64,  NONE ), F_0F,   1,  no_WDS, 0x6F, 0x00, P_586 or P_MMX, 0,0xE0)
 = 41C                      *1C T_MOVQ equ 0x41C
                              C 
                              C insa(MOVAPD, movapd,  OpCls( XMM,      XMM_M128, NONE ), F_660F, 1,  no_WDS, 0x28, 0x00, P_686 or P_SSE2,0,0xE0)
 = 41D                      *1C T_MOVAPD equ 0x41D
                              C insa(MOVAPS, movaps,  OpCls( XMM,      XMM_M128, NONE ), F_0F,   1,  no_WDS, 0x28, 0x00, P_686 or P_SSE1,0,0xE0)
 = 41E                      *1C T_MOVAPS equ 0x41E
                              C insa(MOVDQA, movdqa,  OpCls( XMM,      XMM_M128, NONE ), F_660F, 1,  no_WDS, 0x6F, 0x00, P_686 or P_SSE2,0,0)
 = 41F                      *1C T_MOVDQA equ 0x41F
                              C insa(MOVDQU, movdqu,  OpCls( XMM,      XMM_M128, NONE ), F_F30F, 1,  no_WDS, 0x6F, 0x00, P_686 or P_SSE2,0,0)
 = 420                      *1C T_MOVDQU equ 0x420
                              C insa(MOVUPD, movupd,  OpCls( XMM,      XMM_M128, NONE ), F_660F, 1,  no_WDS, 0x10, 0x00, P_686 or P_SSE2,0,0xE0)
 = 421                      *1C T_MOVUPD equ 0x421
                              C insa(MOVUPS, movups,  OpCls( XMM,      XMM_M128, NONE ), F_0F,   1,  no_WDS, 0x10, 0x00, P_686 or P_SSE1,0,0xE0)
 = 422                      *1C T_MOVUPS equ 0x422
                              C insa(MOVHPD, movhpd,  OpCls( XMM,      M64,      NONE ), F_660F, 1,  no_WDS, 0x16, 0x00, P_686 or P_SSE2,0,0xE0)
 = 423                      *1C T_MOVHPD equ 0x423
                              C insa(MOVHPS, movhps,  OpCls( XMM,      M64,      NONE ), F_0F,   1,  no_WDS, 0x16, 0x00, P_686 or P_SSE1,0,0xE0)
 = 424                      *1C T_MOVHPS equ 0x424
                              C insa(MOVLPD, movlpd,  OpCls( XMM,      M64,      NONE ), F_660F, 1,  no_WDS, 0x12, 0x00, P_686 or P_SSE2,0,0xE0)
 = 425                      *1C T_MOVLPD equ 0x425
                              C insa(MOVLPS, movlps,  OpCls( XMM,      M64,      NONE ), F_0F,   1,  no_WDS, 0x12, 0x00, P_686 or P_SSE1,0,0xE0)
 = 426                      *1C T_MOVLPS equ 0x426
                              C insa(MOVHLPS, movhlps, OpCls( XMM,     XMM,      NONE ), F_0F,   1,  no_WDS, 0x12, 0x00, P_686 or P_SSE1,0,0xE0)
 = 427                      *1C T_MOVHLPS equ 0x427
                              C insa(MOVLHPS, movlhps, OpCls( XMM,     XMM,      NONE ), F_0F,   1,  no_WDS, 0x16, 0x00, P_686 or P_SSE1,0,0xE0)
 = 428                      *1C T_MOVLHPS equ 0x428
                              C insa(MOVDQ2Q, movdq2q, OpCls( MMX,     XMM,      NONE ), F_F20F, 1,  no_WDS, 0xD6, 0x00, P_686 or P_SSE2,0,0)
 = 429                      *1C T_MOVDQ2Q equ 0x429
                              C insa(MOVQ2DQ, movq2dq, OpCls( XMM,     MMX,      NONE ), F_F30F, 1,  no_WDS, 0xD6, 0x00, P_686 or P_SSE2,0,0)
 = 42A                      *1C T_MOVQ2DQ equ 0x42A
                              C insa(MOVMSKPD, movmskpd, OpCls( RGT16, XMM,      NONE ), F_660F, 1,  no_WDS, 0x50, 0x00, P_686 or P_SSE2,0,0)
 = 42B                      *1C T_MOVMSKPD equ 0x42B
                              C insa(MOVMSKPS, movmskps, OpCls( RGT16, XMM,      NONE ), F_0F,   1,  no_WDS, 0x50, 0x00, P_686 or P_SSE1,0,0)
 = 42C                      *1C T_MOVMSKPS equ 0x42C
                              C insa(MOVNTDQ, movntdq,OpCls( M128,     XMM,      NONE ), F_660F, 0,  no_WDS, 0xE7, 0x00, P_686 or P_SSE2,0,0xE0)
 = 42D                      *1C T_MOVNTDQ equ 0x42D
                              C insa(MOVNTI, movnti,  OpCls( MGT16,    RGT16,    NONE ), F_0F,   0,  no_WDS, 0xC3, 0x00, P_686 or P_SSE2,0,0)
 = 42E                      *1C T_MOVNTI equ 0x42E
                              C insa(MOVNTPD, movntpd,OpCls( M128,     XMM,      NONE ), F_660F, 0,  no_WDS, 0x2B, 0x00, P_686 or P_SSE2,0,0xE0)
 = 42F                      *1C T_MOVNTPD equ 0x42F
                              C insa(MOVNTPS, movntps,OpCls( M128,     XMM,      NONE ), F_0F,   0,  no_WDS, 0x2B, 0x00, P_686 or P_SSE1,0,0xE0)
 = 430                      *1C T_MOVNTPS equ 0x430
                              C insa(MOVNTQ, movntq,  OpCls( M64,      MMX,      NONE ), F_0F,   0,  no_WDS, 0xE7, 0x00, P_686 or P_SSE1,0,0)
 = 431                      *1C T_MOVNTQ equ 0x431
                              C insa(MOVSS, movss,    OpCls( XMM,      XMM_M32,  NONE ), F_F30F, 1,  no_WDS, 0x10, 0x00, P_686 or P_SSE1,0,0xE0)
 = 432                      *1C T_MOVSS equ 0x432
                              C 
                              C insa(PACKSSDW, packssdw,OpCls( MMX,  MMX_M64,    NONE ), F_0F,   1,  no_WDS, 0x6B, 0x00, P_586 or P_MMX, 0,0xF0)
 = 433                      *1C T_PACKSSDW equ 0x433
                              C insa(PACKSSWB, packsswb,OpCls( MMX,  MMX_M64,    NONE ), F_0F,   1,  no_WDS, 0x63, 0x00, P_586 or P_MMX, 0,0xF0)
 = 434                      *1C T_PACKSSWB equ 0x434
                              C insa(PACKUSWB, packuswb,OpCls( MMX,  MMX_M64,    NONE ), F_0F,   1,  no_WDS, 0x67, 0x00, P_586 or P_MMX, 0,0xF0)
 = 435                      *1C T_PACKUSWB equ 0x435
                              C insa(PADDB, paddb,    OpCls( MMX,    MMX_M64_08, NONE ), F_0F,   1,  no_WDS, 0xFC, 0x00, P_586 or P_MMX, 0,0xE0)
 = 436                      *1C T_PADDB equ 0x436
                              C insa(PADDW, paddw,    OpCls( MMX,    MMX_M64_16, NONE ), F_0F,   1,  no_WDS, 0xFD, 0x00, P_586 or P_MMX, 0,0xE0)
 = 437                      *1C T_PADDW equ 0x437
                              C insa(PADDD, paddd,    OpCls( MMX,    MMX_M64_32, NONE ), F_0F,   1,  no_WDS, 0xFE, 0x00, P_586 or P_MMX, 0,0)
 = 438                      *1C T_PADDD equ 0x438
                              C insa(PADDQ, paddq,    OpCls( MMX,    MMX_M64,    NONE ), F_0F,   1,  no_WDS, 0xD4, 0x00, P_686 or P_SSE2,0,0xE0)
 = 439                      *1C T_PADDQ equ 0x439
                              C insa(PADDSB, paddsb,  OpCls( MMX,    MMX_M64_08, NONE ), F_0F,   1,  no_WDS, 0xEC, 0x00, P_586 or P_MMX, 0,0xE0)
 = 43A                      *1C T_PADDSB equ 0x43A
                              C insa(PADDSW, paddsw,  OpCls( MMX,    MMX_M64_16, NONE ), F_0F,   1,  no_WDS, 0xED, 0x00, P_586 or P_MMX, 0,0xE0)
 = 43B                      *1C T_PADDSW equ 0x43B
                              C insa(PADDUSB, paddusb,OpCls( MMX,    MMX_M64_08, NONE ), F_0F,   1,  no_WDS, 0xDC, 0x00, P_586 or P_MMX, 0,0xE0)
 = 43C                      *1C T_PADDUSB equ 0x43C
                              C insa(PADDUSW, paddusw,OpCls( MMX,    MMX_M64_16, NONE ), F_0F,   1,  no_WDS, 0xDD, 0x00, P_586 or P_MMX, 0,0xE0)
 = 43D                      *1C T_PADDUSW equ 0x43D
                              C insa(PAND, pand,      OpCls( MMX,    MMX_M64,    NONE ), F_0F,   1,  no_WDS, 0xDB, 0x00, P_586 or P_MMX, 0,0)
 = 43E                      *1C T_PAND equ 0x43E
                              C insa(PANDN, pandn,    OpCls( MMX,    MMX_M64,    NONE ), F_0F,   1,  no_WDS, 0xDF, 0x00, P_586 or P_MMX, 0,0)
 = 43F                      *1C T_PANDN equ 0x43F
                              C insa(PAVGB, pavgb,    OpCls( MMX,    MMX_M64,    NONE ), F_0F,   1,  no_WDS, 0xE0, 0x00, P_686 or P_SSE1,0,0xE0)
 = 440                      *1C T_PAVGB equ 0x440
                              C insa(PAVGW, pavgw,    OpCls( MMX,    MMX_M64,  NONE ), F_0F,   1,  no_WDS, 0xE3, 0x00, P_686 or P_SSE1,0,0xE0)
 = 441                      *1C T_PAVGW equ 0x441
                              C insa(PCMPEQB, pcmpeqb,OpCls( MMX,    MMX_M64,  NONE ), F_0F,   1,  no_WDS, 0x74, 0x00, P_586 or P_MMX, 0,0xF0)
 = 442                      *1C T_PCMPEQB equ 0x442
                              C insa(PCMPEQW, pcmpeqw,OpCls( MMX,    MMX_M64,  NONE ), F_0F,   1,  no_WDS, 0x75, 0x00, P_586 or P_MMX, 0,0xF0)
 = 443                      *1C T_PCMPEQW equ 0x443
                              C insa(PCMPEQD, pcmpeqd,OpCls( MMX,    MMX_M64,  NONE ), F_0F,   1,  no_WDS, 0x76, 0x00, P_586 or P_MMX, 0,0xF0)
 = 444                      *1C T_PCMPEQD equ 0x444
                              C insa(PCMPGTB, pcmpgtb,OpCls( MMX,    MMX_M64,  NONE ), F_0F,   1,  no_WDS, 0x64, 0x00, P_586 or P_MMX, 0,0xF0)
 = 445                      *1C T_PCMPGTB equ 0x445
                              C insa(PCMPGTW, pcmpgtw,OpCls( MMX,    MMX_M64,  NONE ), F_0F,   1,  no_WDS, 0x65, 0x00, P_586 or P_MMX, 0,0xF0)
 = 446                      *1C T_PCMPGTW equ 0x446
                              C insa(PCMPGTD, pcmpgtd,OpCls( MMX,    MMX_M64,  NONE ), F_0F,   1,  no_WDS, 0x66, 0x00, P_586 or P_MMX, 0,0xF0)
 = 447                      *1C T_PCMPGTD equ 0x447
                              C 
                              C insa(PEXTRW, pextrw,  OpCls( RGT16,  MMX,      I8_U ), F_0F,   1,  no_WDS, 0xC5, 0x00, P_686 or P_SSE1,0,0xE0)
 = 448                      *1C T_PEXTRW equ 0x448
                              C insa(PINSRW, pinsrw,  OpCls( MMX,      R32_M16,  I8_U ), F_0F,   1,  no_WDS, 0xC4, 0x00, P_686 or P_SSE1,0,0xE0)
 = 449                      *1C T_PINSRW equ 0x449
                              C insa(PMADDWD, pmaddwd,OpCls( MMX,      MMX_M64,  NONE ), F_0F,   1,  no_WDS, 0xF5, 0x00, P_586 or P_MMX, 0,0xE0)
 = 44A                      *1C T_PMADDWD equ 0x44A
                              C insa(PMAXSW, pmaxsw,  OpCls( MMX,      MMX_M64,  NONE ), F_0F,   1,  no_WDS, 0xEE, 0x00, P_686 or P_SSE1,0,0xE0)
 = 44B                      *1C T_PMAXSW equ 0x44B
                              C insa(PMAXUB, pmaxub,  OpCls( MMX,      MMX_M64,  NONE ), F_0F,   1,  no_WDS, 0xDE, 0x00, P_686 or P_SSE1,0,0xE0)
 = 44C                      *1C T_PMAXUB equ 0x44C
                              C insa(PMINSW, pminsw,  OpCls( MMX,      MMX_M64,  NONE ), F_0F,   1,  no_WDS, 0xEA, 0x00, P_686 or P_SSE1,0,0xE0)
 = 44D                      *1C T_PMINSW equ 0x44D
                              C insa(PMINUB, pminub,  OpCls( MMX,      MMX_M64,  NONE ), F_0F,   1,  no_WDS, 0xDA, 0x00, P_686 or P_SSE1,0,0xE0)
 = 44E                      *1C T_PMINUB equ 0x44E
                              C insa(PMOVMSKB, pmovmskb, OpCls( RGT16, MMX,      NONE ), F_0F,   1,  no_WDS, 0xD7, 0x00, P_686 or P_SSE1,0,0)
 = 44F                      *1C T_PMOVMSKB equ 0x44F
                              C 
                              C insa(PMULHUW, pmulhuw,OpCls( MMX,      MMX_M64,  NONE ), F_0F,   1,  no_WDS, 0xE4, 0x00, P_586 or P_SSE1,0,0)
 = 450                      *1C T_PMULHUW equ 0x450
                              C insa(PMULHW, pmulhw,  OpCls( MMX,      MMX_M64,  NONE ), F_0F,   1,  no_WDS, 0xE5, 0x00, P_586 or P_MMX, 0,0xE0)
 = 451                      *1C T_PMULHW equ 0x451
                              C insa(PMULLW, pmullw,  OpCls( MMX,      MMX_M64,  NONE ), F_0F,   1,  no_WDS, 0xD5, 0x00, P_586 or P_MMX, 0,0xE0)
 = 452                      *1C T_PMULLW equ 0x452
                              C insa(PMULUDQ, pmuludq,OpCls( MMX,      MMX_M64,  NONE ), F_0F,   1,  no_WDS, 0xF4, 0x00, P_686 or P_SSE2,0,0xE2)
 = 453                      *1C T_PMULUDQ equ 0x453
                              C insa(POR, por,        OpCls( MMX,      MMX_M64,  NONE ), F_0F,   1,  no_WDS, 0xEB, 0x00, P_586 or P_MMX, 0,0)
 = 454                      *1C T_POR equ 0x454
                              C insa(PSADBW, psadbw,  OpCls( MMX,      MMX_M64,  NONE ), F_0F,   1,  no_WDS, 0xF6, 0x00, P_686 or P_SSE1,0,0xE0)
 = 455                      *1C T_PSADBW equ 0x455
                              C insa(PSHUFD, pshufd,  OpCls( XMM,  XMM_M128_M32, I8_U ), F_660F, 1,  no_WDS, 0x70, 0x00, P_686 or P_SSE2,0,0x80)
 = 456                      *1C T_PSHUFD equ 0x456
                              C insa(PSHUFW, pshufw,  OpCls( MMX,      MMX_M64,  I8_U ), F_0F,   1,  no_WDS, 0x70, 0x00, P_686 or P_SSE1,0,0xE0)
 = 457                      *1C T_PSHUFW equ 0x457
                              C insa(PSHUFHW, pshufhw,OpCls( XMM,      XMM_M128, I8_U ), F_F30F, 1,  no_WDS, 0x70, 0x00, P_686 or P_SSE2,0,0xE0)
 = 458                      *1C T_PSHUFHW equ 0x458
                              C insa(PSHUFLW, pshuflw,OpCls( XMM,      XMM_M128, I8_U ), F_F20F, 1,  no_WDS, 0x70, 0x00, P_686 or P_SSE2,0,0xE0)
 = 459                      *1C T_PSHUFLW equ 0x459
                              C 
                              C insa(PSLLW, psllw, OpCls( MMX, MMX_M64,  NONE ), F_0F,   1, no_WDS, 0xF1, 0x00, P_586 or P_MMX, 0,0xE4)
 = 45A                      *1C T_PSLLW equ 0x45A
                              C insa(PSLLD, pslld, OpCls( MMX, MMX_M64,  NONE ), F_0F,   1, no_WDS, 0xF2, 0x00, P_586 or P_MMX, 0,0xE0)
 = 45B                      *1C T_PSLLD equ 0x45B
                              C insa(PSLLQ, psllq, OpCls( MMX, MMX_M64,  NONE ), F_0F,   1, no_WDS, 0xF3, 0x00, P_586 or P_MMX, 0,0xE0)
 = 45C                      *1C T_PSLLQ equ 0x45C
                              C 
                              C insa(PSRAW, psraw, OpCls( MMX, MMX_M64,  NONE ), F_0F,   1,  no_WDS, 0xE1, 0x00, P_586 or P_MMX, 0,0xE0)
 = 45D                      *1C T_PSRAW equ 0x45D
                              C insa(PSRAD, psrad, OpCls( MMX, MMX_M64,  NONE ), F_0F,   1,  no_WDS, 0xE2, 0x00, P_586 or P_MMX, 0,0xE0)
 = 45E                      *1C T_PSRAD equ 0x45E
                              C 
                              C insa(PSRLW, psrlw, OpCls( MMX, MMX_M64,  NONE ), F_0F,   1,  no_WDS, 0xD1, 0x00, P_586 or P_MMX, 0,0xE0)
 = 45F                      *1C T_PSRLW equ 0x45F
                              C 
                              C insa(PSRLD, psrld, OpCls( MMX, MMX_M64,  NONE ), F_0F,   1,  no_WDS, 0xD2, 0x00, P_586 or P_MMX, 0,0x90)
 = 460                      *1C T_PSRLD equ 0x460
                              C 
                              C insa(PSRLQ, psrlq, OpCls( MMX, MMX_M64,  NONE ), F_0F,   1,  no_WDS, 0xD3, 0x00, P_586 or P_MMX, 0,0x90)
 = 461                      *1C T_PSRLQ equ 0x461
                              C 
                              C insa(PSLLDQ, pslldq, OpCls( XMM, I8_U,   NONE ), F_660F, 0,  no_WDS, 0x73, 0x38, P_686 or P_SSE2,0,0xF0)
 = 462                      *1C T_PSLLDQ equ 0x462
                              C insa(PSRLDQ, psrldq, OpCls( XMM, I8_U,   NONE ), F_660F, 0,  no_WDS, 0x73, 0x18, P_686 or P_SSE2,0,0x90)
 = 463                      *1C T_PSRLDQ equ 0x463
                              C 
                              C insa(PSUBB, psubb,      OpCls( MMX,      MMX_M64,  NONE ), F_0F,   1,  no_WDS, 0xF8, 0x00, P_586 or P_MMX, 0,0xF0)
 = 464                      *1C T_PSUBB equ 0x464
                              C insa(PSUBW, psubw,      OpCls( MMX,      MMX_M64,  NONE ), F_0F,   1,  no_WDS, 0xF9, 0x00, P_586 or P_MMX, 0,0xF0)
 = 465                      *1C T_PSUBW equ 0x465
                              C insa(PSUBD, psubd,      OpCls( MMX,      MMX_M64,  NONE ), F_0F,   1,  no_WDS, 0xFA, 0x00, P_586 or P_MMX, 0,0xF0)
 = 466                      *1C T_PSUBD equ 0x466
                              C insa(PSUBQ, psubq,      OpCls( MMX,      MMX_M64,  NONE ), F_0F,   1,  no_WDS, 0xFB, 0x00, P_686 or P_SSE2,0,0xF0)
 = 467                      *1C T_PSUBQ equ 0x467
                              C insa(PSUBSB, psubsb,    OpCls( MMX,      MMX_M64,  NONE ), F_0F,   1,  no_WDS, 0xE8, 0x00, P_586 or P_MMX, 0,0xF0)
 = 468                      *1C T_PSUBSB equ 0x468
                              C insa(PSUBSW, psubsw,    OpCls( MMX,      MMX_M64,  NONE ), F_0F,   1,  no_WDS, 0xE9, 0x00, P_586 or P_MMX, 0,0xF0)
 = 469                      *1C T_PSUBSW equ 0x469
                              C insa(PSUBUSB, psubusb,  OpCls( MMX,      MMX_M64,  NONE ), F_0F,   1,  no_WDS, 0xD8, 0x00, P_586 or P_MMX, 0,0xF0)
 = 46A                      *1C T_PSUBUSB equ 0x46A
                              C insa(PSUBUSW, psubusw,  OpCls( MMX,      MMX_M64,  NONE ), F_0F,   1,  no_WDS, 0xD9, 0x00, P_586 or P_MMX, 0,0xF0)
 = 46B                      *1C T_PSUBUSW equ 0x46B
                              C insa(PXOR, pxor,        OpCls( MMX,      MMX_M64,  NONE ), F_0F,   1,  no_WDS, 0xEF, 0x00, P_586 or P_MMX, 0,0)
 = 46C                      *1C T_PXOR equ 0x46C
                              C insa(PUNPCKHBW, punpckhbw, OpCls( MMX,   MMX_M64,  NONE ), F_0F,   1,  no_WDS, 0x68, 0x00, P_586 or P_MMX, 0,0xF0)
 = 46D                      *1C T_PUNPCKHBW equ 0x46D
                              C insa(PUNPCKHWD, punpckhwd, OpCls( MMX,   MMX_M64,  NONE ), F_0F,   1,  no_WDS, 0x69, 0x00, P_586 or P_MMX, 0,0xF0)
 = 46E                      *1C T_PUNPCKHWD equ 0x46E
                              C insa(PUNPCKHDQ, punpckhdq, OpCls( MMX,   MMX_M64,  NONE ), F_0F,   1,  no_WDS, 0x6A, 0x00, P_586 or P_MMX, 0,0xF0)
 = 46F                      *1C T_PUNPCKHDQ equ 0x46F
                              C insa(PUNPCKLBW, punpcklbw, OpCls( MMX,   MMX_M64,  NONE ), F_0F,   1,  no_WDS, 0x60, 0x00, P_586 or P_MMX, 0,0xF0)
 = 470                      *1C T_PUNPCKLBW equ 0x470
                              C insa(PUNPCKLWD, punpcklwd, OpCls( MMX,   MMX_M64,  NONE ), F_0F,   1,  no_WDS, 0x61, 0x00, P_586 or P_MMX, 0,0xF0)
 = 471                      *1C T_PUNPCKLWD equ 0x471
                              C insa(PUNPCKLDQ, punpckldq, OpCls( MMX,   MMX_M64,  NONE ), F_0F,   1,  no_WDS, 0x62, 0x00, P_586 or P_MMX, 0,0xF0)
 = 472                      *1C T_PUNPCKLDQ equ 0x472
                              C insa(PUNPCKHQDQ, punpckhqdq, OpCls(XMM,XMM_M128_M64,NONE), F_660F, 1,  no_WDS, 0x6D, 0x00, P_686 or P_SSE2,0,0xF0)
 = 473                      *1C T_PUNPCKHQDQ equ 0x473
                              C insa(PUNPCKLQDQ, punpcklqdq, OpCls(XMM,XMM_M128_M64,NONE), F_660F, 1,  no_WDS, 0x6C, 0x00, P_686 or P_SSE2,0,0xF0)
 = 474                      *1C T_PUNPCKLQDQ equ 0x474
                              C 
                              C insa(RCPPS, rcpps,      OpCls( XMM,      XMM_M128, NONE ), F_0F,   1,  no_WDS, 0x53, 0x00, P_686 or P_SSE1,0,0)
 = 475                      *1C T_RCPPS equ 0x475
                              C insa(RCPSS, rcpss,      OpCls( XMM,      XMM_M32,  NONE ), F_F30F, 1,  no_WDS, 0x53, 0x00, P_686 or P_SSE1,0,0)
 = 476                      *1C T_RCPSS equ 0x476
                              C insa(RSQRTPS, rsqrtps,  OpCls( XMM,      XMM_M128, NONE ), F_0F,   1,  no_WDS, 0x52, 0x00, P_686 or P_SSE1,0,0)
 = 477                      *1C T_RSQRTPS equ 0x477
                              C insa(RSQRTSS, rsqrtss,  OpCls( XMM,      XMM_M32,  NONE ), F_F30F, 1,  no_WDS, 0x52, 0x00, P_686 or P_SSE1,0,0)
 = 478                      *1C T_RSQRTSS equ 0x478
                              C insa(SHUFPD, shufpd,    OpCls( XMM,  XMM_M128_M64, I8_U ), F_660F, 1,  no_WDS, 0xC6, 0x00, P_686 or P_SSE2,0,0xE0)
 = 479                      *1C T_SHUFPD equ 0x479
                              C insa(SHUFPS, shufps,    OpCls( XMM,  XMM_M128_M32, I8_U ), F_0F,   1,  no_WDS, 0xC6, 0x00, P_686 or P_SSE1,0,0xE0)
 = 47A                      *1C T_SHUFPS equ 0x47A
                              C insa(UCOMISD, ucomisd,  OpCls( XMM,      XMM_M64,  NONE ), F_660F, 1,  no_WDS, 0x2E, 0x00, P_686 or P_SSE2,0,0xE0)
 = 47B                      *1C T_UCOMISD equ 0x47B
                              C insa(UCOMISS, ucomiss,  OpCls( XMM,      XMM_M32,  NONE ), F_0F,   1,  no_WDS, 0x2E, 0x00, P_686 or P_SSE1,0,0xE0)
 = 47C                      *1C T_UCOMISS equ 0x47C
                              C insa(UNPCKHPD, unpckhpd, OpCls( XMM, XMM_M128_M64, NONE ), F_660F, 1,  no_WDS, 0x15, 0x00, P_686 or P_SSE2,0,0xE0)
 = 47D                      *1C T_UNPCKHPD equ 0x47D
                              C insa(UNPCKHPS, unpckhps, OpCls( XMM, XMM_M128_M32, NONE ), F_0F,   1,  no_WDS, 0x15, 0x00, P_686 or P_SSE1,0,0xE0)
 = 47E                      *1C T_UNPCKHPS equ 0x47E
                              C insa(UNPCKLPD, unpcklpd, OpCls( XMM, XMM_M128_M64, NONE ), F_660F, 1,  no_WDS, 0x14, 0x00, P_686 or P_SSE2,0,0xE0)
 = 47F                      *1C T_UNPCKLPD equ 0x47F
                              C insa(UNPCKLPS, unpcklps, OpCls( XMM, XMM_M128_M32, NONE ), F_0F,   1,  no_WDS, 0x14, 0x00, P_686 or P_SSE1,0,0xE0)
 = 480                      *1C T_UNPCKLPS equ 0x480
                              C 
                              C ; K3D instructions
                              C 
                              C insa(FEMMS, femms,      OpCls( NONE,     NONE,     NONE ), F_0F,   0,  no_RM,  0x0E, 0x00, P_586 or P_K3D, 0,0)
 = 481                      *1C T_FEMMS equ 0x481
                              C insa(PREFETCH, prefetch,OpCls( M_ANY,    NONE,     NONE ), F_0F,   0,  no_WDS, 0x0D, 0x00, P_586 or P_K3D, 0,0)
 = 482                      *1C T_PREFETCH equ 0x482
                              C insa(PREFETCHW, prefetchw,OpCls( M_ANY,  NONE,     NONE ), F_0F,   0,  no_WDS, 0x0D, 0x08, P_586 or P_K3D, 0,0)
 = 483                      *1C T_PREFETCHW equ 0x483
                              C insa(PAVGUSB, pavgusb,  OpCls( MMX,      MMX_M64,  NONE ), F_0F0F, 1,  no_WDS, 0xBF, 0x00, P_586 or P_K3D, 0,0)
 = 484                      *1C T_PAVGUSB equ 0x484
                              C insa(PF2ID, pf2id,      OpCls( MMX,      MMX_M64,  NONE ), F_0F0F, 1,  no_WDS, 0x1D, 0x00, P_586 or P_K3D, 0,0)
 = 485                      *1C T_PF2ID equ 0x485
                              C insa(PF2IW, pf2iw,      OpCls( MMX,      MMX_M64,  NONE ), F_0F0F, 1,  no_WDS, 0x1C, 0x00, P_586 or P_K3D, 0,0)
 = 486                      *1C T_PF2IW equ 0x486
                              C insa(PFACC, pfacc,      OpCls( MMX,      MMX_M64,  NONE ), F_0F0F, 1,  no_WDS, 0xAE, 0x00, P_586 or P_K3D, 0,0)
 = 487                      *1C T_PFACC equ 0x487
                              C insa(PFADD, pfadd,      OpCls( MMX,      MMX_M64,  NONE ), F_0F0F, 1,  no_WDS, 0x9E, 0x00, P_586 or P_K3D, 0,0)
 = 488                      *1C T_PFADD equ 0x488
                              C insa(PFCMPEQ, pfcmpeq,  OpCls( MMX,      MMX_M64,  NONE ), F_0F0F, 1,  no_WDS, 0xB0, 0x00, P_586 or P_K3D, 0,0)
 = 489                      *1C T_PFCMPEQ equ 0x489
                              C insa(PFCMPGE, pfcmpge,  OpCls( MMX,      MMX_M64,  NONE ), F_0F0F, 1,  no_WDS, 0x90, 0x00, P_586 or P_K3D, 0,0)
 = 48A                      *1C T_PFCMPGE equ 0x48A
                              C insa(PFCMPGT, pfcmpgt,  OpCls( MMX,      MMX_M64,  NONE ), F_0F0F, 1,  no_WDS, 0xA0, 0x00, P_586 or P_K3D, 0,0)
 = 48B                      *1C T_PFCMPGT equ 0x48B
                              C insa(PFMAX, pfmax,      OpCls( MMX,      MMX_M64,  NONE ), F_0F0F, 1,  no_WDS, 0xA4, 0x00, P_586 or P_K3D, 0,0)
 = 48C                      *1C T_PFMAX equ 0x48C
                              C insa(PFMIN, pfmin,      OpCls( MMX,      MMX_M64,  NONE ), F_0F0F, 1,  no_WDS, 0x94, 0x00, P_586 or P_K3D, 0,0)
 = 48D                      *1C T_PFMIN equ 0x48D
                              C insa(PFMUL, pfmul,      OpCls( MMX,      MMX_M64,  NONE ), F_0F0F, 1,  no_WDS, 0xB4, 0x00, P_586 or P_K3D, 0,0)
 = 48E                      *1C T_PFMUL equ 0x48E
                              C insa(PFNACC, pfnacc,    OpCls( MMX,      MMX_M64,  NONE ), F_0F0F, 1,  no_WDS, 0x8A, 0x00, P_586 or P_K3D, 0,0)
 = 48F                      *1C T_PFNACC equ 0x48F
                              C insa(PFPNACC, pfpnacc,  OpCls( MMX,      MMX_M64,  NONE ), F_0F0F, 1,  no_WDS, 0x8E, 0x00, P_586 or P_K3D, 0,0)
 = 490                      *1C T_PFPNACC equ 0x490
                              C insa(PFRCP, pfrcp,      OpCls( MMX,      MMX_M64,  NONE ), F_0F0F, 1,  no_WDS, 0x96, 0x00, P_586 or P_K3D, 0,0)
 = 491                      *1C T_PFRCP equ 0x491
                              C insa(PFRCPIT1, pfrcpit1,OpCls( MMX,      MMX_M64,  NONE ), F_0F0F, 1,  no_WDS, 0xA6, 0x00, P_586 or P_K3D, 0,0)
 = 492                      *1C T_PFRCPIT1 equ 0x492
                              C insa(PFRCPIT2, pfrcpit2,OpCls( MMX,      MMX_M64,  NONE ), F_0F0F, 1,  no_WDS, 0xB6, 0x00, P_586 or P_K3D, 0,0)
 = 493                      *1C T_PFRCPIT2 equ 0x493
                              C insa(PFRSQIT1, pfrsqit1,OpCls( MMX,      MMX_M64,  NONE ), F_0F0F, 1,  no_WDS, 0xA7, 0x00, P_586 or P_K3D, 0,0)
 = 494                      *1C T_PFRSQIT1 equ 0x494
                              C insa(PFRSQRT, pfrsqrt,  OpCls( MMX,      MMX_M64,  NONE ), F_0F0F, 1,  no_WDS, 0x97, 0x00, P_586 or P_K3D, 0,0)
 = 495                      *1C T_PFRSQRT equ 0x495
                              C insa(PFSUB, pfsub,      OpCls( MMX,      MMX_M64,  NONE ), F_0F0F, 1,  no_WDS, 0x9A, 0x00, P_586 or P_K3D, 0,0)
 = 496                      *1C T_PFSUB equ 0x496
                              C insa(PFSUBR, pfsubr,    OpCls( MMX,      MMX_M64,  NONE ), F_0F0F, 1,  no_WDS, 0xAA, 0x00, P_586 or P_K3D, 0,0)
 = 497                      *1C T_PFSUBR equ 0x497
                              C insa(PI2FD, pi2fd,      OpCls( MMX,      MMX_M64,  NONE ), F_0F0F, 1,  no_WDS, 0x0D, 0x00, P_586 or P_K3D, 0,0)
 = 498                      *1C T_PI2FD equ 0x498
                              C insa(PI2FW, pi2fw,      OpCls( MMX,      MMX_M64,  NONE ), F_0F0F, 1,  no_WDS, 0x0C, 0x00, P_586 or P_K3D, 0,0)
 = 499                      *1C T_PI2FW equ 0x499
                              C insa(PMULHRW, pmulhrw,  OpCls( MMX,      MMX_M64,  NONE ), F_0F0F, 1,  no_WDS, 0xB7, 0x00, P_586 or P_K3D, 0,0)
 = 49A                      *1C T_PMULHRW equ 0x49A
                              C insa(PSWAPD, pswapd,    OpCls( MMX,      MMX_M64,  NONE ), F_0F0F, 1,  no_WDS, 0xBB, 0x00, P_586 or P_K3D, 0,0)
 = 49B                      *1C T_PSWAPD equ 0x49B
                              C 
                              C insa(ADDSUBPD, addsubpd,OpCls( XMM,      XMM_M128, NONE ), F_660F, 1,  no_WDS, 0xD0, 0x00, P_686 or P_SSE3,0,0)
 = 49C                      *1C T_ADDSUBPD equ 0x49C
                              C insa(ADDSUBPS, addsubps,OpCls( XMM,      XMM_M128, NONE ), F_F20F, 1,  no_WDS, 0xD0, 0x00, P_686 or P_SSE3,0,0)
 = 49D                      *1C T_ADDSUBPS equ 0x49D
                              C insa(FISTTP, fisttp,    OpCls( M32,      NONE,     NONE ), 0,      0,  no_WDS, 0xDB, 0x08, P_686 or P_SSE3,0,0)
 = 49E                      *1C T_FISTTP equ 0x49E
                              C insa(HADDPD, haddpd,    OpCls( XMM,      XMM_M128, NONE ), F_660F, 1,  no_WDS, 0x7C, 0x00, P_686 or P_SSE3,0,0)
 = 49F                      *1C T_HADDPD equ 0x49F
                              C insa(HADDPS, haddps,    OpCls( XMM,      XMM_M128, NONE ), F_F20F, 1,  no_WDS, 0x7C, 0x00, P_686 or P_SSE3,0,0)
 = 4A0                      *1C T_HADDPS equ 0x4A0
                              C insa(HSUBPD, hsubpd,    OpCls( XMM,      XMM_M128, NONE ), F_660F, 1,  no_WDS, 0x7D, 0x00, P_686 or P_SSE3,0,0)
 = 4A1                      *1C T_HSUBPD equ 0x4A1
                              C insa(HSUBPS, hsubps,    OpCls( XMM,      XMM_M128, NONE ), F_F20F, 1,  no_WDS, 0x7D, 0x00, P_686 or P_SSE3,0,0)
 = 4A2                      *1C T_HSUBPS equ 0x4A2
                              C insa(LDDQU, lddqu,      OpCls( XMM,      M128,     NONE ), F_F20F, 1,  no_WDS, 0xF0, 0x00, P_686 or P_SSE3,0,0)
 = 4A3                      *1C T_LDDQU equ 0x4A3
                              C insa(MONITOR, monitor,  OpCls( NONE,     NONE,     NONE ), F_0F,   0,  0,      0x01, 0xC8, P_686 or P_SSE3,0,0)
 = 4A4                      *1C T_MONITOR equ 0x4A4
                              C insa(MOVDDUP, movddup,  OpCls( XMM,      XMM_M64,  NONE ), F_F20F, 1,  no_WDS, 0x12, 0x00, P_686 or P_SSE3,0,0xE0)
 = 4A5                      *1C T_MOVDDUP equ 0x4A5
                              C 
                              C insa(MOVSHDUP, movshdup,OpCls( XMM,      XMM_M128, NONE ), F_F30F, 1,  no_WDS, 0x16, 0x00, P_686 or P_SSE3,0,0xF0)
 = 4A6                      *1C T_MOVSHDUP equ 0x4A6
                              C insa(MOVSLDUP, movsldup,OpCls( XMM,      XMM_M128, NONE ), F_F30F, 1,  no_WDS, 0x12, 0x00, P_686 or P_SSE3,0,0xF0)
 = 4A7                      *1C T_MOVSLDUP equ 0x4A7
                              C insa(MWAIT, mwait,      OpCls( NONE,     NONE,     NONE ), F_0F,   0,  0,      0x01, 0xC9, P_686 or P_SSE3,0,0)
 = 4A8                      *1C T_MWAIT equ 0x4A8
                              C 
                              C insa(PABSB, pabsb,      OpCls( MMX,  MMX_M64,  NONE ), F_0F38,  1,  no_WDS, 0x1C, 0x00, P_686 or P_SSSE3, 0,0xF0)
 = 4A9                      *1C T_PABSB equ 0x4A9
                              C insa(PABSD, pabsd,      OpCls( MMX,  MMX_M64,  NONE ), F_0F38,  1,  no_WDS, 0x1E, 0x00, P_686 or P_SSSE3, 0,0xF0)
 = 4AA                      *1C T_PABSD equ 0x4AA
                              C insa(PABSW, pabsw,      OpCls( MMX,  MMX_M64,  NONE ), F_0F38,  1,  no_WDS, 0x1D, 0x00, P_686 or P_SSSE3, 0,0xF0)
 = 4AB                      *1C T_PABSW equ 0x4AB
                              C insa(PALIGNR, palignr,  OpCls( MMX,  MMX_M64,  I8_U ), F_0F3A,  1,  no_WDS, 0x0F, 0x00, P_686 or P_SSSE3, 0,0xF0)
 = 4AC                      *1C T_PALIGNR equ 0x4AC
                              C insa(PHADDD, phaddd,    OpCls( MMX,  MMX_M64,  NONE ), F_0F38,  1,  no_WDS, 0x02, 0x00, P_686 or P_SSSE3, 0,0)
 = 4AD                      *1C T_PHADDD equ 0x4AD
                              C insa(PHADDSW, phaddsw,  OpCls( MMX,  MMX_M64,  NONE ), F_0F38,  1,  no_WDS, 0x03, 0x00, P_686 or P_SSSE3, 0,0)
 = 4AE                      *1C T_PHADDSW equ 0x4AE
                              C insa(PHADDW, phaddw,    OpCls( MMX,  MMX_M64,  NONE ), F_0F38,  1,  no_WDS, 0x01, 0x00, P_686 or P_SSSE3, 0,0)
 = 4AF                      *1C T_PHADDW equ 0x4AF
                              C insa(PHSUBD, phsubd,    OpCls( MMX,  MMX_M64,  NONE ), F_0F38,  1,  no_WDS, 0x06, 0x00, P_686 or P_SSSE3, 0,0)
 = 4B0                      *1C T_PHSUBD equ 0x4B0
                              C insa(PHSUBSW, phsubsw,  OpCls( MMX,  MMX_M64,  NONE ), F_0F38,  1,  no_WDS, 0x07, 0x00, P_686 or P_SSSE3, 0,0)
 = 4B1                      *1C T_PHSUBSW equ 0x4B1
                              C insa(PHSUBW, phsubw,    OpCls( MMX,  MMX_M64,  NONE ), F_0F38,  1,  no_WDS, 0x05, 0x00, P_686 or P_SSSE3, 0,0)
 = 4B2                      *1C T_PHSUBW equ 0x4B2
                              C insa(PMADDUBSW, pmaddubsw, OpCls( MMX, MMX_M64,NONE ), F_0F38,  1, no_WDS, 0x04, 0x00, P_686 or P_SSSE3,  0,0xF0)
 = 4B3                      *1C T_PMADDUBSW equ 0x4B3
                              C insa(PMULHRSW, pmulhrsw,OpCls( MMX,  MMX_M64,  NONE ), F_0F38,  1,  no_WDS, 0x0B, 0x00, P_686 or P_SSSE3, 0,0xF0)
 = 4B4                      *1C T_PMULHRSW equ 0x4B4
                              C insa(PSHUFB, pshufb,    OpCls( MMX,  MMX_M64,  NONE ), F_0F38,  1,  no_WDS, 0x00, 0x00, P_686 or P_SSSE3, 0,0xF0)
 = 4B5                      *1C T_PSHUFB equ 0x4B5
                              C insa(PSIGNB, psignb,    OpCls( MMX,  MMX_M64,  NONE ), F_0F38,  1,  no_WDS, 0x08, 0x00, P_686 or P_SSSE3, 0,0)
 = 4B6                      *1C T_PSIGNB equ 0x4B6
                              C insa(PSIGND, psignd,    OpCls( MMX,  MMX_M64,  NONE ), F_0F38,  1,  no_WDS, 0x0A, 0x00, P_686 or P_SSSE3, 0,0)
 = 4B7                      *1C T_PSIGND equ 0x4B7
                              C insa(PSIGNW, psignw,    OpCls( MMX,  MMX_M64,  NONE ), F_0F38,  1,  no_WDS, 0x09, 0x00, P_686 or P_SSSE3, 0,0)
 = 4B8                      *1C T_PSIGNW equ 0x4B8
                              C 
                              C insa(PCLMULQDQ,pclmulqdq,OpCls( XMM, XMM_M128, I8_U ), F_660F3A,1,  no_WDS, 0x44, 0x00, P_686 or P_SSSE3, 0,0)
 = 4B9                      *1C T_PCLMULQDQ equ 0x4B9
                              C insa(AESDECLAST,aesdeclast,OpCls(XMM,XMM_M128, NONE ), F_660F38,1,  no_WDS, 0xDF, 0x00, P_686 or P_SSSE3, 0,0)
 = 4BA                      *1C T_AESDECLAST equ 0x4BA
                              C insa(AESDEC, aesdec,    OpCls( XMM,  XMM_M128, NONE ), F_660F38,1,  no_WDS, 0xDE, 0x00, P_686 or P_SSSE3, 0,0)
 = 4BB                      *1C T_AESDEC equ 0x4BB
                              C insa(AESENC, aesenc,    OpCls( XMM,  XMM_M128, NONE ), F_660F38,1,  no_WDS, 0xDC, 0x00, P_686 or P_SSSE3, 0,0)
 = 4BC                      *1C T_AESENC equ 0x4BC
                              C insa(AESENCLAST,aesenclast,OpCls(XMM,XMM_M128, NONE ), F_660F38,1,  no_WDS, 0xDD, 0x00, P_686 or P_SSSE3, 0,0)
 = 4BD                      *1C T_AESENCLAST equ 0x4BD
                              C insa(AESIMC, aesimc,    OpCls( XMM,  XMM_M128, NONE ), F_660F38,1,  no_WDS, 0xDB, 0x00, P_686 or P_SSSE3, 0,0)
 = 4BE                      *1C T_AESIMC equ 0x4BE
                              C insa(AESKEYGENASSIST,aeskeygenassist,OpCls(XMM,XMM_M128,I8_U),F_660F3A,1,no_WDS,0xDF,0x00,P_686 or P_SSSE3,0,0)
 = 4BF                      *1C T_AESKEYGENASSIST equ 0x4BF
                              C insa(ADCX, adcx,        OpCls( R32,  R32_M32,  NONE ), F_660F38,1,  no_WDS, 0xF6, 0x00, P_686 or P_SSSE3, 0,0)
 = 4C0                      *1C T_ADCX equ 0x4C0
                              C 
                              C ; CDQE must be first in this group, see reswords.asm
                              C 
                              C insx(CDQE, cdqe,        OpCls( NONE,     NONE,       NONE ), F_48,   0,  no_RM,  0x98, 0x00, P_64,     0,0,      RWF_X64)
 = 4C1                      *1C T_CDQE equ 0x4C1
                              C insx(CQO, cqo,          OpCls( NONE,     NONE,       NONE ), F_48,   0,  no_RM,  0x99, 0x00, P_64,     0,0,      RWF_X64)
 = 4C2                      *1C T_CQO equ 0x4C2
                              C insx(PUSHFQ, pushfq,    OpCls( NONE,     NONE,       NONE ), 0,      0,  no_RM,  0x9C, 0x00, P_64,     0,0,      RWF_X64)
 = 4C3                      *1C T_PUSHFQ equ 0x4C3
                              C insx(POPFQ, popfq,      OpCls( NONE,     NONE,       NONE ), 0,      0,  no_RM,  0x9D, 0x00, P_64,     0,0,      RWF_X64)
 = 4C4                      *1C T_POPFQ equ 0x4C4
                              C insx(IRETQ, iretq,      OpCls( NONE,     NONE,       NONE ), F_48,   0,  no_RM,  0xCF, 0x00, P_64,     0,0,      RWF_X64)
 = 4C5                      *1C T_IRETQ equ 0x4C5
                              C insx(CMPXCHG16B, cmpxchg16b, OpCls( M128, NONE,      NONE ), F_480F, 0,  0,      0xC7, 0x08, P_64,     AP_LOCK,0, RWF_X64)
 = 4C6                      *1C T_CMPXCHG16B equ 0x4C6
                              C insx(MOVSXD,movsxd,     OpCls( R64,      R32_M32,    NONE ), 0,      1,  0,      0x63, 0x00, P_64,     0,0,      RWF_X64)
 = 4C7                      *1C T_MOVSXD equ 0x4C7
                              C insx(CMPSQ, cmpsq,      OpCls( NONE,     NONE,       NONE ), F_48,   0,  no_RM,  0xA7, 0x00, P_64,     AP_REPxx,0, RWF_X64)
 = 4C8                      *1C T_CMPSQ equ 0x4C8
                              C insx(LODSQ, lodsq,      OpCls( NONE,     NONE,       NONE ), F_48,   0,  no_RM,  0xAD, 0x00, P_64,     AP_REP,0,   RWF_X64)
 = 4C9                      *1C T_LODSQ equ 0x4C9
                              C insx(MOVSQ, movsq,      OpCls( NONE,     NONE,       NONE ), F_48,   0,  no_RM,  0xA5, 0x00, P_64,     AP_REP,0,   RWF_X64)
 = 4CA                      *1C T_MOVSQ equ 0x4CA
                              C insx(SCASQ, scasq,      OpCls( NONE,     NONE,       NONE ), F_48,   0,  no_RM,  0xAF, 0x00, P_64,     AP_REPxx,0, RWF_X64)
 = 4CB                      *1C T_SCASQ equ 0x4CB
                              C insx(STOSQ, stosq,      OpCls( NONE,     NONE,       NONE ), F_48,   0,  no_RM,  0xAB, 0x00, P_64,     AP_REP,0,   RWF_X64)
 = 4CC                      *1C T_STOSQ equ 0x4CC
                              C 
                              C ; PEXTRQ/PINSRQ need a REX.W prefix if M64 is dst/src!
                              C 
                              C insx(PEXTRQ, pextrq,    OpCls( R64_M64,  XMM,        I8_U ), F_660F3A,0, no_WDS, 0x16, 0x00, P_64 or P_SSE4,0, 0xE0, RWF_X64)
 = 4CD                      *1C T_PEXTRQ equ 0x4CD
                              C insx(PINSRQ, pinsrq,    OpCls( XMM,      R64_M64,    I8_U ), F_660F3A,1, no_WDS, 0x22, 0x00, P_64 or P_SSE4,0, 0xE0, RWF_X64)
 = 4CE                      *1C T_PINSRQ equ 0x4CE
                              C insx(SWAPGS, swapgs,    OpCls( NONE,     NONE,       NONE ), F_0F,   0,  0,      0x01, 0xF8, P_64,     0,0, RWF_X64)
 = 4CF                      *1C T_SWAPGS equ 0x4CF
                              C insx(SYSCALL_, syscall, OpCls( NONE,     NONE,       NONE ), F_0F,   0,  no_RM,  0x05, 0x00, P_64,     0,0, RWF_X64)
 = 4D0                      *1C T_SYSCALL_ equ 0x4D0
                              C insx(SYSRET, sysret,    OpCls( NONE,     NONE,       NONE ), F_0F,   0,  no_RM,  0x07, 0x00, P_64,     0,0, RWF_X64)
 = 4D1                      *1C T_SYSRET equ 0x4D1
                              C 
                              C ; Terminate an Indirect Branch in 64-bit Mode
                              C 
                              C insx(ENDBR64, endbr64,  OpCls( NONE,     NONE,       NONE ), F_F30F, 0,  0,      0x1E, 0xFA, P_64,     0,0, RWF_X64)
 = 4D2                      *1C T_ENDBR64 equ 0x4D2
                              C insa(ENDBR32, endbr32,  OpCls( NONE,     NONE,       NONE ), F_F30F, 0,  0,      0x1E, 0xFB, P_686,    0,0)
 = 4D3                      *1C T_ENDBR32 equ 0x4D3
                              C 
                              C ; SSE4.1
                              C 
                              C insa(BLENDPD, blendpd,  OpCls( XMM,      XMM_M128, I8_U ), F_660F3A, 1,  no_WDS, 0x0D, 0x00, P_686 or P_SSE4, 0,0)
 = 4D4                      *1C T_BLENDPD equ 0x4D4
                              C insa(BLENDPS, blendps,  OpCls( XMM,      XMM_M128, I8_U ), F_660F3A, 1,  no_WDS, 0x0C, 0x00, P_686 or P_SSE4, 0,0)
 = 4D5                      *1C T_BLENDPS equ 0x4D5
                              C insa(BLENDVPD, blendvpd,OpCls( XMM,      XMM_M128, XMM0 ), F_660F38, 1,  no_WDS, 0x15, 0x00, P_686 or P_SSE4, 0,0)
 = 4D6                      *1C T_BLENDVPD equ 0x4D6
                              C insa(BLENDVPS, blendvps,OpCls( XMM,      XMM_M128, XMM0 ), F_660F38, 1,  no_WDS, 0x14, 0x00, P_686 or P_SSE4, 0,0)
 = 4D7                      *1C T_BLENDVPS equ 0x4D7
                              C insa(DPPD, dppd,        OpCls( XMM,      XMM_M128, I8_U ), F_660F3A, 1,  no_WDS, 0x41, 0x00, P_686 or P_SSE4, 0,0)
 = 4D8                      *1C T_DPPD equ 0x4D8
                              C insa(DPPS, dpps,        OpCls( XMM,      XMM_M128, I8_U ), F_660F3A, 1,  no_WDS, 0x40, 0x00, P_686 or P_SSE4, 0,0)
 = 4D9                      *1C T_DPPS equ 0x4D9
                              C insa(EXTRACTPS, extractps,OpCls( RGT16,  XMM,      I8_U ), F_660F3A, 0,  no_WDS, 0x17, 0x00, P_686 or P_SSE4, 0,0x80)
 = 4DA                      *1C T_EXTRACTPS equ 0x4DA
                              C insa(INSERTPS, insertps,OpCls( XMM,      XMM_M32,  I8_U ), F_660F3A, 1,  no_WDS, 0x21, 0x00, P_686 or P_SSE4, 0,0xE0)
 = 4DB                      *1C T_INSERTPS equ 0x4DB
                              C insa(MOVNTDQA, movntdqa,OpCls( XMM,      M128,     NONE ), F_660F38, 1,  no_WDS, 0x2A, 0x00, P_686 or P_SSE4, 0,0xF0)
 = 4DC                      *1C T_MOVNTDQA equ 0x4DC
                              C 
                              C insa(MPSADBW, mpsadbw,  OpCls( XMM,      XMM_M128, I8_U ), F_660F3A, 1,  no_WDS, 0x42, 0x00, P_686 or P_SSE4, 0,0)
 = 4DD                      *1C T_MPSADBW equ 0x4DD
                              C insa(PACKUSDW, packusdw,OpCls( XMM,      XMM_M128, NONE ), F_660F38, 1,  no_WDS, 0x2B, 0x00, P_686 or P_SSE4, 0,0xF0)
 = 4DE                      *1C T_PACKUSDW equ 0x4DE
                              C insa(PBLENDVB, pblendvb,OpCls( XMM,      XMM_M128, XMM0 ), F_660F38, 1,  no_WDS, 0x10, 0x00, P_686 or P_SSE4, 0,0)
 = 4DF                      *1C T_PBLENDVB equ 0x4DF
                              C insa(PBLENDW, pblendw,  OpCls( XMM,      XMM_M128, I8_U ), F_660F3A, 1,  no_WDS, 0x0E, 0x00, P_686 or P_SSE4, 0,0)
 = 4E0                      *1C T_PBLENDW equ 0x4E0
                              C insa(PCMPEQQ, pcmpeqq,  OpCls( XMM,      XMM_M128, NONE ), F_660F38, 1,  no_WDS, 0x29, 0x00, P_686 or P_SSE4, 0,0xF2)
 = 4E1                      *1C T_PCMPEQQ equ 0x4E1
                              C 
                              C insa(PEXTRB, pextrb,    OpCls( RGT16_M08,XMM,      I8_U ), F_660F3A, 0,  no_WDS, 0x14, 0x00, P_686 or P_SSE4, 0,0xE0)
 = 4E2                      *1C T_PEXTRB equ 0x4E2
                              C insa(PEXTRD, pextrd,    OpCls( R32_M32,  XMM,      I8_U ), F_660F3A, 0,  no_WDS, 0x16, 0x00, P_686 or P_SSE4, 0,0xE0)
 = 4E3                      *1C T_PEXTRD equ 0x4E3
                              C insa(PHMINPOSUW, phminposuw,OpCls( XMM,  XMM_M128, NONE ), F_660F38, 1,  no_WDS, 0x41, 0x00, P_686 or P_SSE4, 0,0)
 = 4E4                      *1C T_PHMINPOSUW equ 0x4E4
                              C insa(PINSRB, pinsrb,    OpCls( XMM,      R32_M08,  I8_U ), F_660F3A, 1,  no_WDS, 0x20, 0x00, P_686 or P_SSE4, 0,0xF0)
 = 4E5                      *1C T_PINSRB equ 0x4E5
                              C insa(PINSRD, pinsrd,    OpCls( XMM,      R32_M32,  I8_U ), F_660F3A, 1,  no_WDS, 0x22, 0x00, P_686 or P_SSE4, 0,0xF0)
 = 4E6                      *1C T_PINSRD equ 0x4E6
                              C insa(PMAXSB, pmaxsb,    OpCls( XMM,      XMM_M128, NONE ), F_660F38, 1,  no_WDS, 0x3C, 0x00, P_686 or P_SSE4, 0,0xF0)
 = 4E7                      *1C T_PMAXSB equ 0x4E7
                              C insa(PMAXSD, pmaxsd,    OpCls( XMM,  XMM_M128_M32, NONE ), F_660F38, 1,  no_WDS, 0x3D, 0x00, P_686 or P_SSE4, 0,0xF0)
 = 4E8                      *1C T_PMAXSD equ 0x4E8
                              C insa(PMAXUW, pmaxuw,    OpCls( XMM,      XMM_M128, NONE ), F_660F38, 1,  no_WDS, 0x3E, 0x00, P_686 or P_SSE4, 0,0xF0)
 = 4E9                      *1C T_PMAXUW equ 0x4E9
                              C insa(PMAXUD, pmaxud,    OpCls( XMM,  XMM_M128_M32, NONE ), F_660F38, 1,  no_WDS, 0x3F, 0x00, P_686 or P_SSE4, 0,0xF0)
 = 4EA                      *1C T_PMAXUD equ 0x4EA
                              C insa(PMINSB, pminsb,    OpCls( XMM,      XMM_M128, NONE ), F_660F38, 1,  no_WDS, 0x38, 0x00, P_686 or P_SSE4, 0,0xF0)
 = 4EB                      *1C T_PMINSB equ 0x4EB
                              C insa(PMINSD, pminsd,    OpCls( XMM,  XMM_M128_M32, NONE ), F_660F38, 1,  no_WDS, 0x39, 0x00, P_686 or P_SSE4, 0,0xF0)
 = 4EC                      *1C T_PMINSD equ 0x4EC
                              C insa(PMINUW, pminuw,    OpCls( XMM,      XMM_M128, NONE ), F_660F38, 1,  no_WDS, 0x3A, 0x00, P_686 or P_SSE4, 0,0xF0)
 = 4ED                      *1C T_PMINUW equ 0x4ED
                              C insa(PMINUD, pminud,    OpCls( XMM,  XMM_M128_M32, NONE ), F_660F38, 1,  no_WDS, 0x3B, 0x00, P_686 or P_SSE4, 0,0xF0)
 = 4EE                      *1C T_PMINUD equ 0x4EE
                              C insa(PMOVSXBW, pmovsxbw,OpCls( XMM,      XMM_M64,  NONE ), F_660F38, 1,  no_WDS, 0x20, 0x00, P_686 or P_SSE4, 0,0xF0)
 = 4EF                      *1C T_PMOVSXBW equ 0x4EF
                              C insa(PMOVSXBD, pmovsxbd,OpCls( XMM,      XMM_M32,  NONE ), F_660F38, 1,  no_WDS, 0x21, 0x00, P_686 or P_SSE4, 0,0xF0)
 = 4F0                      *1C T_PMOVSXBD equ 0x4F0
                              C 
                              C insa(PMOVSXBQ, pmovsxbq, OpCls( XMM, XMM_MXQDW,    NONE ), F_660F38, 1,  no_WDS, 0x22, 0x00, P_686 or P_SSE4, 0,0xF0)
 = 4F1                      *1C T_PMOVSXBQ equ 0x4F1
                              C insa(PMOVZXDQ, pmovzxdq, OpCls( XMM, XMM_MXQDW,    NONE ), F_660F38, 1,  no_WDS, 0x35, 0x00, P_686 or P_SSE4, 0,0xF0)
 = 4F2                      *1C T_PMOVZXDQ equ 0x4F2
                              C insa(PMOVZXBQ, pmovzxbq, OpCls( XMM, XMM_MXQDW,    NONE ), F_660F38, 1,  no_WDS, 0x32, 0x00, P_686 or P_SSE4, 0,0xF0)
 = 4F3                      *1C T_PMOVZXBQ equ 0x4F3
                              C 
                              C insa(PMOVSXWD, pmovsxwd,OpCls( XMM,      XMM_M64,  NONE ), F_660F38, 1,  no_WDS, 0x23, 0x00, P_686 or P_SSE4, 0,0xF0)
 = 4F4                      *1C T_PMOVSXWD equ 0x4F4
                              C insa(PMOVSXWQ, pmovsxwq,OpCls( XMM,      XMM_M32,  NONE ), F_660F38, 1,  no_WDS, 0x24, 0x00, P_686 or P_SSE4, 0,0xF0)
 = 4F5                      *1C T_PMOVSXWQ equ 0x4F5
                              C insa(PMOVSXDQ, pmovsxdq,OpCls( XMM,      XMM_M64,  NONE ), F_660F38, 1,  no_WDS, 0x25, 0x00, P_686 or P_SSE4, 0,0xF0)
 = 4F6                      *1C T_PMOVSXDQ equ 0x4F6
                              C insa(PMOVZXBW, pmovzxbw,OpCls( XMM,      XMM_M64,  NONE ), F_660F38, 1,  no_WDS, 0x30, 0x00, P_686 or P_SSE4, 0,0xF0)
 = 4F7                      *1C T_PMOVZXBW equ 0x4F7
                              C insa(PMOVZXBD, pmovzxbd,OpCls( XMM,      XMM_M32,  NONE ), F_660F38, 1,  no_WDS, 0x31, 0x00, P_686 or P_SSE4, 0,0xF0)
 = 4F8                      *1C T_PMOVZXBD equ 0x4F8
                              C insa(PMOVZXWD, pmovzxwd,OpCls( XMM,      XMM_M64,  NONE ), F_660F38, 1,  no_WDS, 0x33, 0x00, P_686 or P_SSE4, 0,0xF0)
 = 4F9                      *1C T_PMOVZXWD equ 0x4F9
                              C insa(PMOVZXWQ, pmovzxwq,OpCls( XMM,      XMM_M32,  NONE ), F_660F38, 1,  no_WDS, 0x34, 0x00, P_686 or P_SSE4, 0,0xF0)
 = 4FA                      *1C T_PMOVZXWQ equ 0x4FA
                              C insa(PMULDQ, pmuldq,    OpCls( XMM,  XMM_M128_M64, NONE ), F_660F38, 1,  no_WDS, 0x28, 0x00, P_686 or P_SSE4, 0,0xF2)
 = 4FB                      *1C T_PMULDQ equ 0x4FB
                              C insa(PMULLD, pmulld,    OpCls( XMM,  XMM_M128_M32, NONE ), F_660F38, 1,  no_WDS, 0x40, 0x00, P_686 or P_SSE4, 0,0xF0)
 = 4FC                      *1C T_PMULLD equ 0x4FC
                              C insa(PTEST, ptest,      OpCls( XMM,      XMM_M128, NONE ), F_660F38, 1,  no_WDS, 0x17, 0x00, P_686 or P_SSE4, 0,0)
 = 4FD                      *1C T_PTEST equ 0x4FD
                              C insa(ROUNDPS, roundps,  OpCls( XMM,      XMM_M128, I8_U ), F_660F3A, 1,  no_WDS, 0x08, 0x00, P_686 or P_SSE4, 0,0)
 = 4FE                      *1C T_ROUNDPS equ 0x4FE
                              C insa(ROUNDPD, roundpd,  OpCls( XMM,      XMM_M128, I8_U ), F_660F3A, 1,  no_WDS, 0x09, 0x00, P_686 or P_SSE4, 0,0)
 = 4FF                      *1C T_ROUNDPD equ 0x4FF
                              C insa(ROUNDSS, roundss,  OpCls( XMM,      XMM_M32 , I8_U ), F_660F3A, 1,  no_WDS, 0x0A, 0x00, P_686 or P_SSE4, 0,0)
 = 500                      *1C T_ROUNDSS equ 0x500
                              C insa(ROUNDSD, roundsd,  OpCls( XMM,      XMM_M64 , I8_U ), F_660F3A, 1,  no_WDS, 0x0B, 0x00, P_686 or P_SSE4, 0,0)
 = 501                      *1C T_ROUNDSD equ 0x501
                              C 
                              C ; SSE4.2
                              C 
                              C insa(CRC32, crc32,      OpCls( RGT16,    R8_M08,   NONE ), F_F20F38, 1, no_WDS, 0xF0, 0x00, P_686 or P_SSE4, 0,0)
 = 502                      *1C T_CRC32 equ 0x502
                              C insa(PCMPESTRM, pcmpestrm,OpCls( XMM,    XMM_M128, I8_U ), F_660F3A, 1, no_WDS, 0x60, 0x00, P_686 or P_SSE4, 0,0)
 = 503                      *1C T_PCMPESTRM equ 0x503
                              C insa(PCMPESTRI, pcmpestri,OpCls( XMM,    XMM_M128, I8_U ), F_660F3A, 1, no_WDS, 0x61, 0x00, P_686 or P_SSE4, 0,0)
 = 504                      *1C T_PCMPESTRI equ 0x504
                              C insa(PCMPISTRM, pcmpistrm,OpCls( XMM,    XMM_M128, I8_U ), F_660F3A, 1, no_WDS, 0x62, 0x00, P_686 or P_SSE4, 0,0)
 = 505                      *1C T_PCMPISTRM equ 0x505
                              C insa(PCMPISTRI, pcmpistri,OpCls( XMM,    XMM_M128, I8_U ), F_660F3A, 1, no_WDS, 0x63, 0x00, P_686 or P_SSE4, 0,0)
 = 506                      *1C T_PCMPISTRI equ 0x506
                              C insa(PCMPGTQ, pcmpgtq,  OpCls( XMM,      XMM_M128, NONE ), F_660F38, 1, no_WDS, 0x37, 0x00, P_686 or P_SSE4, 0,0x96)
 = 507                      *1C T_PCMPGTQ equ 0x507
                              C insa(POPCNT, popcnt,    OpCls( RGT8,     RGT8_MS,  NONE ), F_F30F,   1, no_WDS, 0xB8, 0x00, P_686 or P_SSE4, 0,0)
 = 508                      *1C T_POPCNT equ 0x508
                              C insa(RDRAND, rdrand,    OpCls( R,        NONE,     NONE ), F_0F,     0, no_WDS, 0xC7, 0x30, P_686 or P_SSE4, 0,0)
 = 509                      *1C T_RDRAND equ 0x509
                              C insa(RDSEED, rdseed,    OpCls( R,        NONE,     NONE ), F_0F,     0, no_WDS, 0xC7, 0x38, P_686 or P_SSE4, 0,0)
 = 50A                      *1C T_RDSEED equ 0x50A
                              C insa(LZCNT, lzcnt,      OpCls( RGT8,     RGT8_MS,  NONE ), F_F30F,   1, no_WDS, 0xBD, 0x00, P_686 or P_SSE4, 0,0)
 = 50B                      *1C T_LZCNT equ 0x50B
                              C insa(TZCNT, tzcnt,      OpCls( RGT8,     RGT8_MS,  NONE ), F_F30F,   1, no_WDS, 0xBC, 0x00, P_686 or P_SSE4, 0,0)
 = 50C                      *1C T_TZCNT equ 0x50C
                              C insa(INVPCID, invpcid,  OpCls( RGT8,     MS,       NONE ), F_660F38, 1, no_WDS, 0x82, 0x00, P_686 or P_SSE4, 0,0)
 = 50D                      *1C T_INVPCID equ 0x50D
                              C insa(RDPID, rdpid,      OpCls( RGT8,     NONE,     NONE ), F_F30F,   0, 0,      0xC7, 0x00, P_686,           0,0)
 = 50E                      *1C T_RDPID equ 0x50E
                              C insa(ADOX, adox,        OpCls( RGT8,     RGT8_MS,  NONE ), F_F30F,   1, no_WDS, 0x38, 0x00, P_686,           0,0)
 = 50F                      *1C T_ADOX equ 0x50F
                              C 
                              C insa(RDFSBASE, rdfsbase,OpCls( RGT8,     NONE,     NONE ), F_F30F,   0, no_WDS, 0xAE, 0x00, P_686,           0,0)
 = 510                      *1C T_RDFSBASE equ 0x510
                              C insa(RDGSBASE, rdgsbase,OpCls( RGT8,     NONE,     NONE ), F_F30F,   0, no_WDS, 0xAE, 0x08, P_686,           0,0)
 = 511                      *1C T_RDGSBASE equ 0x511
                              C insa(WRFSBASE, wrfsbase,OpCls( RGT8,     NONE,     NONE ), F_F30F,   0, no_WDS, 0xAE, 0x10, P_686,           0,0)
 = 512                      *1C T_WRFSBASE equ 0x512
                              C insa(WRGSBASE, wrgsbase,OpCls( RGT8,     NONE,     NONE ), F_F30F,   0, no_WDS, 0xAE, 0x18, P_686,           0,0)
 = 513                      *1C T_WRGSBASE equ 0x513
                              C 
                              C insa(XRSTOR, xrstor,    OpCls( M_ANY,    NONE,     NONE ), F_0F,   0,  no_WDS, 0xAE, 0x28, P_686 or P_SSE4,0,0)
 = 514                      *1C T_XRSTOR equ 0x514
                              C insa(XSAVE, xsave,      OpCls( M_ANY,    NONE,     NONE ), F_0F,   0,  no_WDS, 0xAE, 0x20, P_686 or P_SSE4,0,0)
 = 515                      *1C T_XSAVE equ 0x515
                              C insa(XSAVEOPT, xsaveopt,OpCls( M_ANY,    NONE,     NONE ), F_0F,   0,  no_WDS, 0xAE, 0x30, P_686 or P_SSE4,0,0)
 = 516                      *1C T_XSAVEOPT equ 0x516
                              C insa(XGETBV, xgetbv,    OpCls( NONE,     NONE,     NONE ), F_0F,   0,  no_WDS, 0x01, 0xD0, P_686 or P_SSE4,0,0)
 = 517                      *1C T_XGETBV equ 0x517
                              C insa(XSETBV, xsetbv,    OpCls( NONE,     NONE,     NONE ), F_0F,   0,  no_WDS, 0x01, 0xD1, P_686p or P_SSE4,0,0)
 = 518                      *1C T_XSETBV equ 0x518
                              C 
                              C insa(VMCALL,  vmcall,   OpCls( NONE,    NONE,      NONE ), F_0F,    0, 0,      0x01, 0xC1, P_686, 0,0)
 = 519                      *1C T_VMCALL equ 0x519
                              C insa(VMLAUNCH,vmlaunch, OpCls( NONE,    NONE,      NONE ), F_0F,    0, 0,      0x01, 0xC2, P_686p,0,0)
 = 51A                      *1C T_VMLAUNCH equ 0x51A
                              C insa(VMRESUME,vmresume, OpCls( NONE,    NONE,      NONE ), F_0F,    0, 0,      0x01, 0xC3, P_686p,0,0)
 = 51B                      *1C T_VMRESUME equ 0x51B
                              C insa(VMXOFF,  vmxoff,   OpCls( NONE,    NONE,      NONE ), F_0F,    0, 0,      0x01, 0xC4, P_686p,0,0)
 = 51C                      *1C T_VMXOFF equ 0x51C
                              C insa(VMPTRLD, vmptrld,  OpCls( M64,     NONE,      NONE ), F_0F,    0, no_WDS, 0xC7, 0x30, P_686p,0,0)
 = 51D                      *1C T_VMPTRLD equ 0x51D
                              C insa(VMPTRST, vmptrst,  OpCls( M64,     NONE,      NONE ), F_0F,    0, no_WDS, 0xC7, 0x38, P_686p,0,0)
 = 51E                      *1C T_VMPTRST equ 0x51E
                              C insa(VMCLEAR, vmclear,  OpCls( M64,     NONE,      NONE ), F_660F,  0, no_WDS, 0xC7, 0x30, P_686p,0,0)
 = 51F                      *1C T_VMCLEAR equ 0x51F
                              C insa(VMXON,   vmxon,    OpCls( M64,     NONE,      NONE ), F_F30F,  0, no_WDS, 0xC7, 0x30, P_686p,0,0)
 = 520                      *1C T_VMXON equ 0x520
                              C insa(VMREAD,  vmread,   OpCls( R32_M32, R32,       NONE ), F_0F,    0, no_WDS, 0x78, 0x00, P_686p,0,0)
 = 521                      *1C T_VMREAD equ 0x521
                              C insa(VMWRITE, vmwrite,  OpCls( R32,     R32_M32,   NONE ), F_0F,    1, no_WDS, 0x79, 0x00, P_686p,0,0)
 = 522                      *1C T_VMWRITE equ 0x522
                              C insa(INVEPT,  invept,   OpCls( RGT16,   M128,      NONE ), F_660F38,1, no_WDS, 0x80, 0x00, P_686p,0,0)
 = 523                      *1C T_INVEPT equ 0x523
                              C insa(INVVPID, invvpid,  OpCls( RGT16,   M128,      NONE ), F_660F38,1, no_WDS, 0x81, 0x00, P_686p,0,0)
 = 524                      *1C T_INVVPID equ 0x524
                              C 
                              C ; VBROADCASTSS is first VEX encoded instruction (VEX_START in parser.inc).
                              C 
                              C insv(VBROADCASTSS, vbroadcastss, OpCls( XMM,  XMM_M32,    NONE ), F_660F38, 1, no_WDS, 0x18, 0x00, P_686 or P_AVX, 0,0xE0, RWF_VEX or RWF_T1S, VX_NND or VX_RW0 )
 = 525                      *1C T_VBROADCASTSS equ 0x525
                              C insv(VBROADCASTSD, vbroadcastsd, OpCls( YMM,  XMM_M64,    NONE ), F_660F38, 1, no_WDS, 0x19, 0x00, P_686 or P_AVX, 0,0xE2, RWF_VEX or RWF_T1S, VX_NND )
 = 526                      *1C T_VBROADCASTSD equ 0x526
                              C insv(VBROADCASTF128, vbroadcastf128, OpCls( YMM, M128,    NONE ), F_660F38, 1, no_WDS, 0x1A, 0x00, P_686 or P_AVX, 0,0, RWF_VEX, VX_NND )
 = 527                      *1C T_VBROADCASTF128 equ 0x527
                              C insv(VBLENDVPD, vblendvpd,      OpCls( XMM,   XMM_M128,   XMM  ), F_660F3A, 1, no_WDS, 0x4B, 0x00, P_686 or P_AVX, 0,0, RWF_VEX, VX_L )
 = 528                      *1C T_VBLENDVPD equ 0x528
                              C insv(VBLENDVPS, vblendvps,      OpCls( XMM,   XMM_M128,   XMM  ), F_660F3A, 1, no_WDS, 0x4A, 0x00, P_686 or P_AVX, 0,0, RWF_VEX, VX_L or VX_RW0 )
 = 529                      *1C T_VBLENDVPS equ 0x529
                              C 
                              C insv(VINSERTF128, vinsertf128, OpCls( YMM,    XMM_M128,   I8_U ), F_660F3A,1, no_WDS, 0x18, 0x00, P_686 or P_AVX, 0,0, RWF_VEX, 0 )
 = 52A                      *1C T_VINSERTF128 equ 0x52A
                              C insv(VEXTRACTF128, vextractf128, OpCls( XMM,  YMM,        I8_U ), F_660F3A,0, no_WDS, 0x19, 0x00, P_686 or P_AVX, 0,0, RWF_VEX, VX_NND )
 = 52B                      *1C T_VEXTRACTF128 equ 0x52B
                              C insv(VMASKMOVPS, vmaskmovps, OpCls( XMM,      XMM_M128,   NONE ), F_660F38,1, no_WDS, 0x2C, 0x00, P_686 or P_AVX, 0,0, RWF_VEX, VX_L or VX_RW0 )
 = 52C                      *1C T_VMASKMOVPS equ 0x52C
                              C insv(VMASKMOVPD, vmaskmovpd, OpCls( XMM,      XMM_M128,   NONE ), F_660F38,1, no_WDS, 0x2D, 0x00, P_686 or P_AVX, 0,0, RWF_VEX, VX_L )
 = 52D                      *1C T_VMASKMOVPD equ 0x52D
                              C insv(VPBLENDVB, vpblendvb,   OpCls( XMM,      XMM_M128,   XMM  ), F_660F3A,1, no_WDS, 0x4C, 0x00, P_686 or P_AVX, 0,0, RWF_VEX, VX_L )
 = 52E                      *1C T_VPBLENDVB equ 0x52E
                              C insv(VPERMILPD, vpermilpd,   OpCls( XMM,  XMM_M128_M64,   NONE ), F_660F38,1, no_WDS, 0x0D, 0x00, P_686 or P_AVX, 0,0xE2, RWF_VEX, VX_L or VX_IMM )
 = 52F                      *1C T_VPERMILPD equ 0x52F
                              C ; bug v2.17 vpermilpd: Selection by immediate byte operand: C4 RXB.00011 0.1111.1.01 05 /r ib
                              C insv(VPERMILPS, vpermilps,   OpCls( XMM,  XMM_M128_M32,   NONE ), F_660F38,1, no_WDS, 0x0C, 0x00, P_686 or P_AVX, 0,0x80, RWF_VEX, VX_L or VX_IMM or VX_RW0 )
 = 530                      *1C T_VPERMILPS equ 0x530
                              C ; bug v2.17 vpermilps: Selection by immediate byte operand: C4 RXB.00011 0.1111.1.01 04 /r ib
                              C insv(VPERM2F128, vperm2f128, OpCls( YMM,      YMM_M256,   I8_U ), F_660F3A,1, no_WDS, 0x06, 0x00, P_686 or P_AVX, 0,0, RWF_VEX, 0 )
 = 531                      *1C T_VPERM2F128 equ 0x531
                              C insv(VTESTPS, vtestps,       OpCls( XMM,      XMM_M128,   NONE ), F_660F38,1, no_WDS, 0x0E, 0x00, P_686 or P_AVX, 0,0, RWF_VEX, VX_L or VX_NND )
 = 532                      *1C T_VTESTPS equ 0x532
                              C insv(VTESTPD, vtestpd,       OpCls( XMM,      XMM_M128,   NONE ), F_660F38,1, no_WDS, 0x0F, 0x00, P_686 or P_AVX, 0,0, RWF_VEX, VX_L or VX_NND )
 = 533                      *1C T_VTESTPD equ 0x533
                              C insv(VZEROALL, vzeroall,     OpCls( NONE,     NONE,       NONE ), F_0F,    0, no_RM,  0x77, 0x00, P_686 or P_AVX, 0,0, RWF_VEX, VX_L )
 = 534                      *1C T_VZEROALL equ 0x534
                              C insv(VZEROUPPER, vzeroupper, OpCls( NONE,     NONE,       NONE ), F_0F,    0, no_RM,  0x77, 0x00, P_686 or P_AVX, 0,0, RWF_VEX, 0 )
 = 535                      *1C T_VZEROUPPER equ 0x535
                              C 
                              C insv(VCMPPD, vcmppd,         OpCls( XMM,      XMM_M128,   I8_U ), F_660F,  1, no_WDS, 0xC2, 0x00, P_686 or P_SSE2, 0,0xF0, RWF_VEX, VX_L or VX_HALF or VX_RW1 )
 = 536                      *1C T_VCMPPD equ 0x536
                              C insv(VCMPPS, vcmpps,         OpCls( XMM,      XMM_M128,   I8_U ), F_0F,    1, no_WDS, 0xC2, 0x00, P_686 or P_SSE2, 0,0xF0, RWF_VEX, VX_L or VX_HALF or VX_RW0 )
 = 537                      *1C T_VCMPPS equ 0x537
                              C insv(VCMPSS, vcmpss,         OpCls( XMM,      XMM_M32,    I8_U ), F_F30F,  1, no_WDS, 0xC2, 0x00, P_686 or P_SSE2, 0,0xF0, RWF_VEX, VX_RW0 )
 = 538                      *1C T_VCMPSS equ 0x538
                              C insv(VCMPSD, vcmpsd,         OpCls( XMM,  XMM_M128_M64,   I8_U ), F_F20F,  1, no_WDS, 0xC2, 0x00, P_686 or P_SSE2, 0,0xF2, RWF_VEX or RWF_T1S, VX_RW1 )
 = 539                      *1C T_VCMPSD equ 0x539
                              C 
                              C avxins(CVTDQ2PD, VCVTDQ2PD, vcvtdq2pd,     0, VX_L or VX_NND or VX_HALF or VX_RW0 )
 = 53A                      *1C T_VCVTDQ2PD equ 0x53A
                              C avxins(CVTPD2DQ, VCVTPD2DQ, vcvtpd2dq,     0, VX_L or VX_NND or VX_RW1 )
 = 53B                      *1C T_VCVTPD2DQ equ 0x53B
                              C avxins(CVTTPD2DQ,VCVTTPD2DQ, vcvttpd2dq,   0, VX_L or VX_NND or VX_RW1 )
 = 53C                      *1C T_VCVTTPD2DQ equ 0x53C
                              C avxins(CVTPD2PS, VCVTPD2PS, vcvtpd2ps,     0, VX_L or VX_NND or VX_RW1 )
 = 53D                      *1C T_VCVTPD2PS equ 0x53D
                              C avxins(MOVDDUP,  VMOVDDUP, vmovddup,       0, VX_L or VX_NND or VX_RW1 )
 = 53E                      *1C T_VMOVDDUP equ 0x53E
                              C 
                              C avxins(ADDPD,    VADDPD,    vaddpd,        0, VX_L or VX_RW1 )
 = 53F                      *1C T_VADDPD equ 0x53F
                              C avxins(ADDPS,    VADDPS,    vaddps,        0, VX_L or VX_RW0 )
 = 540                      *1C T_VADDPS equ 0x540
                              C avxins(ADDSD,    VADDSD,    vaddsd,        RWF_T1S, VX_RW1 )
 = 541                      *1C T_VADDSD equ 0x541
                              C avxins(ADDSS,    VADDSS,    vaddss,        RWF_T1S, VX_RW0 )
 = 542                      *1C T_VADDSS equ 0x542
                              C avxins(DIVPD,    VDIVPD,    vdivpd,        0, VX_L or VX_RW1 )
 = 543                      *1C T_VDIVPD equ 0x543
                              C avxins(DIVPS,    VDIVPS,    vdivps,        0, VX_L or VX_RW0 )
 = 544                      *1C T_VDIVPS equ 0x544
                              C avxins(DIVSD,    VDIVSD,    vdivsd,        0, VX_RW1 )
 = 545                      *1C T_VDIVSD equ 0x545
                              C avxins(DIVSS,    VDIVSS,    vdivss,        0, VX_RW0 )
 = 546                      *1C T_VDIVSS equ 0x546
                              C avxins(MAXPD,    VMAXPD,    vmaxpd,        0, VX_L or VX_RW1 )
 = 547                      *1C T_VMAXPD equ 0x547
                              C avxins(MAXPS,    VMAXPS,    vmaxps,        0, VX_L or VX_RW0 )
 = 548                      *1C T_VMAXPS equ 0x548
                              C avxins(MAXSD,    VMAXSD,    vmaxsd,        0, 0 )
 = 549                      *1C T_VMAXSD equ 0x549
                              C avxins(MAXSS,    VMAXSS,    vmaxss,        0, VX_RW0 )
 = 54A                      *1C T_VMAXSS equ 0x54A
                              C avxins(MINPD,    VMINPD,    vminpd,        0, VX_L or VX_RW1 )
 = 54B                      *1C T_VMINPD equ 0x54B
                              C avxins(MINPS,    VMINPS,    vminps,        0, VX_L or VX_RW0 )
 = 54C                      *1C T_VMINPS equ 0x54C
                              C avxins(MINSD,    VMINSD,    vminsd,        0, 0 )
 = 54D                      *1C T_VMINSD equ 0x54D
                              C avxins(MINSS,    VMINSS,    vminss,        0, VX_RW0 )
 = 54E                      *1C T_VMINSS equ 0x54E
                              C avxins(MULPD,    VMULPD,    vmulpd,        0, VX_L or VX_RW1 )
 = 54F                      *1C T_VMULPD equ 0x54F
                              C avxins(MULPS,    VMULPS,    vmulps,        0, VX_L or VX_RW0 )
 = 550                      *1C T_VMULPS equ 0x550
                              C avxins(MULSD,    VMULSD,    vmulsd,        0, 0 )
 = 551                      *1C T_VMULSD equ 0x551
                              C avxins(MULSS,    VMULSS,    vmulss,        0, VX_RW0 )
 = 552                      *1C T_VMULSS equ 0x552
                              C avxins(SQRTPD,   VSQRTPD,   vsqrtpd,       0, VX_L or VX_RW1 or VX_NND )
 = 553                      *1C T_VSQRTPD equ 0x553
                              C avxins(SQRTPS,   VSQRTPS,   vsqrtps,       0, VX_L or VX_NND or VX_RW0 )
 = 554                      *1C T_VSQRTPS equ 0x554
                              C avxins(SQRTSD,   VSQRTSD,   vsqrtsd,       0, 0 )
 = 555                      *1C T_VSQRTSD equ 0x555
                              C avxins(SQRTSS,   VSQRTSS,   vsqrtss,       0, VX_RW0 )
 = 556                      *1C T_VSQRTSS equ 0x556
                              C avxins(SUBPD,    VSUBPD,    vsubpd,        0, VX_L or VX_RW1 )
 = 557                      *1C T_VSUBPD equ 0x557
                              C avxins(SUBPS,    VSUBPS,    vsubps,        0, VX_L or VX_RW0 )
 = 558                      *1C T_VSUBPS equ 0x558
                              C avxins(SUBSD,    VSUBSD,    vsubsd,        0, 0 )
 = 559                      *1C T_VSUBSD equ 0x559
                              C avxins(SUBSS,    VSUBSS,    vsubss,        0, VX_RW0 )
 = 55A                      *1C T_VSUBSS equ 0x55A
                              C avxins(ANDPD,    VANDPD,    vandpd,        0, VX_L or VX_RW1 )
 = 55B                      *1C T_VANDPD equ 0x55B
                              C avxins(ANDPS,    VANDPS,    vandps,        0, VX_L or VX_RW0 )
 = 55C                      *1C T_VANDPS equ 0x55C
                              C avxins(ANDNPD,   VANDNPD,   vandnpd,       0, VX_L or VX_RW1 )
 = 55D                      *1C T_VANDNPD equ 0x55D
                              C avxins(ANDNPS,   VANDNPS,   vandnps,       0, VX_L or VX_RW0 )
 = 55E                      *1C T_VANDNPS equ 0x55E
                              C avxins(ORPD,     VORPD,     vorpd,         0, VX_L )
 = 55F                      *1C T_VORPD equ 0x55F
                              C avxins(ORPS,     VORPS,     vorps,         0, VX_L or VX_RW0 )
 = 560                      *1C T_VORPS equ 0x560
                              C avxins(COMISD,   VCOMISD,   vcomisd,       0, VX_NND or VX_RW1 )
 = 561                      *1C T_VCOMISD equ 0x561
                              C avxins(COMISS,   VCOMISS,   vcomiss,       RWF_T1S, VX_NND or VX_RW0 )
 = 562                      *1C T_VCOMISS equ 0x562
                              C avxins(XORPD,    VXORPD,    vxorpd,        0, VX_L or VX_RW1 )
 = 563                      *1C T_VXORPD equ 0x563
                              C avxins(XORPS,    VXORPS,    vxorps,        0, VX_L or VX_RW0 )
 = 564                      *1C T_VXORPS equ 0x564
                              C 
                              C avxins(CVTDQ2PS, VCVTDQ2PS, vcvtdq2ps,     0, VX_L or VX_NND or VX_HALF or VX_RW0 )
 = 565                      *1C T_VCVTDQ2PS equ 0x565
                              C avxins(CVTPS2DQ, VCVTPS2DQ, vcvtps2dq,     0, VX_L or VX_NND or VX_RW0 )
 = 566                      *1C T_VCVTPS2DQ equ 0x566
                              C avxins(CVTTPS2DQ,VCVTTPS2DQ,vcvttps2dq,    0, VX_L or VX_NND or VX_RW0 )
 = 567                      *1C T_VCVTTPS2DQ equ 0x567
                              C avxins(CVTPS2PD, VCVTPS2PD, vcvtps2pd,     0, VX_L or VX_NND or VX_HALF or VX_RW0 )
 = 568                      *1C T_VCVTPS2PD equ 0x568
                              C avxins(CVTSD2SI, VCVTSD2SI, vcvtsd2si,     0, VX_NND or VX_RW1 or VX_RW0 )
 = 569                      *1C T_VCVTSD2SI equ 0x569
                              C avxins(CVTTSD2SI,VCVTTSD2SI,vcvttsd2si,    0, VX_NND or VX_RW0 )
 = 56A                      *1C T_VCVTTSD2SI equ 0x56A
                              C avxins(CVTSD2SS, VCVTSD2SS, vcvtsd2ss,     RWF_T1S, VX_RW1 )
 = 56B                      *1C T_VCVTSD2SS equ 0x56B
                              C avxins(CVTSI2SD, VCVTSI2SD, vcvtsi2sd,     0, VX_RW1 or VX_RW0 )
 = 56C                      *1C T_VCVTSI2SD equ 0x56C
                              C avxins(CVTSI2SS, VCVTSI2SS, vcvtsi2ss,     RWF_T1S, VX_RW0 )
 = 56D                      *1C T_VCVTSI2SS equ 0x56D
                              C avxins(CVTSS2SD, VCVTSS2SD, vcvtss2sd,     0, VX_RW0 )
 = 56E                      *1C T_VCVTSS2SD equ 0x56E
                              C avxins(CVTSS2SI, VCVTSS2SI, vcvtss2si,     0, VX_NND or VX_RW0 )
 = 56F                      *1C T_VCVTSS2SI equ 0x56F
                              C avxins(CVTTSS2SI,VCVTTSS2SI,vcvttss2si,    0, VX_NND or VX_RW0 )
 = 570                      *1C T_VCVTTSS2SI equ 0x570
                              C 
                              C avxins(ADDSUBPD, VADDSUBPD, vaddsubpd,     0, VX_L )
 = 571                      *1C T_VADDSUBPD equ 0x571
                              C avxins(ADDSUBPS, VADDSUBPS, vaddsubps,     0, VX_L )
 = 572                      *1C T_VADDSUBPS equ 0x572
                              C avxins(BLENDPD , VBLENDPD , vblendpd ,     0, VX_L )
 = 573                      *1C T_VBLENDPD equ 0x573
                              C avxins(BLENDPS , VBLENDPS , vblendps ,     0, VX_L )
 = 574                      *1C T_VBLENDPS equ 0x574
                              C avxins(DPPD    , VDPPD    , vdppd    ,     0, 0 )
 = 575                      *1C T_VDPPD equ 0x575
                              C avxins(DPPS    , VDPPS    , vdpps    ,     0, VX_L )
 = 576                      *1C T_VDPPS equ 0x576
                              C avxins(EXTRACTPS,VEXTRACTPS,vextractps,    RWF_T1S, VX_NND or VX_RW0 )
 = 577                      *1C T_VEXTRACTPS equ 0x577
                              C avxins(HADDPD  , VHADDPD  , vhaddpd  ,     0, VX_L )
 = 578                      *1C T_VHADDPD equ 0x578
                              C avxins(HADDPS  , VHADDPS  , vhaddps  ,     0, VX_L )
 = 579                      *1C T_VHADDPS equ 0x579
                              C avxins(HSUBPD  , VHSUBPD  , vhsubpd  ,     0, VX_L )
 = 57A                      *1C T_VHSUBPD equ 0x57A
                              C avxins(HSUBPS  , VHSUBPS  , vhsubps  ,     0, VX_L )
 = 57B                      *1C T_VHSUBPS equ 0x57B
                              C avxins(INSERTPS, VINSERTPS, vinsertps,     0, VX_RW0 )
 = 57C                      *1C T_VINSERTPS equ 0x57C
                              C avxins(LDDQU   , VLDDQU   , vlddqu   ,     0, VX_L or VX_NND )
 = 57D                      *1C T_VLDDQU equ 0x57D
                              C avxins(LDMXCSR , VLDMXCSR , vldmxcsr ,     0, 0 )
 = 57E                      *1C T_VLDMXCSR equ 0x57E
                              C avxins(STMXCSR , VSTMXCSR , vstmxcsr ,     0, 0 )
 = 57F                      *1C T_VSTMXCSR equ 0x57F
                              C 
                              C avxins(MASKMOVDQU,VMASKMOVDQU,vmaskmovdqu,  0, VX_NND )
 = 580                      *1C T_VMASKMOVDQU equ 0x580
                              C avxins(MOVAPD  , VMOVAPD  , vmovapd  ,     0, VX_L or VX_NND or VX_RW1 )
 = 581                      *1C T_VMOVAPD equ 0x581
                              C avxins(MOVAPS  , VMOVAPS  , vmovaps  ,     0, VX_L or VX_NND or VX_RW0 )
 = 582                      *1C T_VMOVAPS equ 0x582
                              C avxins(MOVD    , VMOVD    , vmovd    ,     0, VX_NND or VX_RW0 )
 = 583                      *1C T_VMOVD equ 0x583
                              C 
                              C avxins(MOVQ    , VMOVQ    , vmovq    ,     RWF_T1S, VX_NND or VX_RW1 )
 = 584                      *1C T_VMOVQ equ 0x584
                              C 
                              C avxins(MOVDQA  , VMOVDQA  , vmovdqa  ,     0, VX_L or VX_NND )
 = 585                      *1C T_VMOVDQA equ 0x585
                              C avxins(MOVDQU  , VMOVDQU  , vmovdqu  ,     0, VX_L or VX_NND )
 = 586                      *1C T_VMOVDQU equ 0x586
                              C avxins(MOVHLPS , VMOVHLPS , vmovhlps ,     0, VX_RW0 )
 = 587                      *1C T_VMOVHLPS equ 0x587
                              C avxins(MOVLHPS , VMOVLHPS , vmovlhps ,     0, VX_RW0 )
 = 588                      *1C T_VMOVLHPS equ 0x588
                              C avxins(MOVHPD  , VMOVHPD  , vmovhpd  ,     0, VX_NMEM or VX_RW1 )
 = 589                      *1C T_VMOVHPD equ 0x589
                              C avxins(MOVHPS  , VMOVHPS  , vmovhps  ,     0, VX_NMEM or VX_RW0 )
 = 58A                      *1C T_VMOVHPS equ 0x58A
                              C avxins(MOVLPD  , VMOVLPD  , vmovlpd  ,     0, VX_NMEM or VX_RW1 )
 = 58B                      *1C T_VMOVLPD equ 0x58B
                              C avxins(MOVLPS  , VMOVLPS  , vmovlps  ,     0, VX_NMEM or VX_RW0 )
 = 58C                      *1C T_VMOVLPS equ 0x58C
                              C avxins(MOVSD   , VMOVSD   , vmovsd   ,     0, VX_NMEM or VX_RW1 )
 = 58D                      *1C T_VMOVSD equ 0x58D
                              C avxins(MOVSS   , VMOVSS   , vmovss   ,     0, VX_NMEM or VX_RW0 )
 = 58E                      *1C T_VMOVSS equ 0x58E
                              C avxins(MOVNTDQ , VMOVNTDQ , vmovntdq ,     0, VX_L or VX_NND or VX_RW0 )
 = 58F                      *1C T_VMOVNTDQ equ 0x58F
                              C avxins(MOVNTDQA, VMOVNTDQA, vmovntdqa,     0, VX_L or VX_NND or VX_RW0 )
 = 590                      *1C T_VMOVNTDQA equ 0x590
                              C avxins(MOVNTPD , VMOVNTPD , vmovntpd ,     0, VX_L or VX_NND or VX_RW1 )
 = 591                      *1C T_VMOVNTPD equ 0x591
                              C avxins(MOVNTPS , VMOVNTPS , vmovntps ,     0, VX_L or VX_NND or VX_RW0 )
 = 592                      *1C T_VMOVNTPS equ 0x592
                              C avxins(MOVSHDUP, VMOVSHDUP, vmovshdup,     0, VX_L or VX_NND or VX_RW0 )
 = 593                      *1C T_VMOVSHDUP equ 0x593
                              C avxins(MOVSLDUP, VMOVSLDUP, vmovsldup,     0, VX_L or VX_NND or VX_RW0 )
 = 594                      *1C T_VMOVSLDUP equ 0x594
                              C avxins(MOVUPD  , VMOVUPD  , vmovupd  ,     0, VX_L or VX_NND or VX_RW1 )
 = 595                      *1C T_VMOVUPD equ 0x595
                              C avxins(MOVUPS  , VMOVUPS  , vmovups  ,     0, VX_L or VX_NND or VX_RW0 )
 = 596                      *1C T_VMOVUPS equ 0x596
                              C 
                              C avxins(MPSADBW , VMPSADBW , vmpsadbw ,     0, VX_L )
 = 597                      *1C T_VMPSADBW equ 0x597
                              C 
                              C avxins(PABSB   , VPABSB   , vpabsb   ,     0, VX_L or VX_NND or VX_RW0 )
 = 598                      *1C T_VPABSB equ 0x598
                              C avxins(PABSW   , VPABSW   , vpabsw   ,     0, VX_L or VX_NND or VX_RW0 )
 = 599                      *1C T_VPABSW equ 0x599
                              C avxins(PABSD   , VPABSD   , vpabsd   ,     0, VX_L or VX_NND or VX_RW0 )
 = 59A                      *1C T_VPABSD equ 0x59A
                              C 
                              C avxins(PACKSSWB, VPACKSSWB, vpacksswb,     0, VX_L or VX_RW0 )
 = 59B                      *1C T_VPACKSSWB equ 0x59B
                              C avxins(PACKSSDW, VPACKSSDW, vpackssdw,     0, VX_L or VX_RW0 )
 = 59C                      *1C T_VPACKSSDW equ 0x59C
                              C avxins(PACKUSWB, VPACKUSWB, vpackuswb,     0, VX_L or VX_RW0 )
 = 59D                      *1C T_VPACKUSWB equ 0x59D
                              C avxins(PACKUSDW, VPACKUSDW, vpackusdw,     0, VX_L or VX_RW0 )
 = 59E                      *1C T_VPACKUSDW equ 0x59E
                              C avxins(PADDB   , VPADDB   , vpaddb   ,     0, VX_RW0 )
 = 59F                      *1C T_VPADDB equ 0x59F
                              C avxins(PADDW   , VPADDW   , vpaddw   ,     0, VX_L or VX_RW0 )
 = 5A0                      *1C T_VPADDW equ 0x5A0
                              C avxins(PADDD   , VPADDD   , vpaddd   ,     0, VX_L or VX_RW0 )
 = 5A1                      *1C T_VPADDD equ 0x5A1
                              C avxins(PADDQ   , VPADDQ   , vpaddq   ,     0, VX_L or VX_RW1 )
 = 5A2                      *1C T_VPADDQ equ 0x5A2
                              C avxins(PADDSB  , VPADDSB  , vpaddsb  ,     0, VX_L or VX_RW0 )
 = 5A3                      *1C T_VPADDSB equ 0x5A3
                              C avxins(PADDSW  , VPADDSW  , vpaddsw  ,     0, VX_L or VX_RW0 )
 = 5A4                      *1C T_VPADDSW equ 0x5A4
                              C avxins(PADDUSB , VPADDUSB , vpaddusb ,     0, VX_RW0 )
 = 5A5                      *1C T_VPADDUSB equ 0x5A5
                              C avxins(PADDUSW , VPADDUSW , vpaddusw ,     0, VX_L or VX_RW0 )
 = 5A6                      *1C T_VPADDUSW equ 0x5A6
                              C avxins(PALIGNR , VPALIGNR , vpalignr ,     0, VX_L or VX_RW0  )
 = 5A7                      *1C T_VPALIGNR equ 0x5A7
                              C avxins(PAND    , VPAND    , vpand    ,     0, VX_L )
 = 5A8                      *1C T_VPAND equ 0x5A8
                              C avxins(PANDN   , VPANDN   , vpandn   ,     0, VX_L )
 = 5A9                      *1C T_VPANDN equ 0x5A9
                              C avxins(PAVGB   , VPAVGB   , vpavgb   ,     0, VX_L or VX_RW0 )
 = 5AA                      *1C T_VPAVGB equ 0x5AA
                              C avxins(PAVGW   , VPAVGW   , vpavgw   ,     0, VX_L or VX_RW0 )
 = 5AB                      *1C T_VPAVGW equ 0x5AB
                              C avxins(PBLENDW , VPBLENDW , vpblendw ,     0, VX_L )
 = 5AC                      *1C T_VPBLENDW equ 0x5AC
                              C avxins(PCMPESTRI,VPCMPESTRI,vpcmpestri,    0, VX_NND )
 = 5AD                      *1C T_VPCMPESTRI equ 0x5AD
                              C avxins(PCMPESTRM,VPCMPESTRM,vpcmpestrm,    0, VX_NND )
 = 5AE                      *1C T_VPCMPESTRM equ 0x5AE
                              C avxins(PCMPISTRI,VPCMPISTRI,vpcmpistri,    0, VX_NND )
 = 5AF                      *1C T_VPCMPISTRI equ 0x5AF
                              C avxins(PCMPISTRM,VPCMPISTRM,vpcmpistrm,    0, VX_NND )
 = 5B0                      *1C T_VPCMPISTRM equ 0x5B0
                              C avxins(PCMPEQB  ,VPCMPEQB  ,vpcmpeqb  ,    0, VX_L or VX_RW0 )
 = 5B1                      *1C T_VPCMPEQB equ 0x5B1
                              C avxins(PCMPEQW  ,VPCMPEQW  ,vpcmpeqw  ,    0, VX_L or VX_RW0 )
 = 5B2                      *1C T_VPCMPEQW equ 0x5B2
                              C avxins(PCMPEQD  ,VPCMPEQD  ,vpcmpeqd  ,    0, VX_L or VX_RW0 )
 = 5B3                      *1C T_VPCMPEQD equ 0x5B3
                              C avxins(PCMPEQQ  ,VPCMPEQQ  ,vpcmpeqq  ,    0, VX_L)
 = 5B4                      *1C T_VPCMPEQQ equ 0x5B4
                              C avxins(PCMPGTB  ,VPCMPGTB  ,vpcmpgtb  ,    0, VX_L or VX_RW0 )
 = 5B5                      *1C T_VPCMPGTB equ 0x5B5
                              C avxins(PCMPGTW  ,VPCMPGTW  ,vpcmpgtw  ,    0, VX_L or VX_RW0 )
 = 5B6                      *1C T_VPCMPGTW equ 0x5B6
                              C avxins(PCMPGTD  ,VPCMPGTD  ,vpcmpgtd  ,    0, VX_L or VX_RW0 )
 = 5B7                      *1C T_VPCMPGTD equ 0x5B7
                              C avxins(PCMPGTQ  ,VPCMPGTQ  ,vpcmpgtq  ,    0, VX_L )
 = 5B8                      *1C T_VPCMPGTQ equ 0x5B8
                              C avxins(PEXTRB   ,VPEXTRB   ,vpextrb   ,    0, VX_L or VX_NND or VX_RW0 )
 = 5B9                      *1C T_VPEXTRB equ 0x5B9
                              C avxins(PEXTRW   ,VPEXTRW   ,vpextrw   ,    0, VX_L or VX_NND or VX_RW0 )
 = 5BA                      *1C T_VPEXTRW equ 0x5BA
                              C avxins(PEXTRD   ,VPEXTRD   ,vpextrd   ,    0, VX_L or VX_NND or VX_RW0 )
 = 5BB                      *1C T_VPEXTRD equ 0x5BB
                              C avxins(PINSRB   ,VPINSRB   ,vpinsrb   ,    0, VX_L or VX_RW0 )
 = 5BC                      *1C T_VPINSRB equ 0x5BC
                              C avxins(PINSRW   ,VPINSRW   ,vpinsrw   ,    0, VX_L or VX_RW0 )
 = 5BD                      *1C T_VPINSRW equ 0x5BD
                              C avxins(PINSRD   ,VPINSRD   ,vpinsrd   ,    0, VX_L or VX_RW0 )
 = 5BE                      *1C T_VPINSRD equ 0x5BE
                              C 
                              C avxins(PCLMULQDQ,VPCLMULQDQ,vpclmulqdq,    0, VX_RW0 )
 = 5BF                      *1C T_VPCLMULQDQ equ 0x5BF
                              C avxins(AESDECLAST,VAESDECLAST,vaesdeclast,  0, VX_RW0 )
 = 5C0                      *1C T_VAESDECLAST equ 0x5C0
                              C avxins(AESDEC   ,VAESDEC   ,vaesdec   ,    0, VX_RW0 )
 = 5C1                      *1C T_VAESDEC equ 0x5C1
                              C avxins(AESENC   ,VAESENC   ,vaesenc   ,    0, VX_RW0 )
 = 5C2                      *1C T_VAESENC equ 0x5C2
                              C avxins(AESENCLAST,VAESENCLAST,vaesenclast,  0, VX_RW0 )
 = 5C3                      *1C T_VAESENCLAST equ 0x5C3
                              C avxins(AESIMC   ,VAESIMC   ,vaesimc   ,    0, VX_NND or VX_RW0 )
 = 5C4                      *1C T_VAESIMC equ 0x5C4
                              C avxins(AESKEYGENASSIST,VAESKEYGENASSIST,vaeskeygenassist, 0, VX_NND or VX_RW0 )
 = 5C5                      *1C T_VAESKEYGENASSIST equ 0x5C5
                              C 
                              C avxins(PEXTRQ   ,VPEXTRQ   ,vpextrq   ,    0, VX_NND or VX_RW1 )
 = 5C6                      *1C T_VPEXTRQ equ 0x5C6
                              C avxins(PINSRQ   ,VPINSRQ   ,vpinsrq   ,    0, VX_RW1 )
 = 5C7                      *1C T_VPINSRQ equ 0x5C7
                              C 
                              C avxins(PHADDW   ,VPHADDW   ,vphaddw   ,    0, VX_L )
 = 5C8                      *1C T_VPHADDW equ 0x5C8
                              C avxins(PHADDD   ,VPHADDD   ,vphaddd   ,    0, VX_L )
 = 5C9                      *1C T_VPHADDD equ 0x5C9
                              C avxins(PHADDSW  ,VPHADDSW  ,vphaddsw  ,    0, VX_L )
 = 5CA                      *1C T_VPHADDSW equ 0x5CA
                              C avxins(PHMINPOSUW,VPHMINPOSUW,vphminposuw,  0, VX_NND )
 = 5CB                      *1C T_VPHMINPOSUW equ 0x5CB
                              C avxins(PHSUBW   ,VPHSUBW   ,vphsubw   ,    0, VX_L )
 = 5CC                      *1C T_VPHSUBW equ 0x5CC
                              C avxins(PHSUBD   ,VPHSUBD   ,vphsubd   ,    0, VX_L )
 = 5CD                      *1C T_VPHSUBD equ 0x5CD
                              C avxins(PHSUBSW  ,VPHSUBSW  ,vphsubsw  ,    0, VX_L )
 = 5CE                      *1C T_VPHSUBSW equ 0x5CE
                              C avxins(PMADDWD  ,VPMADDWD  ,vpmaddwd  ,    0, VX_L or VX_RW0 )
 = 5CF                      *1C T_VPMADDWD equ 0x5CF
                              C avxins(PMADDUBSW,VPMADDUBSW,vpmaddubsw,    0, VX_L or VX_RW0 )
 = 5D0                      *1C T_VPMADDUBSW equ 0x5D0
                              C avxins(PMAXSB   ,VPMAXSB   ,vpmaxsb   ,    0, VX_L or VX_RW0 )
 = 5D1                      *1C T_VPMAXSB equ 0x5D1
                              C avxins(PMAXSW   ,VPMAXSW   ,vpmaxsw   ,    0, VX_L or VX_RW0 )
 = 5D2                      *1C T_VPMAXSW equ 0x5D2
                              C avxins(PMAXSD   ,VPMAXSD   ,vpmaxsd   ,    0, VX_L or VX_RW0 )
 = 5D3                      *1C T_VPMAXSD equ 0x5D3
                              C avxins(PMAXUB   ,VPMAXUB   ,vpmaxub   ,    0, VX_L or VX_RW0 )
 = 5D4                      *1C T_VPMAXUB equ 0x5D4
                              C avxins(PMAXUW   ,VPMAXUW   ,vpmaxuw   ,    0, VX_L or VX_RW0 )
 = 5D5                      *1C T_VPMAXUW equ 0x5D5
                              C avxins(PMAXUD   ,VPMAXUD   ,vpmaxud   ,    0, VX_L or VX_RW0 )
 = 5D6                      *1C T_VPMAXUD equ 0x5D6
                              C avxins(PMINSB   ,VPMINSB   ,vpminsb   ,    0, VX_L or VX_RW0 )
 = 5D7                      *1C T_VPMINSB equ 0x5D7
                              C avxins(PMINSW   ,VPMINSW   ,vpminsw   ,    0, VX_L or VX_RW0 )
 = 5D8                      *1C T_VPMINSW equ 0x5D8
                              C avxins(PMINSD   ,VPMINSD   ,vpminsd   ,    0, VX_L or VX_RW0 )
 = 5D9                      *1C T_VPMINSD equ 0x5D9
                              C avxins(PMINUB   ,VPMINUB   ,vpminub   ,    0, VX_L or VX_RW0 )
 = 5DA                      *1C T_VPMINUB equ 0x5DA
                              C avxins(PMINUW   ,VPMINUW   ,vpminuw   ,    0, VX_L or VX_RW0 )
 = 5DB                      *1C T_VPMINUW equ 0x5DB
                              C avxins(PMINUD   ,VPMINUD   ,vpminud   ,    0, VX_L or VX_RW0 )
 = 5DC                      *1C T_VPMINUD equ 0x5DC
                              C avxins(PMOVMSKB ,VPMOVMSKB ,vpmovmskb ,    0, VX_L or VX_NND )
 = 5DD                      *1C T_VPMOVMSKB equ 0x5DD
                              C avxins(PMOVSXBW ,VPMOVSXBW ,vpmovsxbw ,    0, VX_L or VX_NND or VX_HALF or VX_RW0 )
 = 5DE                      *1C T_VPMOVSXBW equ 0x5DE
                              C avxins(PMOVSXBD ,VPMOVSXBD ,vpmovsxbd ,    0, VX_L or VX_NND or VX_HALF or VX_RW0 )
 = 5DF                      *1C T_VPMOVSXBD equ 0x5DF
                              C avxins(PMOVSXBQ ,VPMOVSXBQ ,vpmovsxbq ,    0, VX_L or VX_NND or VX_HALF or VX_RW0 )
 = 5E0                      *1C T_VPMOVSXBQ equ 0x5E0
                              C avxins(PMOVSXWD ,VPMOVSXWD ,vpmovsxwd ,    0, VX_L or VX_NND or VX_HALF or VX_RW0 )
 = 5E1                      *1C T_VPMOVSXWD equ 0x5E1
                              C avxins(PMOVSXWQ ,VPMOVSXWQ ,vpmovsxwq ,    0, VX_L or VX_NND or VX_HALF or VX_RW0 )
 = 5E2                      *1C T_VPMOVSXWQ equ 0x5E2
                              C avxins(PMOVSXDQ ,VPMOVSXDQ ,vpmovsxdq ,    0, VX_L or VX_NND or VX_HALF or VX_RW0 )
 = 5E3                      *1C T_VPMOVSXDQ equ 0x5E3
                              C avxins(PMOVZXBW ,VPMOVZXBW ,vpmovzxbw ,    0, VX_L or VX_NND or VX_HALF or VX_RW0 )
 = 5E4                      *1C T_VPMOVZXBW equ 0x5E4
                              C avxins(PMOVZXBD ,VPMOVZXBD ,vpmovzxbd ,    0, VX_L or VX_NND or VX_HALF or VX_RW0 )
 = 5E5                      *1C T_VPMOVZXBD equ 0x5E5
                              C avxins(PMOVZXBQ ,VPMOVZXBQ ,vpmovzxbq ,    0, VX_L or VX_NND or VX_HALF or VX_RW0 )
 = 5E6                      *1C T_VPMOVZXBQ equ 0x5E6
                              C avxins(PMOVZXWD ,VPMOVZXWD ,vpmovzxwd ,    0, VX_L or VX_NND or VX_HALF or VX_RW0 )
 = 5E7                      *1C T_VPMOVZXWD equ 0x5E7
                              C avxins(PMOVZXWQ ,VPMOVZXWQ ,vpmovzxwq ,    0, VX_L or VX_NND or VX_HALF or VX_RW0 )
 = 5E8                      *1C T_VPMOVZXWQ equ 0x5E8
                              C avxins(PMOVZXDQ ,VPMOVZXDQ ,vpmovzxdq ,    0, VX_L or VX_NND or VX_HALF or VX_RW0 )
 = 5E9                      *1C T_VPMOVZXDQ equ 0x5E9
                              C avxins(PMULHUW  ,VPMULHUW  ,vpmulhuw  ,    0, VX_L )
 = 5EA                      *1C T_VPMULHUW equ 0x5EA
                              C avxins(PMULHRSW ,VPMULHRSW ,vpmulhrsw ,    0, VX_L or VX_RW0 )
 = 5EB                      *1C T_VPMULHRSW equ 0x5EB
                              C avxins(PMULHW   ,VPMULHW   ,vpmulhw   ,    0, VX_L or VX_RW0 )
 = 5EC                      *1C T_VPMULHW equ 0x5EC
                              C avxins(PMULLW   ,VPMULLW   ,vpmullw   ,    0, VX_L or VX_RW0 )
 = 5ED                      *1C T_VPMULLW equ 0x5ED
                              C avxins(PMULLD   ,VPMULLD   ,vpmulld   ,    0, VX_L or VX_RW0 )
 = 5EE                      *1C T_VPMULLD equ 0x5EE
                              C avxins(PMULUDQ  ,VPMULUDQ  ,vpmuludq  ,    0, VX_L )
 = 5EF                      *1C T_VPMULUDQ equ 0x5EF
                              C avxins(PMULDQ   ,VPMULDQ   ,vpmuldq   ,    0, VX_L )
 = 5F0                      *1C T_VPMULDQ equ 0x5F0
                              C avxins(POR      ,VPOR      ,vpor      ,    0, VX_L )
 = 5F1                      *1C T_VPOR equ 0x5F1
                              C avxins(PSADBW   ,VPSADBW   ,vpsadbw   ,    0, VX_L or VX_RW0 )
 = 5F2                      *1C T_VPSADBW equ 0x5F2
                              C avxins(PSHUFB   ,VPSHUFB   ,vpshufb   ,    0, VX_L or VX_RW0 )
 = 5F3                      *1C T_VPSHUFB equ 0x5F3
                              C avxins(PSHUFD   ,VPSHUFD   ,vpshufd   ,    0, VX_L or VX_NND or VX_RW0 )
 = 5F4                      *1C T_VPSHUFD equ 0x5F4
                              C avxins(PSHUFHW  ,VPSHUFHW  ,vpshufhw  ,    0, VX_L or VX_NND or VX_RW0 )
 = 5F5                      *1C T_VPSHUFHW equ 0x5F5
                              C avxins(PSHUFLW  ,VPSHUFLW  ,vpshuflw  ,    0, VX_L or VX_NND or VX_RW0 )
 = 5F6                      *1C T_VPSHUFLW equ 0x5F6
                              C avxins(PSIGNB   ,VPSIGNB   ,vpsignb   ,    0, VX_L )
 = 5F7                      *1C T_VPSIGNB equ 0x5F7
                              C avxins(PSIGNW   ,VPSIGNW   ,vpsignw   ,    0, VX_L )
 = 5F8                      *1C T_VPSIGNW equ 0x5F8
                              C avxins(PSIGND   ,VPSIGND   ,vpsignd   ,    0, VX_L )
 = 5F9                      *1C T_VPSIGND equ 0x5F9
                              C avxins(PSLLDQ   ,VPSLLDQ   ,vpslldq   ,    0, VX_L or VX_HALF or VX_DST or VX_RW0 )
 = 5FA                      *1C T_VPSLLDQ equ 0x5FA
                              C avxins(PSRLDQ   ,VPSRLDQ   ,vpsrldq   ,    0, VX_L or VX_HALF or VX_DST or VX_RW0 )
 = 5FB                      *1C T_VPSRLDQ equ 0x5FB
                              C avxins(PSLLW    ,VPSLLW    ,vpsllw    ,    RWF_M128, VX_L or VX_HALF or VX_DST or VX_RW0 )
 = 5FC                      *1C T_VPSLLW equ 0x5FC
                              C avxins(PSLLD    ,VPSLLD    ,vpslld    ,    RWF_M128, VX_L or VX_HALF or VX_DST or VX_RW0 )
 = 5FD                      *1C T_VPSLLD equ 0x5FD
                              C avxins(PSLLQ    ,VPSLLQ    ,vpsllq    ,    RWF_M128, VX_L or VX_HALF or VX_DST or VX_RW1 )
 = 5FE                      *1C T_VPSLLQ equ 0x5FE
                              C avxins(PSRAW    ,VPSRAW    ,vpsraw    ,    RWF_M128, VX_L or VX_HALF or VX_DST or VX_RW0 )
 = 5FF                      *1C T_VPSRAW equ 0x5FF
                              C avxins(PSRAD    ,VPSRAD    ,vpsrad    ,    RWF_M128, VX_L or VX_HALF or VX_DST or VX_RW0 )
 = 600                      *1C T_VPSRAD equ 0x600
                              C avxins(PSRLW    ,VPSRLW    ,vpsrlw    ,    RWF_M128, VX_L or VX_HALF or VX_DST or VX_RW0 )
 = 601                      *1C T_VPSRLW equ 0x601
                              C avxins(PSRLD    ,VPSRLD    ,vpsrld    ,    RWF_M128, VX_L or VX_HALF or VX_DST or VX_RW0 )
 = 602                      *1C T_VPSRLD equ 0x602
                              C avxins(PSRLQ    ,VPSRLQ    ,vpsrlq    ,    RWF_M128, VX_L or VX_HALF or VX_DST or VX_RW1 )
 = 603                      *1C T_VPSRLQ equ 0x603
                              C avxins(PTEST    ,VPTEST    ,vptest    ,    0, VX_L or VX_NND )
 = 604                      *1C T_VPTEST equ 0x604
                              C avxins(PSUBB    ,VPSUBB    ,vpsubb    ,    0, VX_L or VX_RW0  or VX_RW1 )
 = 605                      *1C T_VPSUBB equ 0x605
                              C avxins(PSUBW    ,VPSUBW    ,vpsubw    ,    0, VX_L or VX_RW0  or VX_RW1 )
 = 606                      *1C T_VPSUBW equ 0x606
                              C avxins(PSUBD    ,VPSUBD    ,vpsubd    ,    0, VX_L or VX_RW0 )
 = 607                      *1C T_VPSUBD equ 0x607
                              C avxins(PSUBQ    ,VPSUBQ    ,vpsubq    ,    0, VX_L or VX_RW1 )
 = 608                      *1C T_VPSUBQ equ 0x608
                              C avxins(PSUBSB   ,VPSUBSB   ,vpsubsb   ,    0, VX_L or VX_RW0 or VX_RW1 )
 = 609                      *1C T_VPSUBSB equ 0x609
                              C avxins(PSUBSW   ,VPSUBSW   ,vpsubsw   ,    0, VX_L or VX_RW0 or VX_RW1 )
 = 60A                      *1C T_VPSUBSW equ 0x60A
                              C avxins(PSUBUSB  ,VPSUBUSB  ,vpsubusb  ,    0, VX_L or VX_RW0 or VX_RW1 )
 = 60B                      *1C T_VPSUBUSB equ 0x60B
                              C avxins(PSUBUSW  ,VPSUBUSW  ,vpsubusw  ,    0, VX_L or VX_RW0 or VX_RW1 )
 = 60C                      *1C T_VPSUBUSW equ 0x60C
                              C avxins(PUNPCKHBW ,VPUNPCKHBW ,vpunpckhbw,   0, VX_L or VX_RW0 or VX_RW1 )
 = 60D                      *1C T_VPUNPCKHBW equ 0x60D
                              C avxins(PUNPCKHWD ,VPUNPCKHWD ,vpunpckhwd,   0, VX_L or VX_RW0 or VX_RW1 )
 = 60E                      *1C T_VPUNPCKHWD equ 0x60E
                              C avxins(PUNPCKHDQ ,VPUNPCKHDQ ,vpunpckhdq,   0, VX_L or VX_RW0 )
 = 60F                      *1C T_VPUNPCKHDQ equ 0x60F
                              C avxins(PUNPCKHQDQ,VPUNPCKHQDQ,vpunpckhqdq,  0, VX_L or VX_RW1 )
 = 610                      *1C T_VPUNPCKHQDQ equ 0x610
                              C avxins(PUNPCKLBW ,VPUNPCKLBW ,vpunpcklbw,   0, VX_L or VX_RW0  or VX_RW1 )
 = 611                      *1C T_VPUNPCKLBW equ 0x611
                              C avxins(PUNPCKLWD ,VPUNPCKLWD ,vpunpcklwd,   0, VX_L or VX_RW0  or VX_RW1 )
 = 612                      *1C T_VPUNPCKLWD equ 0x612
                              C avxins(PUNPCKLDQ ,VPUNPCKLDQ ,vpunpckldq,   0, VX_L or VX_RW0 )
 = 613                      *1C T_VPUNPCKLDQ equ 0x613
                              C avxins(PUNPCKLQDQ,VPUNPCKLQDQ,vpunpcklqdq,  0, VX_L or VX_RW1 )
 = 614                      *1C T_VPUNPCKLQDQ equ 0x614
                              C avxins(PXOR     ,VPXOR     ,vpxor     ,    0, VX_L )
 = 615                      *1C T_VPXOR equ 0x615
                              C 
                              C avxins(RCPPS    ,VRCPPS    ,vrcpps    ,    0, VX_L or VX_NND )
 = 616                      *1C T_VRCPPS equ 0x616
                              C avxins(RCPSS    ,VRCPSS    ,vrcpss    ,    0, 0 )
 = 617                      *1C T_VRCPSS equ 0x617
                              C avxins(RSQRTPS  ,VRSQRTPS  ,vrsqrtps  ,    0, VX_L or VX_NND )
 = 618                      *1C T_VRSQRTPS equ 0x618
                              C avxins(RSQRTSS  ,VRSQRTSS  ,vrsqrtss  ,    0, 0 )
 = 619                      *1C T_VRSQRTSS equ 0x619
                              C avxins(ROUNDPD  ,VROUNDPD  ,vroundpd  ,    0, VX_L or VX_NND )
 = 61A                      *1C T_VROUNDPD equ 0x61A
                              C avxins(ROUNDPS  ,VROUNDPS  ,vroundps  ,    0, VX_L or VX_NND )
 = 61B                      *1C T_VROUNDPS equ 0x61B
                              C avxins(ROUNDSD  ,VROUNDSD  ,vroundsd  ,    0, 0 )
 = 61C                      *1C T_VROUNDSD equ 0x61C
                              C avxins(ROUNDSS  ,VROUNDSS  ,vroundss  ,    0, 0 )
 = 61D                      *1C T_VROUNDSS equ 0x61D
                              C avxins(SHUFPD   ,VSHUFPD   ,vshufpd   ,    0, VX_L or VX_RW1 )
 = 61E                      *1C T_VSHUFPD equ 0x61E
                              C avxins(SHUFPS   ,VSHUFPS   ,vshufps   ,    0, VX_L or VX_RW0 )
 = 61F                      *1C T_VSHUFPS equ 0x61F
                              C avxins(UCOMISD  ,VUCOMISD  ,vucomisd  ,    0, VX_NND or VX_RW1 )
 = 620                      *1C T_VUCOMISD equ 0x620
                              C avxins(UCOMISS  ,VUCOMISS  ,vucomiss  ,    0, VX_NND or VX_RW0 )
 = 621                      *1C T_VUCOMISS equ 0x621
                              C avxins(UNPCKHPD ,VUNPCKHPD ,vunpckhpd ,    0, VX_L or VX_RW1 )
 = 622                      *1C T_VUNPCKHPD equ 0x622
                              C avxins(UNPCKHPS ,VUNPCKHPS ,vunpckhps ,    0, VX_L or VX_RW0 )
 = 623                      *1C T_VUNPCKHPS equ 0x623
                              C avxins(UNPCKLPD ,VUNPCKLPD ,vunpcklpd ,    0, VX_L or VX_RW1 )
 = 624                      *1C T_VUNPCKLPD equ 0x624
                              C avxins(UNPCKLPS ,VUNPCKLPS ,vunpcklps ,    0, VX_L or VX_RW0 )
 = 625                      *1C T_VUNPCKLPS equ 0x625
                              C 
                              C ; AVX-2 - v2.26
                              C 
                              C avxins(MOVMSKPD, VMOVMSKPD, vmovmskpd,  0, VX_L or VX_NND )
 = 626                      *1C T_VMOVMSKPD equ 0x626
                              C avxins(MOVMSKPS, VMOVMSKPS, vmovmskps,  0, VX_L or VX_NND )
 = 627                      *1C T_VMOVMSKPS equ 0x627
                              C 
                              C insv(VPMASKMOVD, vpmaskmovd, OpCls( XMM,      XMM_M128,   NONE ), F_660F38, 1, no_WDS, 0x8C, 0x00, P_686 or P_AVX, 0,0, RWF_VEX, VX_L )
 = 628                      *1C T_VPMASKMOVD equ 0x628
                              C insv(VPMASKMOVQ, vpmaskmovq, OpCls( XMM,      XMM_M128,   NONE ), F_660F38, 1, no_WDS, 0x8C, 0x00, P_686 or P_AVX, 0,0, RWF_VEX, VX_L or VX_RW1 )
 = 629                      *1C T_VPMASKMOVQ equ 0x629
                              C insv(VPERMPD, vpermpd,       OpCls( YMM,  YMM_M256_M64,   NONE ), F_660F38, 1, no_WDS, 0x16, 0x00, P_686 or P_AVX, 0,0x80, RWF_VEX, VX_L or VX_IMM or VX_RW1 )
 = 62A                      *1C T_VPERMPD equ 0x62A
                              C insv(VPERMB, vpermb,         OpCls( XMM,      XMM_M128,   NONE ), F_660F38, 1, no_WDS, 0x8D, 0x00, P_686 or P_AVX, 0,0, RWF_VEX, VX_L )
 = 62B                      *1C T_VPERMB equ 0x62B
                              C insv(VPERMD, vpermd,         OpCls( XMM,  XMM_M128_M32,   NONE ), F_660F38, 1, no_WDS, 0x36, 0x00, P_686 or P_AVX, 0,0x80, RWF_VEX, VX_L or VX_RW0 )
 = 62C                      *1C T_VPERMD equ 0x62C
                              C insv(VPERMQ, vpermq,         OpCls( YMM,  YMM_M256_M64,   NONE ), F_660F38, 1, no_WDS, 0x36, 0x00, P_686 or P_AVX, 0,0x80, RWF_VEX, VX_L or VX_IMM or VX_RW1 )
 = 62D                      *1C T_VPERMQ equ 0x62D
                              C insv(VPERMPS, vpermps,       OpCls( YMM,  YMM_M256_M32,   NONE ), F_660F38, 1, no_WDS, 0x16, 0x00, P_686 or P_AVX, 0,0x80, RWF_VEX, VX_L or VX_RW0 )
 = 62E                      *1C T_VPERMPS equ 0x62E
                              C insv(VPSLLVW, vpsllvw,       OpCls( XMM,      XMM_M128,   NONE ), F_660F38, 1, no_WDS, 0x12, 0x00, P_686 or P_AVX, 0,0, RWF_VEX, VX_L or VX_RW0 )
 = 62F                      *1C T_VPSLLVW equ 0x62F
                              C insv(VPSLLVD, vpsllvd,       OpCls( XMM,  XMM_M128_M32,   NONE ), F_660F38, 1, no_WDS, 0x47, 0x00, P_686 or P_AVX, 0,0x80, RWF_VEX, VX_L or VX_RW0 )
 = 630                      *1C T_VPSLLVD equ 0x630
                              C insv(VPSLLVQ, vpsllvq,       OpCls( XMM,  XMM_M128_M64,   NONE ), F_660F38, 1, no_WDS, 0x47, 0x00, P_686 or P_AVX, 0,0x80, RWF_VEX, VX_L or VX_RW1 )
 = 631                      *1C T_VPSLLVQ equ 0x631
                              C insv(VPSRAVD, vpsravd,       OpCls( XMM,  XMM_M128_M32,   NONE ), F_660F38, 1, no_WDS, 0x46, 0x00, P_686 or P_AVX, 0,0xE0, RWF_VEX, VX_L or VX_RW0 )
 = 632                      *1C T_VPSRAVD equ 0x632
                              C insv(VPSRLVD, vpsrlvd,       OpCls( XMM,  XMM_M128_M32,   NONE ), F_660F38, 1, no_WDS, 0x45, 0x00, P_686 or P_AVX, 0,0xE0, RWF_VEX, VX_L or VX_RW0 )
 = 633                      *1C T_VPSRLVD equ 0x633
                              C insv(VPSRLVQ, vpsrlvq,       OpCls( XMM,  XMM_M128_M64,   NONE ), F_660F38, 1, no_WDS, 0x45, 0x00, P_686 or P_AVX, 0,0xE0, RWF_VEX, VX_L or VX_RW1 )
 = 634                      *1C T_VPSRLVQ equ 0x634
                              C insv(VPBLENDD, vpblendd,     OpCls( XMM,      XMM_M128,   I8_U ), F_660F3A, 1, no_WDS, 0x02, 0x00, P_686 or P_AVX, 0,0, RWF_VEX, VX_L )
 = 635                      *1C T_VPBLENDD equ 0x635
                              C insv(VPERM2I128, vperm2i128, OpCls( YMM,      YMM_M256,   I8_U ), F_660F3A, 1, no_WDS, 0x46, 0x00, P_686 or P_AVX, 0,0, RWF_VEX, VX_L )
 = 636                      *1C T_VPERM2I128 equ 0x636
                              C insv(VINSERTI128, vinserti128, OpCls(YMM,     XMM_M128,   I8_U ), F_660F3A, 1, no_WDS, 0x38, 0x00, P_686 or P_AVX, 0,0, RWF_VEX, VX_L or VX_HALF )
 = 637                      *1C T_VINSERTI128 equ 0x637
                              C insv(VBROADCASTI128, vbroadcasti128,OpCls(YMM,M128,       NONE ), F_660F38, 1, no_WDS, 0x5A, 0x00, P_686 or P_AVX, 0,0, RWF_VEX, VX_L or VX_NND )
 = 638                      *1C T_VBROADCASTI128 equ 0x638
                              C insv(VEXTRACTI128, vextracti128, OpCls( XMM,  YMM,        I8_U ), F_660F3A, 0, no_WDS, 0x39, 0x00, P_686 or P_AVX, 0,0, RWF_VEX, VX_L or VX_NND )
 = 639                      *1C T_VEXTRACTI128 equ 0x639
                              C insv(VPBROADCASTQ, vpbroadcastq, OpCls( XMM,  R64,        NONE ), F_660F38, 1, no_WDS, 0x7C, 0x00, P_686 or P_AVX, 0,0xE0, RWF_VEX, VX_L or VX_NND or VX_HALF )
 = 63A                      *1C T_VPBROADCASTQ equ 0x63A
                              C insv(VPBROADCASTD, vpbroadcastd, OpCls( XMM,  R32,        NONE ), F_660F38, 1, no_WDS, 0x7C, 0x00, P_686 or P_AVX, 0,0xE0, RWF_VEX or RWF_T1S, VX_L or VX_NND or VX_HALF or VX_RW0 )
 = 63B                      *1C T_VPBROADCASTD equ 0x63B
                              C insv(VPBROADCASTW, vpbroadcastw, OpCls( XMM,  R16,        NONE ), F_660F38, 1, no_WDS, 0x7B, 0x00, P_686 or P_AVX, 0,0, RWF_VEX, VX_L or VX_NND or VX_HALF )
 = 63C                      *1C T_VPBROADCASTW equ 0x63C
                              C insv(VPBROADCASTB, vpbroadcastb, OpCls( XMM,  R8,         NONE ), F_660F38, 1, no_WDS, 0x7A, 0x00, P_686 or P_AVX, 0,0, RWF_VEX, VX_L or VX_NND or VX_HALF )
 = 63D                      *1C T_VPBROADCASTB equ 0x63D
                              C 
                              C ; GPR instructions v2.28
                              C 
                              C insv(ANDN,      andn,        OpCls( RGT16,    RGT16,      R_MS ), F_0F38,   1, no_WDS, 0xF2, 0x00, P_686 or P_AVX, 0,0, RWF_VEX, VX_L )
 = 63E                      *1C T_ANDN equ 0x63E
                              C insv(MULX,      mulx,        OpCls( RGT16,    RGT16,      R_MS ), F_F20F38, 1, no_WDS, 0xF6, 0x00, P_686 or P_AVX, 0,0, RWF_VEX, VX_L )
 = 63F                      *1C T_MULX equ 0x63F
                              C insv(BEXTR,     bextr,       OpCls( RGT16,    R_MS,       RGT16), F_0F38,   1, 0,      0xF7, 0x00, P_686 or P_AVX, 0,0x08, RWF_VEX, VX_L or VX_NND )
 = 640                      *1C T_BEXTR equ 0x640
                              C insv(SARX,      sarx,        OpCls( RGT16,    R_MS,       RGT16), F_F30F38, 1, 0,      0xF7, 0x00, P_686 or P_AVX, 0,0x08, RWF_VEX, VX_L or VX_NND )
 = 641                      *1C T_SARX equ 0x641
                              C insv(SHLX,      shlx,        OpCls( RGT16,    R_MS,       RGT16), F_660F38, 1, 0,      0xF7, 0x00, P_686 or P_AVX, 0,0x08, RWF_VEX, VX_L or VX_NND )
 = 642                      *1C T_SHLX equ 0x642
                              C insv(SHRX,      shrx,        OpCls( RGT16,    R_MS,       RGT16), F_F20F38, 1, 0,      0xF7, 0x00, P_686 or P_AVX, 0,0x08, RWF_VEX, VX_L or VX_NND )
 = 643                      *1C T_SHRX equ 0x643
                              C insv(BZHI,      bzhi,        OpCls( RGT16,    R_MS,       RGT16), F_0F38,   1, 0,      0xF5, 0x00, P_686 or P_AVX, 0,0x08, RWF_VEX, VX_L or VX_NND )
 = 644                      *1C T_BZHI equ 0x644
                              C insv(PDEP,      pdep,        OpCls( RGT16,    RGT16,      R_MS ), F_F20F38, 1, no_WDS, 0xF5, 0x00, P_686 or P_AVX, 0,0, RWF_VEX, VX_L )
 = 645                      *1C T_PDEP equ 0x645
                              C insv(PEXT,      pext,        OpCls( RGT16,    RGT16,      R_MS ), F_F30F38, 1, no_WDS, 0xF5, 0x00, P_686 or P_AVX, 0,0, RWF_VEX, VX_L )
 = 646                      *1C T_PEXT equ 0x646
                              C insv(RORX,      rorx,        OpCls( RGT16,    RGT16,      I8_U ), F_F20F3A, 1, no_WDS, 0xF0, 0x00, P_686 or P_AVX, 0,0, RWF_VEX, VX_L )
 = 647                      *1C T_RORX equ 0x647
                              C insv(BLSI,      blsi,        OpCls( RGT8,     RGT8_MS,    NONE ), F_0F38,   1, no_WDS, 0xF3, 0x18, P_686 or P_AVX, 0,0x09, RWF_VEX, VX_L )
 = 648                      *1C T_BLSI equ 0x648
                              C insv(BLSMSK,    blsmsk,      OpCls( RGT8,     RGT8_MS,    NONE ), F_0F38,   1, no_WDS, 0xF3, 0x10, P_686 or P_AVX, 0,0x09, RWF_VEX, VX_L )
 = 649                      *1C T_BLSMSK equ 0x649
                              C insv(BLSR,      blsr,        OpCls( RGT8,     RGT8_MS,    NONE ), F_0F38,   1, no_WDS, 0xF3, 0x08, P_686 or P_AVX, 0,0x09, RWF_VEX, VX_L )
 = 64A                      *1C T_BLSR equ 0x64A
                              C 
                              C ;  AVX-512 - v2.26
                              C 
                              C insv(VPERMW,  vpermw,        OpCls( XMM, XMM_M128,        NONE ), F_660F38, 1, no_WDS, 0x8D, 0x00, P_686 or P_AVX, 0,0xF0, RWF_VEX or RWF_EVEX, VX_L or VX_RW1 )
 = 64B                      *1C T_VPERMW equ 0x64B
                              C insv(VPSRAVW, vpsravw,       OpCls( XMM, XMM_M128,        NONE ), F_660F38, 1, no_WDS, 0x11, 0x00, P_686 or P_AVX, 0,0xF0, RWF_VEX or RWF_EVEX, VX_L or VX_RW1)
 = 64C                      *1C T_VPSRAVW equ 0x64C
                              C insv(VPSRAVQ, vpsravq,       OpCls( XMM, XMM_M128_M64,    NONE ), F_660F38, 1, no_WDS, 0x46, 0x00, P_686 or P_AVX, 0,0xF0, RWF_VEX or RWF_EVEX, VX_L or VX_RW1 )
 = 64D                      *1C T_VPSRAVQ equ 0x64D
                              C insv(VPSRLVW, vpsrlvw,       OpCls( XMM, XMM_M128,        NONE ), F_660F38, 1, no_WDS, 0x10, 0x00, P_686 or P_AVX, 0,0xF0, RWF_VEX or RWF_EVEX, VX_L or VX_RW1 )
 = 64E                      *1C T_VPSRLVW equ 0x64E
                              C insv(VPANDD,  vpandd,        OpCls( XMM, XMM_M128_M32,    NONE ), F_660F,   1, no_WDS, 0xDB, 0x00, P_686 or P_AVX, 0,0xE0, RWF_VEX or RWF_EVEX, VX_L or VX_RW0 )
 = 64F                      *1C T_VPANDD equ 0x64F
                              C insv(VPANDQ,  vpandq,        OpCls( XMM, XMM_M128_M64,    NONE ), F_660F,   1, no_WDS, 0xDB, 0x00, P_686 or P_AVX, 0,0xE0, RWF_VEX or RWF_EVEX, VX_L or VX_RW1 )
 = 650                      *1C T_VPANDQ equ 0x650
                              C insv(VPANDND, vpandnd,       OpCls( XMM, XMM_M128_M32,    NONE ), F_660F,   1, no_WDS, 0xDF, 0x00, P_686 or P_AVX, 0,0xE0, RWF_VEX or RWF_EVEX, VX_L or VX_RW0 )
 = 651                      *1C T_VPANDND equ 0x651
                              C insv(VPANDNQ, vpandnq,       OpCls( XMM, XMM_M128_M64,    NONE ), F_660F,   1, no_WDS, 0xDF, 0x00, P_686 or P_AVX, 0,0xE0, RWF_VEX or RWF_EVEX, VX_L or VX_RW1 )
 = 652                      *1C T_VPANDNQ equ 0x652
                              C insv(VPXORD,  vpxord,        OpCls( XMM, XMM_M128_M32,    NONE ), F_660F,   1, no_WDS, 0xEF, 0x00, P_686 or P_AVX, 0,0xE0, RWF_VEX or RWF_EVEX, VX_L or VX_RW0 )
 = 653                      *1C T_VPXORD equ 0x653
                              C insv(VPXORQ,  vpxorq,        OpCls( XMM, XMM_M128_M64,    NONE ), F_660F,   1, no_WDS, 0xEF, 0x00, P_686 or P_AVX, 0,0xE0, RWF_VEX or RWF_EVEX, VX_L or VX_RW1 )
 = 654                      *1C T_VPXORQ equ 0x654
                              C insv(VPSRAQ,  vpsraq,        OpCls( XMM, XMM_M128,        NONE ), F_660F,   1, no_WDS, 0xE2, 0x00, P_686 or P_AVX, 0,0xE0, RWF_VEX or RWF_EVEX or RWF_M128, VX_L or VX_HALF or VX_DST or VX_RW1 )
 = 655                      *1C T_VPSRAQ equ 0x655
                              C insv(VPROLVD, vprolvd,       OpCls( XMM, XMM_M128_M32,    NONE ), F_660F38, 1, no_WDS, 0x15, 0x00, P_686 or P_AVX, 0,0x80, RWF_VEX or RWF_EVEX, VX_L or VX_RW0 )
 = 656                      *1C T_VPROLVD equ 0x656
                              C insv(VPROLVQ, vprolvq,       OpCls( XMM, XMM_M128_M64,    NONE ), F_660F38, 1, no_WDS, 0x15, 0x00, P_686 or P_AVX, 0,0x80, RWF_VEX or RWF_EVEX, VX_L or VX_RW1 )
 = 657                      *1C T_VPROLVQ equ 0x657
                              C insv(VPROLD,  vprold,        OpCls( XMM, I8_U,            NONE ), F_660F,   0, no_WDS, 0x72, 0x08, P_686 or P_AVX, 0,0x10, RWF_VEX or RWF_EVEX, VX_L or VX_HALF or VX_DST or VX_RW0 )
 = 658                      *1C T_VPROLD equ 0x658
                              C insv(VPROLQ,  vprolq,        OpCls( XMM, I8_U,            NONE ), F_660F,   0, no_WDS, 0x72, 0x08, P_686 or P_AVX, 0,0x10, RWF_VEX or RWF_EVEX, VX_L or VX_HALF or VX_DST or VX_RW1 )
 = 659                      *1C T_VPROLQ equ 0x659
                              C insv(VPRORVD, vprorvd,       OpCls( XMM, XMM_M128_M32,    NONE ), F_660F38, 1, no_WDS, 0x14, 0x00, P_686 or P_AVX, 0,0xE0, RWF_VEX or RWF_EVEX, VX_L or VX_HALF or VX_DST or VX_RW0 )
 = 65A                      *1C T_VPRORVD equ 0x65A
                              C insv(VPRORVQ, vprorvq,       OpCls( XMM, XMM_M128_M64,    NONE ), F_660F38, 1, no_WDS, 0x14, 0x00, P_686 or P_AVX, 0,0xE0, RWF_VEX or RWF_EVEX, VX_L or VX_HALF or VX_DST or VX_RW1 )
 = 65B                      *1C T_VPRORVQ equ 0x65B
                              C insv(VPRORD, vprord,         OpCls( XMM, I8_U,            NONE ), F_660F,   0, no_WDS, 0x72, 0x01, P_686 or P_AVX, 0,0x10, RWF_VEX or RWF_EVEX, VX_L or VX_HALF or VX_DST or VX_RW0 )
 = 65C                      *1C T_VPRORD equ 0x65C
                              C insv(VPRORQ, vprorq,         OpCls( XMM, I8_U,            NONE ), F_660F,   0, no_WDS, 0x72, 0x01, P_686 or P_AVX, 0,0x10, RWF_VEX or RWF_EVEX, VX_L or VX_HALF or VX_DST or VX_RW1 )
 = 65D                      *1C T_VPRORQ equ 0x65D
                              C 
                              C insv(VPCONFLICTD, vpconflictd, OpCls( XMM,    XMM_M32,    NONE ), F_660F38, 1, no_WDS, 0xC4, 0x00, P_686 or P_AVX, 0,0x90, RWF_VEX or RWF_EVEX, VX_L or VX_NND or VX_HALF or VX_RW0 )
 = 65E                      *1C T_VPCONFLICTD equ 0x65E
                              C insv(VPCONFLICTQ, vpconflictq, OpCls( XMM,    XMM_M64,    NONE ), F_660F38, 1, no_WDS, 0xC4, 0x00, P_686 or P_AVX, 0,0x60, RWF_VEX or RWF_EVEX, VX_L or VX_NND or VX_HALF or VX_RW1 )
 = 65F                      *1C T_VPCONFLICTQ equ 0x65F
                              C insv(VPLZCNTD, vplzcntd,     OpCls( XMM,      XMM_M32,    NONE ), F_660F38, 1, no_WDS, 0x44, 0x00, P_686 or P_AVX, 0,0x60, RWF_VEX or RWF_EVEX, VX_L or VX_NND or VX_HALF or VX_RW0 )
 = 660                      *1C T_VPLZCNTD equ 0x660
                              C insv(VPLZCNTQ, vplzcntq,     OpCls( XMM,      XMM_M64,    NONE ), F_660F38, 1, no_WDS, 0x44, 0x00, P_686 or P_AVX, 0,0x60, RWF_VEX or RWF_EVEX, VX_L or VX_NND or VX_HALF or VX_RW1 )
 = 661                      *1C T_VPLZCNTQ equ 0x661
                              C insv(VPTESTNMB, vptestnmb,   OpCls( K,        XMM_M128,   NONE ), F_F30F38, 1, no_WDS, 0x26, 0x00, P_686 or P_AVX, 0,0xE0, RWF_VEX or RWF_EVEX, VX_L or VX_HALF or VX_RW0 )
 = 662                      *1C T_VPTESTNMB equ 0x662
                              C insv(VPTESTNMW, vptestnmw,   OpCls( K,        XMM_M128,   NONE ), F_F30F38, 1, no_WDS, 0x26, 0x00, P_686 or P_AVX, 0,0xE0, RWF_VEX or RWF_EVEX, VX_L or VX_HALF or VX_RW1 )
 = 663                      *1C T_VPTESTNMW equ 0x663
                              C insv(VPTESTNMD, vptestnmd,   OpCls( K,        XMM_M32,    NONE ), F_F30F38, 1, no_WDS, 0x27, 0x00, P_686 or P_AVX, 0,0x94, RWF_VEX or RWF_EVEX, VX_L or VX_HALF or VX_RW0 )
 = 664                      *1C T_VPTESTNMD equ 0x664
                              C insv(VPTESTNMQ, vptestnmq,   OpCls( K,        XMM_M64,    NONE ), F_F30F38, 1, no_WDS, 0x27, 0x00, P_686 or P_AVX, 0,0x94, RWF_VEX or RWF_EVEX, VX_L or VX_HALF or VX_RW1 )
 = 665                      *1C T_VPTESTNMQ equ 0x665
                              C insv(VPBROADCASTMW2D, vpbroadcastmw2d, OpCls( XMM, K,     NONE ), F_F30F38, 1, no_WDS, 0x3A, 0x00, P_686 or P_AVX, 0,0xE0, RWF_VEX or RWF_EVEX, VX_L or VX_NND or VX_HALF or VX_RW0 )
 = 666                      *1C T_VPBROADCASTMW2D equ 0x666
                              C insv(VPBROADCASTMB2Q, vpbroadcastmb2q, OpCls( XMM, K,     NONE ), F_F30F38, 1, no_WDS, 0x2A, 0x00, P_686 or P_AVX, 0,0xE0, RWF_VEX or RWF_EVEX, VX_L or VX_NND or VX_HALF or VX_RW1 )
 = 667                      *1C T_VPBROADCASTMB2Q equ 0x667
                              C 
                              C insv(KADDB,     kaddb,       OpCls( K,        K,          NONE ), F_C5LP0,  1, no_WDS, 0x4A, 0x00, P_686 or P_AVX, 0,0, RWF_VEX, VX_L )
 = 668                      *1C T_KADDB equ 0x668
                              C insv(KADDW,     kaddw,       OpCls( K,        K,          NONE ), F_C5L,    1, no_WDS, 0x4A, 0x00, P_686 or P_AVX, 0,0, RWF_VEX, VX_L )
 = 669                      *1C T_KADDW equ 0x669
                              C insv(KANDB,     kandb,       OpCls( K,        K,          NONE ), F_C5LP0,  1, no_WDS, 0x41, 0x00, P_686 or P_AVX, 0,0, RWF_VEX, VX_L )
 = 66A                      *1C T_KANDB equ 0x66A
                              C insv(KANDW,     kandw,       OpCls( K,        K,          NONE ), F_C5L,    1, no_WDS, 0x41, 0x00, P_686 or P_AVX, 0,0, RWF_VEX, VX_L )
 = 66B                      *1C T_KANDW equ 0x66B
                              C insv(KANDNB,    kandnb,      OpCls( K,        K,          NONE ), F_C5LP0,  1, no_WDS, 0x42, 0x00, P_686 or P_AVX, 0,0, RWF_VEX, VX_L )
 = 66C                      *1C T_KANDNB equ 0x66C
                              C insv(KANDNW,    kandnw,      OpCls( K,        K,          NONE ), F_C5L,    1, no_WDS, 0x42, 0x00, P_686 or P_AVX, 0,0, RWF_VEX, VX_L )
 = 66D                      *1C T_KANDNW equ 0x66D
                              C insv(KORB,      korb,        OpCls( K,        K,          NONE ), F_C5LP0,  1, no_WDS, 0x45, 0x00, P_686 or P_AVX, 0,0, RWF_VEX, VX_L )
 = 66E                      *1C T_KORB equ 0x66E
                              C insv(KORW,      korw,        OpCls( K,        K,          NONE ), F_C5L,    1, no_WDS, 0x45, 0x00, P_686 or P_AVX, 0,0, RWF_VEX, VX_L )
 = 66F                      *1C T_KORW equ 0x66F
                              C insv(KXORB,     kxorb,       OpCls( K,        K,          NONE ), F_C5LP0,  1, no_WDS, 0x47, 0x00, P_686 or P_AVX, 0,0, RWF_VEX, VX_L )
 = 670                      *1C T_KXORB equ 0x670
                              C insv(KXORW,     kxorw,       OpCls( K,        K,          NONE ), F_C5L,    1, no_WDS, 0x47, 0x00, P_686 or P_AVX, 0,0, RWF_VEX, VX_L )
 = 671                      *1C T_KXORW equ 0x671
                              C insv(KXNORB,    kxnorb,      OpCls( K,        K,          NONE ), F_C5LP0,  1, no_WDS, 0x46, 0x00, P_686 or P_AVX, 0,0, RWF_VEX, VX_L )
 = 672                      *1C T_KXNORB equ 0x672
                              C insv(KXNORW,    kxnorw,      OpCls( K,        K,          NONE ), F_C5L,    1, no_WDS, 0x46, 0x00, P_686 or P_AVX, 0,0, RWF_VEX, VX_L )
 = 673                      *1C T_KXNORW equ 0x673
                              C insv(KUNPCKBW,  kunpckbw,    OpCls( K,        K,          NONE ), F_C5LP0,  1, no_WDS, 0x4B, 0x00, P_686 or P_AVX, 0,0, RWF_VEX, VX_L )
 = 674                      *1C T_KUNPCKBW equ 0x674
                              C insv(KUNPCKWD,  kunpckwd,    OpCls( K,        K,          NONE ), F_C5L,    1, no_WDS, 0x4B, 0x00, P_686 or P_AVX, 0,0, RWF_VEX, VX_L )
 = 675                      *1C T_KUNPCKWD equ 0x675
                              C 
                              C insv(KADDD,     kaddd,       OpCls( K,        K,          NONE ), F_C4M0P0L,1, no_WDS, 0x4A, 0x00, P_686 or P_AVX, 0,0, RWF_VEX, VX_L or VX_RW1 )
 = 676                      *1C T_KADDD equ 0x676
                              C insv(KADDQ,     kaddq,       OpCls( K,        K,          NONE ), F_C4M0L,  1, no_WDS, 0x4A, 0x00, P_686 or P_AVX, 0,0, RWF_VEX, VX_L or VX_RW1 )
 = 677                      *1C T_KADDQ equ 0x677
                              C insv(KANDD,     kandd,       OpCls( K,        K,          NONE ), F_C4M0P0L,1, no_WDS, 0x41, 0x00, P_686 or P_AVX, 0,0, RWF_VEX, VX_L or VX_RW1 )
 = 678                      *1C T_KANDD equ 0x678
                              C insv(KANDQ,     kandq,       OpCls( K,        K,          NONE ), F_C4M0L,  1, no_WDS, 0x41, 0x00, P_686 or P_AVX, 0,0, RWF_VEX, VX_L or VX_RW1 )
 = 679                      *1C T_KANDQ equ 0x679
                              C insv(KANDND,    kandnd,      OpCls( K,        K,          NONE ), F_C4M0P0L,1, no_WDS, 0x42, 0x00, P_686 or P_AVX, 0,0, RWF_VEX, VX_L or VX_RW1 )
 = 67A                      *1C T_KANDND equ 0x67A
                              C insv(KANDNQ,    kandnq,      OpCls( K,        K,          NONE ), F_C4M0L,  1, no_WDS, 0x42, 0x00, P_686 or P_AVX, 0,0, RWF_VEX, VX_L or VX_RW1 )
 = 67B                      *1C T_KANDNQ equ 0x67B
                              C insv(KORD,      kord,        OpCls( K,        K,          NONE ), F_C4M0P0L,1, no_WDS, 0x45, 0x00, P_686 or P_AVX, 0,0, RWF_VEX, VX_L or VX_RW1 )
 = 67C                      *1C T_KORD equ 0x67C
                              C insv(KORQ,      korq,        OpCls( K,        K,          NONE ), F_C4M0L,  1, no_WDS, 0x45, 0x00, P_686 or P_AVX, 0,0, RWF_VEX, VX_L or VX_RW1 )
 = 67D                      *1C T_KORQ equ 0x67D
                              C insv(KXORD,     kxord,       OpCls( K,        K,          NONE ), F_C4M0P0L,1, no_WDS, 0x47, 0x00, P_686 or P_AVX, 0,0, RWF_VEX, VX_L or VX_RW1 )
 = 67E                      *1C T_KXORD equ 0x67E
                              C insv(KXORQ,     kxorq,       OpCls( K,        K,          NONE ), F_C4M0L,  1, no_WDS, 0x47, 0x00, P_686 or P_AVX, 0,0, RWF_VEX, VX_L or VX_RW1 )
 = 67F                      *1C T_KXORQ equ 0x67F
                              C insv(KXNORD,    kxnord,      OpCls( K,        K,          NONE ), F_C4M0P0L,1, no_WDS, 0x46, 0x00, P_686 or P_AVX, 0,0, RWF_VEX, VX_L or VX_RW1 )
 = 680                      *1C T_KXNORD equ 0x680
                              C insv(KXNORQ,    kxnorq,      OpCls( K,        K,          NONE ), F_C4M0L,  1, no_WDS, 0x46, 0x00, P_686 or P_AVX, 0,0, RWF_VEX, VX_L or VX_RW1 )
 = 681                      *1C T_KXNORQ equ 0x681
                              C insv(KUNPCKDQ,  kunpckdq,    OpCls( K,        K,          NONE ), F_C4M0L,  1, no_WDS, 0x4B, 0x00, P_686 or P_AVX, 0,0, RWF_VEX, VX_L or VX_RW1 )
 = 682                      *1C T_KUNPCKDQ equ 0x682
                              C 
                              C insv(KNOTB,     knotb,       OpCls( K,        K,          NONE ), F_660F,   1, no_WDS, 0x44, 0x00, P_686 or P_AVX, 0,0, RWF_VEX, VX_L or VX_NND )
 = 683                      *1C T_KNOTB equ 0x683
                              C insv(KNOTW,     knotw,       OpCls( K,        K,          NONE ), F_0F,     1, no_WDS, 0x44, 0x00, P_686 or P_AVX, 0,0, RWF_VEX, VX_L or VX_NND )
 = 684                      *1C T_KNOTW equ 0x684
                              C insv(KNOTD,     knotd,       OpCls( K,        K,          NONE ), F_C4M0P0, 1, no_WDS, 0x44, 0x00, P_686 or P_AVX, 0,0, RWF_VEX, VX_L or VX_NND or VX_RW1 )
 = 685                      *1C T_KNOTD equ 0x685
                              C insv(KNOTQ,     knotq,       OpCls( K,        K,          NONE ), F_C4M0,   1, no_WDS, 0x44, 0x00, P_686 or P_AVX, 0,0, RWF_VEX, VX_L or VX_NND or VX_RW1 )
 = 686                      *1C T_KNOTQ equ 0x686
                              C insv(KORTESTB,  kortestb,    OpCls( K,        K,          NONE ), F_660F,   1, no_WDS, 0x98, 0x00, P_686 or P_AVX, 0,0, RWF_VEX, VX_L or VX_NND )
 = 687                      *1C T_KORTESTB equ 0x687
                              C insv(KORTESTW,  kortestw,    OpCls( K,        K,          NONE ), F_0F,     1, no_WDS, 0x98, 0x00, P_686 or P_AVX, 0,0, RWF_VEX, VX_L or VX_NND )
 = 688                      *1C T_KORTESTW equ 0x688
                              C insv(KORTESTD,  kortestd,    OpCls( K,        K,          NONE ), F_C4M0P0, 1, no_WDS, 0x98, 0x00, P_686 or P_AVX, 0,0, RWF_VEX, VX_L or VX_NND or VX_RW1 )
 = 689                      *1C T_KORTESTD equ 0x689
                              C insv(KORTESTQ,  kortestq,    OpCls( K,        K,          NONE ), F_C4M0,   1, no_WDS, 0x98, 0x00, P_686 or P_AVX, 0,0, RWF_VEX, VX_L or VX_NND or VX_RW1 )
 = 68A                      *1C T_KORTESTQ equ 0x68A
                              C insv(KSHIFTLB,  kshiftlb,    OpCls( K,        K,          I8_U ), F_660F3A, 1, no_WDS, 0x32, 0x00, P_686 or P_AVX, 0,0, RWF_VEX, VX_L or VX_NND )
 = 68B                      *1C T_KSHIFTLB equ 0x68B
                              C insv(KSHIFTLW,  kshiftlw,    OpCls( K,        K,          I8_U ), F_660F3A, 1, no_WDS, 0x32, 0x00, P_686 or P_AVX, 0,0, RWF_VEX, VX_L or VX_NND or VX_RW1 )
 = 68C                      *1C T_KSHIFTLW equ 0x68C
                              C insv(KSHIFTLD,  kshiftld,    OpCls( K,        K,          I8_U ), F_660F3A, 1, no_WDS, 0x33, 0x00, P_686 or P_AVX, 0,0, RWF_VEX, VX_L or VX_NND )
 = 68D                      *1C T_KSHIFTLD equ 0x68D
                              C insv(KSHIFTLQ,  kshiftlq,    OpCls( K,        K,          I8_U ), F_660F3A, 1, no_WDS, 0x33, 0x00, P_686 or P_AVX, 0,0, RWF_VEX, VX_L or VX_NND or VX_RW1 )
 = 68E                      *1C T_KSHIFTLQ equ 0x68E
                              C insv(KSHIFTRB,  kshiftrb,    OpCls( K,        K,          I8_U ), F_660F3A, 1, no_WDS, 0x30, 0x00, P_686 or P_AVX, 0,0, RWF_VEX, VX_L or VX_NND )
 = 68F                      *1C T_KSHIFTRB equ 0x68F
                              C insv(KSHIFTRW,  kshiftrw,    OpCls( K,        K,          I8_U ), F_660F3A, 1, no_WDS, 0x30, 0x00, P_686 or P_AVX, 0,0, RWF_VEX, VX_L or VX_NND or VX_RW1 )
 = 690                      *1C T_KSHIFTRW equ 0x690
                              C insv(KSHIFTRD,  kshiftrd,    OpCls( K,        K,          I8_U ), F_660F3A, 1, no_WDS, 0x31, 0x00, P_686 or P_AVX, 0,0, RWF_VEX, VX_L or VX_NND )
 = 691                      *1C T_KSHIFTRD equ 0x691
                              C insv(KSHIFTRQ,  kshiftrq,    OpCls( K,        K,          I8_U ), F_660F3A, 1, no_WDS, 0x31, 0x00, P_686 or P_AVX, 0,0, RWF_VEX, VX_L or VX_NND or VX_RW1 )
 = 692                      *1C T_KSHIFTRQ equ 0x692
                              C 
                              C insv(KMOVB,  kmovb,          OpCls( K,        K,          NONE ), F_660F,   1, no_WDS, 0x90, 0x00, P_686 or P_AVX, 0,0, RWF_VEX, VX_L or VX_NND )
 = 693                      *1C T_KMOVB equ 0x693
                              C insv(KMOVD,  kmovd,          OpCls( K,        K,          NONE ), F_C4M0P0, 1, 0,      0x90, 0x00, P_686 or P_AVX, 0,0, RWF_VEX, VX_L or VX_NND or VX_RW1 )
 = 694                      *1C T_KMOVD equ 0x694
                              C insv(KMOVQ,  kmovq,          OpCls( K,        K,          NONE ), F_C4M0,   1, 0,      0x90, 0x00, P_686 or P_AVX, 0,0, RWF_VEX, VX_L or VX_NND or VX_RW1 )
 = 695                      *1C T_KMOVQ equ 0x695
                              C insv(KMOVW,  kmovw,          OpCls( K,        K,          NONE ), F_0F,     1, 0,      0x90, 0x00, P_686 or P_AVX, 0,0, RWF_VEX, VX_L or VX_NND )
 = 696                      *1C T_KMOVW equ 0x696
                              C 
                              C insv(VEXP2PS, vexp2ps,       OpCls( ZMM, ZMM_M512_M32,    NONE ), F_660F38, 1, no_WDS, 0xC8, 0x00, P_686 or P_AVX, 0,0x60, RWF_VEX or RWF_EVEX, VX_L or VX_NND or VX_HALF or VX_RW0 )
 = 697                      *1C T_VEXP2PS equ 0x697
                              C insv(VEXP2PD, vexp2pd,       OpCls( ZMM, ZMM_M512_M64,    NONE ), F_660F38, 1, no_WDS, 0xC8, 0x00, P_686 or P_AVX, 0,0x60, RWF_VEX or RWF_EVEX, VX_L or VX_NND or VX_HALF or VX_RW1 )
 = 698                      *1C T_VEXP2PD equ 0x698
                              C insv(VRCP28PS, vrcp28ps,     OpCls( ZMM, ZMM_M512_M32,    NONE ), F_660F38, 1, no_WDS, 0xCA, 0x00, P_686 or P_AVX, 0,0x60, RWF_VEX or RWF_EVEX, VX_L or VX_NND or VX_HALF or VX_RW0 )
 = 699                      *1C T_VRCP28PS equ 0x699
                              C insv(VRCP28PD, vrcp28pd,     OpCls( ZMM, ZMM_M512_M64,    NONE ), F_660F38, 1, no_WDS, 0xCA, 0x00, P_686 or P_AVX, 0,0x60, RWF_VEX or RWF_EVEX, VX_L or VX_NND or VX_HALF or VX_RW1 )
 = 69A                      *1C T_VRCP28PD equ 0x69A
                              C insv(VRCP28SS, vrcp28ss,     OpCls( XMM, XMM_M128_M32,    NONE ), F_660F38, 1, no_WDS, 0xCB, 0x00, P_686 or P_AVX, 0,0x60, RWF_VEX or RWF_EVEX or RWF_T1S, VX_L or VX_RW0 )
 = 69B                      *1C T_VRCP28SS equ 0x69B
                              C insv(VRCP28SD, vrcp28sd,     OpCls( XMM, XMM_M128_M64,    NONE ), F_660F38, 1, no_WDS, 0xCB, 0x00, P_686 or P_AVX, 0,0x60, RWF_VEX or RWF_EVEX or RWF_T1S, VX_L or VX_RW1 )
 = 69C                      *1C T_VRCP28SD equ 0x69C
                              C insv(VMOVDQA32, vmovdqa32,   OpCls( XMM,      XMM_M128,   NONE ), F_660F,   1, no_WDS, 0x6F, 0x00, P_686 or P_AVX, 0,0xF0, RWF_VEX or RWF_EVEX, VX_L or VX_NND or VX_RW0 )
 = 69D                      *1C T_VMOVDQA32 equ 0x69D
                              C insv(VMOVDQU8,  vmovdqu8,    OpCls( XMM,      XMM_M128,   NONE ), F_F20F,   1, no_WDS, 0x6F, 0x00, P_686 or P_AVX, 0,0x60, RWF_VEX or RWF_EVEX, VX_L or VX_NND or VX_RW0 )
 = 69E                      *1C T_VMOVDQU8 equ 0x69E
                              C insv(VMOVDQU32, vmovdqu32,   OpCls( XMM,      XMM_M128,   NONE ), F_F30F,   1, no_WDS, 0x6F, 0x00, P_686 or P_AVX, 0,0x60, RWF_VEX or RWF_EVEX, VX_L or VX_NND or VX_RW0 )
 = 69F                      *1C T_VMOVDQU32 equ 0x69F
                              C insv(VBROADCASTF32X2, vbroadcastf32x2, OpCls(XMM, XMM_M64, NONE), F_660F38, 1, no_WDS, 0x19, 0x00, P_686 or P_AVX, 0,0xF0, RWF_VEX or RWF_EVEX or RWF_T2, VX_L or VX_NND or VX_HALF or VX_RW0 )
 = 6A0                      *1C T_VBROADCASTF32X2 equ 0x6A0
                              C insv(VBROADCASTF32X4, vbroadcastf32x4, OpCls(XMM, XMM_M128,NONE), F_660F38, 1, no_WDS, 0x1A, 0x00, P_686 or P_AVX, 0,0xF0, RWF_VEX or RWF_EVEX or RWF_T4, VX_L or VX_NND or VX_HALF or VX_RW0 )
 = 6A1                      *1C T_VBROADCASTF32X4 equ 0x6A1
                              C insv(VBROADCASTF32X8, vbroadcastf32x8, OpCls(ZMM,M256_M128,NONE), F_660F38, 1, no_WDS, 0x1B, 0x00, P_686 or P_AVX, 0,0xF0, RWF_VEX or RWF_EVEX, VX_L or VX_NND or VX_HALF or VX_RW0 )
 = 6A2                      *1C T_VBROADCASTF32X8 equ 0x6A2
                              C insv(VBROADCASTF64X4, vbroadcastf64x4, OpCls(XMM, XMM_M128,NONE), F_660F38, 1, no_WDS, 0x1B, 0x00, P_686 or P_AVX, 0,0xF0, RWF_VEX or RWF_EVEX or RWF_T4, VX_L or VX_NND or VX_HALF or VX_RW1 )
 = 6A3                      *1C T_VBROADCASTF64X4 equ 0x6A3
                              C insv(VBROADCASTI32x2, vbroadcasti32x2, OpCls(XMM, XMM_M128_M64, NONE ), F_660F38, 1, no_WDS, 0x59, 0x00, P_686 or P_AVX, 0,0xF0, RWF_VEX or RWF_EVEX or RWF_T2, VX_L or VX_NND or VX_HALF or VX_RW0 )
 = 6A4                      *1C T_VBROADCASTI32x2 equ 0x6A4
                              C insv(VBROADCASTI32X4, vbroadcasti32x4, OpCls(XMM, XMM_M128_M64, NONE ), F_660F38, 1, no_WDS, 0x5A, 0x00, P_686 or P_AVX, 0,0xF0, RWF_VEX or RWF_EVEX or RWF_T4, VX_L or VX_NND or VX_HALF or VX_RW0 )
 = 6A5                      *1C T_VBROADCASTI32X4 equ 0x6A5
                              C insv(VBROADCASTI32X8, vbroadcasti32x8, OpCls(XMM, XMM_M128_M64, NONE ), F_660F38, 1, no_WDS, 0x5B, 0x00, P_686 or P_AVX, 0,0xF0, RWF_VEX or RWF_EVEX, VX_L or VX_NND or VX_HALF or VX_RW0 )
 = 6A6                      *1C T_VBROADCASTI32X8 equ 0x6A6
                              C insv(VCOMPRESSPD, vcompresspd, OpCls( XMM_M128, XMM,      NONE ), F_660F38, 0, no_WDS, 0x8A, 0x00, P_686 or P_AVX, 0,0xF0, RWF_VEX or RWF_EVEX or RWF_T1S, VX_L or VX_HALF or VX_RW1 )
 = 6A7                      *1C T_VCOMPRESSPD equ 0x6A7
                              C insv(VPCOMPRESSD, vpcompressd, OpCls( XMM_M128, XMM,      NONE ), F_660F38, 0, no_WDS, 0x8B, 0x00, P_686 or P_AVX, 0,0xF0, RWF_VEX or RWF_EVEX or RWF_T1S, VX_L or VX_HALF or VX_RW0 )
 = 6A8                      *1C T_VPCOMPRESSD equ 0x6A8
                              C insv(VCVTPD2QQ, vcvtpd2qq,   OpCls( XMM, XMM_M128_M64,    NONE ), F_660F,   1, no_WDS, 0x7B, 0x00, P_686 or P_AVX, 0,0xE0, RWF_VEX or RWF_EVEX, VX_L or VX_NND or VX_RW1 )
 = 6A9                      *1C T_VCVTPD2QQ equ 0x6A9
                              C insv(VCVTPD2UDQ, vcvtpd2udq, OpCls( XMM, XMM_MXMM,        NONE ), F_0F,     1, no_WDS, 0x79, 0x00, P_686 or P_AVX, 0,0xF0, RWF_VEX or RWF_EVEX, VX_L or VX_NND or VX_HALF or VX_RW1 )
 = 6AA                      *1C T_VCVTPD2UDQ equ 0x6AA
                              C insv(VCVTPD2UQQ, vcvtpd2uqq, OpCls( XMM, XMM_M128_M64,    NONE ), F_660F,   1, no_WDS, 0x79, 0x00, P_686 or P_AVX, 0,0x60, RWF_VEX or RWF_EVEX, VX_L or VX_NND or VX_RW1 )
 = 6AB                      *1C T_VCVTPD2UQQ equ 0x6AB
                              C insv(VCVTPH2PS, vcvtph2ps,   OpCls( XMM, XMM_M128_M64,    NONE ), F_660F38, 1, no_WDS, 0x13, 0x00, P_686 or P_AVX, 0,0xF0, RWF_VEX or RWF_HVM, VX_L or VX_NND or VX_HALF or VX_RW0 )
 = 6AC                      *1C T_VCVTPH2PS equ 0x6AC
                              C insv(VCVTPS2PH, vcvtps2ph,   OpCls( XMM_M128_M64, XMM_YMM,I8_U ), F_660F3A, 0, no_WDS, 0x1D, 0x00, P_686 or P_AVX, 0,0x80, RWF_VEX or RWF_HVM, VX_L or VX_NND or VX_HALF  or VX_RW0 )
 = 6AD                      *1C T_VCVTPS2PH equ 0x6AD
                              C insv(VCVTQQ2PD, vcvtqq2pd,   OpCls( XMM, XMM_M128_M64,    NONE ), F_F30F,   1, no_WDS, 0xE6, 0x00, P_686 or P_AVX, 0,0xF0, RWF_VEX or RWF_EVEX, VX_L or VX_NND or VX_HALF or VX_RW1 )
 = 6AE                      *1C T_VCVTQQ2PD equ 0x6AE
                              C insv(VCVTQQ2PS, vcvtqq2ps,   OpCls( XMM, XMM_MXMM,        NONE ), F_0F,     1, no_WDS, 0x5B, 0x00, P_686 or P_AVX, 0,0xF0, RWF_VEX or RWF_EVEX, VX_L or VX_NND or VX_HALF or VX_RW1 )
 = 6AF                      *1C T_VCVTQQ2PS equ 0x6AF
                              C insv(VCVTTPD2QQ, vcvttpd2qq, OpCls( XMM, XMM_M128_M64,    NONE ), F_660F,   1, no_WDS, 0x7A, 0x00, P_686 or P_AVX, 0,0xF0, RWF_VEX or RWF_EVEX, VX_L or VX_NND or VX_RW1 )
 = 6B0                      *1C T_VCVTTPD2QQ equ 0x6B0
                              C insv(VCVTTPD2UDQ, vcvttpd2udq,OpCls(XMM, XMM_MXMM,        NONE ), F_0F,     1, no_WDS, 0x78, 0x00, P_686 or P_AVX, 0,0xF0, RWF_VEX or RWF_EVEX, VX_L or VX_NND or VX_HALF or VX_RW1 )
 = 6B1                      *1C T_VCVTTPD2UDQ equ 0x6B1
                              C insv(VCVTTPD2UQQ, vcvttpd2uqq,OpCls(XMM, XMM_M128_M64,    NONE ), F_660F,   1, no_WDS, 0x78, 0x00, P_686 or P_AVX, 0,0xF0, RWF_VEX or RWF_EVEX, VX_L or VX_NND or VX_RW1 )
 = 6B2                      *1C T_VCVTTPD2UQQ equ 0x6B2
                              C insv(VCVTUDQ2PD, vcvtudq2pd, OpCls( XMM, XMM_M128_M32,    NONE ), F_F30F,   1, no_WDS, 0x7A, 0x00, P_686 or P_AVX, 0,0xF0, RWF_VEX or RWF_EVEX, VX_L or VX_NND or VX_HALF or VX_RW0 )
 = 6B3                      *1C T_VCVTUDQ2PD equ 0x6B3
                              C insv(VCVTUQQ2PS, vcvtuqq2ps, OpCls( XMM, XMM_MXMM,        NONE ), F_F20F,   1, no_WDS, 0x7A, 0x00, P_686 or P_AVX, 0,0x60, RWF_VEX or RWF_EVEX, VX_L or VX_NND or VX_HALF or VX_RW1 )
 = 6B4                      *1C T_VCVTUQQ2PS equ 0x6B4
                              C insv(VEXPANDPD, vexpandpd,   OpCls( XMM, XMM_M128,        NONE ), F_660F38, 1, no_WDS, 0x88, 0x00, P_686 or P_AVX, 0,0xF0, RWF_VEX or RWF_EVEX or RWF_T1S, VX_L or VX_NND or VX_RW1 )
 = 6B5                      *1C T_VEXPANDPD equ 0x6B5
                              C insv(VEXTRACTF32x4, vextractf32x4, OpCls(XMM_M128,YMM_ZMM,I8_U ), F_660F3A, 0, no_WDS, 0x19, 0x00, P_686 or P_AVX, 0,0x80, RWF_VEX or RWF_EVEX, VX_L or VX_HALF or VX_NND or VX_RW0 )
 = 6B6                      *1C T_VEXTRACTF32x4 equ 0x6B6
                              C insv(VEXTRACTF32X8, vextractf32x8, OpCls(YMM_M256,ZMM,    I8_U ), F_660F3A, 0, no_WDS, 0x1B, 0x00, P_686 or P_AVX, 0,0x80, RWF_VEX or RWF_EVEX, VX_L or VX_NND or VX_RW0 )
 = 6B7                      *1C T_VEXTRACTF32X8 equ 0x6B7
                              C insv(VEXTRACTI32x4, vextracti32x4, OpCls(XMM_M128,YMM_ZMM,I8_U ), F_660F3A, 0, no_WDS, 0x39, 0x00, P_686 or P_AVX, 0,0x80, RWF_VEX or RWF_EVEX, VX_L or VX_NND or VX_RW0 )
 = 6B8                      *1C T_VEXTRACTI32x4 equ 0x6B8
                              C insv(VEXTRACTI32X8, vextracti32x8, OpCls(YMM_M256,ZMM,    I8_U ), F_660F3A, 0, no_WDS, 0x3B, 0x00, P_686 or P_AVX, 0,0x80, RWF_VEX or RWF_EVEX, VX_L or VX_NND or VX_RW0 )
 = 6B9                      *1C T_VEXTRACTI32X8 equ 0x6B9
                              C insv(VFPCLASSPD, vfpclasspd, OpCls( K,        XMM_M128,   I8_U ), F_660F3A, 1, no_WDS, 0x66, 0x00, P_686 or P_AVX, 0,0xF0, RWF_VEX or RWF_EVEX, VX_L or VX_NND or VX_HALF or VX_RW1 )
 = 6BA                      *1C T_VFPCLASSPD equ 0x6BA
                              C insv(VGATHERDPS, vgatherdps, OpCls( XMM,      XMM_M32,    NONE ), F_660F38, 1, no_WDS, 0x92, 0x00, P_686 or P_AVX, 0,0x08, RWF_VEX or RWF_T1S, VX_L or VX_NND or VX_HALF or VX_RW0 )
 = 6BB                      *1C T_VGATHERDPS equ 0x6BB
                              C insv(VGATHERQPS, vgatherqps, OpCls( XMM,      XMM_M64,    NONE ), F_660F38, 1, no_WDS, 0x93, 0x00, P_686 or P_AVX, 0,0x08, RWF_VEX or RWF_T1S, VX_L or VX_NND or VX_RW0 )
 = 6BC                      *1C T_VGATHERQPS equ 0x6BC
                              C insv(VPGATHERDD, vpgatherdd, OpCls( XMM,      M32_M64,    XMM  ), F_660F38, 1, no_WDS, 0x90, 0x00, P_686 or P_AVX, 0,0x08, RWF_VEX or RWF_T1S, VX_L or VX_NND or VX_RW0 )
 = 6BD                      *1C T_VPGATHERDD equ 0x6BD
                              C insv(VPGATHERQD, vpgatherqd, OpCls( XMM,      M32_M64,    XMM  ), F_660F38, 1, no_WDS, 0x91, 0x00, P_686 or P_AVX, 0,0x08, RWF_VEX or RWF_T1S, VX_L or VX_NND or VX_RW0 )
 = 6BE                      *1C T_VPGATHERQD equ 0x6BE
                              C insv(VGATHERPF0DPS, vgatherpf0dps, OpCls( M32_M512, NONE, NONE ), F_660F38, 0, no_WDS, 0xC6, 0x08, P_686 or P_AVX, 0,0x98, RWF_VEX or RWF_EVEX or RWF_T1S, VX_L or VX_NND or VX_RW0 )
 = 6BF                      *1C T_VGATHERPF0DPS equ 0x6BF
                              C insv(VGATHERPF0QPS, vgatherpf0qps, OpCls( M64_M512, NONE, NONE ), F_660F38, 0, no_WDS, 0xC7, 0x08, P_686 or P_AVX, 0,0x98, RWF_VEX or RWF_EVEX or RWF_T1S, VX_L or VX_NND or VX_RW0 )
 = 6C0                      *1C T_VGATHERPF0QPS equ 0x6C0
                              C insv(VGATHERPF0DPD, vgatherpf0dpd, OpCls( M32_M256, NONE, NONE ), F_660F38, 0, no_WDS, 0xC6, 0x08, P_686 or P_AVX, 0,0x98, RWF_VEX or RWF_EVEX or RWF_T1S, VX_L or VX_NND or VX_RW1 )
 = 6C1                      *1C T_VGATHERPF0DPD equ 0x6C1
                              C insv(VGATHERPF0QPD, vgatherpf0qpd, OpCls( M64_M256, NONE, NONE ), F_660F38, 0, no_WDS, 0xC7, 0x08, P_686 or P_AVX, 0,0x98, RWF_VEX or RWF_EVEX or RWF_T1S, VX_L or VX_NND or VX_RW1 )
 = 6C2                      *1C T_VGATHERPF0QPD equ 0x6C2
                              C insv(VGATHERPF1DPS, vgatherpf1dps, OpCls( M32_M512, NONE, NONE ), F_660F38, 0, no_WDS, 0xC6, 0x10, P_686 or P_AVX, 0,0x98, RWF_VEX or RWF_EVEX or RWF_T1S, VX_L or VX_NND or VX_RW0 )
 = 6C3                      *1C T_VGATHERPF1DPS equ 0x6C3
                              C insv(VGATHERPF1QPS, vgatherpf1qps, OpCls( M64_M512, NONE, NONE ), F_660F38, 0, no_WDS, 0xC7, 0x10, P_686 or P_AVX, 0,0x98, RWF_VEX or RWF_EVEX or RWF_T1S, VX_L or VX_NND or VX_RW0 )
 = 6C4                      *1C T_VGATHERPF1QPS equ 0x6C4
                              C insv(VGATHERPF1DPD, vgatherpf1dpd, OpCls( M32_M256, NONE, NONE ), F_660F38, 0, no_WDS, 0xC6, 0x10, P_686 or P_AVX, 0,0x98, RWF_VEX or RWF_EVEX or RWF_T1S, VX_L or VX_NND or VX_RW1 )
 = 6C5                      *1C T_VGATHERPF1DPD equ 0x6C5
                              C insv(VGATHERPF1QPD, vgatherpf1qpd, OpCls( M64_M512, NONE, NONE ), F_660F38, 0, no_WDS, 0xC7, 0x10, P_686 or P_AVX, 0,0x98, RWF_VEX or RWF_EVEX or RWF_T1S, VX_L or VX_NND or VX_RW1 )
 = 6C6                      *1C T_VGATHERPF1QPD equ 0x6C6
                              C insv(VSCATTERDPS,   vscatterdps,   OpCls( M32_M64, XMM,   NONE ), F_660F38, 0, no_WDS, 0xA2, 0x00, P_686 or P_AVX, 0,0x08, RWF_VEX or RWF_EVEX or RWF_T1S, VX_L or VX_NND or VX_RW0 )
 = 6C7                      *1C T_VSCATTERDPS equ 0x6C7
                              C insv(VSCATTERQPS,   vscatterqps,   OpCls( M32_M64, XMM,   NONE ), F_660F38, 0, no_WDS, 0xA3, 0x00, P_686 or P_AVX, 0,0x08, RWF_VEX or RWF_EVEX or RWF_T1S, VX_L or VX_NND or VX_RW0 )
 = 6C8                      *1C T_VSCATTERQPS equ 0x6C8
                              C insv(VPSCATTERDD, vpscatterdd,     OpCls( M32_M64, XMM,   NONE ), F_660F38, 0, no_WDS, 0xA0, 0x00, P_686 or P_AVX, 0,0x08, RWF_VEX or RWF_EVEX or RWF_T1S, VX_L or VX_NND or VX_RW0 )
 = 6C9                      *1C T_VPSCATTERDD equ 0x6C9
                              C insv(VPSCATTERQD, vpscatterqd,     OpCls( M32_M64, XMM,   NONE ), F_660F38, 0, no_WDS, 0xA1, 0x00, P_686 or P_AVX, 0,0x08, RWF_VEX or RWF_EVEX or RWF_T1S, VX_L or VX_NND or VX_RW0 )
 = 6CA                      *1C T_VPSCATTERQD equ 0x6CA
                              C insv(VSCATTERPF0DPS, vscatterpf0dps, OpCls(M32_M512,NONE, NONE ), F_660F38, 0, no_WDS, 0xC6, 0x28, P_686 or P_AVX, 0,0x98, RWF_VEX or RWF_EVEX or RWF_T1S, VX_L or VX_NND or VX_RW0 )
 = 6CB                      *1C T_VSCATTERPF0DPS equ 0x6CB
                              C insv(VSCATTERPF0QPS, vscatterpf0qps, OpCls(M64_M512,NONE, NONE ), F_660F38, 0, no_WDS, 0xC7, 0x28, P_686 or P_AVX, 0,0x98, RWF_VEX or RWF_EVEX or RWF_T1S, VX_L or VX_NND or VX_RW0 )
 = 6CC                      *1C T_VSCATTERPF0QPS equ 0x6CC
                              C insv(VSCATTERPF0DPD, vscatterpf0dpd, OpCls(M32_M256,NONE, NONE ), F_660F38, 0, no_WDS, 0xC6, 0x28, P_686 or P_AVX, 0,0x98, RWF_VEX or RWF_EVEX or RWF_T1S, VX_L or VX_NND or VX_RW1 )
 = 6CD                      *1C T_VSCATTERPF0DPD equ 0x6CD
                              C insv(VSCATTERPF0QPD, vscatterpf0qpd, OpCls(M64_M256,NONE, NONE ), F_660F38, 0, no_WDS, 0xC7, 0x28, P_686 or P_AVX, 0,0x98, RWF_VEX or RWF_EVEX or RWF_T1S, VX_L or VX_NND or VX_RW1 )
 = 6CE                      *1C T_VSCATTERPF0QPD equ 0x6CE
                              C insv(VSCATTERPF1DPS, vscatterpf1dps, OpCls(M32_M512,NONE, NONE ), F_660F38, 0, no_WDS, 0xC6, 0x30, P_686 or P_AVX, 0,0x98, RWF_VEX or RWF_EVEX or RWF_T1S, VX_L or VX_NND or VX_RW0 )
 = 6CF                      *1C T_VSCATTERPF1DPS equ 0x6CF
                              C insv(VSCATTERPF1QPS, vscatterpf1qps, OpCls(M64_M512,NONE, NONE ), F_660F38, 0, no_WDS, 0xC7, 0x30, P_686 or P_AVX, 0,0x98, RWF_VEX or RWF_EVEX or RWF_T1S, VX_L or VX_NND or VX_RW0 )
 = 6D0                      *1C T_VSCATTERPF1QPS equ 0x6D0
                              C insv(VSCATTERPF1DPD, vscatterpf1dpd, OpCls(M32_M256,NONE, NONE ), F_660F38, 0, no_WDS, 0xC6, 0x30, P_686 or P_AVX, 0,0x98, RWF_VEX or RWF_EVEX or RWF_T1S, VX_L or VX_NND or VX_RW1 )
 = 6D1                      *1C T_VSCATTERPF1DPD equ 0x6D1
                              C insv(VSCATTERPF1QPD, vscatterpf1qpd, OpCls(M64_M512,NONE, NONE ), F_660F38, 0, no_WDS, 0xC7, 0x30, P_686 or P_AVX, 0,0x98, RWF_VEX or RWF_EVEX or RWF_T1S, VX_L or VX_NND or VX_RW1 )
 = 6D2                      *1C T_VSCATTERPF1QPD equ 0x6D2
                              C insv(VGETEXPPD, vgetexppd,   OpCls( XMM,    XMM_M128_M64, NONE ), F_660F38, 1, no_WDS, 0x42, 0x00, P_686 or P_AVX, 0,0x60, RWF_VEX or RWF_EVEX, VX_L or VX_NND or VX_RW1 )
 = 6D3                      *1C T_VGETEXPPD equ 0x6D3
                              C insv(VGETEXPPS, vgetexpps,   OpCls( XMM,    XMM_M128_M32, NONE ), F_660F38, 1, no_WDS, 0x42, 0x00, P_686 or P_AVX, 0,0x60, RWF_VEX or RWF_EVEX, VX_L or VX_NND or VX_RW0 )
 = 6D4                      *1C T_VGETEXPPS equ 0x6D4
                              C insv(VGETEXPSD, vgetexpsd,   OpCls( XMM,    XMM_M128_M64, NONE ), F_660F38, 1, no_WDS, 0x43, 0x00, P_686 or P_AVX, 0,0x60, RWF_VEX or RWF_EVEX or RWF_T1S, VX_L or VX_RW1 )
 = 6D5                      *1C T_VGETEXPSD equ 0x6D5
                              C insv(VGETEXPSS, vgetexpss,   OpCls( XMM,    XMM_M128_M32, NONE ), F_660F38, 1, no_WDS, 0x43, 0x00, P_686 or P_AVX, 0,0x60, RWF_VEX or RWF_EVEX or RWF_T1S, VX_L or VX_RW0 )
 = 6D6                      *1C T_VGETEXPSS equ 0x6D6
                              C insv(VRSQRT14PD, vrsqrt14pd, OpCls( XMM,    XMM_M128_M64, NONE ), F_660F38, 1, no_WDS, 0x4E, 0x00, P_686 or P_AVX, 0,0x60, RWF_VEX or RWF_EVEX, VX_L or VX_NND or VX_HALF or VX_RW1 )
 = 6D7                      *1C T_VRSQRT14PD equ 0x6D7
                              C insv(VRSQRT14PS, vrsqrt14ps, OpCls( XMM,    XMM_M128_M32, NONE ), F_660F38, 1, no_WDS, 0x4E, 0x00, P_686 or P_AVX, 0,0xF0, RWF_VEX or RWF_EVEX, VX_L or VX_NND or VX_HALF or VX_RW0 )
 = 6D8                      *1C T_VRSQRT14PS equ 0x6D8
                              C insv(VRSQRT14SD, vrsqrt14sd, OpCls( XMM,    XMM_M128_M64, NONE ), F_660F38, 1, no_WDS, 0x4F, 0x00, P_686 or P_AVX, 0,0x60, RWF_VEX or RWF_EVEX or RWF_T1S, VX_L or VX_RW1 )
 = 6D9                      *1C T_VRSQRT14SD equ 0x6D9
                              C insv(VRSQRT14SS, vrsqrt14ss, OpCls( XMM,    XMM_M128_M32, NONE ), F_660F38, 1, no_WDS, 0x4F, 0x00, P_686 or P_AVX, 0,0x60, RWF_VEX or RWF_EVEX or RWF_T1S, VX_L or VX_RW0 )
 = 6DA                      *1C T_VRSQRT14SS equ 0x6DA
                              C insv(VRSQRT28PD, vrsqrt28pd, OpCls( ZMM,    ZMM_M512_M64, NONE ), F_660F38, 1, no_WDS, 0xCC, 0x00, P_686 or P_AVX, 0,0x60, RWF_VEX or RWF_EVEX, VX_L or VX_NND or VX_HALF or VX_RW1 )
 = 6DB                      *1C T_VRSQRT28PD equ 0x6DB
                              C insv(VRSQRT28PS, vrsqrt28ps, OpCls( ZMM,    ZMM_M512_M32, NONE ), F_660F38, 1, no_WDS, 0xCC, 0x00, P_686 or P_AVX, 0,0x60, RWF_VEX or RWF_EVEX, VX_L or VX_NND or VX_HALF or VX_RW0 )
 = 6DC                      *1C T_VRSQRT28PS equ 0x6DC
                              C insv(VRSQRT28SD, vrsqrt28sd, OpCls( XMM,    XMM_M128_M64, NONE ), F_660F38, 1, no_WDS, 0xCD, 0x00, P_686 or P_AVX, 0,0x60, RWF_VEX or RWF_EVEX or RWF_T1S, VX_L or VX_RW1 )
 = 6DD                      *1C T_VRSQRT28SD equ 0x6DD
                              C insv(VRSQRT28SS, vrsqrt28ss, OpCls( XMM,    XMM_M128_M32, NONE ), F_660F38, 1, no_WDS, 0xCD, 0x00, P_686 or P_AVX, 0,0x60, RWF_VEX or RWF_EVEX or RWF_T1S, VX_L or VX_RW0 )
 = 6DE                      *1C T_VRSQRT28SS equ 0x6DE
                              C insv(VGETMANTPD, vgetmantpd, OpCls( XMM,    XMM_M128_M64, I8_U ), F_660F3A, 1, no_WDS, 0x26, 0x00, P_686 or P_AVX, 0,0xA0, RWF_VEX or RWF_EVEX, VX_L or VX_NND or VX_RW1 )
 = 6DF                      *1C T_VGETMANTPD equ 0x6DF
                              C insv(VGETMANTPS, vgetmantps, OpCls( XMM,    XMM_M128_M32, I8_U ), F_660F3A, 1, no_WDS, 0x26, 0x00, P_686 or P_AVX, 0,0xA0, RWF_VEX or RWF_EVEX, VX_L or VX_NND or VX_RW0 )
 = 6E0                      *1C T_VGETMANTPS equ 0x6E0
                              C insv(VGETMANTSD, vgetmantsd, OpCls( XMM,    XMM_M128_M64, I8_U ), F_660F3A, 1, no_WDS, 0x27, 0x00, P_686 or P_AVX, 0,0x60, RWF_VEX or RWF_EVEX or RWF_T1S, VX_L or VX_RW1 )
 = 6E1                      *1C T_VGETMANTSD equ 0x6E1
                              C insv(VGETMANTSS, vgetmantss, OpCls( XMM,    XMM_M128_M32, I8_U ), F_660F3A, 1, no_WDS, 0x27, 0x00, P_686 or P_AVX, 0,0x60, RWF_VEX or RWF_EVEX or RWF_T1S, VX_L or VX_RW0 )
 = 6E2                      *1C T_VGETMANTSS equ 0x6E2
                              C insv(VPEXPANDD, vpexpandd,   OpCls( XMM,    XMM_M128,     NONE ), F_660F38, 1, no_WDS, 0x89, 0x00, P_686 or P_AVX, 0,0x60, RWF_VEX or RWF_EVEX or RWF_T1S, VX_L or VX_NND or VX_RW0 )
 = 6E3                      *1C T_VPEXPANDD equ 0x6E3
                              C insv(VRCP14PD, vrcp14pd,     OpCls( XMM,    XMM_M128_M64, NONE ), F_660F38, 1, no_WDS, 0x4C, 0x00, P_686 or P_AVX, 0,0x60, RWF_VEX or RWF_EVEX, VX_L or VX_NND or VX_RW1 )
 = 6E4                      *1C T_VRCP14PD equ 0x6E4
                              C insv(VRCP14PS, vrcp14ps,     OpCls( XMM,    XMM_M128_M32, NONE ), F_660F38, 1, no_WDS, 0x4C, 0x00, P_686 or P_AVX, 0,0x60, RWF_VEX or RWF_EVEX, VX_L or VX_NND or VX_RW0 )
 = 6E5                      *1C T_VRCP14PS equ 0x6E5
                              C insv(VRCP14SD, vrcp14sd,     OpCls( XMM,    XMM_M128_M64, NONE ), F_660F38, 1, no_WDS, 0x4D, 0x00, P_686 or P_AVX, 0,0x60, RWF_VEX or RWF_EVEX or RWF_T1S, VX_L or VX_RW1 )
 = 6E6                      *1C T_VRCP14SD equ 0x6E6
                              C insv(VRCP14SS, vrcp14ss,     OpCls( XMM,    XMM_M128_M32, NONE ), F_660F38, 1, no_WDS, 0x4D, 0x00, P_686 or P_AVX, 0,0x60, RWF_VEX or RWF_EVEX or RWF_T1S, VX_L or VX_RW0 )
 = 6E7                      *1C T_VRCP14SS equ 0x6E7
                              C insv(VREDUCEPD, vreducepd,   OpCls( XMM,    XMM_M128_M64, I8_U ), F_660F3A, 1, no_WDS, 0x56, 0x00, P_686 or P_AVX, 0,0xF0, RWF_VEX or RWF_EVEX, VX_L or VX_NND or VX_RW1 )
 = 6E8                      *1C T_VREDUCEPD equ 0x6E8
                              C insv(VREDUCEPS, vreduceps,   OpCls( XMM,    XMM_M128_M32, I8_U ), F_660F3A, 1, no_WDS, 0x56, 0x00, P_686 or P_AVX, 0,0xF0, RWF_VEX or RWF_EVEX, VX_L or VX_NND or VX_RW0 )
 = 6E9                      *1C T_VREDUCEPS equ 0x6E9
                              C insv(VREDUCESD, vreducesd,   OpCls( XMM,    XMM_M128_M64, I8_U ), F_660F3A, 1, no_WDS, 0x57, 0x00, P_686 or P_AVX, 0,0xF0, RWF_VEX or RWF_EVEX or RWF_T1S, VX_L or VX_RW1 )
 = 6EA                      *1C T_VREDUCESD equ 0x6EA
                              C insv(VREDUCESS, vreducess,   OpCls( XMM,    XMM_M128_M32, I8_U ), F_660F3A, 1, no_WDS, 0x57, 0x00, P_686 or P_AVX, 0,0xF0, RWF_VEX or RWF_EVEX or RWF_T1S, VX_L or VX_RW0 )
 = 6EB                      *1C T_VREDUCESS equ 0x6EB
                              C insv(VRNDSCALEPD, vrndscalepd, OpCls(XMM,   XMM_M128_M64, I8_U ), F_660F3A, 1, no_WDS, 0x09, 0x00, P_686 or P_AVX, 0,0x80, RWF_VEX or RWF_EVEX, VX_L or VX_NND or VX_RW1 )
 = 6EC                      *1C T_VRNDSCALEPD equ 0x6EC
                              C insv(VRNDSCALEPS, vrndscaleps, OpCls(XMM,   XMM_M128_M32, I8_U ), F_660F3A, 1, no_WDS, 0x08, 0x00, P_686 or P_AVX, 0,0x80, RWF_VEX or RWF_EVEX, VX_L or VX_NND or VX_RW0 )
 = 6ED                      *1C T_VRNDSCALEPS equ 0x6ED
                              C insv(VRNDSCALESD, vrndscalesd, OpCls(XMM,   XMM_M128_M64, I8_U ), F_660F3A, 1, no_WDS, 0x0B, 0x00, P_686 or P_AVX, 0,0xF0, RWF_VEX or RWF_EVEX or RWF_T1S, VX_L or VX_RW1 )
 = 6EE                      *1C T_VRNDSCALESD equ 0x6EE
                              C insv(VRNDSCALESS, vrndscaless, OpCls(XMM,   XMM_M128_M32, I8_U ), F_660F3A, 1, no_WDS, 0x0A, 0x00, P_686 or P_AVX, 0,0xF0, RWF_VEX or RWF_EVEX or RWF_T1S, VX_L or VX_RW0 )
 = 6EF                      *1C T_VRNDSCALESS equ 0x6EF
                              C insv(VPMOVB2M, vpmovb2m,     OpCls( K,      XMM,          NONE ), F_F30F38, 1, no_WDS, 0x29, 0x00, P_686 or P_AVX, 0,0xF0, RWF_VEX or RWF_EVEX, VX_L or VX_HALF or VX_RW0 )
 = 6F0                      *1C T_VPMOVB2M equ 0x6F0
                              C insv(VPMOVD2M, vpmovd2m,     OpCls( K,      XMM,          NONE ), F_F30F38, 1, no_WDS, 0x39, 0x00, P_686 or P_AVX, 0,0xF0, RWF_VEX or RWF_EVEX, VX_L or VX_HALF or VX_RW0 )
 = 6F1                      *1C T_VPMOVD2M equ 0x6F1
                              C insv(VPMOVM2B, vpmovm2b,     OpCls( XMM,    K,            NONE ), F_F30F38, 1, no_WDS, 0x28, 0x00, P_686 or P_AVX, 0,0xF0, RWF_VEX or RWF_EVEX, VX_L or VX_HALF or VX_RW0 )
 = 6F2                      *1C T_VPMOVM2B equ 0x6F2
                              C insv(VPMOVM2D, vpmovm2d,     OpCls( XMM,    K,            NONE ), F_F30F38, 1, no_WDS, 0x38, 0x00, P_686 or P_AVX, 0,0xF0, RWF_VEX or RWF_EVEX, VX_L or VX_HALF or VX_RW0 )
 = 6F3                      *1C T_VPMOVM2D equ 0x6F3
                              C insv(VPMOVDB, vpmovdb,       OpCls( XMM_MXQD,  XYZMM,     NONE ), F_F30F38, 0, no_WDS, 0x31, 0x00, P_686 or P_AVX, 0,0x80, RWF_VEX or RWF_EVEX or RWF_QVM, VX_L or VX_NND or VX_RW0 )
 = 6F4                      *1C T_VPMOVDB equ 0x6F4
                              C insv(VPMOVDW, vpmovdw,       OpCls( XMM_MXQ,   XYZMM,     NONE ), F_F30F38, 0, no_WDS, 0x33, 0x00, P_686 or P_AVX, 0,0x80, RWF_VEX or RWF_EVEX or RWF_QVM, VX_L or VX_NND or VX_RW0 )
 = 6F5                      *1C T_VPMOVDW equ 0x6F5
                              C insv(VPMOVQB, vpmovqb,       OpCls( XMM_MXQDW, XYZMM,     NONE ), F_F30F38, 0, no_WDS, 0x32, 0x00, P_686 or P_AVX, 0,0x80, RWF_VEX or RWF_EVEX or RWF_QVM, VX_L or VX_NND or VX_RW0 )
 = 6F6                      *1C T_VPMOVQB equ 0x6F6
                              C insv(VPMOVQD, vpmovqd,       OpCls( XMM_MXQD,  XYZMM,     NONE ), F_F30F38, 0, no_WDS, 0x35, 0x00, P_686 or P_AVX, 0,0x80, RWF_VEX or RWF_EVEX or RWF_QVM, VX_L or VX_NND or VX_RW0 )
 = 6F7                      *1C T_VPMOVQD equ 0x6F7
                              C insv(VPMOVQW, vpmovqw,       OpCls( XMM_MXQD,  XYZMM,     NONE ), F_F30F38, 0, no_WDS, 0x34, 0x00, P_686 or P_AVX, 0,0x80, RWF_VEX or RWF_EVEX or RWF_QVM, VX_L or VX_NND or VX_RW0 )
 = 6F8                      *1C T_VPMOVQW equ 0x6F8
                              C insv(VPMOVWB, vpmovwb,       OpCls( XMM_MXQ,   XYZMM,     NONE ), F_F30F38, 0, no_WDS, 0x30, 0x00, P_686 or P_AVX, 0,0x80, RWF_VEX or RWF_EVEX or RWF_QVM, VX_L or VX_NND or VX_RW0 )
 = 6F9                      *1C T_VPMOVWB equ 0x6F9
                              C insv(VPMOVSDB, vpmovsdb,     OpCls( XMM_MXQD,  XYZMM,     NONE ), F_F30F38, 0, no_WDS, 0x21, 0x00, P_686 or P_AVX, 0,0x60, RWF_VEX or RWF_EVEX or RWF_QVM, VX_L or VX_NND or VX_RW0 )
 = 6FA                      *1C T_VPMOVSDB equ 0x6FA
                              C insv(VPMOVSDW, vpmovsdw,     OpCls( XMM_MXQ,   XYZMM,     NONE ), F_F30F38, 0, no_WDS, 0x23, 0x00, P_686 or P_AVX, 0,0x60, RWF_VEX or RWF_EVEX or RWF_QVM, VX_L or VX_NND or VX_RW0 )
 = 6FB                      *1C T_VPMOVSDW equ 0x6FB
                              C insv(VPMOVSQB, vpmovsqb,     OpCls( XMM_MXQDW, XYZMM,     NONE ), F_F30F38, 0, no_WDS, 0x22, 0x00, P_686 or P_AVX, 0,0x60, RWF_VEX or RWF_EVEX or RWF_QVM, VX_L or VX_NND or VX_RW0 )
 = 6FC                      *1C T_VPMOVSQB equ 0x6FC
                              C insv(VPMOVSQD, vpmovsqd,     OpCls( XMM_MXQD,  XYZMM,     NONE ), F_F30F38, 0, no_WDS, 0x25, 0x00, P_686 or P_AVX, 0,0x60, RWF_VEX or RWF_EVEX or RWF_QVM, VX_L or VX_NND or VX_RW0 )
 = 6FD                      *1C T_VPMOVSQD equ 0x6FD
                              C insv(VPMOVSQW, vpmovsqw,     OpCls( XMM_MXQD,  XYZMM,     NONE ), F_F30F38, 0, no_WDS, 0x24, 0x00, P_686 or P_AVX, 0,0x60, RWF_VEX or RWF_EVEX or RWF_QVM, VX_L or VX_NND or VX_RW0 )
 = 6FE                      *1C T_VPMOVSQW equ 0x6FE
                              C insv(VPMOVSWB, vpmovswb,     OpCls( XMM_MXQ,   XYZMM,     NONE ), F_F30F38, 0, no_WDS, 0x20, 0x00, P_686 or P_AVX, 0,0xF0, RWF_VEX or RWF_EVEX or RWF_QVM, VX_L or VX_NND or VX_RW0 )
 = 6FF                      *1C T_VPMOVSWB equ 0x6FF
                              C insv(VPMOVUSDB, vpmovusdb,   OpCls( XMM_MXQD,  XYZMM,     NONE ), F_F30F38, 0, no_WDS, 0x11, 0x00, P_686 or P_AVX, 0,0x60, RWF_VEX or RWF_EVEX or RWF_QVM, VX_L or VX_NND or VX_RW0 )
 = 700                      *1C T_VPMOVUSDB equ 0x700
                              C insv(VPMOVUSDW, vpmovusdw,   OpCls( XMM_MXQ,   XYZMM,     NONE ), F_F30F38, 0, no_WDS, 0x13, 0x00, P_686 or P_AVX, 0,0x60, RWF_VEX or RWF_EVEX or RWF_QVM, VX_L or VX_NND or VX_RW0 )
 = 701                      *1C T_VPMOVUSDW equ 0x701
                              C insv(VPMOVUSQB, vpmovusqb,   OpCls( XMM_MXQDW, XYZMM,     NONE ), F_F30F38, 0, no_WDS, 0x12, 0x00, P_686 or P_AVX, 0,0x60, RWF_VEX or RWF_EVEX or RWF_QVM, VX_L or VX_NND or VX_RW0 )
 = 702                      *1C T_VPMOVUSQB equ 0x702
                              C insv(VPMOVUSQD, vpmovusqd,   OpCls( XMM_MXQD,  XYZMM,     NONE ), F_F30F38, 0, no_WDS, 0x15, 0x00, P_686 or P_AVX, 0,0x60, RWF_VEX or RWF_EVEX or RWF_QVM, VX_L or VX_NND or VX_RW0 )
 = 703                      *1C T_VPMOVUSQD equ 0x703
                              C insv(VPMOVUSQW, vpmovusqw,   OpCls( XMM_MXQD,  XYZMM,     NONE ), F_F30F38, 0, no_WDS, 0x14, 0x00, P_686 or P_AVX, 0,0x60, RWF_VEX or RWF_EVEX or RWF_QVM, VX_L or VX_NND or VX_RW0 )
 = 704                      *1C T_VPMOVUSQW equ 0x704
                              C insv(VPMOVUSWB, vpmovuswb,   OpCls( XMM_MXQ,   XYZMM,     NONE ), F_F30F38, 0, no_WDS, 0x10, 0x00, P_686 or P_AVX, 0,0xF0, RWF_VEX or RWF_EVEX or RWF_QVM, VX_L or VX_NND or VX_RW0 )
 = 705                      *1C T_VPMOVUSWB equ 0x705
                              C insv(VALIGND, valignd,       OpCls( XMM,    XMM_M128_M32, I8_U ), F_660F3A, 1, no_WDS, 0x03, 0x00, P_686 or P_AVX, 0,0xF0, RWF_VEX or RWF_EVEX, VX_L or VX_RW0 )
 = 706                      *1C T_VALIGND equ 0x706
                              C insv(VALIGNQ, valignq,       OpCls( XMM,    XMM_M128_M64, I8_U ), F_660F3A, 1, no_WDS, 0x03, 0x00, P_686 or P_AVX, 0,0xF0, RWF_VEX or RWF_EVEX, VX_L or VX_RW1 )
 = 707                      *1C T_VALIGNQ equ 0x707
                              C insv(VBLENDMPD, vblendmpd,   OpCls( XMM,    XMM_M128_M64, NONE ), F_660F38, 1, no_WDS, 0x65, 0x00, P_686 or P_AVX, 0,0xF0, RWF_VEX or RWF_EVEX, VX_L or VX_RW1 )
 = 708                      *1C T_VBLENDMPD equ 0x708
                              C insv(VBLENDMPS, vblendmps,   OpCls( XMM,    XMM_M128_M32, NONE ), F_660F38, 1, no_WDS, 0x65, 0x00, P_686 or P_AVX, 0,0xF0, RWF_VEX or RWF_EVEX, VX_L or VX_RW0 )
 = 709                      *1C T_VBLENDMPS equ 0x709
                              C 
                              C insv(VFMADD132PD, vfmadd132pd, OpCls( XMM, XMM_M128_M64,  NONE ), F_660F38, 1, no_WDS, 0x98, 0x00, P_686 or P_AVX, 0,0xF0, RWF_VEX, VX_L or VX_RW1 )
 = 70A                      *1C T_VFMADD132PD equ 0x70A
                              C insv(VFMADD213PD, vfmadd213pd, OpCls( XMM, XMM_M128_M64,  NONE ), F_660F38, 1, no_WDS, 0xA8, 0x00, P_686 or P_AVX, 0,0xF0, RWF_VEX, VX_L or VX_RW1 )
 = 70B                      *1C T_VFMADD213PD equ 0x70B
                              C insv(VFMADD231PD, vfmadd231pd, OpCls( XMM, XMM_M128_M64,  NONE ), F_660F38, 1, no_WDS, 0xB8, 0x00, P_686 or P_AVX, 0,0xF0, RWF_VEX, VX_L or VX_RW1 )
 = 70C                      *1C T_VFMADD231PD equ 0x70C
                              C insv(VFMADD132PS, vfmadd132ps, OpCls( XMM, XMM_M128_M32,  NONE ), F_660F38, 1, no_WDS, 0x98, 0x00, P_686 or P_AVX, 0,0xF0, RWF_VEX, VX_L or VX_RW0 )
 = 70D                      *1C T_VFMADD132PS equ 0x70D
                              C insv(VFMADD213PS, vfmadd213ps, OpCls( XMM, XMM_M128_M32,  NONE ), F_660F38, 1, no_WDS, 0xA8, 0x00, P_686 or P_AVX, 0,0xF0, RWF_VEX, VX_L or VX_RW0 )
 = 70E                      *1C T_VFMADD213PS equ 0x70E
                              C insv(VFMADD231PS, vfmadd231ps, OpCls( XMM, XMM_M128_M32,  NONE ), F_660F38, 1, no_WDS, 0xB8, 0x00, P_686 or P_AVX, 0,0xF0, RWF_VEX, VX_L or VX_RW0 )
 = 70F                      *1C T_VFMADD231PS equ 0x70F
                              C insv(VFMADD132SD, vfmadd132sd, OpCls( XMM, XMM_M64,       NONE ), F_660F38, 1, no_WDS, 0x99, 0x00, P_686 or P_AVX, 0,0xF0, RWF_VEX or RWF_T1S, VX_L or VX_RW1 )
 = 710                      *1C T_VFMADD132SD equ 0x710
                              C insv(VFMADD213SD, vfmadd213sd, OpCls( XMM, XMM_M64,       NONE ), F_660F38, 1, no_WDS, 0xA9, 0x00, P_686 or P_AVX, 0,0xF0, RWF_VEX or RWF_T1S, VX_L or VX_RW1 )
 = 711                      *1C T_VFMADD213SD equ 0x711
                              C insv(VFMADD231SD, vfmadd231sd, OpCls( XMM, XMM_M64,       NONE ), F_660F38, 1, no_WDS, 0xB9, 0x00, P_686 or P_AVX, 0,0xF0, RWF_VEX or RWF_T1S, VX_L or VX_RW1 )
 = 712                      *1C T_VFMADD231SD equ 0x712
                              C insv(VFMADD132SS, vfmadd132ss, OpCls( XMM, XMM_M128_M32,  NONE ), F_660F38, 1, no_WDS, 0x99, 0x00, P_686 or P_AVX, 0,0xF0, RWF_VEX, VX_L or VX_RW0 )
 = 713                      *1C T_VFMADD132SS equ 0x713
                              C insv(VFMADD213SS, vfmadd213ss, OpCls( XMM, XMM_M128_M32,  NONE ), F_660F38, 1, no_WDS, 0xA9, 0x00, P_686 or P_AVX, 0,0xF0, RWF_VEX, VX_L or VX_RW0 )
 = 714                      *1C T_VFMADD213SS equ 0x714
                              C insv(VFMADD231SS, vfmadd231ss, OpCls( XMM, XMM_M128_M32,  NONE ), F_660F38, 1, no_WDS, 0xB9, 0x00, P_686 or P_AVX, 0,0xF0, RWF_VEX, VX_L or VX_RW0 )
 = 715                      *1C T_VFMADD231SS equ 0x715
                              C 
                              C insv(VFMSUB132PD, vfmsub132pd, OpCls( XMM, XMM_M128_M64,  NONE ), F_660F38, 1, no_WDS, 0x9A, 0x00, P_686 or P_AVX, 0,0xF0, RWF_VEX, VX_L or VX_RW1 )
 = 716                      *1C T_VFMSUB132PD equ 0x716
                              C insv(VFMSUB213PD, vfmsub213pd, OpCls( XMM, XMM_M128_M64,  NONE ), F_660F38, 1, no_WDS, 0xAA, 0x00, P_686 or P_AVX, 0,0xF0, RWF_VEX, VX_L or VX_RW1 )
 = 717                      *1C T_VFMSUB213PD equ 0x717
                              C insv(VFMSUB231PD, vfmsub231pd, OpCls( XMM, XMM_M128_M64,  NONE ), F_660F38, 1, no_WDS, 0xBA, 0x00, P_686 or P_AVX, 0,0xF0, RWF_VEX, VX_L or VX_RW1 )
 = 718                      *1C T_VFMSUB231PD equ 0x718
                              C insv(VFMSUB132PS, vfmsub132ps, OpCls( XMM, XMM_M128_M32,  NONE ), F_660F38, 1, no_WDS, 0x9A, 0x00, P_686 or P_AVX, 0,0xF0, RWF_VEX, VX_L or VX_RW0 )
 = 719                      *1C T_VFMSUB132PS equ 0x719
                              C insv(VFMSUB213PS, vfmsub213ps, OpCls( XMM, XMM_M128_M32,  NONE ), F_660F38, 1, no_WDS, 0xAA, 0x00, P_686 or P_AVX, 0,0xF0, RWF_VEX, VX_L or VX_RW0 )
 = 71A                      *1C T_VFMSUB213PS equ 0x71A
                              C insv(VFMSUB231PS, vfmsub231ps, OpCls( XMM, XMM_M128_M32,  NONE ), F_660F38, 1, no_WDS, 0xBA, 0x00, P_686 or P_AVX, 0,0xF0, RWF_VEX, VX_L or VX_RW0 )
 = 71B                      *1C T_VFMSUB231PS equ 0x71B
                              C 
                              C insv(VFMSUB132SD, vfmsub132sd, OpCls( XMM, XMM_M64,       NONE ), F_660F38, 1, no_WDS, 0x9B, 0x00, P_686 or P_AVX, 0,0x80, RWF_VEX or RWF_T1S, VX_L or VX_RW1 )
 = 71C                      *1C T_VFMSUB132SD equ 0x71C
                              C insv(VFMSUB213SD, vfmsub213sd, OpCls( XMM, XMM_M64,       NONE ), F_660F38, 1, no_WDS, 0xAB, 0x00, P_686 or P_AVX, 0,0x80, RWF_VEX or RWF_T1S, VX_L or VX_RW1 )
 = 71D                      *1C T_VFMSUB213SD equ 0x71D
                              C insv(VFMSUB231SD, vfmsub231sd, OpCls( XMM, XMM_M64,       NONE ), F_660F38, 1, no_WDS, 0xBB, 0x00, P_686 or P_AVX, 0,0x80, RWF_VEX or RWF_T1S, VX_L or VX_RW1 )
 = 71E                      *1C T_VFMSUB231SD equ 0x71E
                              C insv(VFMSUB132SS, vfmsub132ss, OpCls( XMM, XMM_M128_M32,  NONE ), F_660F38, 1, no_WDS, 0x9B, 0x00, P_686 or P_AVX, 0,0x80, RWF_VEX, VX_L or VX_RW0 )
 = 71F                      *1C T_VFMSUB132SS equ 0x71F
                              C insv(VFMSUB213SS, vfmsub213ss, OpCls( XMM, XMM_M128_M32,  NONE ), F_660F38, 1, no_WDS, 0xAB, 0x00, P_686 or P_AVX, 0,0x80, RWF_VEX, VX_L or VX_RW0 )
 = 720                      *1C T_VFMSUB213SS equ 0x720
                              C insv(VFMSUB231SS, vfmsub231ss, OpCls( XMM, XMM_M128_M32,  NONE ), F_660F38, 1, no_WDS, 0xBB, 0x00, P_686 or P_AVX, 0,0x80, RWF_VEX, VX_L or VX_RW0 )
 = 721                      *1C T_VFMSUB231SS equ 0x721
                              C 
                              C insv(VFMADDSUB132PD, vfmaddsub132pd, OpCls( XMM, XMM_M128_M64,  NONE ), F_660F38, 1, no_WDS, 0x96, 0x00, P_686 or P_AVX, 0,0xF0, RWF_VEX, VX_L or VX_RW1 )
 = 722                      *1C T_VFMADDSUB132PD equ 0x722
                              C insv(VFMADDSUB213PD, vfmaddsub213pd, OpCls( XMM, XMM_M128_M64,  NONE ), F_660F38, 1, no_WDS, 0xA6, 0x00, P_686 or P_AVX, 0,0xF0, RWF_VEX, VX_L or VX_RW1 )
 = 723                      *1C T_VFMADDSUB213PD equ 0x723
                              C insv(VFMADDSUB231PD, vfmaddsub231pd, OpCls( XMM, XMM_M128_M64,  NONE ), F_660F38, 1, no_WDS, 0xB6, 0x00, P_686 or P_AVX, 0,0xF0, RWF_VEX, VX_L or VX_RW1 )
 = 724                      *1C T_VFMADDSUB231PD equ 0x724
                              C insv(VFMADDSUB132PS, vfmaddsub132ps, OpCls( XMM, XMM_M128_M32,  NONE ), F_660F38, 1, no_WDS, 0x96, 0x00, P_686 or P_AVX, 0,0xF0, RWF_VEX, VX_L or VX_RW0 )
 = 725                      *1C T_VFMADDSUB132PS equ 0x725
                              C insv(VFMADDSUB213PS, vfmaddsub213ps, OpCls( XMM, XMM_M128_M32,  NONE ), F_660F38, 1, no_WDS, 0xA6, 0x00, P_686 or P_AVX, 0,0xF0, RWF_VEX, VX_L or VX_RW0 )
 = 726                      *1C T_VFMADDSUB213PS equ 0x726
                              C insv(VFMADDSUB231PS, vfmaddsub231ps, OpCls( XMM, XMM_M128_M32,  NONE ), F_660F38, 1, no_WDS, 0xB6, 0x00, P_686 or P_AVX, 0,0xF0, RWF_VEX, VX_L or VX_RW0 )
 = 727                      *1C T_VFMADDSUB231PS equ 0x727
                              C 
                              C insv(VFMSUBADD132PD, vfmsubadd132pd, OpCls( XMM, XMM_M128_M64,  NONE ), F_660F38, 1, no_WDS, 0x97, 0x00, P_686 or P_AVX, 0,0xF0, RWF_VEX, VX_L or VX_RW1 )
 = 728                      *1C T_VFMSUBADD132PD equ 0x728
                              C insv(VFMSUBADD213PD, vfmsubadd213pd, OpCls( XMM, XMM_M128_M64,  NONE ), F_660F38, 1, no_WDS, 0xA7, 0x00, P_686 or P_AVX, 0,0xF0, RWF_VEX, VX_L or VX_RW1 )
 = 729                      *1C T_VFMSUBADD213PD equ 0x729
                              C insv(VFMSUBADD231PD, vfmsubadd231pd, OpCls( XMM, XMM_M128_M64,  NONE ), F_660F38, 1, no_WDS, 0xB7, 0x00, P_686 or P_AVX, 0,0xF0, RWF_VEX, VX_L or VX_RW1 )
 = 72A                      *1C T_VFMSUBADD231PD equ 0x72A
                              C insv(VFMSUBADD132PS, vfmsubadd132ps, OpCls( XMM, XMM_M128_M32,  NONE ), F_660F38, 1, no_WDS, 0x97, 0x00, P_686 or P_AVX, 0,0xF0, RWF_VEX, VX_L or VX_RW0 )
 = 72B                      *1C T_VFMSUBADD132PS equ 0x72B
                              C insv(VFMSUBADD213PS, vfmsubadd213ps, OpCls( XMM, XMM_M128_M32,  NONE ), F_660F38, 1, no_WDS, 0xA7, 0x00, P_686 or P_AVX, 0,0xF0, RWF_VEX, VX_L or VX_RW0 )
 = 72C                      *1C T_VFMSUBADD213PS equ 0x72C
                              C insv(VFMSUBADD231PS, vfmsubadd231ps, OpCls( XMM, XMM_M128_M32,  NONE ), F_660F38, 1, no_WDS, 0xB7, 0x00, P_686 or P_AVX, 0,0xF0, RWF_VEX, VX_L or VX_RW0 )
 = 72D                      *1C T_VFMSUBADD231PS equ 0x72D
                              C 
                              C insv(VFNMADD132PD, vfnmadd132pd, OpCls( XMM, XMM_M128_M64,  NONE ), F_660F38, 1, no_WDS, 0x9C, 0x00, P_686 or P_AVX, 0,0xF0, RWF_VEX, VX_L or VX_RW1 )
 = 72E                      *1C T_VFNMADD132PD equ 0x72E
                              C insv(VFNMADD213PD, vfnmadd213pd, OpCls( XMM, XMM_M128_M64,  NONE ), F_660F38, 1, no_WDS, 0xAC, 0x00, P_686 or P_AVX, 0,0xF0, RWF_VEX, VX_L or VX_RW1 )
 = 72F                      *1C T_VFNMADD213PD equ 0x72F
                              C insv(VFNMADD231PD, vfnmadd231pd, OpCls( XMM, XMM_M128_M64,  NONE ), F_660F38, 1, no_WDS, 0xBC, 0x00, P_686 or P_AVX, 0,0xF0, RWF_VEX, VX_L or VX_RW1 )
 = 730                      *1C T_VFNMADD231PD equ 0x730
                              C insv(VFNMADD132PS, vfnmadd132ps, OpCls( XMM, XMM_M128_M32,  NONE ), F_660F38, 1, no_WDS, 0x9C, 0x00, P_686 or P_AVX, 0,0xF0, RWF_VEX, VX_L or VX_RW0 )
 = 731                      *1C T_VFNMADD132PS equ 0x731
                              C insv(VFNMADD213PS, vfnmadd213ps, OpCls( XMM, XMM_M128_M32,  NONE ), F_660F38, 1, no_WDS, 0xAC, 0x00, P_686 or P_AVX, 0,0xF0, RWF_VEX, VX_L or VX_RW0 )
 = 732                      *1C T_VFNMADD213PS equ 0x732
                              C insv(VFNMADD231PS, vfnmadd231ps, OpCls( XMM, XMM_M128_M32,  NONE ), F_660F38, 1, no_WDS, 0xBC, 0x00, P_686 or P_AVX, 0,0xF0, RWF_VEX, VX_L or VX_RW0 )
 = 733                      *1C T_VFNMADD231PS equ 0x733
                              C 
                              C insv(VFNMADD132SD, vfnmadd132sd, OpCls( XMM, XMM_M64,       NONE ), F_660F38, 1, no_WDS, 0x9D, 0x00, P_686 or P_AVX, 0,0xF0, RWF_VEX or RWF_T1S, VX_L or VX_RW1 )
 = 734                      *1C T_VFNMADD132SD equ 0x734
                              C insv(VFNMADD213SD, vfnmadd213sd, OpCls( XMM, XMM_M64,       NONE ), F_660F38, 1, no_WDS, 0xAD, 0x00, P_686 or P_AVX, 0,0xF0, RWF_VEX or RWF_T1S, VX_L or VX_RW1 )
 = 735                      *1C T_VFNMADD213SD equ 0x735
                              C insv(VFNMADD231SD, vfnmadd231sd, OpCls( XMM, XMM_M64,       NONE ), F_660F38, 1, no_WDS, 0xBD, 0x00, P_686 or P_AVX, 0,0xF0, RWF_VEX or RWF_T1S, VX_L or VX_RW1 )
 = 736                      *1C T_VFNMADD231SD equ 0x736
                              C insv(VFNMADD132SS, vfnmadd132ss, OpCls( XMM, XMM_M128_M32,  NONE ), F_660F38, 1, no_WDS, 0x9D, 0x00, P_686 or P_AVX, 0,0xF0, RWF_VEX, VX_L or VX_RW0 )
 = 737                      *1C T_VFNMADD132SS equ 0x737
                              C insv(VFNMADD213SS, vfnmadd213ss, OpCls( XMM, XMM_M128_M32,  NONE ), F_660F38, 1, no_WDS, 0xAD, 0x00, P_686 or P_AVX, 0,0xF0, RWF_VEX, VX_L or VX_RW0 )
 = 738                      *1C T_VFNMADD213SS equ 0x738
                              C insv(VFNMADD231SS, vfnmadd231ss, OpCls( XMM, XMM_M128_M32,  NONE ), F_660F38, 1, no_WDS, 0xBD, 0x00, P_686 or P_AVX, 0,0xF0, RWF_VEX, VX_L or VX_RW0 )
 = 739                      *1C T_VFNMADD231SS equ 0x739
                              C 
                              C insv(VFNMSUB132PD, vfnmsub132pd, OpCls( XMM, XMM_M128_M64,  NONE ), F_660F38, 1, no_WDS, 0x9E, 0x00, P_686 or P_AVX, 0,0xF0, RWF_VEX, VX_L or VX_RW1 )
 = 73A                      *1C T_VFNMSUB132PD equ 0x73A
                              C insv(VFNMSUB213PD, vfnmsub213pd, OpCls( XMM, XMM_M128_M64,  NONE ), F_660F38, 1, no_WDS, 0xAE, 0x00, P_686 or P_AVX, 0,0xF0, RWF_VEX, VX_L or VX_RW1 )
 = 73B                      *1C T_VFNMSUB213PD equ 0x73B
                              C insv(VFNMSUB231PD, vfnmsub231pd, OpCls( XMM, XMM_M128_M64,  NONE ), F_660F38, 1, no_WDS, 0xBE, 0x00, P_686 or P_AVX, 0,0xF0, RWF_VEX, VX_L or VX_RW1 )
 = 73C                      *1C T_VFNMSUB231PD equ 0x73C
                              C insv(VFNMSUB132PS, vfnmsub132ps, OpCls( XMM, XMM_M128_M32,  NONE ), F_660F38, 1, no_WDS, 0x9E, 0x00, P_686 or P_AVX, 0,0xF0, RWF_VEX, VX_L or VX_RW0 )
 = 73D                      *1C T_VFNMSUB132PS equ 0x73D
                              C insv(VFNMSUB213PS, vfnmsub213ps, OpCls( XMM, XMM_M128_M32,  NONE ), F_660F38, 1, no_WDS, 0xAE, 0x00, P_686 or P_AVX, 0,0xF0, RWF_VEX, VX_L or VX_RW0 )
 = 73E                      *1C T_VFNMSUB213PS equ 0x73E
                              C insv(VFNMSUB231PS, vfnmsub231ps, OpCls( XMM, XMM_M128_M32,  NONE ), F_660F38, 1, no_WDS, 0xBE, 0x00, P_686 or P_AVX, 0,0xF0, RWF_VEX, VX_L or VX_RW0 )
 = 73F                      *1C T_VFNMSUB231PS equ 0x73F
                              C 
                              C insv(VFNMSUB132SD, vfnmsub132sd, OpCls( XMM, XMM_M64,       NONE ), F_660F38, 1, no_WDS, 0x9F, 0x00, P_686 or P_AVX, 0,0xF0, RWF_VEX or RWF_T1S, VX_L or VX_RW1 )
 = 740                      *1C T_VFNMSUB132SD equ 0x740
                              C insv(VFNMSUB213SD, vfnmsub213sd, OpCls( XMM, XMM_M64,       NONE ), F_660F38, 1, no_WDS, 0xAF, 0x00, P_686 or P_AVX, 0,0xF0, RWF_VEX or RWF_T1S, VX_L or VX_RW1 )
 = 741                      *1C T_VFNMSUB213SD equ 0x741
                              C insv(VFNMSUB231SD, vfnmsub231sd, OpCls( XMM, XMM_M64,       NONE ), F_660F38, 1, no_WDS, 0xBF, 0x00, P_686 or P_AVX, 0,0xF0, RWF_VEX or RWF_T1S, VX_L or VX_RW1 )
 = 742                      *1C T_VFNMSUB231SD equ 0x742
                              C insv(VFNMSUB132SS, vfnmsub132ss, OpCls( XMM, XMM_M128_M32,  NONE ), F_660F38, 1, no_WDS, 0x9F, 0x00, P_686 or P_AVX, 0,0xF0, RWF_VEX, VX_L or VX_RW0 )
 = 743                      *1C T_VFNMSUB132SS equ 0x743
                              C insv(VFNMSUB213SS, vfnmsub213ss, OpCls( XMM, XMM_M128_M32,  NONE ), F_660F38, 1, no_WDS, 0xAF, 0x00, P_686 or P_AVX, 0,0xF0, RWF_VEX, VX_L or VX_RW0 )
 = 744                      *1C T_VFNMSUB213SS equ 0x744
                              C insv(VFNMSUB231SS, vfnmsub231ss, OpCls( XMM, XMM_M128_M32,  NONE ), F_660F38, 1, no_WDS, 0xBF, 0x00, P_686 or P_AVX, 0,0xF0, RWF_VEX, VX_L or VX_RW0 )
 = 745                      *1C T_VFNMSUB231SS equ 0x745
                              C 
                              C insv(VINSERTF32X4, vinsertf32x4, OpCls( YMM, XMM_M128,      I8_U ), F_660F3A, 1, no_WDS, 0x18, 0x00, P_686 or P_AVX, 0,0xF0, RWF_VEX or RWF_EVEX, VX_L or VX_HALF or VX_RW0 )
 = 746                      *1C T_VINSERTF32X4 equ 0x746
                              C insv(VINSERTF64x2, vinsertf64x2, OpCls( YMM, XMM_M128,      I8_U ), F_660F3A, 1, no_WDS, 0x18, 0x00, P_686 or P_AVX, 0,0xF0, RWF_VEX or RWF_EVEX, VX_L or VX_RW1 )
 = 747                      *1C T_VINSERTF64x2 equ 0x747
                              C insv(VINSERTF32x8, vinsertf32x8, OpCls( YMM, XMM_M128,      I8_U ), F_660F3A, 1, no_WDS, 0x1A, 0x00, P_686 or P_AVX, 0,0xF0, RWF_VEX or RWF_EVEX, VX_L or VX_RW0 )
 = 748                      *1C T_VINSERTF32x8 equ 0x748
                              C insv(VINSERTF64x4, vinsertf64x4, OpCls( YMM, XMM_M128,      I8_U ), F_660F3A, 1, no_WDS, 0x1A, 0x00, P_686 or P_AVX, 0,0xF0, RWF_VEX or RWF_EVEX, VX_L or VX_RW1 )
 = 749                      *1C T_VINSERTF64x4 equ 0x749
                              C insv(VINSERTI32x4, vinserti32x4, OpCls( YMM, XMM_M128,      I8_U ), F_660F3A, 1, no_WDS, 0x38, 0x00, P_686 or P_AVX, 0,0xF0, RWF_VEX or RWF_EVEX, VX_L or VX_HALF or VX_RW0 )
 = 74A                      *1C T_VINSERTI32x4 equ 0x74A
                              C insv(VINSERTI64x2, vinserti64x2, OpCls( YMM, XMM_M128,      I8_U ), F_660F3A, 1, no_WDS, 0x38, 0x00, P_686 or P_AVX, 0,0xF0, RWF_VEX or RWF_EVEX, VX_L or VX_RW1 )
 = 74B                      *1C T_VINSERTI64x2 equ 0x74B
                              C insv(VINSERTI32x8, vinserti32x8, OpCls( YMM, XMM_M128,      I8_U ), F_660F3A, 1, no_WDS, 0x3A, 0x00, P_686 or P_AVX, 0,0xF0, RWF_VEX or RWF_EVEX, VX_L or VX_RW0 )
 = 74C                      *1C T_VINSERTI32x8 equ 0x74C
                              C insv(VINSERTI64x4, vinserti64x4, OpCls( YMM, XMM_M128,      I8_U ), F_660F3A, 1, no_WDS, 0x3A, 0x00, P_686 or P_AVX, 0,0xF0, RWF_VEX or RWF_EVEX, VX_L or VX_RW1 )
 = 74D                      *1C T_VINSERTI64x4 equ 0x74D
                              C 
                              C insv(VPABSQ, vpabsq,             OpCls( XMM,  XMM_M128_M64, NONE ), F_660F38, 1, no_WDS, 0x1F, 0x00, P_686 or P_AVX, 0,0xF0, RWF_VEX or RWF_EVEX, VX_L or VX_NND or VX_RW1 )
 = 74E                      *1C T_VPABSQ equ 0x74E
                              C insv(VPCMPB, vpcmpb,             OpCls( K,    XMM_M128_M32, I8_U ), F_660F3A, 1, no_WDS, 0x3F, 0x00, P_686 or P_AVX, 0,0xF0, RWF_VEX or RWF_EVEX, VX_L or VX_RW0 )
 = 74F                      *1C T_VPCMPB equ 0x74F
                              C insv(VPCMPD, vpcmpd,             OpCls( K,    XMM_M128_M32, I8_U ), F_660F3A, 1, no_WDS, 0x1F, 0x00, P_686 or P_AVX, 0,0xF0, RWF_VEX or RWF_EVEX, VX_L or VX_RW0 )
 = 750                      *1C T_VPCMPD equ 0x750
                              C insv(VPCMPQ, vpcmpq,             OpCls( K,    XMM_M128_M64, I8_U ), F_660F3A, 1, no_WDS, 0x1F, 0x00, P_686 or P_AVX, 0,0xF0, RWF_VEX or RWF_EVEX, VX_L or VX_RW1 )
 = 751                      *1C T_VPCMPQ equ 0x751
                              C insv(VPCMPUB, vpcmpub,           OpCls( K,    XMM_M128_M32, I8_U ), F_660F3A, 1, no_WDS, 0x3E, 0x00, P_686 or P_AVX, 0,0xF0, RWF_VEX or RWF_EVEX, VX_L or VX_RW0 )
 = 752                      *1C T_VPCMPUB equ 0x752
                              C insv(VPCMPUD, vpcmpud,           OpCls( K,    XMM_M128_M32, I8_U ), F_660F3A, 1, no_WDS, 0x1E, 0x00, P_686 or P_AVX, 0,0xF0, RWF_VEX or RWF_EVEX, VX_L or VX_RW0 )
 = 753                      *1C T_VPCMPUD equ 0x753
                              C insv(VPCMPUQ, vpcmpuq,           OpCls( K,    XMM_M128_M64, I8_U ), F_660F3A, 1, no_WDS, 0x1E, 0x00, P_686 or P_AVX, 0,0xF0, RWF_VEX or RWF_EVEX, VX_L or VX_RW1 )
 = 754                      *1C T_VPCMPUQ equ 0x754
                              C insv(VPBLENDMD, vpblendmd,       OpCls( XMM,  XMM_M128_M32, NONE ), F_660F38, 1, no_WDS, 0x64, 0x00, P_686 or P_AVX, 0,0xF0, RWF_VEX or RWF_EVEX, VX_L or VX_RW0 )
 = 755                      *1C T_VPBLENDMD equ 0x755
                              C insv(VPBLENDMQ, vpblendmq,       OpCls( XMM,  XMM_M128_M64, NONE ), F_660F38, 1, no_WDS, 0x64, 0x00, P_686 or P_AVX, 0,0xF0, RWF_VEX or RWF_EVEX, VX_L or VX_RW1 )
 = 756                      *1C T_VPBLENDMQ equ 0x756
                              C insv(VPMAXSQ, vpmaxsq,           OpCls( XMM,  XMM_M128_M64, NONE ), F_660F38, 1, no_WDS, 0x3D, 0x00, P_686 or P_AVX, 0,0xF0, RWF_VEX or RWF_EVEX, VX_L or VX_RW1 )
 = 757                      *1C T_VPMAXSQ equ 0x757
                              C insv(VPMAXUQ, vpmaxuq,           OpCls( XMM,  XMM_M128_M64, NONE ), F_660F38, 1, no_WDS, 0x3F, 0x00, P_686 or P_AVX, 0,0xF0, RWF_VEX or RWF_EVEX, VX_L or VX_RW1 )
 = 758                      *1C T_VPMAXUQ equ 0x758
                              C insv(VPMINSQ, vpminsq,           OpCls( XMM,  XMM_M128_M64, NONE ), F_660F38, 1, no_WDS, 0x39, 0x00, P_686 or P_AVX, 0,0xF0, RWF_VEX or RWF_EVEX, VX_L or VX_RW1 )
 = 759                      *1C T_VPMINSQ equ 0x759
                              C insv(VPMINUQ, vpminuq,           OpCls( XMM,  XMM_M128_M64, NONE ), F_660F38, 1, no_WDS, 0x3B, 0x00, P_686 or P_AVX, 0,0xF0, RWF_VEX or RWF_EVEX, VX_L or VX_RW1 )
 = 75A                      *1C T_VPMINUQ equ 0x75A
                              C insv(VPORD, vpord,               OpCls( XMM,  XMM_M128_M32, NONE ), F_660F,   1, no_WDS, 0xEB, 0x00, P_686 or P_AVX, 0,0xF0, RWF_VEX or RWF_EVEX, VX_L or VX_RW0 )
 = 75B                      *1C T_VPORD equ 0x75B
                              C insv(VPORQ, vporq,               OpCls( XMM,  XMM_M128_M64, NONE ), F_660F,   1, no_WDS, 0xEB, 0x00, P_686 or P_AVX, 0,0xF0, RWF_VEX or RWF_EVEX, VX_L or VX_RW1 )
 = 75C                      *1C T_VPORQ equ 0x75C
                              C 
                              C insv(VPTESTMB, vptestmb,         OpCls( K,    XMM_M128_M64, NONE ), F_660F38, 1, no_WDS, 0x26, 0x00, P_686 or P_AVX, 0,0xF0, RWF_VEX or RWF_EVEX, VX_L or VX_RW0 )
 = 75D                      *1C T_VPTESTMB equ 0x75D
                              C insv(VPTESTMW, vptestmw,         OpCls( K,    XMM_M128_M64, NONE ), F_660F38, 1, no_WDS, 0x26, 0x00, P_686 or P_AVX, 0,0xF0, RWF_VEX or RWF_EVEX, VX_L or VX_RW1 )
 = 75E                      *1C T_VPTESTMW equ 0x75E
                              C insv(VPTESTMD, vptestmd,         OpCls( K,    XMM_M128_M32, NONE ), F_660F38, 1, no_WDS, 0x27, 0x00, P_686 or P_AVX, 0,0xF0, RWF_VEX or RWF_EVEX, VX_L or VX_RW0 )
 = 75F                      *1C T_VPTESTMD equ 0x75F
                              C insv(VPTESTMQ, vptestmq,         OpCls( K,    XMM_M128_M64, NONE ), F_660F38, 1, no_WDS, 0x27, 0x00, P_686 or P_AVX, 0,0xF0, RWF_VEX or RWF_EVEX, VX_L or VX_RW1 )
 = 760                      *1C T_VPTESTMQ equ 0x760
                              C insv(VPTERNLOGD, vpternlogd,     OpCls( XMM,  XMM_M128_M32, I8_U ), F_660F3A, 1, no_WDS, 0x25, 0x00, P_686 or P_AVX, 0,0xF0, RWF_VEX or RWF_EVEX, VX_L or VX_RW0 )
 = 761                      *1C T_VPTERNLOGD equ 0x761
                              C insv(VPTERNLOGQ, vpternlogq,     OpCls( XMM,  XMM_M128_M64, I8_U ), F_660F3A, 1, no_WDS, 0x25, 0x00, P_686 or P_AVX, 0,0xF0, RWF_VEX or RWF_EVEX, VX_L or VX_RW1 )
 = 762                      *1C T_VPTERNLOGQ equ 0x762
                              C insv(VSHUFF32X4, vshuff32x4,     OpCls( YMM,  YMM_M256_M32, I8_U ), F_660F3A, 1, no_WDS, 0x23, 0x00, P_686 or P_AVX, 0,0xF0, RWF_VEX or RWF_EVEX, VX_L or VX_RW0 )
 = 763                      *1C T_VSHUFF32X4 equ 0x763
                              C insv(VSHUFF64X2, vshuff64x2,     OpCls( YMM,  YMM_M256_M64, I8_U ), F_660F3A, 1, no_WDS, 0x23, 0x00, P_686 or P_AVX, 0,0xF0, RWF_VEX or RWF_EVEX, VX_L or VX_RW1 )
 = 764                      *1C T_VSHUFF64X2 equ 0x764
                              C insv(VSHUFI32X4, vshufi32x4,     OpCls( YMM,  YMM_M256_M32, I8_U ), F_660F3A, 1, no_WDS, 0x43, 0x00, P_686 or P_AVX, 0,0xF0, RWF_VEX or RWF_EVEX, VX_L or VX_RW0 )
 = 765                      *1C T_VSHUFI32X4 equ 0x765
                              C insv(VSHUFI64X2, vshufi64x2,     OpCls( YMM,  YMM_M256_M64, I8_U ), F_660F3A, 1, no_WDS, 0x43, 0x00, P_686 or P_AVX, 0,0xF0, RWF_VEX or RWF_EVEX, VX_L or VX_RW1 )
 = 766                      *1C T_VSHUFI64X2 equ 0x766
                              C insv(VCVTSD2USI, vcvtsd2usi,     OpCls( R32_M32, XMM_M64,   NONE ), F_F20F,   1, no_WDS, 0x79, 0x00, P_686 or P_AVX, 0,0xF0, RWF_VEX or RWF_EVEX, VX_L or VX_RW0 )
 = 767                      *1C T_VCVTSD2USI equ 0x767
                              C insv(VCVTSS2USI, vcvtss2usi,     OpCls( R32_M32, XMM_M32,   NONE ), F_F30F,   1, no_WDS, 0x79, 0x00, P_686 or P_AVX, 0,0xF0, RWF_VEX or RWF_EVEX, VX_L or VX_RW0 )
 = 768                      *1C T_VCVTSS2USI equ 0x768
                              C insv(VCVTUSI2SD, vcvtusi2sd,     OpCls( XMM,  R32_M32,      NONE ), F_F20F,   1, no_WDS, 0x7B, 0x00, P_686 or P_AVX, 0,0xF0, RWF_VEX or RWF_EVEX or RWF_T1S, VX_L or VX_RW0 )
 = 769                      *1C T_VCVTUSI2SD equ 0x769
                              C insv(VCVTUSI2SS, vcvtusi2ss,     OpCls( XMM,  R32_M32,      NONE ), F_F30F,   1, no_WDS, 0x7B, 0x00, P_686 or P_AVX, 0,0xF0, RWF_VEX or RWF_EVEX or RWF_T1S, VX_L or VX_RW0 )
 = 76A                      *1C T_VCVTUSI2SS equ 0x76A
                              C insv(VCVTTSD2USI, vcvttsd2usi,   OpCls( R32_M32, XMM_M64,   NONE ), F_F20F,   1, no_WDS, 0x78, 0x00, P_686 or P_AVX, 0,0xF0, RWF_VEX or RWF_EVEX, VX_L or VX_RW0 )
 = 76B                      *1C T_VCVTTSD2USI equ 0x76B
                              C insv(VCVTTSS2USI, vcvttss2usi,   OpCls( R32_M32, XMM_M32,   NONE ), F_F30F,   1, no_WDS, 0x78, 0x00, P_686 or P_AVX, 0,0xF0, RWF_VEX or RWF_EVEX, VX_L or VX_RW0 )
 = 76C                      *1C T_VCVTTSS2USI equ 0x76C
                              C insv(VSCALEFPD, vscalefpd,       OpCls( XMM,  XMM_M128_M64, NONE ), F_660F38, 1, no_WDS, 0x2C, 0x00, P_686 or P_AVX, 0,0xF0, RWF_VEX or RWF_EVEX, VX_L or VX_RW1 )
 = 76D                      *1C T_VSCALEFPD equ 0x76D
                              C insv(VSCALEFPS, vscalefps,       OpCls( XMM,  XMM_M128_M32, NONE ), F_660F38, 1, no_WDS, 0x2C, 0x00, P_686 or P_AVX, 0,0xF0, RWF_VEX or RWF_EVEX, VX_L or VX_RW0 )
 = 76E                      *1C T_VSCALEFPS equ 0x76E
                              C insv(VSCALEFSD, vscalefsd,       OpCls( XMM,  XMM_M128_M64, NONE ), F_660F38, 1, no_WDS, 0x2D, 0x00, P_686 or P_AVX, 0,0xF0, RWF_VEX or RWF_EVEX or RWF_T1S, VX_L or VX_RW1 )
 = 76F                      *1C T_VSCALEFSD equ 0x76F
                              C insv(VSCALEFSS, vscalefss,       OpCls( XMM,  XMM_M128_M32, NONE ), F_660F38, 1, no_WDS, 0x2D, 0x00, P_686 or P_AVX, 0,0xF0, RWF_VEX or RWF_EVEX or RWF_T1S, VX_L or VX_RW0 )
 = 770                      *1C T_VSCALEFSS equ 0x770
                              C insv(VFIXUPIMMPD, vfixupimmpd,   OpCls( XMM,  XMM_M128_M64, I8_U ), F_660F3A, 1, no_WDS, 0x54, 0x00, P_686 or P_AVX, 0,0xF0, RWF_VEX or RWF_EVEX, VX_L or VX_RW1 )
 = 771                      *1C T_VFIXUPIMMPD equ 0x771
                              C insv(VFIXUPIMMPS, vfixupimmps,   OpCls( XMM,  XMM_M128_M32, I8_U ), F_660F3A, 1, no_WDS, 0x54, 0x00, P_686 or P_AVX, 0,0xF0, RWF_VEX or RWF_EVEX, VX_L or VX_RW0 )
 = 772                      *1C T_VFIXUPIMMPS equ 0x772
                              C insv(VFIXUPIMMSD, vfixupimmsd,   OpCls( XMM,  XMM_M128_M64, I8_U ), F_660F3A, 1, no_WDS, 0x55, 0x00, P_686 or P_AVX, 0,0xF0, RWF_VEX or RWF_EVEX or RWF_T1S, VX_L or VX_RW1 )
 = 773                      *1C T_VFIXUPIMMSD equ 0x773
                              C insv(VFIXUPIMMSS, vfixupimmss,   OpCls( XMM,  XMM_M128_M32, I8_U ), F_660F3A, 1, no_WDS, 0x55, 0x00, P_686 or P_AVX, 0,0xF0, RWF_VEX or RWF_EVEX or RWF_T1S, VX_L or VX_RW0 )
 = 774                      *1C T_VFIXUPIMMSS equ 0x774
                              C insv(VPERMI2D, vpermi2d,         OpCls( XMM,  XMM_M128_M32, NONE ), F_660F38, 1, no_WDS, 0x76, 0x00, P_686 or P_AVX, 0,0xF0, RWF_VEX or RWF_EVEX, VX_L or VX_RW0 )
 = 775                      *1C T_VPERMI2D equ 0x775
                              C insv(VPERMI2Q, vpermi2q,         OpCls( XMM,  XMM_M128_M64, NONE ), F_660F38, 1, no_WDS, 0x76, 0x00, P_686 or P_AVX, 0,0xF0, RWF_VEX or RWF_EVEX, VX_L or VX_RW1 )
 = 776                      *1C T_VPERMI2Q equ 0x776
                              C insv(VPERMI2PS, vpermi2ps,       OpCls( XMM,  XMM_M128_M32, NONE ), F_660F38, 1, no_WDS, 0x77, 0x00, P_686 or P_AVX, 0,0xF0, RWF_VEX or RWF_EVEX, VX_L or VX_RW0 )
 = 777                      *1C T_VPERMI2PS equ 0x777
                              C insv(VPERMI2PD, vpermi2pd,       OpCls( XMM,  XMM_M128_M64, NONE ), F_660F38, 1, no_WDS, 0x77, 0x00, P_686 or P_AVX, 0,0xF0, RWF_VEX or RWF_EVEX, VX_L or VX_RW1 )
 = 778                      *1C T_VPERMI2PD equ 0x778
                              C 
                              C avxins(VMOVDQA32,       VMOVDQA64,      vmovdqa64,      RWF_EVEX, VX_L or VX_NND or VX_RW1 )
 = 779                      *1C T_VMOVDQA64 equ 0x779
                              C avxins(VMOVDQU8,        VMOVDQU16,      vmovdqu16,      RWF_EVEX, VX_L or VX_NND or VX_RW1 )
 = 77A                      *1C T_VMOVDQU16 equ 0x77A
                              C avxins(VMOVDQU32,       VMOVDQU64,      vmovdqu64,      RWF_EVEX, VX_L or VX_NND or VX_RW1 )
 = 77B                      *1C T_VMOVDQU64 equ 0x77B
                              C avxins(VCOMPRESSPD,     VCOMPRESSPS,    vcompressps,    RWF_EVEX or RWF_T1S, VX_L or VX_NND or VX_HALF or VX_RW0 )
 = 77C                      *1C T_VCOMPRESSPS equ 0x77C
                              C avxins(VPCOMPRESSD,     VPCOMPRESSQ,    vpcompressq,    RWF_EVEX or RWF_T1S, VX_L or VX_HALF or VX_RW1 )
 = 77D                      *1C T_VPCOMPRESSQ equ 0x77D
                              C avxins(VBROADCASTF32X4, VBROADCASTF64X2,vbroadcastf64x2,RWF_EVEX or RWF_T2, VX_L or VX_NND or VX_HALF or VX_RW1 )
 = 77E                      *1C T_VBROADCASTF64X2 equ 0x77E
                              C avxins(VBROADCASTI32X4, VBROADCASTI64X2,vbroadcasti64x2,RWF_EVEX or RWF_T2, VX_L or VX_NND or VX_HALF or VX_RW1 )
 = 77F                      *1C T_VBROADCASTI64X2 equ 0x77F
                              C avxins(VBROADCASTI32X8, VBROADCASTI64X4,vbroadcasti64x4,RWF_EVEX or RWF_T4, VX_L or VX_NND or VX_HALF or VX_RW1 )
 = 780                      *1C T_VBROADCASTI64X4 equ 0x780
                              C avxins(VCVTPD2QQ,       VCVTPS2QQ,      vcvtps2qq,      RWF_EVEX, VX_L or VX_NND or VX_HALF or VX_RW0 )
 = 781                      *1C T_VCVTPS2QQ equ 0x781
                              C avxins(VCVTPD2UDQ,      VCVTPS2UDQ,     vcvtps2udq,     RWF_EVEX, VX_L or VX_NND or VX_RW0 )
 = 782                      *1C T_VCVTPS2UDQ equ 0x782
                              C avxins(VCVTPD2UQQ,      VCVTPS2UQQ,     vcvtps2uqq,     RWF_EVEX, VX_L or VX_NND or VX_HALF or VX_RW0 )
 = 783                      *1C T_VCVTPS2UQQ equ 0x783
                              C avxins(VCVTTPD2QQ,      VCVTTPS2QQ,     vcvttps2qq,     RWF_EVEX, VX_L or VX_NND or VX_HALF or VX_RW0 )
 = 784                      *1C T_VCVTTPS2QQ equ 0x784
                              C avxins(VCVTTPD2UDQ,     VCVTTPS2UDQ,    vcvttps2udq,    RWF_EVEX, VX_L or VX_NND or VX_RW0 )
 = 785                      *1C T_VCVTTPS2UDQ equ 0x785
                              C avxins(VCVTTPD2UQQ,     VCVTTPS2UQQ,    vcvttps2uqq,    RWF_EVEX, VX_L or VX_NND or VX_HALF or VX_RW0 )
 = 786                      *1C T_VCVTTPS2UQQ equ 0x786
                              C avxins(VCVTUDQ2PD,      VCVTUQQ2PD,     vcvtuqq2pd,     RWF_EVEX, VX_L or VX_NND or VX_RW1 )
 = 787                      *1C T_VCVTUQQ2PD equ 0x787
                              C avxins(VCVTUQQ2PS,      VCVTUDQ2PS,     vcvtudq2ps,     RWF_EVEX, VX_L or VX_NND or VX_RW0 )
 = 788                      *1C T_VCVTUDQ2PS equ 0x788
                              C avxins(VEXPANDPD,       VEXPANDPS,      vexpandps,      RWF_EVEX or RWF_T1S, VX_L or VX_NND or VX_RW0 )
 = 789                      *1C T_VEXPANDPS equ 0x789
                              C avxins(VEXTRACTF32x4,   VEXTRACTF64X2,  vextractf64x2,  RWF_EVEX, VX_L or VX_NND or VX_RW1 )
 = 78A                      *1C T_VEXTRACTF64X2 equ 0x78A
                              C avxins(VEXTRACTF32X8,   VEXTRACTF64x4,  vextractf64x4,  RWF_EVEX, VX_L or VX_NND or VX_RW1 )
 = 78B                      *1C T_VEXTRACTF64x4 equ 0x78B
                              C avxins(VEXTRACTI32x4,   VEXTRACTI64X2,  vextracti64x2,  RWF_EVEX, VX_L or VX_NND or VX_RW1 )
 = 78C                      *1C T_VEXTRACTI64X2 equ 0x78C
                              C avxins(VEXTRACTI32X8,   VEXTRACTI64x4,  vextracti64x4,  RWF_EVEX, VX_L or VX_NND or VX_RW1 )
 = 78D                      *1C T_VEXTRACTI64x4 equ 0x78D
                              C avxins(VFPCLASSPD,      VFPCLASSPS,     vfpclassps,     RWF_EVEX, VX_L or VX_NND or VX_HALF or VX_RW0 )
 = 78E                      *1C T_VFPCLASSPS equ 0x78E
                              C avxins(VGATHERDPS,      VGATHERDPD,     vgatherdpd,     RWF_T1S,  VX_L or VX_NND or VX_RW1 )
 = 78F                      *1C T_VGATHERDPD equ 0x78F
                              C avxins(VGATHERQPS,      VGATHERQPD,     vgatherqpd,     RWF_T1S,  VX_L or VX_NND or VX_RW1 )
 = 790                      *1C T_VGATHERQPD equ 0x790
                              C avxins(VPGATHERDD,      VPGATHERDQ,     vpgatherdq,     RWF_T1S, VX_L or VX_NND or VX_RW1 )
 = 791                      *1C T_VPGATHERDQ equ 0x791
                              C avxins(VPGATHERQD,      VPGATHERQQ,     vpgatherqq,     RWF_T1S, VX_L or VX_NND or VX_RW1 )
 = 792                      *1C T_VPGATHERQQ equ 0x792
                              C avxins(VSCATTERDPS,     VSCATTERDPD,    vscatterdpd,    RWF_EVEX or RWF_T1S, VX_L or VX_NND or VX_RW1 )
 = 793                      *1C T_VSCATTERDPD equ 0x793
                              C avxins(VSCATTERQPS,     VSCATTERQPD,    vscatterqpd,    RWF_EVEX or RWF_T1S, VX_L or VX_NND or VX_RW1 )
 = 794                      *1C T_VSCATTERQPD equ 0x794
                              C avxins(VPSCATTERDD,     VPSCATTERDQ,    vpscatterdq,    RWF_EVEX or RWF_T1S, VX_L or VX_NND or VX_RW1 )
 = 795                      *1C T_VPSCATTERDQ equ 0x795
                              C avxins(VPSCATTERQD,     VPSCATTERQQ,    vpscatterqq,    RWF_EVEX or RWF_T1S, VX_L or VX_NND or VX_RW1 )
 = 796                      *1C T_VPSCATTERQQ equ 0x796
                              C avxins(VPEXPANDD,       VPEXPANDQ,      vpexpandq,      RWF_EVEX or RWF_T1S, VX_L or VX_NND or VX_RW1 )
 = 797                      *1C T_VPEXPANDQ equ 0x797
                              C avxins(VPMOVB2M,        VPMOVW2M,       vpmovw2m,       RWF_EVEX, VX_L or VX_HALF or VX_RW1 )
 = 798                      *1C T_VPMOVW2M equ 0x798
                              C avxins(VPMOVD2M,        VPMOVQ2M,       vpmovq2m,       RWF_EVEX, VX_L or VX_HALF or VX_RW1 )
 = 799                      *1C T_VPMOVQ2M equ 0x799
                              C avxins(VPMOVM2D,        VPMOVM2Q,       vpmovm2q,       RWF_EVEX, VX_L or VX_HALF or VX_RW1 )
 = 79A                      *1C T_VPMOVM2Q equ 0x79A
                              C avxins(VPMOVM2B,        VPMOVM2W,       vpmovm2w,       RWF_EVEX, VX_L or VX_HALF or VX_RW1 )
 = 79B                      *1C T_VPMOVM2W equ 0x79B
                              C undef insm
                              C undef insn
                              C undef insx
                              C undef insv
                              C undef insa
                              C undef avxins
                              C 
 = 525                        C VEX_START equ T_VBROADCASTSS ; first VEX encoded item
                              C 
                              C 
                              C ; queue of symbols
                              C 
                              C .template symbol_queue
00000000                    * C symbol_queue struct
00000000                      C     head ptr dsym ?
00000008                      C     tail ptr dsym ?
                              C    .ends
00000010                    * C symbol_queue ends
                              C 
                              C 
                              C .enum queue_type {
                            * C queue_type typedef sdword
 = 0                        * C TAB_UNDEF equ 0x0
 = 1                        * C TAB_EXT equ 0x1
 = 2                        * C TAB_SEG equ 0x2
 = 3                        * C TAB_GRP equ 0x3
 = 4                        * C TAB_PROC equ 0x4
 = 5                        * C TAB_ALIAS equ 0x5
 = 6                        * C TAB_LAST equ 0x6
                              C 
                              C ; several lists, see enum queue_type above
                              C externdef SymTables:symbol_queue
                              C 
 = SymTables[TAB_SEG*symbol_  C SegTable    equ <SymTables[TAB_SEG*symbol_queue].head>
   queue].head                  
 = SymTables[TAB_EXT*symbol_  C ExtTable    equ <SymTables[TAB_EXT*symbol_queue].head>
   queue].head                  
 = SymTables[TAB_ALIAS*symbo  C AliasTable  equ <SymTables[TAB_ALIAS*symbol_queue].head>
   l_queue].head                
 = SymTables[TAB_PROC*symbol  C ProcTable   equ <SymTables[TAB_PROC*symbol_queue].head>
   _queue].head                 
                              C 
                              C ; values for <rm_info> (3 bits)
                              C ; 000		  -> has rm_byte with w-, d- and/or s-bit in opcode
                              C ; 001( no_RM	) -> no rm_byte - may have w-bit
                              C ; 010( no_WDS	) -> has rm_byte, but w-bit, d-bit, s-bit of opcode are absent
                              C ; 011( R_in_OP ) -> no rm_byte, reg field (if any) is included in opcode
                              C 
                              C .enum rm_info {
                            * C rm_info typedef sdword
 = 1                        * C no_RM equ 0x1
 = 2                        * C no_WDS equ 0x2
 = 3                        * C R_in_OP equ 0x3
                              C 
                              C ; values for <allowed_prefix> (3 bits) */
                              C .enum allowed_prefix {
                            * C allowed_prefix typedef sdword
                              C     ; AP_NO_PREFIX= 0x00, ; value 0 means "normal"
 = 1                        * C AP_LOCK equ 0x1
 = 2                        * C AP_REP equ 0x2
 = 3                        * C AP_REPxx equ 0x3
 = 4                        * C AP_FWAIT equ 0x4
 = 5                        * C AP_NO_FWAIT equ 0x5
                              C 
                              C ; values for field type in special_item.
                              C ; it should match order of T_REGISTER - T_RES_ID in token.h
                              C 
                              C .enum special_type {
                            * C special_type typedef sdword
 = 2                        * C RWT_REG equ 0x2
 = 3                        * C RWT_DIRECTIVE equ 0x3
 = 4                        * C RWT_UNARY_OP equ 0x4
 = 5                        * C RWT_BINARY_OP equ 0x5
 = 6                        * C RWT_STYPE equ 0x6
 = 7                        * C RWT_RES_ID equ 0x7
                              C 
                              C ; values for sflags if register
                              C .enum op1_flags {
                            * C op1_flags typedef sdword
 = 7F                       * C SFR_SIZMSK equ 0x7F
 = 80                       * C SFR_IREG equ 0x80
 = 100                      * C SFR_SSBASED equ 0x100
                              C 
                              C .enum rex_bits {
                            * C rex_bits typedef sdword
 = 1                        * C REX_B equ 0x1
 = 2                        * C REX_X equ 0x2
 = 4                        * C REX_R equ 0x4
 = 8                        * C REX_W equ 0x8
                              C 
                              C ; operand classes. this table is defined in reswords.c.
                              C ; index into this array is member opclsidx in instr_item.
                              C ; v2.06: data removed from struct instr_item.
                              C 
00000000                      C opnd_class	STRUC
00000000                      C opnd_type	dd 2 dup(?)
00000008                      C opnd_type_3rd	db ?	; operand 3
00000009                      C opnd_class	ENDS
                              C 
                              C ; instr_item is the structure used to store instructions
                              C ; in InstrTable (instruct.h).
                              C ; Most compilers will use unsigned type for enums, just OW
                              C ; allows to use the smallest size possible.
                              C 
 = 7                          C II_ALLOWED_PREFIX equ 0x07 ; 3 - allowed prefix
 = 8                          C II_FIRST	equ 0x08 ; 1 - 1=opcode's first entry
 = 70                         C II_RM_INFO	equ 0x70 ; 3 - info on r/m byte
 = 80                         C II_OPND_DIR	equ 0x80 ; 1 - operand direction
                              C 
00000000                      C instr_item	STRUC
00000000                      C opclsidx	db ?	; v2.06: index for opnd_clstab
00000001                      C byte1_info	db ?	; flags for 1st byte
00000002                      C flags		db ?
00000003                      C evex		db ?	; EVEX
00000004                      C cpu		dw ?
00000006                      C opcode		db ?	; opcode byte
00000007                      C rm_byte		db ?	; mod_rm_byte
00000008                      C instr_item	ENDS
                              C instr_t		typedef ptr instr_item
                              C 
                              C 
                              C ; special_item is the structure used to store directives and
                              C ; other reserved words in SpecialTable (special.h).
                              C 
00000000                      C special_item	STRUC
00000000                      C value		dd ?
00000004                      C sflags		dd ?
00000008                      C cpu		dw ?	; CPU type
0000000A                      C bytval		db ?
0000000B                      C type		db ?
0000000C                      C special_item	ENDS
                              C 
                              C ifdef _WIN64
                              C GetRegNo macro x
 >                            C 	 lea  r11,SpecialTable
 >                            C 	 imul eax,x,special_item
 >                            C 	 exitm<[r11+rax].special_item.bytval>
 >                            C 	 endm
                              C GetSflagsSp macro x
 >                            C 	 lea  r11,SpecialTable
 >                            C 	 imul eax,x,special_item
 >                            C 	 exitm<[r11+rax].special_item.sflags>
 >                            C 	 endm
                              C GetValueSp macro x
 >                            C 	 lea  r11,SpecialTable
 >                            C 	 imul eax,x,special_item
 >                            C 	 exitm<[r11+rax].special_item.value>
 >                            C 	 endm
                              C GetMemtypeSp macro x
 >                            C 	 lea  r11,SpecialTable
 >                            C 	 imul eax,x,special_item
 >                            C 	 exitm<[r11+rax].special_item.bytval>
 >                            C 	 endm
                              C GetCpuSp macro x
 >                            C 	 lea  r11,SpecialTable
 >                            C 	 imul eax,x,special_item
 >                            C 	 exitm<[r11+rax].special_item.cpu>
 >                            C 	 endm
                              C endif
                              C 
                              C ; values for <value> if type == RWT_DIRECTIVE
                              C 
                              C .enum directive_flags {
                            * C directive_flags typedef sdword
 = 1                        * C DF_CEXPR equ 0x1
 = 2                        * C DF_STRPARM equ 0x2
                              C 			; enclose strings in <> in macro expansion step
 = 4                        * C DF_NOEXPAND equ 0x4
 = 8                        * C DF_LABEL equ 0x8
 = 10                       * C DF_NOSTRUC equ 0x10
 = 20                       * C DF_NOCONCAT equ 0x20
 = 40                       * C DF_PROC equ 0x40
 = 80                       * C DF_STORE equ 0x80
 = 100                      * C DF_CGEN equ 0x100
                              C 
                              C ; values for <bytval> if type == RWT_DIRECTIVE
                              C 
                              C res macro token, function
 >                            C     DRT_&token&,
 >                            C     exitm<>
 >                            C     endm
                              C 
                              C .enum directive_type {
                            * C directive_type typedef sdword
                              C include dirtype.inc
                              C ; DIRTYPE.INC--
                              C ;
                              C ; Copyright (c) The Asmc Contributors. All rights reserved.
                              C ; Consult your license regarding permissions and restrictions.
                              C ;
                              C ; DRT_ values ( directive types )
                              C ; items CONDDIR ... INCLUDE must be first, INCLUDE the last of them.
                              C ; DATADIR must be the first non-preprocessor directive!
                              C ;
                              C 
 = 0                        *1C DRT_CONDDIR equ 0x0
 = 1                        *1C DRT_LOOPDIR equ 0x1
 = 2                        *1C DRT_PURGE equ 0x2
 = 3                        *1C DRT_INCLUDE equ 0x3
 = 4                        *1C DRT_MACRO equ 0x4
 = 5                        *1C DRT_CATSTR equ 0x5
 = 6                        *1C DRT_SUBSTR equ 0x6
 = 7                        *1C DRT_MACINT equ 0x7
                              C 
                              C ; non-preprocessor directives
                              C 
 = 8                        *1C DRT_DATADIR equ 0x8
 = 9                        *1C DRT_END equ 0x9
 = A                        *1C DRT_ERRDIR equ 0xA
                              C ifndef ASMC64
 = B                        *1C DRT_CPU equ 0xB
                              C endif
 = C                        *1C DRT_LISTING equ 0xC
 = D                        *1C DRT_LISTMAC equ 0xD
 = E                        *1C DRT_SEGORDER equ 0xE
 = F                        *1C DRT_SIMSEG equ 0xF
 = 10                       *1C DRT_HLLSTART equ 0x10
 = 11                       *1C DRT_HLLEXIT equ 0x11
 = 12                       *1C DRT_HLLEND equ 0x12
                              C ifndef ASMC64
 = 13                       *1C DRT_STARTEXIT equ 0x13
                              C endif
                              C ifndef ASMC64
 = 14                       *1C DRT_MODEL equ 0x14
                              C endif
 = 15                       *1C DRT_RADIX equ 0x15
 = 16                       *1C DRT_SAFESEH equ 0x16
 = 17                       *1C DRT_INSTR equ 0x17
 = 18                       *1C DRT_SIZESTR equ 0x18
 = 19                       *1C DRT_EXCFRAME equ 0x19
 = 1A                       *1C DRT_STRUCT equ 0x1A
 = 1B                       *1C DRT_TYPEDEF equ 0x1B
 = 1C                       *1C DRT_RECORD equ 0x1C
 = 1D                       *1C DRT_COMM equ 0x1D
 = 1E                       *1C DRT_EXTERN equ 0x1E
 = 1F                       *1C DRT_EXTERNDEF equ 0x1F
 = 20                       *1C DRT_PROTO equ 0x20
 = 21                       *1C DRT_PUBLIC equ 0x21
 = 22                       *1C DRT_PROC equ 0x22
 = 23                       *1C DRT_ENDP equ 0x23
 = 24                       *1C DRT_LOCAL equ 0x24
 = 25                       *1C DRT_INVOKE equ 0x25
 = 26                       *1C DRT_ORG equ 0x26
 = 27                       *1C DRT_ALIGN equ 0x27
 = 28                       *1C DRT_SEGMENT equ 0x28
 = 29                       *1C DRT_ENDS equ 0x29
 = 2A                       *1C DRT_GROUP equ 0x2A
 = 2B                       *1C DRT_ASSUME equ 0x2B
 = 2C                       *1C DRT_LABEL equ 0x2C
 = 2D                       *1C DRT_ALIAS equ 0x2D
 = 2E                       *1C DRT_ECHO equ 0x2E
 = 2F                       *1C DRT_EQU equ 0x2F
 = 30                       *1C DRT_EQUALSGN equ 0x30
 = 31                       *1C DRT_INCBIN equ 0x31
 = 32                       *1C DRT_INCLIB equ 0x32
 = 33                       *1C DRT_DOT_NAME equ 0x33
 = 34                       *1C DRT_OPTION equ 0x34
 = 35                       *1C DRT_CONTEXT equ 0x35
 = 36                       *1C DRT_HLLFOR equ 0x36
 = 37                       *1C DRT_SWITCH equ 0x37
 = 38                       *1C DRT_ASSERT equ 0x38
 = 39                       *1C DRT_UNDEF equ 0x39
 = 3A                       *1C DRT_CLASS equ 0x3A
 = 3B                       *1C DRT_PRAGMA equ 0x3B
 = 3C                       *1C DRT_NEW equ 0x3C
 = 3D                       *1C DRT_RETURN equ 0x3D
 = 3E                       *1C DRT_ENUM equ 0x3E
 = 3F                       *1C DRT_NAMESPACE equ 0x3F
                              C undef res
                              C 
 = 3                          C MAX_OPND	equ 3
                              C 
00000000                      C opnd_item	STRUC
00000000                      C type		uint_t ?
00000004                      C InsFixup	fixup_t ?
0000000C                      C UNION
00000000                      C  STRUC
00000000                      C   data32l	int_t ?
00000004                      C   data32h	int_t ? ; needed for OP_I48 and OP_I64
00000008                      C  ENDS
00000000                      C  data64		uint64_t ?
00000008                      C ENDS
00000014                      C opnd_item	ENDS
                              C 
                              C ; code_info describes the current instruction. It's the communication
                              C ; structure between parser and code generator.
                              C 
                              C ; EVEX:
                              C ; P1: R.X.B.R1.0.0.m1.m2
                              C ; P2: W.v3.v2.v1.v0.1.p1.p0
                              C ; P3: z.L1.L0.b.V1.a2.a1.a0
                              C 
 = 80                         C VX1_R		equ 0x80
 = 40                         C VX1_X		equ 0x40
 = 20                         C VX1_B		equ 0x20
 = 10                         C VX1_R1		equ 0x10
 = 2                          C VX1_M1		equ 0x02
 = 1                          C VX1_M2		equ 0x01
                              C 
 = 80                         C VX2_W		equ 0x80
 = 40                         C VX2_V3		equ 0x40
 = 20                         C VX2_V2		equ 0x20
 = 10                         C VX2_V1		equ 0x10
 = 8                          C VX2_V0		equ 0x08
 = 4                          C VX2_1		equ 0x04
 = 2                          C VX2_P1		equ 0x02
 = 1                          C VX2_P0		equ 0x01
                              C 
 = 80                         C VX3_Z		equ 0x80 ; {z}
 = 40                         C VX3_L1		equ 0x40
 = 20                         C VX3_L0		equ 0x20
 = 10                         C VX3_B		equ 0x10 ; {1to4} {1to8} {1to16}
 = 8                          C VX3_V		equ 0x08
 = 4                          C VX3_A2		equ 0x04 ; {k1..k7}
 = 2                          C VX3_A1		equ 0x02
 = 1                          C VX3_A0		equ 0x01
                              C 
                              C ; vflags
                              C 
 = 1                          C VX_OP1V		equ 0x01 ; set if op1..3 is [z|y|x]mm16..31 register
 = 2                          C VX_OP2V		equ 0x02
 = 4                          C VX_OP3V		equ 0x04
 = 8                          C VX_OP3		equ 0x08 ; more than 2 instruction args used
 = 10                         C VX_ZMM		equ 0x10 ; ZMM used
 = 20                         C VX_SAE		equ 0x20 ; {sae} used
 = 40                         C VX_ZMM8		equ 0x40 ; zmm8..15 used
 = 80                         C VX_ZMM24	equ 0x80 ; zmm24..31 used
                              C 
                              C ; pinstr->evex
                              C 
 = F                          C VX_RXB		equ 0x0F ; P1: R.X.B.R1
 = 8                          C VX_XMMI		equ 0x08 ; XMM register used as index
 = 4                          C VX_NV0		equ 0x04 ; P2: V0=0
 = 2                          C VX_W1		equ 0x02 ; P2: W=1
                              C 
 = 1                          C CI_ISWIDE	equ 0x01 ; 0=byte, 1=word/dword/qword
 = 2                          C CI_ISDIRECT	equ 0x02 ; 1=direct addressing mode
 = 4                          C CI_ISFAR	equ 0x04 ; CALL/JMP far
 = 8                          C CI_CONST_SIZE_FIXED equ 0x08 ; v2.01
 = 10                         C CI_X86HI_USED	equ 0x10 ; AH,BH,CH,DH used
 = 20                         C CI_x64LO_USED	equ 0x20 ; SPL,BPL,SIL,DIL used
 = 40                         C CI_UNDEF_SYM	equ 0x40 ; v2.06b: struct member is forward ref
 = 80                         C CI_BASE_RIP	equ 0x80
                              C 
00000000                      C code_info	STRUC
00000000                      C inst		int_t ?
00000004                      C RegOverride	int_t ?
00000008                      C rex		db ?
00000009                      C adrsiz		db ?	; address size prefix 0x67 is to be emitted
0000000A                      C opsiz		db ?	; operand size prefix 0x66 is to be emitted
0000000B                      C evex		db ?	; EVEX prefix 0x62 is to be emitted
0000000C                      C evexP3		db ?
0000000D                      C vflags		db ?
0000000E                      C token		dw ?
00000010                      C opnd		opnd_item MAX_OPND dup(<>)
0000004C                      C pinstr		instr_t ?
00000054                      C mem_type	db ?	; byte / word / etc. NOT near/far
00000055                      C rm_byte		db ?
00000056                      C sib		db ?
00000057                      C Ofssize		db ?
00000058                      C opc_or		db ?
00000059                      C vexregop	db ?	; in based-1 format (0=empty)
0000005A                      C flags		db ?
0000005B                      C code_info	ENDS
                              C 
 = 0                          C OPND1		equ 0
 = 1                          C OPND2		equ 1
 = 2                          C OPND3		equ 2
 = 14                         C OPNI2		equ OPND2 * sizeof(opnd_item)
 = 28                         C OPNI3		equ OPND3 * sizeof(opnd_item)
                              C 
                              C ; branch instructions are still sorted:
                              C ; CALL, JMP, Jcc, J[e|r]CXZ, LOOP, LOOPcc
                              C 
                              C IS_CALL macro inst
 >                            C     exitm<(inst == T_CALL)>
 >                            C     endm
                              C IS_JMPCALL macro inst
 >                            C     exitm<(inst == T_CALL || inst ==  T_JMP)>
 >                            C     endm
                              C IS_JMP macro inst
 >                            C     exitm<(inst !>= T_JMP && inst !< T_LOOP)>
 >                            C     endm
                              C IS_JCC macro inst
 >                            C     exitm<(inst !> T_JMP && inst !< T_JCXZ)>
 >                            C     endm
                              C IS_BRANCH macro inst
 >                            C     exitm<(inst !>= T_CALL && inst !< T_LOOP)>
 >                            C     endm
                              C IS_ANY_BRANCH macro inst
 >                            C     exitm<(inst !>= T_CALL && inst !<= T_LOOPNZW)>
 >                            C     endm
                              C IS_XCX_BRANCH macro inst
 >                            C     exitm<(inst !>= T_JCXZ && inst !< T_LOOPNZW)>
 >                            C     endm
                              C IS_OPER_32 macro s
 >                            C     xor eax,eax
 >                            C     cmp [s].Ofssize,al
 >                            C     setz al
 >                            C     exitm<[s].opsiz == al>
 >                            C     endm
                              C 
                              C 
                              C ; globals
                              C 
                              C externdef InstrTable:instr_item		; instruction table
                              C externdef SpecialTable:special_item	; rest of res words
                              C externdef optable_idx:ushort_t		; helper, access thru IndexFromToken() only
                              C 
                              C IndexFromToken_imm macro tok
 >                            C     exitm<optable_idx[(tok-SPECIAL_LAST)*2]>
 >                            C     endm
                              C ifdef _WIN64
                            * C IndexFromToken_dword macro tok
 >                          * C sub eax,SPECIAL_LAST
 >                          * C lea rcx,optable_idx
 >                          * C retm<word ptr [rcx+rax*2]>
 >                          * C endm
                              C IndexFromToken_dword proto watcall tok:uint_t 
                              C endif
                              C 
                              C IndexFromToken macro tok
 >                            C %   exitm<typeid(IndexFromToken_,tok)(tok)>
 >                            C     endm
                              C 
                              C SizeFromMemtype		proto fastcall :uchar_t, :int_t, :ptr asym
                              C MemtypeFromSize		proto fastcall :int_t, :ptr uchar_t
                              C SizeFromRegister	proto fastcall :int_t
                              C GetLangType		proto fastcall :ptr int_t, :ptr asm_tok, :ptr uchar_t
                              C sym_add_table		proto fastcall :ptr symbol_queue, :ptr dsym
                              C sym_remove_table	proto fastcall :ptr symbol_queue, :ptr dsym
                              C sym_ext2int		proto fastcall :ptr asym
                              C OperandSize		proto fastcall :int_t, :ptr code_info
                              C set_frame		proto fastcall :ptr asym
                              C set_frame2		proto fastcall :ptr asym
                              C ParseLine		proto fastcall :ptr asm_tok
                              C ProcessFile		proto fastcall :ptr asm_tok
                              C WritePreprocessedLine	proto fastcall :string_t
                              C parsevex		proto fastcall :string_t, :ptr uchar_t
                              C 
                              C endif
                                include preproc.inc
                              C ; PREPROC.INC--
                              C ;
                              C ; Copyright (c) The Asmc Contributors. All rights reserved.
                              C ; Consult your license regarding permissions and restrictions.
                              C ;
                              C ; v2.11: preprocessor functions moved from input.asm to preproc.asm
                              C ;
                              C ifndef __PREPROC_INC
 = 0                          C define __PREPROC_INC
                              C 
                              C PreprocessLine proto fastcall :ptr asm_tok
                              C WriteCodeLabel proto fastcall :string_t, :ptr asm_tok
                              C 
                              C endif
                                include expreval.inc
                              C ; EXPREVAL.INC--
                              C ;
                              C ; Copyright (c) The Asmc Contributors. All rights reserved.
                              C ; Consult your license regarding permissions and restrictions.
                              C ;
                              C ; interface to expression evaluator
                              C ;
                              C ifndef __EXPREVAL_INC
 = 0                          C define __EXPREVAL_INC
                              C 
                              C ; v2.11: EXPR_UNDEF changed to EXPR_ERROR, value -1
                              C 
                              C .enum exprtype {
                            * C exprtype typedef sdword
 = FFFFFFFE                 * C EXPR_EMPTY equ 0xFFFFFFFE
 = FFFFFFFF                 * C EXPR_ERROR equ 0xFFFFFFFF
 = 0                        * C EXPR_CONST equ 0x0
 = 1                        * C EXPR_ADDR equ 0x1
 = 2                        * C EXPR_REG equ 0x2
 = 3                        * C EXPR_FLOAT equ 0x3
                              C 
                              C ; argument types accepted by unary operators
                              C 
                              C .enum oparg_types {
                            * C oparg_types typedef sdword
 = 1                        * C AT_TYPE equ 0x1
 = 2                        * C AT_LABEL equ 0x2
 = 4                        * C AT_IND equ 0x4
 = 8                        * C AT_REG equ 0x8
 = 10                       * C AT_FIELD equ 0x10
 = 20                       * C AT_NUM equ 0x20
 = 40                       * C AT_BF equ 0x40
 = 80                       * C AT_UNDEF equ 0x80
 = 100                      * C AT_FLOAT equ 0x100
 = 21                       * C AT_CONST equ 0x21
 = 3                        * C AT_TL equ 0x3
 = 23                       * C AT_TLN equ 0x23
 = 13                       * C AT_TLF equ 0x13
 = 33                       * C AT_TLFN equ 0x33
 = 41                       * C AT_TBF equ 0x41
 = 12                       * C AT_LF equ 0x12
 = 16                       * C AT_LIF equ 0x16
 = 32                       * C AT_LFN equ 0x32
 = B                        * C AT_TLR equ 0xB
 = 1FF                      * C AT_ALL equ 0x1FF
                              C 
                              C ; expression, returned by expression evaluator
                              C 
 = 1                          C define E_INDIRECT	0x01 ; indirect addressing used
 = 2                          C define E_EXPLICIT	0x02 ; Whether expression type explicitly given (to be removed!)
 = 4                          C define E_IS_ABS		0x04 ; external ABS
 = 8                          C define E_IS_TYPE	0x08 ; constant is a type
 = 10                         C define E_IS_OPEATTR	0x10 ; current operator is OPATTR
 = 20                         C define E_NEGATIVE	0x20 ; for EXPR_FLOAT only
 = 40                         C define E_ASSUMECHECK	0x40 ; v2.07: for ASSUMEd std registers
 = 80                         C define E_IS_DOT		0x80 ; v2.10: see regression test dotop5.asm
                              C 
00000000                      C expr		struct
00000000                      C union		; value of expression
00000000                      C  struct
00000000                      C   value		int_t ?
00000004                      C   hvalue	int_t ?
00000008                      C  ends
00000008                      C  struct
00000000                      C   union
00000000                      C    llvalue	uint64_t ?
00000008                      C    struct
00000000                      C     l64_l	uint_t ?
00000004                      C     l64_h	uint_t ?
00000008                      C    ends
00000008                      C   ends
00000008                      C   union
00000000                      C    hlvalue	uint64_t ?
00000008                      C    struct
00000000                      C     h64_l	uint_t ?
00000004                      C     h64_h	uint_t ?
00000008                      C    ends
00000008                      C   ends
00000010                      C  ends
00000000                      C  uvalue		uint_t ?
00000000                      C  value64	int64_t ?
00000000                      C  dvalue		real8 ?
00000000                      C  fvalue		real4 ?
00000000                      C  st_idx		int_t ?		; EXPR_REG: index if reg is ST
00000000                      C  chararray	uchar_t 16 dup(?)
00000010                      C ends
00000010                      C union
00000000                      C  quoted_string	token_t ?	; for EXPR_CONST + quoted strings only
00000000                      C  float_tok	token_t ?	; for EXPR_FLOAT only
00000008                      C ends
00000018                      C base_reg	token_t ?	; EXPR_ADDR: base register token, EXPR_REG: register token
00000020                      C idx_reg		token_t ?	; EXPR_ADDR: index register token
00000028                      C union
00000000                      C  label_tok	token_t ?	; token holding the label (EXPR_ADDR, used for overrides, inside expreval only)
00000000                      C  type_tok	token_t ?	; v2.10: token if target type of a label (SYM_STACK, MT_PTR) is to be stored
00000008                      C ends
00000030                      C override	token_t ?	; EXPR_ADDR: token holding the override label or segment register
00000038                      C inst		int_t ?		; operator token
0000003C                      C kind		int_t ?		; Type of expression
00000040                      C mem_type	uchar_t ?
00000041                      C scale		uchar_t ?	; EXPR_ADDR: scaling factor 1, 2, 4, or 8 - 386 code only
00000042                      C Ofssize		uchar_t ?	; 16,32,64 bit if MT_NEAR, MT_FAR
00000043                      C flags		uchar_t ?	; bit-flag
00000044                      C op		ptr opinfo ?
0000004C                      C sym		asym_t ?	; label used
00000054                      C mbr		asym_t ?	; struct member
0000005C                      C type		asym_t ?	; for DOT operator. Must be last (see TokenAssign)!
00000064                      C expr		ends
                              C expr_t		typedef ptr expr
                              C 
                              C ; flags for last argument of EvalOperand()
                              C 
                              C .enum expr_flags {
                            * C expr_flags typedef sdword
 = 1                        * C EXPF_NOERRMSG equ 0x1
 = 2                        * C EXPF_NOUNDEF equ 0x2
 = 4                        * C EXPF_ONEOPND equ 0x4
 = 8                        * C EXPF_IN_SQBR equ 0x8
                              C 
                              C EvalOperand	proto fastcall :ptr int_t, :ptr asm_tok, :int_t, :ptr expr, :uchar_t
                              C ExprEvalInit	proto fastcall
                              C EmitConstError	proto fastcall :expr_t
                              C 
                              C endif
                                include equate.inc
                              C ; EQUATE.INC--
                              C ;
                              C ; Copyright (c) The Asmc Contributors. All rights reserved.
                              C ; Consult your license regarding permissions and restrictions.
                              C ;
                              C ; EQU and '=' directives interface
                              C ;
                              C ifndef __EQUATE_INC
 = 0                          C define __EQUATE_INC
                              C 
                              C CreateConstant proto fastcall :ptr asm_tok
                              C CreateVariable proto fastcall :string_t, :int_t
                              C 
                              C endif
                                include input.inc
                              C ; INPUT.INC--
                              C ;
                              C ; Copyright (c) The Asmc Contributors. All rights reserved.
                              C ; Consult your license regarding permissions and restrictions.
                              C ;
                              C ifndef __INPUT_INC
 = 0                          C define __INPUT_INC
                              C 
                              C ; prototypes for input queueing/processing procedures
                              C 
00000000                      C macro_instance	struct
00000000                      C currline	srcline_t ?
00000008                      C startline	srcline_t ?
00000010                      C localstart	uint_t ?
00000014                      C parm_array	array_t ?
0000001C                      C _macro		asym_t ?
00000024                      C parmcnt		uint_t ?
00000028                      C macro_instance	ends
                              C 
                              C ; for line numbers, the source files have to be stored
                              C ; in a list in the very same order as they appear in
                              C ; the input stream.
                              C 
                              C fileseq_t	typedef ptr file_seq
00000000                      C file_seq	struct
00000000                      C next		fileseq_t ?
00000008                      C file		ushort_t ? ; index of file in FNames
0000000A                      C file_seq	ends
                              C 
00000000                      C input_status	struct
00000000                      C token_stringbuf string_t ?
00000008                      C currsource	string_t ?
00000010                      C CurrComment	string_t ?
00000018                      C token_count	int_t ?
0000001C                      C line_flags	char_t ? ; v2.08: added
0000001D                      C input_status	ends
                              C input_t		typedef ptr input_status
                              C 
                              C GetLineNumber		proto fastcall
                              C GetFNamePart		proto fastcall :string_t
                              C GetExtPart		proto fastcall :string_t
                              C SearchFile		proto fastcall :string_t, :int_t
                              C GetTextLine		proto fastcall :string_t
                              C PushMacro		proto fastcall :ptr macro_instance
                              C SetLineNumber		proto fastcall :uint_t
                              C AddStringToIncludePath	proto fastcall :string_t
                              C InputInit		proto fastcall
                              C InputPassInit		proto fastcall
                              C InputFini		proto fastcall
                              C InputExtend		proto fastcall :ptr line_status
                              C PushInputStatus		proto fastcall :input_t
                              C PopInputStatus		proto fastcall :input_t
                              C ClearSrcStack		proto fastcall
                              C get_curr_srcfile	proto fastcall
                              C set_curr_srcfile	proto fastcall :uint_t, :uint_t
                              C GetFName		proto fastcall :uint_t
                              C 
                            * C GetAlignedPointer macro p, size
 >                          * C add edx,size_t
 >                          * C and edx,not ( size_t - 1 )
 >                          * C add rax,rdx
 >                          * C exitm<>
 >                          * C endm
                              C GetAlignedPointer proto watcall p:ptr, size:int_t 
                              C 
                              C endif
                                include tokenize.inc
                              C ; TOKENIZE.INC--
                              C ;
                              C ; Copyright (c) The Asmc Contributors. All rights reserved.
                              C ; Consult your license regarding permissions and restrictions.
                              C ;
                              C ifndef __TOKENIZE_INC
 = 0                          C define __TOKENIZE_INC
                              C 
                              C ; prototypes for tokenizer
                              C 
00000000                      C line_status	    struc
00000000                      C input		    string_t ?
00000008                      C output		    string_t ?	; free space in token string buffer
00000010                      C start		    string_t ?	; start of line
00000018                      C index		    uint_t ?	; index token array
0000001C                      C flags		    char_t ?	; v2.08: added
0000001D                      C flags2		    char_t ?	; v2.08: was global var g_flags
0000001E                      C flags3		    char_t ?	; v2.08: added
0000001F                      C brachets	    char_t ?	; v2.32: added
00000020                      C tokenarray	    token_t ?	; v2.32: input to Tokenize() -- may change!
00000028                      C outbuf		    string_t ?	; v2.32: output start -- may change!
00000030                      C cstring		    char_t ?	; v2.32: added
00000031                      C line_status	    ends
                              C 
 = 0                          C TOK_DEFAULT	    equ 0x00	; default mode - handle conditional assembly
 = 1                          C TOK_RESCAN	    equ 0x01	; retokenize after expansion - ignore conditional assembly
 = 2                          C TOK_NOCURLBRACES    equ 0x02	; don't handle {}-literals
 = 4                          C TOK_LINE	    equ 0x04	; full line is retokenized
                              C 
 = 1                          C TF3_ISCONCAT	    equ 0x01	; line was concatenated
 = 2                          C TF3_EXPANSION	    equ 0x02	; expansion operator % at pos 0
                              C 
                              C GetToken proto fastcall :token_t, :ptr line_status
                              C Tokenize proto fastcall :string_t, :uint_t, :token_t, :uint_t
                              C 
                              C endif
                                include macro.inc
                              C ; MACRO.INC--
                              C ;
                              C ; Copyright (c) The Asmc Contributors. All rights reserved.
                              C ; Consult your license regarding permissions and restrictions.
                              C ;
                              C ; prototypes for macro stuff
                              C ;
                              C ifndef __MACRO_INC
 = 0                          C define __MACRO_INC
                              C 
 = A                          C PLACEHOLDER_CHAR	equ 10	 ; "escape" char for macro placeholders
                              C 
 = 1                          C MF_LABEL		equ 0x01 ; a label exists at pos 0
 = 2                          C MF_NOSAVE		equ 0x02 ; no need to save/restore input status
 = 4                          C MF_IGNARGS		equ 0x04 ; ignore additional arguments (for FOR directive)
                              C 
                              C ; functions in expans.asm
                              C 
                              C GetLiteralValue		proto fastcall :string_t, :string_t
                              C RunMacro		proto fastcall :ptr dsym, :int_t, :ptr asm_tok, :string_t, :int_t, :ptr int_t
                              C ExpandText		proto fastcall :string_t, :ptr asm_tok, :uint_t
                              C ExpandLineItems		proto fastcall :string_t, :int_t, :ptr asm_tok, :int_t, :int_t
                              C ExpandLine		proto fastcall :string_t, :ptr asm_tok
                              C ExpandLiterals		proto fastcall :int_t, :ptr asm_tok
                              C 
                              C ; functions in macro.asm
                              C 
                              C CreateMacro		proto fastcall :string_t ; create a macro symbol
                              C ReleaseMacroData	proto fastcall :dsym_t
                              C fill_placeholders	proto fastcall :string_t, :string_t, :uint_t, :uint_t, :array_t
                              C SkipCurrentQueue	proto fastcall :ptr asm_tok
                              C StoreMacro		proto fastcall :ptr dsym, :int_t, :ptr asm_tok, :int_t ;; store macro content
                              C MacroInit		proto fastcall :int_t
                              C 
                              C ; functions in string.asm
                              C 
                              C SetTextMacro		proto fastcall :token_t, :asym_t, :string_t, :string_t ;; EQU for texts
                              C AddPredefinedText	proto fastcall :string_t, :string_t
                              C TextItemError		proto fastcall :token_t
                              C 
                              C StringInit		proto fastcall
                              C MacroLineQueue		proto fastcall
                              C 
                              C endif
                                include condasm.inc
                              C ; CONDASM.INC--
                              C ;
                              C ; Copyright (c) The Asmc Contributors. All rights reserved.
                              C ; Consult your license regarding permissions and restrictions.
                              C ;
                              C ; prototypes for conditional assembly and errors
                              C ;
                              C ifndef __CONDASM_INC
 = 0                          C define __CONDASM_INC
                              C 
                              C .enum if_state {
                            * C if_state typedef sdword
 = 0                        * C BLOCK_ACTIVE equ 0x0
 = 1                        * C BLOCK_INACTIVE equ 0x1
 = 2                        * C BLOCK_DONE equ 0x2
                              C 
                              C .enum cond_class {
                            * C cond_class typedef sdword
 = 0                        * C CC_NULL equ 0x0
 = 1                        * C CC_NUMARG equ 0x1
 = 2                        * C CC_LITARG equ 0x2
 = 3                        * C CC_BLKARG equ 0x3
 = 4                        * C CC_SYMARG equ 0x4
 = 5                        * C CC_PASS1 equ 0x5
 = 6                        * C CC_PASS2 equ 0x6
                              C 
                              C externdef CurrIfState:if_state
                              C 
                              C CondPrepare     proto fastcall :int_t
                              C GetIfNestLevel  proto fastcall
                              C SetIfNestLevel  proto fastcall :int_t
                              C CondCheckOpen   proto fastcall
                              C CondInit        proto fastcall
                              C 
                              C endif
                              C 
                                include listing.inc
                              C ; LISTING.INC--
                              C ;
                              C ; Copyright (c) The Asmc Contributors. All rights reserved.
                              C ; Consult your license regarding permissions and restrictions.
                              C ;
                              C ; listing interface.
                              C ;
                              C ifndef __LISTING_INC
 = 0                          C define __LISTING_INC
                              C 
                              C .enum lsttype {
                            * C lsttype typedef sdword
 = 0                        * C LSTTYPE_DATA equ 0x0
 = 1                        * C LSTTYPE_CODE equ 0x1
 = 2                        * C LSTTYPE_EQUATE equ 0x2
 = 3                        * C LSTTYPE_TMACRO equ 0x3
 = 4                        * C LSTTYPE_DIRECTIVE equ 0x4
 = 5                        * C LSTTYPE_MACRO equ 0x5
 = 6                        * C LSTTYPE_STRUCT equ 0x6
 = 7                        * C LSTTYPE_LABEL equ 0x7
 = 8                        * C LSTTYPE_MACROLINE equ 0x8
                              C 
                              C LstInit		proto fastcall
                              C LstWriteSrcLine proto fastcall
                              C LstWriteCRef	proto fastcall
                              C LstPrintf	proto fastcall :string_t, :vararg
                              C LstSetPosition	proto fastcall
                              C LstNL		proto fastcall
                              C LstWrite	proto fastcall :int_t, :uint_t, :ptr
                              C 
                              C endif
                                include qfloat.inc
                              C ; QFLOAT.INC--
                              C ;
                              C ; Copyright (c) The Asmc Contributors. All rights reserved.
                              C ; Consult your license regarding permissions and restrictions.
                              C ;
                              C ifndef __QFLOAT_INC
 = 0                          C define __QFLOAT_INC
                              C include fltintrn.inc
                              C 
                              C ifdef _WIN64
                            * C __mul64 macro multiplier, multiplicand
 >                          * C mul rdx
 >                          * C exitm<>
 >                          * C endm
                              C __mul64 proto watcall multiplier:int64_t, multiplicand:int64_t 
                              C endif
                              C __div64     proto watcall :int64_t, :int64_t
                              C __rem64     proto watcall :int64_t, :int64_t
                              C 
                              C quad_resize proto fastcall :ptr expr, :int_t
                              C _atoqw      proto fastcall :string_t
                              C _atoow      proto fastcall :string_t, :string_t, :int_t, :int_t
                              C atofloat    proto fastcall :ptr, :string_t, :uint_t, :int_t, :uchar_t
                              C 
                              C endif
                                include lqueue.inc
                              C ; LQUEUE.INC--
                              C ;
                              C ; Copyright (c) The Asmc Contributors. All rights reserved.
                              C ; Consult your license regarding permissions and restrictions.
                              C ;
                              C ; v2.11: line queue functions moved from input.asm to lqueue.asm
                              C ;
                              C ifndef __LQUEUE_INC
 = 0                          C define __LQUEUE_INC
                              C 
                              C DeleteLineQueue proto fastcall
                              C AddLineQueue    proto fastcall :string_t
                              C AddLineQueueX   proto fastcall :string_t, :vararg
                              C RunLineQueue    proto fastcall
                              C InsertLineQueue proto fastcall
 = AddLineQueue               C QueueTestLines  equ <AddLineQueue>
                              C 
                              C is_linequeue_populated macro
 >                            C     exitm<ModuleInfo.line_queue.head>
 >                            C     endm
                              C 
                              C endif
                                include types.inc
                              C ; TYPES.INC--
                              C ;
                              C ; Copyright (c) The Asmc Contributors. All rights reserved.
                              C ; Consult your license regarding permissions and restrictions.
                              C ;
                              C ifndef __TYPES_INC
 = 0                          C define __TYPES_INC
                              C 
                              C ; qualified_type us used for parsing a qualified type.
                              C 
                              C .template qualified_type
00000000                    * C qualified_type struct
00000000                      C     size		int_t ?
00000004                      C     symtype		ptr asym ?
0000000C                      C     mem_type		db ?
0000000D                      C     is_ptr		db ?	; contains level of indirection
0000000E                      C     is_far		db ?
0000000F                      C     Ofssize		db ?
00000010                      C     ptr_memtype		db ?
                              C    .ends
00000011                    * C qualified_type ends
                              C 
                              C externdef CurrStruct:ptr dsym	; start of current STRUCT list
                              C 
                              C CreateType		proto fastcall :int_t, :token_t, :string_t, :ptr ptr asym
                              C CreateTypeSymbol	proto fastcall :ptr asym, :string_t, :int_t
                              C SearchNameInStruct	proto fastcall :ptr asym, :string_t, :ptr uint_t, :int_t
                              C GetQualifiedType	proto fastcall :ptr int_t, :ptr asm_tok, :ptr qualified_type
                              C CreateStructField	proto fastcall :int_t, :ptr asm_tok, :string_t, :uchar_t, :ptr asym, :uint_t
                              C UpdateStructSize	proto fastcall :ptr asym
                              C SetStructCurrentOffset	proto fastcall :int_t
                              C AlignInStruct		proto fastcall :int_t
                              C TypesInit		proto
                              C EndstructDirective	proto fastcall :int_t, :ptr asm_tok
                              C 
                              C DeleteType macro t
 >                            C     endm
                              C 
                              C endif

                                public MacroLocals

                                ; TEVALUE_UNSIGNED
                                ; 1 = the % operator used in an TEXTEQU expression is supposed to
                                ;     return an UNSIGNED value ( Masm-compatible ).

 = 1                            TEVALUE_UNSIGNED equ 1
 = 14                           MAX_TEXTMACRO_NESTING equ 20

                                .data
00000000                    *   _DATA segment
                            *   assume cs:ERROR
00000000                         MacroLocals int_t 0     ; counter for LOCAL names
00000004                         MacroLevel  dd 0        ; current macro nesting level
00000000                        .code
                            *   _DATA ends
00000000                    *   _TEXT segment
                            *   assume cs:FLAT

                                if 0
                                endif

                                ; C ltoa() isn't fully compatible since hex digits are lower case.
                                ; for JWasm, it's ensured that 2 <= radix <= 16.

00000000                        myltoa proc fastcall uses rsi rdi rbx value:qword, buffer:string_t, radix:uint_t, sign:int_t, addzero:int_t

                                  local tmpbuf[64]:char_t

                                ifdef _WIN64

00000000                    *   mov [rsp+8], rcx
00000005                    *   mov [rsp+16], rdx
0000000A                    *   mov [rsp+24], r8
0000000F                    *   mov [rsp+32], r9
00000014                    *   push rsi
00000015                    *   push rdi
00000016                    *   push rbx
00000017                    *   push rbp
00000018                    *   mov rbp, rsp
0000001B                    *   sub rsp, 104
0000001F                            mov rdi,rdx
00000022                            mov rax,rcx

00000025                            .if ( r9d )
00000025                    *   test ( r9d ), ( r9d )
00000028                    *   jz  @C0001

0000002A                                mov byte ptr [rdi],'-'
0000002D                                inc rdi
00000030                                neg rax

00000033                            .elseif ( rax == 0 )
00000033                    *   jmp @C0002
00000035                    *   @C0001:
00000035                    *   test rax , rax 
00000038                    *   jnz @C0003

0000003A                                mov word ptr [rdi],'0'
0000003F                               .return 1
0000003F                    *   mov eax,1
00000044                    *   jmp @C0004
00000046                            .endif
00000046                    *   @C0003:
00000046                    *   @C0002:

00000046                            .for ( rsi = &tmpbuf[63] : rax : rsi-- )
00000046                    *   lea rsi, tmpbuf[63]
0000004A                    *   @C0005:
0000004A                    *   test rax, rax
0000004D                    *   jz  @C0007

0000004F                                xor edx,edx
00000051                                div r8
00000054                                add dl,'0'
00000057                                .if dl > '9'
00000057                    *   cmp dl , '9'
0000005A                    *   jna @C0008
0000005C                                    add dl,'A'-'9'-1
0000005F                                .endif
0000005F                    *   @C0008:
0000005F                                mov [rsi],dl
00000061                            .endf
00000061                    *   @C0006:
00000061                    *   dec rsi
00000064                    *   jmp @C0005
00000066                    *   @C0007:
00000066                            inc rsi

                                endif

                                    ; v2: add a leading '0' if first digit is alpha

00000069                            .if ( addzero && byte ptr [rsi] > '9' )
00000069                    *   cmp addzero , 0
0000006D                    *   jz  @C0009
0000006F                    *   cmp byte ptr [rsi] , '9' 
00000072                    *   jna @C0009
00000074                                mov byte ptr [rdi],'0'
00000077                                inc rdi
0000007A                            .endif
0000007A                    *   @C0009:

0000007A                            lea rcx,tmpbuf[64]
0000007E                            sub rcx,rsi
00000081                            rep movsb
00000083                            mov byte ptr [rdi],0
00000086                            mov rax,rdi
00000089                            sub rax,buffer
0000008D                            ret
0000008D                    *   @C0004:
0000008D                    *   leave
0000008E                    *   pop rbx
0000008F                    *   pop rdi
00000090                    *   pop rsi
00000091                    *   retn 

00000092                        myltoa endp


                                ; Read the current (macro) queue until it's done.

00000092                        SkipMacro proc fastcall private tokenarray:token_t

                                    local buffer:ptr char_t

00000092                    *   mov [rsp+8], rcx
00000097                    *   push rbp
00000098                    *   mov rbp, rsp
0000009B                    *   sub rsp, 48
0000009F                            mov buffer,alloca( ModuleInfo.max_line_len )
0000009F                    *   invoke alloca, ModuleInfo.max_line_len 
0000009F                    *   mov eax, ModuleInfo.max_line_len 
000000A5                    *1  add     eax,16-1
000000A8                    *1  and     eax,-16
000000AB                    *1  sub     rsp,rax
000000AE                    *1  lea     rax,[rsp+@ReservedStack]
000000B3                    *   mov buffer, rax

                                    ; The queue isn't just thrown away, because any
                                    ; coditional assembly directives found in the source
                                    ; must be executed.

000000B7                            .while GetTextLine( buffer )
000000B7                    *   jmp @C000B
000000B9                    *   @C000A:
000000B9                    *   invoke Tokenize, buffer, 0, tokenarray, TOK_DEFAULT 
000000B9                    *    xor r9d, r9d
000000BC                    *    mov r8, tokenarray
000000C0                    *    xor edx, edx
000000C2                    *    mov rcx, buffer
000000C6                    *    call Tokenize
                                invoke Tokenize( buffer, 0, tokenarray, TOK_DEFAULT )
000000CB                            .endw
000000CB                    *   @C000B:
000000CB                    *   invoke GetTextLine, buffer 
000000CB                    *    mov rcx, buffer 
000000CF                    *    call GetTextLine
000000D4                    *   test rax, rax
000000D7                    *   jnz @C000A
000000D9                            ret
000000D9                    *   leave
000000DA                    *   retn 

000000DB                        SkipMacro endp


                                ExpandTMacro proto fastcall :string_t, :token_t, :int_t, :int_t

                                ; run a macro.
                                ; - macro:  macro item
                                ; - out:    value to return (for macro functions)
                                ; - label:  token of label ( or -1 if none )
                                ; - is_exitm: returns TRUE if EXITM has been hit
                                ; returns index of token not processed or -1 on errors

                                    assume rsi:dsym_t
                                    assume rdi:ptr macro_info
                                    assume rbx:token_t

000000DB                        RunMacro proc fastcall uses rsi rdi rbx mac:dsym_t, idx:int_t, tokenarray:token_t,_out:string_t, mflags:int_t, is_exitm:ptr int_t

                                    local currparm          :string_t
                                    local savedStringBuffer :string_t
                                    local i                 :int_t
                                    local _retm             :int_t
                                    local parmidx           :int_t
                                    local skipcomma         :int_t
                                    local varargcnt         :int_t
                                    local bracket_level     :int_t      ;; () level (needed for macro functions)
                                    local parm_end_delim    :int_t      ;; parameter end delimiter
                                    local p                 :string_t
                                    local parmstrings       :string_t
                                    local info              :ptr macro_info
                                    local lnode             :srcline_t
                                    local sym               :asym_t
                                    local opndx             :expr
                                    local mi                :macro_instance
                                    local oldstat           :input_status
                                    local oldifnesting      :int_t
                                    local cntgoto           :int_t
                                    local inside_literal    :int_t
                                    local inside_angle_brackets:int_t
                                    local old_tokencount    :int_t
                                    local max               :int_t
                                    local cnt               :int_t
                                    local cnt_opnum         :int_t
                                    local is_exitm2         :int_t
                                    local len               :int_t
                                    local cvt               :FLTINFO

000000DB                    *   mov [rsp+8], rcx
000000E0                    *   mov [rsp+16], rdx
000000E5                    *   mov [rsp+24], r8
000000EA                    *   mov [rsp+32], r9
000000EF                    *   push rsi
000000F0                    *   push rdi
000000F1                    *   push rbx
000000F2                    *   push rbp
000000F3                    *   mov rbp, rsp
000000F6                    *   sub rsp, 392
000000FD                            mov savedStringBuffer,ModuleInfo.stringbufferend
000000FD                    *    mov rax, ModuleInfo.stringbufferend
00000104                    *    mov savedStringBuffer, rax
00000108                            mov _retm,0
0000010F                            .if idx > 1
0000010F                    *   cmp idx , 1
00000113                    *   jng @C000C
00000115                                inc _retm
00000118                            .endif
00000118                    *   @C000C:
00000118                            mov bracket_level,-1

0000011F                            .return asmerr( 2123 ) .if MacroLevel == MAX_MACRO_NESTING
0000011F                    *   cmp MacroLevel , MAX_MACRO_NESTING
00000126                    *   jnz @C000E
00000128                    *   invoke asmerr, 2123 
00000128                    *    mov ecx, 2123 
0000012D                    *    call asmerr
00000132                    *   jmp @C000D
00000134                    *   @C000E:

00000134                            mov  mi.parm_array,NULL
0000013F                            mov  rsi,mac
00000143                            mov  rdi,[rsi].macroinfo
00000147                            mov  info,rdi
0000014B                            imul ebx,idx,asm_tok
0000014F                            add  rbx,tokenarray

                                    ; invokation of macro functions requires params enclosed in "()"

00000153                            mov parm_end_delim,T_FINAL
0000015A                            .if ( [rsi].mac_flag & M_ISFUNC )
0000015A                    *   test [rsi].mac_flag , M_ISFUNC 
0000015E                    *   je  @C000F
00000160                                .if ( [rbx].token == T_OP_BRACKET ) ; should be always true
00000160                    *   cmp [rbx].token , T_OP_BRACKET 
00000163                    *   jnz @C0010
00000165                                    inc idx
00000168                                    add rbx,asm_tok
0000016C                                    mov parm_end_delim,T_CL_BRACKET
00000173                                    mov bracket_level,1
0000017A                                .endif
0000017A                    *   @C0010:
0000017A                                mov rax,_out ;; v2.08: init return value buffer
0000017E                                mov byte ptr [rax],0
00000181                            .endif
00000181                    *   @C000F:
                                    ;; v2.08: if macro is purged, return "void"
00000181                            .if ( [rsi].mac_flag & M_PURGED )
00000181                    *   test [rsi].mac_flag , M_PURGED 
00000185                    *   je  @C0011
00000187                                .if ( bracket_level > 0 )
00000187                    *   cmp bracket_level , 0 
0000018B                    *   jng @C0012
0000018D                                    .for ( : bracket_level && [rbx].token != T_FINAL: idx++, rbx += asm_tok )
0000018D                    *   @C0013:
0000018D                    *   cmp bracket_level , 0
00000191                    *   jz  @C0015
00000193                    *   cmp [rbx].token , T_FINAL
00000196                    *   jz  @C0015
00000198                                        .if [rbx].token == T_OP_BRACKET
00000198                    *   cmp [rbx].token , T_OP_BRACKET
0000019B                    *   jnz @C0016
0000019D                                            inc bracket_level
000001A0                                        .elseif [rbx].token == T_CL_BRACKET
000001A0                    *   jmp @C0017
000001A2                    *   @C0016:
000001A2                    *   cmp [rbx].token , T_CL_BRACKET
000001A5                    *   jnz @C0018
000001A7                                            dec bracket_level
000001AA                                        .endif
000001AA                    *   @C0018:
000001AA                    *   @C0017:
000001AA                                    .endf
000001AA                    *   @C0014:
000001AA                    *   inc idx
000001AD                    *   add rbx, asm_tok
000001B1                    *   jmp @C0013
000001B3                    *   @C0015:
000001B3                                .else
000001B3                    *   jmp @C0019
000001B5                    *   @C0012:
000001B5                                    mov idx,ModuleInfo.token_count
000001B5                    *    mov eax, ModuleInfo.token_count
000001BB                    *    mov idx, eax
000001BE                                .endif
000001BE                    *   @C0019:
000001BE                                .return idx
000001BE                    *   mov eax,idx
000001C1                    *   jmp @C000D
000001C3                            .endif
000001C3                    *   @C0011:

000001C3                            .if [rdi].parmcnt
000001C3                    *   cmp [rdi].parmcnt, 0
000001C7                    *   jz  @C001A

000001C9                                movzx   ecx,[rdi].parmcnt
000001CC                                mov     eax,ModuleInfo.max_line_len
000001D2                                add     eax,eax
000001D4                                lea     rax,[rax+rcx*size_t]
000001D8                                mov     mi.parm_array,alloca(eax)
000001D8                    *   invoke alloca, eax
000001D8                    *1  add     eax,16-1
000001DB                    *1  and     eax,-16
000001DE                    *1  sub     rsp,rax
000001E1                    *1  lea     rax,[rsp+@ReservedStack]
000001E6                    *   mov     mi.parm_array, rax
000001ED                                movzx   ecx,[rdi].parmcnt
000001F0                                lea     rax,[rax+rcx*size_t]
000001F4                                mov     parmstrings,rax ;; init the macro arguments pointer
000001F8                                mov     currparm,rax
000001FC                            .endif
000001FC                    *   @C001A:

                                    ; now get all the parameters from the original src line.
                                    ; macro parameters are expanded if
                                    ; - it is a macro function call            or
                                    ; - the expansion operator (%) is found

000001FC                            mov rbx,tokenarray
00000200                            mov parmidx,0
00000207                            .if ( [rsi].mac_flag & M_LABEL )
00000207                    *   test [rsi].mac_flag , M_LABEL 
0000020B                    *   je  @C001B
0000020D                                .if ( mflags & MF_LABEL )
0000020D                    *   test mflags , MF_LABEL 
00000214                    *   je  @C001C
00000216                                    mov i,tstrlen( [rbx].string_ptr )
00000216                    *   invoke tstrlen, [rbx].string_ptr 
00000216                    *    mov rcx, [rbx].string_ptr 
0000021A                    *    call tstrlen
0000021F                    *   mov i, eax
00000222                                    mov ecx,parmidx
00000225                                    mov rdx,mi.parm_array
0000022C                                    mov rdi,currparm
00000230                                    mov [rdx+rcx*size_t],rdi
00000234                                    mov ecx,i
00000237                                    inc ecx
00000239                                    mov rsi,[rbx].string_ptr
0000023D                                    rep movsb
0000023F                                    mov currparm,GetAlignedPointer( currparm, i )
0000023F                    *   invoke GetAlignedPointer, currparm, i 
0000023F                    *   mov edx, i 
00000242                    *   mov rax, currparm
00000246                    *1  add edx,size_t
00000249                    *1  and edx,not ( size_t - 1 )
0000024C                    *1  add rax,rdx
0000024F                    *   mov currparm, rax
00000253                                .else
00000253                    *   jmp @C001D
00000255                    *   @C001C:
00000255                                    mov ecx,parmidx
00000258                                    mov rdx,mi.parm_array
00000000                        .data
                            *   _TEXT ends
00000008                    *   _DATA segment
                            *   assume cs:ERROR
00000008                         DS0000 sbyte 0
00000000                        .code
                            *   _DATA ends
0000025F                    *   _TEXT segment
                            *   assume cs:FLAT
0000025F                                    lea rax,DS0000
00000266                                    mov [rdx+rcx*size_t],rax
0000026A                                .endif
0000026A                    *   @C001D:
0000026A                                inc parmidx
0000026D                            .endif
0000026D                    *   @C001B:
0000026D                            mov rax,is_exitm
00000271                            mov dword ptr [rax],FALSE

                                    ;; v2.08: allow T_FINAL to be chained, lastidx==0 is true final
00000277                            imul eax,ModuleInfo.token_count,asm_tok
0000027E                            mov  [rbx+rax].lastidx,0
00000286                            imul eax,idx,asm_tok
0000028A                            add  rbx,rax

0000028D                            .for ( varargcnt = 0, skipcomma = 0 : : parmidx++ )
0000028D                    *   mov varargcnt, 0
00000294                    *   mov skipcomma, 0
0000029B                    *   @C001E:

                                        ;; v2.09: don't skip comma if it was the last argument.
                                        ;; this will a) make a trailing comma trigger warning 'too many arguments...'
                                        ;; and b), argument handling of FOR loop is significantly simplified.

0000029B                                mov rsi,mac
0000029F                                mov rdi,info
000002A3                                movzx ecx,[rdi].parmcnt
000002A6                                .break .if parmidx >= ecx
000002A6                    *   cmp parmidx , ecx
000002A9                    *   jnl @C0020

000002AB                                imul ebx,idx,asm_tok
000002AF                                add  rbx,tokenarray
000002B3                                .if [rbx].token == T_COMMA && skipcomma
000002B3                    *   cmp [rbx].token , T_COMMA 
000002B6                    *   jnz @C0021
000002B8                    *   cmp skipcomma, 0
000002BC                    *   jz  @C0021
000002BE                                    inc idx
000002C1                                    add rbx,asm_tok
000002C5                                .endif
000002C5                    *   @C0021:

000002C5                                mov skipcomma,1
000002CC                                dec ecx

000002CE                                .if ( [rbx].token == T_FINAL || [rbx].token == parm_end_delim ||( [rbx].token == T_COMMA &&( !( [rsi].mac_flag & M_ISVARARG ) || parmidx != ecx ) ) )
000002CE                    *   cmp [rbx].token , T_FINAL 
000002D1                    *   jz  @C0023
000002D3                    *   @C0024:
000002D3                    *   cmp [rbx].token , parm_end_delim 
000002D3                    *    mov eax,  parm_end_delim 
000002D6                    *    cmp [rbx].token , al
000002D8                    *   jz  @C0023
000002DA                    *   @C0025:
000002DA                    *   cmp [rbx].token , T_COMMA 
000002DD                    *   jnz @C0022
000002DF                    *   test [rsi].mac_flag , M_ISVARARG 
000002E3                    *   je  @C0023
000002E5                    *   @C0027:
000002E5                    *   cmp parmidx , ecx 
000002E8                    *   jz  @C0022
000002EA                    *   @C0023:

                                            ;; it's a blank parm
000002EA                                    imul eax,parmidx,mparm_list
000002EE                                    mov rcx,[rdi].parmlist
000002F2                                    add rcx,rax
000002F5                                    .if [rcx].mparm_list.required
000002F5                    *   cmp [rcx].mparm_list.required, 0
000002F9                    *   jz  @C0028
000002FB                                        .return asmerr( 2125 )
000002FB                    *   invoke asmerr, 2125 
000002FB                    *    mov ecx, 2125 
00000300                    *    call asmerr
00000305                    *   jmp @C000D
00000307                                    .endif
00000307                    *   @C0028:
00000307                                    .if varargcnt == 0
00000307                    *   cmp varargcnt , 0
0000030B                    *   jnz @C0029
0000030D                                        imul edx,parmidx,ptr_t
00000311                                        add rdx,mi.parm_array
00000318                                        mov [rdx],[rcx].mparm_list.deflt
00000318                    *    mov rax, [rcx].mparm_list.deflt
0000031B                    *    mov [rdx], rax
0000031E                                    .endif
0000031E                    *   @C0029:
0000031E                                .else
0000031E                    *   jmp @C002A
00000320                    *   @C0022:

00000320                                    mov inside_literal,0
0000032A                                    mov inside_angle_brackets,0
00000334                                    mov old_tokencount,ModuleInfo.token_count
00000334                    *    mov eax, ModuleInfo.token_count
0000033A                    *    mov old_tokencount, eax

00000340                                    mov rdx,currparm
00000344                                    mov byte ptr [rdx],0

00000347                                    .for ( p = rdx : : idx++ )
00000347                    *   mov p, rdx
0000034B                    *   @C002B:

0000034B                                        imul ebx,idx,asm_tok
0000034F                                        add  rbx,tokenarray
00000353                                        .break .if ( [rbx].token == T_FINAL || [rbx].token == T_COMMA ) && !inside_literal
00000353                    *   cmp [rbx].token , T_FINAL 
00000356                    *   jz  @C002F
00000358                    *   cmp [rbx].token , T_COMMA 
0000035B                    *   jnz @C002E
0000035D                    *   @C002F:
0000035D                    *   cmp inside_literal, 0
00000364                    *   jz  @C002D
00000366                    *   @C002E:

                                                ;; if were're inside a literal, go up one level and continue scanning the argument

00000366                                        .if [rbx].token == T_FINAL
00000366                    *   cmp [rbx].token , T_FINAL
00000369                    *   jnz @C0030

0000036B                                            mov  idx,[rbx].lastidx ;; restore token index
0000036B                    *    mov eax, [rbx].lastidx
0000036E                    *    mov idx, eax
00000371                                            imul ebx,eax,asm_tok
00000374                                            add  rbx,tokenarray

00000378                                            dec inside_literal
0000037E                                            .if [rbx].string_delim == '<'
0000037E                    *   cmp [rbx].string_delim , '<'
00000382                    *   jnz @C0031
00000384                                                mov inside_angle_brackets,0
0000038E                                            .else
0000038E                    *   jmp @C0032
00000390                    *   @C0031:
00000390                                                mov rax,p
00000394                                                inc p
00000398                                                mov byte ptr [rax],'}'
0000039B                                            .endif
0000039B                    *   @C0032:
0000039B                                            .continue
0000039B                    *    jmp @C002C
0000039D                                        .endif
0000039D                    *   @C0030:

0000039D                                        .if ( [rbx].token == T_PERCENT )
0000039D                    *   cmp [rbx].token , T_PERCENT 
000003A0                    *   jnz @C0033

                                                    ; expansion of macro parameters.
                                                    ; if the token behind % is not a text macro or macro function
                                                    ; the expression will be always expanded and evaluated.
                                                    ; Else it is expanded, but only evaluated if

000003A2                                            inc idx
000003A5                                            add rbx,asm_tok
000003A9                                            .while [rbx].token == T_PERCENT
000003A9                    *   jmp @C0035
000003AB                    *   @C0034:
000003AB                                                inc idx
000003AE                                                add rbx,asm_tok
000003B2                                            .endw
000003B2                    *   @C0035:
000003B2                    *   cmp [rbx].token , T_PERCENT
000003B5                    *   jz  @C0034
000003B7                                            mov i,idx
000003B7                    *    mov eax, idx
000003BA                    *    mov i, eax
000003BD                                            mov cnt_opnum,1
000003C7                                            .if [rbx].token == T_ID
000003C7                    *   cmp [rbx].token , T_ID
000003CA                    *   jnz @C0036
000003CC                                                mov sym,SymFind([rbx].string_ptr)
000003CC                    *   invoke SymFind, [rbx].string_ptr
000003CC                    *    mov rcx, [rbx].string_ptr
000003D0                    *    call SymFind
000003D5                    *   mov sym, rax
000003D9                                                .if ( rax && [rax].asym.flags & S_ISDEFINED && ( [rax].asym.state == SYM_TMACRO ||( [rax].asym.state == SYM_MACRO && ( [rax].asym.mac_flag & M_ISFUNC ) &&[rbx+asm_tok].token == T_OP_BRACKET ) ) )
000003D9                    *   test rax , rax 
000003DC                    *   jz  @C0037
000003DE                    *   test [rax].asym.flags , S_ISDEFINED 
000003E2                    *   je  @C0037
000003E4                    *   cmp [rax].asym.state , SYM_TMACRO 
000003E8                    *   jz  @C0038
000003EA                    *   @C0039:
000003EA                    *   cmp [rax].asym.state , SYM_MACRO 
000003EE                    *   jnz @C0037
000003F0                    *   test [rax].asym.mac_flag , M_ISFUNC 
000003F4                    *   je  @C0037
000003F6                    *   cmp [rbx+asm_tok].token , T_OP_BRACKET 
000003FA                    *   jnz @C0037
000003FC                    *   @C0038:
000003FC                                                    mov cnt_opnum,0
00000406                                                .endif
00000406                    *   @C0037:
00000406                                            .endif
00000406                    *   @C0036:

00000406                                            .for ( cnt = 0 :: i++ )
00000406                    *   mov cnt, 0
00000410                    *   @C003A:

00000410                                                imul ebx,i,asm_tok
00000414                                                add  rbx,tokenarray
00000418                                                .break .if [rbx].token == T_FINAL || [rbx].token == T_COMMA
00000418                    *   cmp [rbx].token , T_FINAL 
0000041B                    *   jz  @C003C
0000041D                    *   cmp [rbx].token , T_COMMA
00000420                    *   jz  @C003C

00000422                                                mov rcx,[rbx].string_ptr
00000426                                                .if ( isdotlabel( [rcx], ModuleInfo.dotname ) )
00000426                    *   invoke isdotlabel, [rcx], ModuleInfo.dotname 
00000426                    *    movzx edx, byte ptr ModuleInfo.dotname 
0000042D                    *    movzx eax, byte ptr [rcx]
00000430                    *   cmp al , '.' 
00000432                    *   jnz @C003F
00000434                    *   test dl, dl
00000436                    *   jnz @C003E
00000438                    *   @C003F:
00000438                    *   test byte ptr [r15+rax+1] , _LABEL
0000043E                    *   je  @C003D
00000440                    *   @C003E:

00000440                                                    .if ( [rbx+asm_tok].token == T_OP_BRACKET )
00000440                    *   cmp [rbx+asm_tok].token , T_OP_BRACKET 
00000444                    *   jnz @C0040

00000446                                                        add i,2
0000044A                                                        add rbx,asm_tok*2
0000044E                                                        .for ( ecx = 1: ecx && [rbx].token != T_FINAL: i++, rbx += asm_tok )
0000044E                    *   mov ecx, 1
00000453                    *   @C0041:
00000453                    *   test ecx , ecx 
00000455                    *   jz  @C0043
00000457                    *   cmp [rbx].token , T_FINAL
0000045A                    *   jz  @C0043
0000045C                                                            .if [rbx].token == T_OP_BRACKET
0000045C                    *   cmp [rbx].token , T_OP_BRACKET
0000045F                    *   jnz @C0044
00000461                                                                inc ecx
00000463                                                            .elseif [rbx].token == T_CL_BRACKET
00000463                    *   jmp @C0045
00000465                    *   @C0044:
00000465                    *   cmp [rbx].token , T_CL_BRACKET
00000468                    *   jnz @C0046
0000046A                                                                dec ecx
0000046C                                                            .endif
0000046C                    *   @C0046:
0000046C                    *   @C0045:
0000046C                                                        .endf
0000046C                    *   @C0042:
0000046C                    *   inc i
0000046F                    *   add rbx, asm_tok
00000473                    *   jmp @C0041
00000475                    *   @C0043:
00000475                                                        dec i
00000478                                                    .endif
00000478                    *   @C0040:
00000478                                                    .continue
00000478                    *    jmp @C003B
0000047A                                                .endif
0000047A                    *   @C003D:
                                                        ;; count brackets
0000047A                                                .if parm_end_delim == T_CL_BRACKET
0000047A                    *   cmp parm_end_delim , T_CL_BRACKET
0000047E                    *   jnz @C0047
00000480                                                    .if [rbx].token == T_OP_BRACKET
00000480                    *   cmp [rbx].token , T_OP_BRACKET
00000483                    *   jnz @C0048
00000485                                                        inc cnt
0000048B                                                    .elseif [rbx].token == T_CL_BRACKET
0000048B                    *   jmp @C0049
0000048D                    *   @C0048:
0000048D                    *   cmp [rbx].token , T_CL_BRACKET
00000490                    *   jnz @C004A
00000492                                                        .break .if cnt == 0
00000492                    *   cmp cnt , 0
00000499                    *   jz  @C003C
0000049B                                                        dec cnt
000004A1                                                    .endif
000004A1                    *   @C004A:
000004A1                    *   @C0049:
000004A1                                                .endif
000004A1                    *   @C0047:

                                                        ;; stop if undelimited string occurs (need to scan for '!')
000004A1                                                .break .if ( [rbx].token == T_STRING && [rbx].string_delim == 0 )
000004A1                    *   cmp [rbx].token , T_STRING 
000004A4                    *   jnz @C004B
000004A6                    *   @C004C:
000004A6                    *   cmp [rbx].string_delim , 0 
000004AA                    *   jz  @C003C
000004AC                    *   @C004B:

                                                        ;; names dot and amp are ok
000004AC                                                .if !( [rbx].token == T_DOT || [rbx].token == '&' || [rbx].token == '%' )
000004AC                    *   cmp [rbx].token , T_DOT 
000004AF                    *   jz  @C004D
000004B1                    *   cmp [rbx].token , '&' 
000004B4                    *   jz  @C004D
000004B6                    *   cmp [rbx].token , '%' 
000004B9                    *   jz  @C004D
000004BB                                                    inc cnt_opnum ;; anything else will trigger numeric evaluation
000004C1                                                .endif
000004C1                    *   @C004D:
000004C1                                            .endf
000004C1                    *   @C003B:
000004C1                    *   inc i
000004C4                    *   jmp @C003A
000004D1                    *   @C003C:

000004D1                                            .if i == idx ;; no items except %?
000004D1                    *   cmp i , idx
000004D1                    *    mov eax,  idx
000004D4                    *    cmp i , eax
000004D7                    *   jnz @C004E
000004D9                                                dec idx
000004DC                                                .continue
000004DC                    *    jmp @C002C
000004DE                                            .endif
000004DE                    *   @C004E:

000004DE                                            mov   rcx,[rbx].tokpos
000004E2                                            imul  ebx,idx,asm_tok
000004E6                                            add   rbx,tokenarray
000004EA                                            mov   rsi,[rbx].tokpos
000004EE                                            sub   rcx,rsi
000004F1                                            .while islspace( [rsi+rcx-1] )
000004F1                    *   jmp @C0050
000004F3                    *   @C004F:
000004F3                                                dec ecx
000004F5                                            .endw
000004F5                    *   @C0050:
000004F5                    *   invoke islspace, [rsi+rcx-1] 
000004F5                    *    movzx eax, byte ptr [rsi+rcx-1] 
000004FA                    *   test byte ptr [r15+rax+1] , _SPACE
00000500                    *   jne @C004F
00000502                                            mov cnt,ecx
00000508                                            mov rdi,p
0000050C                                            rep movsb
0000050E                                            mov byte ptr [rdi],0

00000511                                            .ifd ExpandText( p, tokenarray, FALSE ) == ERROR
00000511                    *   invoke ExpandText, p, tokenarray, FALSE 
00000511                    *    xor r8d, r8d
00000514                    *    mov rdx, tokenarray
00000518                    *    mov rcx, p
0000051C                    *    call ExpandText
00000521                    *   cmp eax , ERROR
00000524                    *   jnz @C0051
00000526                                                mov rcx,savedStringBuffer
0000052A                                                mov ModuleInfo.stringbufferend,rcx
00000531                                               .return
00000531                    *   jmp @C000D
00000533                                            .endif
00000533                    *   @C0051:
00000533                                            mov idx,i
00000533                    *    mov eax, i
00000536                    *    mov idx, eax
00000539                                            dec idx
0000053C                                            .if cnt_opnum
0000053C                    *   cmp cnt_opnum, 0
00000543                    *   jz  @C0052

                                                        ; convert numeric expression into a string

00000545                                                mov edx,ModuleInfo.token_count
0000054B                                                inc edx
0000054D                                                mov max,Tokenize( p, edx, tokenarray, TOK_RESCAN )
0000054D                    *   invoke Tokenize, p, edx, tokenarray, TOK_RESCAN 
0000054D                    *    mov r9d, TOK_RESCAN 
00000553                    *    mov r8, tokenarray
00000557                    *    mov rcx, p
0000055B                    *    call Tokenize
00000560                    *   mov max, eax
00000566                                                mov i,ModuleInfo.token_count
00000566                    *    mov eax, ModuleInfo.token_count
0000056C                    *    mov i, eax
0000056F                                                inc i

                                                        ; the % operator won't accept forward references.
                                                        ; v2.09: flag EXPF_NOUNDEF set.

00000572                                                .ifd EvalOperand( &i, tokenarray, max, &opndx, EXPF_NOUNDEF ) == ERROR
00000572                    *   invoke EvalOperand, addr i, tokenarray, max, addr opndx, EXPF_NOUNDEF 
00000572                    *    mov byte ptr [rsp+32], EXPF_NOUNDEF 
00000577                    *    lea r9, opndx
0000057E                    *    mov r8d, max
00000585                    *    mov rdx, tokenarray
00000589                    *    lea rcx, i
0000058D                    *    call EvalOperand
00000592                    *   cmp eax , ERROR
00000595                    *   jnz @C0053
00000597                                                    mov opndx.value,0
000005A1                                                    mov opndx.hvalue,0
000005AB                                                .elseif ( opndx.kind != EXPR_CONST &&!( opndx.kind == EXPR_FLOAT && opndx.mem_type == MT_REAL16 ) )
000005AB                    *   jmp @C0054
000005AD                    *   @C0053:
000005AD                    *   cmp opndx.kind , EXPR_CONST 
000005B4                    *   jz  @C0055
000005B6                    *   cmp opndx.kind , EXPR_FLOAT 
000005BD                    *   jnz @C0056
000005BF                    *   @C0057:
000005BF                    *   cmp opndx.mem_type , MT_REAL16 
000005C3                    *   jz  @C0055
000005C5                    *   @C0056:
000005C5                    *   invoke asmerr, 2026 
000005C5                    *    mov ecx, 2026 
000005CA                    *    call asmerr
                                invoke asmerr( 2026 )
000005CF                                                    mov opndx.value,0
000005D9                                                    mov opndx.hvalue,0
000005E3                                                .endif
000005E3                    *   @C0055:
000005E3                    *   @C0054:
                                                        ;; v2.08: accept constant and copy any stuff that's following
000005E3                                                .if opndx.kind == EXPR_CONST
000005E3                    *   cmp opndx.kind , EXPR_CONST
000005EA                    *   jnz @C0058
000005EC                                                    xor eax,eax
000005EE                                                    cmp opndx.hvalue,0
000005F5                                                    setl al
000005F8                    *   invoke myltoa, opndx.llvalue, ModuleInfo.stringbufferend, ModuleInfo.radix, eax, FALSE 
000005F8                    *    mov dword ptr [rsp+32], FALSE 
00000600                    *    mov r9d, eax
00000603                    *    movzx r8d, ModuleInfo.radix
0000060B                    *    mov rdx, ModuleInfo.stringbufferend
00000612                    *    mov rcx, opndx.llvalue
00000619                    *    call myltoa
                                invoke myltoa( opndx.llvalue, ModuleInfo.stringbufferend, ModuleInfo.radix, eax, FALSE )
0000061E                                                .elseif ( opndx.kind == EXPR_FLOAT && opndx.mem_type == MT_REAL16 )
0000061E                    *   jmp @C0059
00000620                    *   @C0058:
00000620                    *   cmp opndx.kind , EXPR_FLOAT 
00000627                    *   jnz @C005A
00000629                    *   cmp opndx.mem_type , MT_REAL16 
0000062D                    *   jnz @C005A
0000062F                                                    .if ( ( opndx.value == 16 && opndx.h64_h == 0 ) )
0000062F                    *   cmp opndx.value , 16 
00000636                    *   jnz @C005B
00000638                    *   cmp opndx.h64_h , 0 
0000063F                    *   jnz @C005B
00000641                        invoke tstrcpy( ModuleInfo.stringbufferend, "16" )
00000000                        .data
                            *   _TEXT ends
00000009                    *   _DATA segment
                            *   assume cs:ERROR
00000009                         DS0001 sbyte "16",0
                                _DATA ends
00000641                        _TEXT segment
00000641                    *   invoke tstrcpy, ModuleInfo.stringbufferend, addr DS0001
00000641                    *    lea rdx, DS0001
00000648                    *    mov rcx, ModuleInfo.stringbufferend
0000064F                    *    call tstrcpy
                                invoke tstrcpy( ModuleInfo.stringbufferend, addr DS0001)
00000654                                                    .elseif ( ModuleInfo.floatformat == 'x' )
00000654                    *   jmp @C005C
00000656                    *   @C005B:
00000656                    *   cmp ModuleInfo.floatformat , 'x' 
0000065D                    *   jnz @C005D
0000065F                        invoke tsprintf( ModuleInfo.stringbufferend, "%16lx%16lx", opndx.hlvalue, opndx.llvalue )
00000000                        .data
                            *   _TEXT ends
0000000C                    *   _DATA segment
                            *   assume cs:ERROR
0000000C                         DS0002 sbyte "%16lx%16lx",0
                                _DATA ends
0000065F                        _TEXT segment
0000065F                    *   invoke tsprintf, ModuleInfo.stringbufferend, addr DS0002 , opndx.hlvalue, opndx.llvalue 
0000065F                    *    mov r9, opndx.llvalue 
00000666                    *    mov r8, opndx.hlvalue
0000066D                    *    lea rdx, DS0002 
00000674                    *    mov rcx, ModuleInfo.stringbufferend
0000067B                    *    call tsprintf
                                invoke tsprintf( ModuleInfo.stringbufferend, addr DS0002 , opndx.hlvalue, opndx.llvalue )
00000680                                                    .else
00000680                    *   jmp @C005C
00000682                    *   @C005D:

00000682                                                        mov cvt.expchar,'e'
0000068C                                                        mov cvt.expwidth,3
00000696                                                        mov cvt.ndigits,ModuleInfo.floatdigits
00000696                    *    mov eax, ModuleInfo.floatdigits
0000069C                    *    mov cvt.ndigits, eax
000006A2                                                        mov cvt.bufsize,ModuleInfo.max_line_len
000006A2                    *    mov eax, ModuleInfo.max_line_len
000006A8                    *    mov cvt.bufsize, eax

000006AE                                                        .if ( ModuleInfo.floatformat == 'e' )
000006AE                    *   cmp ModuleInfo.floatformat , 'e' 
000006B5                    *   jnz @C005E
000006B7                                                            mov cvt.scale,1
000006C1                                                            mov cvt.flags,_ST_E
000006CB                                                        .elseif ( ModuleInfo.floatformat == 'g' )
000006CB                    *   jmp @C005F
000006CD                    *   @C005E:
000006CD                    *   cmp ModuleInfo.floatformat , 'g' 
000006D4                    *   jnz @C0060
000006D6                                                            mov cvt.scale,1
000006E0                                                            mov cvt.flags,_ST_G
000006EA                                                        .else
000006EA                    *   jmp @C005F
000006EC                    *   @C0060:
000006EC                                                            mov cvt.scale,0
000006F6                                                            mov cvt.flags,_ST_F
00000700                                                        .endif
00000700                    *   @C005F:
00000700                                                        mov rsi,ModuleInfo.stringbufferend
00000707                                                        inc rsi
0000070A                    *   invoke _flttostr, addr opndx, addr cvt, rsi, _ST_QUADFLOAT 
0000070A                    *    mov r9d, _ST_QUADFLOAT 
00000710                    *    mov r8, rsi
00000713                    *    lea rdx, cvt
0000071A                    *    lea rcx, opndx
00000721                    *    call _flttostr
                                invoke _flttostr( &opndx, &cvt, rsi, _ST_QUADFLOAT )
00000726                                                        .if ( cvt.sign == -1 )
00000726                    *   cmp cvt.sign , -1 
0000072D                    *   jnz @C0061
0000072F                                                            mov byte ptr [rsi-1],'-'
00000733                                                        .else
00000733                    *   jmp @C0062
00000735                    *   @C0061:
00000735                    *   invoke tstrcpy, ModuleInfo.stringbufferend, rsi 
00000735                    *    mov rdx, rsi 
00000738                    *    mov rcx, ModuleInfo.stringbufferend
0000073F                    *    call tstrcpy
                                invoke tstrcpy( ModuleInfo.stringbufferend, rsi )
00000744                                                        .endif
00000744                    *   @C0062:
00000744                                                    .endif
0000074A                    *   @C005C:
0000074A                                                .endif
00000752                    *   @C005A:
00000755                    *   @C0059:
00000755                                                .if ( i != max )
00000755                    *   cmp i , max 
00000755                    *    mov eax,  max 
0000075B                    *    cmp i , eax
0000075E                    *   jz  @C0063
                                                            ;
                                                            ; the evaluator was unable to evaluate the full expression. the rest
                                                            ; has to be "copied"
                                                            ;
00000760                                                    imul ebx,i,asm_tok
00000764                                                    add  rbx,tokenarray
00000768                    *   invoke tstrcat, ModuleInfo.stringbufferend, [rbx].tokpos 
00000768                    *    mov rdx, [rbx].tokpos 
0000076C                    *    mov rcx, ModuleInfo.stringbufferend
00000773                    *    call tstrcat
                                invoke tstrcat( ModuleInfo.stringbufferend, [rbx].tokpos )
00000778                                                .endif
00000778                    *   @C0063:
00000778                    *   invoke tstrcpy, p, ModuleInfo.stringbufferend 
00000778                    *    mov rdx, ModuleInfo.stringbufferend 
0000077F                    *    mov rcx, p
00000783                    *    call tstrcpy
                                invoke tstrcpy( p, ModuleInfo.stringbufferend )
00000788                                            .endif
0000078C                    *   @C0052:
0000078C                                            add p,tstrlen( p )
0000078C                    *   invoke tstrlen, p 
0000078C                    *    mov rcx, p 
00000790                    *    call tstrlen
00000795                    *   add p, rax
00000799                                            .continue
00000799                    *    jmp @C002C
0000079B                                        .endif
0000079F                    *   @C0033:

0000079F                                        imul ebx,idx,asm_tok
000007A3                                        add  rbx,tokenarray

000007A7                                        .if ( [rbx].token == T_STRING && [rbx].string_delim == '{' )
000007A7                    *   cmp [rbx].token , T_STRING 
000007AA                    *   jnz @C0064
000007AC                    *   cmp [rbx].string_delim , '{' 
000007B0                    *   jnz @C0064

000007B2                                            mov rcx,[rbx].string_ptr
000007B6                                            mov ebx,idx
000007B9                                            mov rax,p ;; copy the '{'
000007BD                                            inc p
000007C1                                            mov byte ptr [rax],'{'
                                                    ; the string must be tokenized
000007C4                                            inc inside_literal
000007CA                                            mov idx,ModuleInfo.token_count
000007CA                    *    mov eax, ModuleInfo.token_count
000007D0                    *    mov idx, eax
000007D3                                            mov ModuleInfo.token_count,Tokenize( rcx, &[rax+1], tokenarray, TOK_RESCAN or TOK_NOCURLBRACES )
000007D3                    *   invoke Tokenize, rcx, addr [rax+1], tokenarray, TOK_RESCAN or TOK_NOCURLBRACES 
000007D3                    *    mov r9d, TOK_RESCAN or TOK_NOCURLBRACES 
000007D9                    *    mov r8, tokenarray
000007DD                    *    lea edx, [rax+1]
000007E0                    *    call Tokenize
000007E5                    *   mov ModuleInfo.token_count, eax
000007EB                                            imul eax,eax,asm_tok
000007EE                                            add rax,tokenarray
000007F2                                            mov [rax].asm_tok.lastidx,ebx
000007F5                                            .continue
000007F5                    *    jmp @C002C
000007F7                                        .endif
000007F7                    *   @C0064:

000007F7                                        .if inside_angle_brackets == 0
000007F7                    *   cmp inside_angle_brackets , 0
000007FE                    *   jnz @C0065
                                                    ;; track brackets for macro functions; exit if one more ')' than '(' is found
00000800                                            .if bracket_level > 0
00000800                    *   cmp bracket_level , 0
00000804                    *   jng @C0066
00000806                                                .if [rbx].token == T_OP_BRACKET
00000806                    *   cmp [rbx].token , T_OP_BRACKET
00000809                    *   jnz @C0067
0000080B                                                    inc bracket_level
0000080E                                                .elseif [rbx].token == T_CL_BRACKET
0000080E                    *   jmp @C0068
00000810                    *   @C0067:
00000810                    *   cmp [rbx].token , T_CL_BRACKET
00000813                    *   jnz @C0069
00000815                                                    dec bracket_level
00000818                                                    .break .ifz ;; ( bracket_level == 0 )
00000818                    *   je  @C002D
0000081A                                                .endif
0000081A                    *   @C0069:
0000081A                    *   @C0068:
0000081A                                            .endif
0000081A                    *   @C0066:

                                                    ;; if there's a literal enclosed in <>, remove the delimiters and
                                                    ;; tokenize the item (Token_Count must be adjusted, since RunMacro()
                                                    ;; might be called later!)

0000081A                                            .if ( [rbx].token == T_STRING && [rbx].string_delim == '<' && inside_angle_brackets == 0 )
0000081A                    *   cmp [rbx].token , T_STRING 
0000081D                    *   jnz @C006A
0000081F                    *   cmp [rbx].string_delim , '<' 
00000823                    *   jnz @C006A
00000825                    *   cmp inside_angle_brackets , 0 
0000082C                    *   jnz @C006A

0000082E                                                mov rsi,[rbx].tokpos
00000832                                                inc rsi
00000835                                                mov rcx,[rbx+asm_tok].tokpos
00000839                                                sub rcx,rsi
0000083C                                                mov edx,ecx
0000083E                                                mov rdi,ModuleInfo.stringbufferend
00000845                                                rep movsb
00000847                                                mov rdi,ModuleInfo.stringbufferend
0000084E                                                .while byte ptr [rdi+rdx-1] != '>'
0000084E                    *   jmp @C006C
00000850                    *   @C006B:
00000850                                                    dec edx
00000852                                                .endw
00000852                    *   @C006C:
00000852                    *   cmp byte ptr [rdi+rdx-1] , '>'
00000857                    *   jnz @C006B
00000859                                                mov byte ptr [rdi+rdx-1],0
0000085E                                                mov ModuleInfo.stringbufferend,GetAlignedPointer( rdi, edx )
0000085E                    *   invoke GetAlignedPointer, rdi, edx 
0000085E                    *    mov rax, rdi
00000861                    *1  add edx,size_t
00000864                    *1  and edx,not ( size_t - 1 )
00000867                    *1  add rax,rdx
0000086A                    *   mov ModuleInfo.stringbufferend, rax
                                                        ;; the string must be tokenized
00000871                                                inc inside_literal
00000877                                                mov inside_angle_brackets,1

00000881                                                mov ebx,idx
00000884                                                mov idx,ModuleInfo.token_count
00000884                    *    mov eax, ModuleInfo.token_count
0000088A                    *    mov idx, eax
0000088D                                                mov ModuleInfo.token_count,Tokenize( rdi, &[rax+1], tokenarray, TOK_RESCAN )
0000088D                    *   invoke Tokenize, rdi, addr [rax+1], tokenarray, TOK_RESCAN 
0000088D                    *    mov r9d, TOK_RESCAN 
00000893                    *    mov r8, tokenarray
00000897                    *    lea edx, [rax+1]
0000089A                    *    mov rcx, rdi
0000089D                    *    call Tokenize
000008A2                    *   mov ModuleInfo.token_count, eax
000008A8                                                imul eax,eax,asm_tok
000008AB                                                add rax,tokenarray
000008AF                                                mov [rax].asm_tok.lastidx,ebx

                                                        ; copy spaces located before the first token
000008B2                                                imul ebx,idx,asm_tok
000008B6                                                add rbx,tokenarray
000008BA                                                mov rcx,[rbx+asm_tok].tokpos
000008BE                                                sub rcx,rdi
000008C1                                                mov rsi,rdi
000008C4                                                mov rdi,p
000008C8                                                rep movsb
000008CA                                                mov p,rdi
000008CE                                                .continue
000008CE                    *    jmp @C002C
000008D0                                            .endif
000008DC                    *   @C006A:

                                                    ; macros functions must be expanded always.
                                                    ; text macros are expanded only selectively

000008DC                                            .if ( [rbx].token == T_ID )
000008DC                    *   cmp [rbx].token , T_ID 
000008DF                    *   jnz @C006D
000008E1                                                .if SymFind([rbx].string_ptr)
000008E1                    *   invoke SymFind, [rbx].string_ptr
000008E1                    *    mov rcx, [rbx].string_ptr
000008E5                    *    call SymFind
000008EA                    *   test rax, rax
000008ED                    *   jz  @C006E
000008EF                                                    mov sym,rax
000008F3                                                    .if ( [rax].asym.state == SYM_MACRO && [rax].asym.flags & S_ISDEFINED &&[rax].asym.mac_flag & M_ISFUNC && [rbx+asm_tok].token == T_OP_BRACKET )
000008F3                    *   cmp [rax].asym.state , SYM_MACRO 
000008F7                    *   jnz @C006F
000008F9                    *   test [rax].asym.flags , S_ISDEFINED 
000008FD                    *   je  @C006F
000008FF                    *   test [rax].asym.mac_flag , M_ISFUNC 
00000903                    *   je  @C006F
00000905                    *   cmp [rbx+asm_tok].token , T_OP_BRACKET 
00000909                    *   jnz @C006F
0000090B                                                        inc idx
0000090E                                                        mov idx,RunMacro( sym, idx, tokenarray, p, 0, &is_exitm2 )
0000090E                    *   invoke RunMacro, sym, idx, tokenarray, p, 0, addr is_exitm2 
0000090E                    *    lea rax, is_exitm2 
00000915                    *    mov [rsp+40], rax
0000091A                    *    mov dword ptr [rsp+32], 0
00000922                    *    mov r9, p
00000926                    *    mov r8, tokenarray
0000092A                    *    mov edx, idx
0000092D                    *    mov rcx, sym
00000931                    *    call RunMacro
00000936                    *   mov idx, eax
00000939                                                        .if idx < 0
00000939                    *   cmp idx , 0
0000093D                    *   jnl @C0070
0000093F                                                            mov ModuleInfo.stringbufferend,savedStringBuffer
0000093F                    *    mov rax, savedStringBuffer
00000943                    *    mov ModuleInfo.stringbufferend, rax
0000094A                                                            .return idx
0000094A                    *   mov eax,idx
0000094D                    *   jmp @C000D
0000094F                                                        .endif
0000094F                    *   @C0070:
0000094F                                                        add p,tstrlen(p)
0000094F                    *   invoke tstrlen, p
0000094F                    *    mov rcx, p
00000953                    *    call tstrlen
00000958                    *   add p, rax
                                                                ;; copy spaces behind macro function call
0000095C                                                        imul ebx,idx,asm_tok
00000960                                                        add  rbx,tokenarray
00000964                                                        .if [rbx].token != T_FINAL && [rbx].token != T_COMMA
00000964                    *   cmp [rbx].token , T_FINAL 
00000967                    *   jz  @C0071
00000969                    *   cmp [rbx].token , T_COMMA
0000096C                    *   jz  @C0071
0000096E                                                            mov rsi,[rbx-asm_tok].tokpos
00000972                                                            inc rsi
00000975                                                            mov rcx,[rbx].tokpos
00000979                                                            sub rcx,rsi
0000097C                                                            mov rdi,p
00000980                                                            rep movsb
00000982                                                            mov p,rdi
00000986                                                        .endif
00000986                    *   @C0071:
00000986                                                        dec idx ;; adjust token index
00000989                                                        sub rbx,asm_tok
0000098D                                                        .continue
0000098D                    *    jmp @C002C

0000098F                                                    .elseif ( [rax].asym.state == SYM_TMACRO && [rax].asym.flags & S_ISDEFINED )
0000098F                    *   jmp @C0072
000009A1                    *   @C006F:
000009A1                    *   cmp [rax].asym.state , SYM_TMACRO 
000009A5                    *   jnz @C0073
000009A7                    *   test [rax].asym.flags , S_ISDEFINED 
000009AB                    *   je  @C0073

000009AD                                                        mov ecx,parmidx
000009B0                                                        mov edx,1
000009B5                                                        shl edx,cl
000009B7                                                        mov rdi,info
000009BB                                                        mov rsi,mac
000009BF                                                        .if ( [rsi].flags & S_PREDEFINED && ( [rdi].autoexp & dx ) )
000009BF                    *   test [rsi].flags , S_PREDEFINED 
000009C3                    *   je  @C0074
000009C5                    *   test [rdi].autoexp , dx 
000009C9                    *   je  @C0074

000009CB                    *   invoke tstrcpy, p, [rax].asym.string_ptr 
000009CB                    *    mov rdx, [rax].asym.string_ptr 
000009CF                    *    mov rcx, p
000009D3                    *    call tstrcpy
                                invoke tstrcpy( p, [rax].asym.string_ptr )
000009D8                    *   invoke ExpandTMacro, p, tokenarray, FALSE, 0 
000009D8                    *    xor r9d, r9d
000009DB                    *    xor r8d, r8d
000009DE                    *    mov rdx, tokenarray
000009E2                    *    mov rcx, p
000009E6                    *    call ExpandTMacro
                                invoke ExpandTMacro( p, tokenarray, FALSE, 0 )
000009EB                                                            add p,tstrlen( p )
000009EB                    *   invoke tstrlen, p 
000009EB                    *    mov rcx, p 
000009EF                    *    call tstrlen
000009F4                    *   add p, rax

                                                                    ;; copy spaces behind text macro
000009F8                                                            .if ( [rbx+asm_tok].token != T_FINAL && [rbx+asm_tok].token != T_COMMA )
000009F8                    *   cmp [rbx+asm_tok].token , T_FINAL 
000009FC                    *   jz  @C0075
000009FE                    *   cmp [rbx+asm_tok].token , T_COMMA 
00000A02                    *   jz  @C0075

00000A04                                                                mov rdx,sym
00000A08                                                                mov esi,[rdx].asym.name_size
00000A0B                                                                add rsi,[rbx].tokpos
00000A0F                                                                mov rcx,[rbx+asm_tok].tokpos
00000A13                                                                sub rcx,rsi
00000A16                                                                mov rdi,p
00000A1A                                                                rep movsb
00000A1C                                                                mov p,rdi
00000A20                                                            .endif
00000A20                    *   @C0075:
00000A20                                                            .continue
00000A20                    *    jmp @C002C
00000A22                                                        .endif
00000A22                    *   @C0074:
00000A22                                                    .endif
00000A22                    *   @C0073:
00000A25                    *   @C0072:
00000A25                                                .endif
00000A29                    *   @C006E:
00000A29                                            .endif
00000A2D                    *   @C006D:
00000A2D                                        .endif
00000A31                    *   @C0065:

                                                ;; get length of item
00000A31                                        mov rcx,[rbx+asm_tok].tokpos
00000A35                                        sub rcx,[rbx].tokpos
00000A39                                        .if ( !inside_literal &&( [rbx+asm_tok].token == T_COMMA || [rbx+asm_tok].token == parm_end_delim ) )
00000A39                    *   cmp inside_literal , 0
00000A40                    *   jnz @C0076
00000A42                    *   cmp [rbx+asm_tok].token , T_COMMA 
00000A46                    *   jz  @C0077
00000A48                    *   @C0078:
00000A48                    *   cmp [rbx+asm_tok].token , parm_end_delim 
00000A48                    *    mov eax,  parm_end_delim 
00000A4B                    *    cmp [rbx+asm_tok].token , al
00000A4E                    *   jnz @C0076
00000A50                    *   @C0077:

00000A50                                            mov rdx,[rbx].tokpos
00000A54                                            .while islspace( [rdx+rcx-1] )
00000A54                    *   jmp @C007A
00000A56                    *   @C0079:
00000A56                                                dec rcx
00000A59                                            .endw
00000A59                    *   @C007A:
00000A59                    *   invoke islspace, [rdx+rcx-1] 
00000A59                    *    movzx eax, byte ptr [rdx+rcx-1] 
00000A5E                    *   test byte ptr [r15+rax+1] , _SPACE
00000A64                    *   jne @C0079
00000A66                                        .endif
00000A66                    *   @C0076:

                                                ;; the literal character operator ! is valid for macro arguments

00000A66                                        mov rdi,p
00000A6A                                        mov rsi,[rbx].tokpos
00000A6E                                        .if ( [rbx].token == T_STRING && [rbx].string_delim == 0 )
00000A6E                    *   cmp [rbx].token , T_STRING 
00000A71                    *   jnz @C007B
00000A73                    *   cmp [rbx].string_delim , 0 
00000A77                    *   jnz @C007B

00000A79                                            add rcx,rsi
00000A7C                                            .for ( : rsi < rcx : )
00000A7C                    *   @C007C:
00000A7C                    *   cmp rsi , rcx
00000A7F                    *   jnb @C007E
00000A81                                                .if ( byte ptr [rsi] == '!' )
00000A81                    *   cmp byte ptr [rsi] , '!' 
00000A84                    *   jnz @C007F
00000A86                                                    inc rsi
00000A89                                                .endif
00000A89                    *   @C007F:
00000A89                                                movsb
00000A8A                                            .endf
00000A8A                    *   @C007D:
00000A8A                    *   jmp @C007C
00000A8C                    *   @C007E:
00000A8C                                            mov p,rdi
00000A90                                            .continue
00000A90                    *    jmp @C002C
00000A92                                        .endif
00000A92                    *   @C007B:
00000A92                                        rep movsb
00000A94                                        mov p,rdi
00000A98                                    .endf
00000AAA                    *   @C002C:
00000AAA                    *   inc idx
00000AAD                    *   jmp @C002B
00000ABA                    *   @C002D:
00000ABA                                    mov rax,p
00000ABE                                    mov byte ptr [rax],0

                                            ;
                                            ; restore input status values
                                            ;
00000AC1                                    mov ModuleInfo.token_count,old_tokencount
00000AC1                    *    mov eax, old_tokencount
00000AC7                    *    mov ModuleInfo.token_count, eax
00000ACD                                    mov ModuleInfo.stringbufferend,savedStringBuffer
00000ACD                    *    mov rax, savedStringBuffer
00000AD1                    *    mov ModuleInfo.stringbufferend, rax

00000AD8                                    mov rdi,info
00000ADC                                    mov rsi,mac

                                            ;
                                            ; store the macro argument in the parameter array
                                            ;
00000AE0                                    movzx eax,[rdi].parmcnt
00000AE3                                    dec eax
00000AE5                                    mov rdx,currparm

00000AE9                                    .if ( [rsi].mac_flag & M_ISVARARG && parmidx == eax )
00000AE9                    *   test [rsi].mac_flag , M_ISVARARG 
00000AED                    *   je  @C0080
00000AEF                    *   cmp parmidx , eax 
00000AF2                    *   jnz @C0080
00000AF4                                        .if ( varargcnt == 0 )
00000AF4                    *   cmp varargcnt , 0 
00000AF8                    *   jnz @C0081
00000AFA                                            mov rax,mi.parm_array
00000B01                                            mov ecx,parmidx
00000B04                                            mov [rax+rcx*size_t],rdx
00000B08                                        .endif
00000B08                    *   @C0081:
00000B08                                        mov rax,p
00000B0C                                        .if ( [rsi].flags & S_PREDEFINED )
00000B0C                    *   test [rsi].flags , S_PREDEFINED 
00000B10                    *   je  @C0082
00000B12                                            sub rax,currparm
00000B16                    *   invoke GetAlignedPointer, currparm, eax 
00000B16                    *    mov edx, eax
00000B18                    *   mov rax, currparm
00000B1C                    *1  add edx,size_t
00000B1F                    *1  and edx,not ( size_t - 1 )
00000B22                    *1  add rax,rdx
                                invoke GetAlignedPointer( currparm, eax )
00000B25                                        .endif
00000B25                    *   @C0082:
00000B25                                        mov currparm,rax

                                                ;; v2.08: Masm swallows the last trailing comma

00000B29                                        .if ( [rbx].token == T_COMMA )
00000B29                    *   cmp [rbx].token , T_COMMA 
00000B2C                    *   jnz @C0083

00000B2E                                            inc idx
00000B31                                            add rbx,asm_tok
00000B35                                            mov rdx,rax

00000B38                                            .if ( !( [rsi].mac_flag & M_ISFUNC ) || [rbx].token != parm_end_delim )
00000B38                    *   test [rsi].mac_flag , M_ISFUNC 
00000B3C                    *   je  @C0085
00000B3E                    *   @C0086:
00000B3E                    *   cmp [rbx].token , parm_end_delim 
00000B3E                    *    mov eax,  parm_end_delim 
00000B41                    *    cmp [rbx].token , al
00000B43                    *   jz  @C0084
00000B45                    *   @C0085:
00000B45                                                dec parmidx
00000B48                                                .if ( !( [rsi].flags & S_PREDEFINED ) )
00000B48                    *   test [rsi].flags , S_PREDEFINED 
00000B4C                    *   jne @C0087
00000B4E                                                    mov byte ptr [rdx],','
00000B51                                                    inc rdx
00000B54                                                    inc currparm
00000B58                                                .endif
00000B58                    *   @C0087:
00000B58                                                mov byte ptr [rdx],0
00000B5B                                            .endif
00000B5B                    *   @C0084:
00000B5B                                            mov skipcomma,0
00000B62                                        .endif
00000B62                    *   @C0083:
00000B62                                        inc varargcnt

00000B65                                    .elseif byte ptr [rdx]
00000B65                    *   jmp @C0088
00000B67                    *   @C0080:
00000B67                    *   cmp byte ptr [rdx], 0
00000B6A                    *   jz  @C0089

00000B6C                                        mov rax,rdx
00000B6F                                        mov rcx,mi.parm_array
00000B76                                        mov edx,parmidx
00000B79                                        mov [rcx+rdx*size_t],rax
00000B7D                                        mov rdx,p
00000B81                                        sub rdx,rax
00000B84                                        mov currparm,GetAlignedPointer( rax, edx )
00000B84                    *   invoke GetAlignedPointer, rax, edx 
00000B84                    *1  add edx,size_t
00000B87                    *1  and edx,not ( size_t - 1 )
00000B8A                    *1  add rax,rdx
00000B8D                    *   mov currparm, rax
00000B91                                    .else
00000B91                    *   jmp @C0088
00000B93                    *   @C0089:
00000B93                                        mov rdx,mi.parm_array
00000B9A                                        mov ecx,parmidx
00000B9D                                        lea rax,DS0002[10]
00000BA4                                        mov [rdx+rcx*size_t],rax
00000BA8                                    .endif
00000BA8                    *   @C0088:
00000BA8                                .endif
00000BAB                    *   @C002A:
00000BAB                            .endf
00000BAB                    *   @C001F:
00000BAB                    *   inc parmidx
00000BAE                    *   jmp @C001E
00000BB7                    *   @C0020:

                                    ; for macro functions, check for the terminating ')'
00000BB7                            .if ( bracket_level >= 0 )
00000BB7                    *   cmp bracket_level , 0 
00000BBB                    *   jl  @C008A
00000BBD                                .if ( [rbx].token != T_CL_BRACKET )
00000BBD                    *   cmp [rbx].token , T_CL_BRACKET 
00000BC0                    *   jz  @C008B
00000BC2                                    .for ( i = idx: idx < ModuleInfo.token_count && [rbx].token != T_CL_BRACKET: idx++, rbx += asm_tok )
00000BC2                    *   mov i, idx
00000BC2                    *    mov eax,  idx
00000BC5                    *    mov i, eax
00000BC8                    *   @C008C:
00000BC8                    *   cmp idx , ModuleInfo.token_count 
00000BC8                    *    mov eax,  ModuleInfo.token_count 
00000BCE                    *    cmp idx , eax
00000BD1                    *   jnl @C008E
00000BD3                    *   cmp [rbx].token , T_CL_BRACKET
00000BD6                    *   jz  @C008E
00000BD8                                    .endf
00000BD8                    *   @C008D:
00000BD8                    *   inc idx
00000BDB                    *   add rbx, asm_tok
00000BDF                    *   jmp @C008C
00000BE1                    *   @C008E:
00000BE1                                    .if ( idx == ModuleInfo.token_count )
00000BE1                    *   cmp idx , ModuleInfo.token_count 
00000BE1                    *    mov eax,  ModuleInfo.token_count 
00000BE7                    *    cmp idx , eax
00000BEA                    *   jnz @C008F
00000BEC                    *   invoke asmerr, 2157 
00000BEC                    *    mov ecx, 2157 
00000BF1                    *    call asmerr
                                invoke asmerr( 2157 )
00000BF6                                        .return( -1 )
00000BF6                    *   mov rax,( -1 )
00000BFD                    *   jmp @C000D
00000BFF                                    .else
00000BFF                    *   jmp @C0090
00000C01                    *   @C008F:
                                                ;; v2.09: changed to a warning only (Masm-compatible)
00000C01                                        imul eax,i,asm_tok
00000C05                                        add rax,tokenarray
00000C09                    *   invoke asmerr, 4006, [rsi].name, [rax].asm_tok.tokpos 
00000C09                    *    mov r8, [rax].asm_tok.tokpos 
00000C0D                    *    mov rdx, [rsi].name
00000C11                    *    mov ecx, 4006
00000C16                    *    call asmerr
                                invoke asmerr( 4006, [rsi].name, [rax].asm_tok.tokpos )
00000C1B                                    .endif
00000C1B                    *   @C0090:
00000C1B                                .endif
00000C1B                    *   @C008B:
00000C1B                                inc idx
00000C1E                                add rbx,asm_tok
00000C22                            .elseif ( [rbx].token != T_FINAL )
00000C22                    *   jmp @C0091
00000C24                    *   @C008A:
00000C24                    *   cmp [rbx].token , T_FINAL 
00000C27                    *   jz  @C0092
                                        ;; v2.05: changed to a warning. That's what Masm does
                                        ;; v2.09: don't emit a warning if it's a FOR directive
                                        ;; (in this case, the caller knows better what to do ).

00000C29                                .if ( !( mflags & MF_IGNARGS ) )
00000C29                    *   test mflags , MF_IGNARGS 
00000C30                    *   jne @C0093
00000C32                    *   invoke asmerr, 4006, [rsi].name, [rbx].tokpos 
00000C32                    *    mov r8, [rbx].tokpos 
00000C36                    *    mov rdx, [rsi].name
00000C3A                    *    mov ecx, 4006
00000C3F                    *    call asmerr
                                invoke asmerr( 4006, [rsi].name, [rbx].tokpos )
00000C44                                .endif
00000C44                    *   @C0093:
00000C44                            .endif
00000C44                    *   @C0092:
00000C44                    *   @C0091:

                                    ;; a predefined macro func with a function address?

                                    assume rsi:asym_t

00000C44                            .if ( [rsi].flags & S_PREDEFINED && [rsi].func_ptr )
00000C44                    *   test [rsi].flags , S_PREDEFINED 
00000C48                    *   je  @C0094
00000C4A                    *   cmp [rsi].func_ptr , 0
00000C4F                    *   jz  @C0094

00000C51                                mov mi.parmcnt,varargcnt
00000C51                    *    mov eax, varargcnt
00000C54                    *    mov mi.parmcnt, eax
00000C5A                    *   invoke [rsi].func_ptr, addr mi, _out, tokenarray 
00000C5A                    *    mov r8, tokenarray 
00000C5E                    *    mov rdx, _out
00000C62                    *    lea rcx, mi
00000C69                    *    call [rsi].func_ptr
                                invoke [rsi].func_ptr( &mi, _out, tokenarray )
00000C6C                                mov rax,is_exitm
00000C70                                mov dword ptr [rax],TRUE
00000C76                               .return idx
00000C76                    *   mov eax,idx
00000C79                    *   jmp @C000D
00000C7B                            .endif
00000C7B                    *   @C0094:

00000C7B                            mov mi.localstart,MacroLocals
00000C7B                    *    mov eax, MacroLocals
00000C81                    *    mov mi.localstart, eax
00000C87                            add MacroLocals,[rdi].localcnt ;; adjust global variable MacroLocals
00000C87                    *    movzx eax, [rdi].localcnt
00000C8B                    *    add MacroLocals, eax

                                    ;; avoid to use values stored in struct macro_info directly. A macro
                                    ;; may be redefined within the macro! Hence copy all values that are
                                    ;; needed later in the while loop to macro_instance!

00000C91                            mov mi.startline,[rdi].lines
00000C91                    *    mov rax, [rdi].lines
00000C95                    *    mov mi.startline, rax
00000C9C                            mov mi.currline,NULL
00000CA7                            mov mi.parmcnt,[rdi].parmcnt
00000CA7                    *    movzx eax, [rdi].parmcnt
00000CAA                    *    mov mi.parmcnt, eax

00000CB0                            .if mi.startline
00000CB0                    *   cmp mi.startline, 0
00000CB8                    *   jz  @C0095

00000CBA                                mov rax,[rsi].name
00000CBE                                .if ( !( [rsi].mac_flag & M_ISFUNC ) && byte ptr [rax] )
00000CBE                    *   test [rsi].mac_flag , M_ISFUNC 
00000CC2                    *   jne @C0096
00000CC4                    *   cmp byte ptr [rax] , 0
00000CC7                    *   jz  @C0096
00000CC9                    *   call LstWriteSrcLine
                                invoke LstWriteSrcLine()
00000CCE                                .endif
00000CCE                    *   @C0096:
00000CCE                                .if ( !( mflags & MF_NOSAVE ) )
00000CCE                    *   test mflags , MF_NOSAVE 
00000CD5                    *   jne @C0097
00000CD7                                    mov tokenarray,PushInputStatus( &oldstat )
00000CD7                    *   invoke PushInputStatus, addr oldstat 
00000CD7                    *    lea rcx, oldstat 
00000CDE                    *    call PushInputStatus
00000CE3                    *   mov tokenarray, rax
00000CE7                                .endif
00000CE7                    *   @C0097:

                                        ;; move the macro instance onto the file stack!
                                        ;; Also reset the current linenumber!

00000CE7                                mov mi._macro,rsi
00000CEE                    *   invoke PushMacro, addr mi 
00000CEE                    *    lea rcx, mi 
00000CF5                    *    call PushMacro
                                invoke PushMacro( &mi )
00000CFA                                inc MacroLevel
00000D00                                mov oldifnesting,GetIfNestLevel() ;; v2.10
00000D00                    *   call GetIfNestLevel
00000D05                    *   mov oldifnesting, eax
00000D0B                                mov cntgoto,0 ;; v2.10

                                        ;; Run the assembler until we hit EXITM or ENDM.
                                        ;; Also handle GOTO and macro label lines!
                                        ;; v2.08 no need anymore to check the queue level
                                        ;; v2.11 GetPreprocessedLine() replaced by GetTextLine()
                                        ;; and PreprocessLine().


00000D15                                .while ( GetTextLine( ModuleInfo.currsource ) )
00000D15                    *   jmp @C0099
00000D17                    *   @C0098:
00000D17                                    .continue .if ( PreprocessLine( tokenarray ) == 0 )
00000D17                    *   invoke PreprocessLine, tokenarray 
00000D17                    *    mov rcx, tokenarray 
00000D1B                    *    call PreprocessLine
00000D20                    *   test rax , rax 
00000D23                    *   jz  @C0099

00000D25                                    mov rbx,tokenarray

                                            ;; skip macro label lines
00000D29                                    .if ( [rbx].token == T_COLON )
00000D29                    *   cmp [rbx].token , T_COLON 
00000D2C                    *   jnz @C009A
                                                ;; v2.05: emit the error msg here, not in StoreMacro()
00000D2E                                        .if ( [rbx+asm_tok].token != T_ID )
00000D2E                    *   cmp [rbx+asm_tok].token , T_ID 
00000D32                    *   jz  @C009B
00000D34                    *   invoke asmerr, 2008, [rbx].tokpos 
00000D34                    *    mov rdx, [rbx].tokpos 
00000D38                    *    mov ecx, 2008
00000D3D                    *    call asmerr
                                invoke asmerr( 2008, [rbx].tokpos )
00000D42                                        .elseif ( [rbx+asm_tok*2].token != T_FINAL )
00000D42                    *   jmp @C009C
00000D44                    *   @C009B:
00000D44                    *   cmp [rbx+asm_tok*2].token , T_FINAL 
00000D48                    *   jz  @C009D
00000D4A                    *   invoke asmerr, 2008, [rbx+asm_tok*2].tokpos 
00000D4A                    *    mov rdx, [rbx+asm_tok*2].tokpos 
00000D4E                    *    mov ecx, 2008
00000D53                    *    call asmerr
                                invoke asmerr( 2008, [rbx+asm_tok*2].tokpos )
00000D58                                        .endif
00000D58                    *   @C009D:
00000D58                    *   @C009C:
00000D58                                        .continue
00000D58                    *    jmp @C0099
00000D5A                                    .endif
00000D5A                    *   @C009A:

00000D5A                                    .if ( [rbx].token == T_DIRECTIVE )
00000D5A                    *   cmp [rbx].token , T_DIRECTIVE 
00000D5D                    *   jnz @C009E
00000D5F                                        .if ( [rbx].tokval == T_EXITM || [rbx].tokval == T_RETM )
00000D5F                    *   cmp [rbx].tokval , T_EXITM 
00000D66                    *   jz  @C00A0
00000D68                    *   @C00A1:
00000D68                    *   cmp [rbx].tokval , T_RETM 
00000D6F                    *   jnz @C009F
00000D71                    *   @C00A0:
00000D71                                            .if ( ModuleInfo.list && ModuleInfo.list_macro == LM_LISTMACROALL )
00000D71                    *   cmp ModuleInfo.list , 0
00000D78                    *   jz  @C00A2
00000D7A                    *   cmp ModuleInfo.list_macro , LM_LISTMACROALL 
00000D81                    *   jnz @C00A2
00000D83                    *   call LstWriteSrcLine
                                invoke LstWriteSrcLine()
00000D88                                            .endif
00000D88                    *   @C00A2:
00000D88                                            .if ( [rbx+asm_tok].token != T_FINAL )
00000D88                    *   cmp [rbx+asm_tok].token , T_FINAL 
00000D8C                    *   jz  @C00A3
                                                        ;
                                                        ; v2.05: display error if there's more than 1 argument or
                                                        ; the argument isn't a text item
                                                        ;
00000D8E                                                .if ( [rbx+asm_tok].token != T_STRING || [rbx+asm_tok].string_delim != '<' )
00000D8E                    *   cmp [rbx+asm_tok].token , T_STRING 
00000D92                    *   jnz @C00A5
00000D94                    *   @C00A6:
00000D94                    *   cmp [rbx+asm_tok].string_delim , '<' 
00000D98                    *   jz  @C00A4
00000D9A                    *   @C00A5:
00000D9A                    *   invoke TextItemError, addr [rbx+asm_tok] 
00000D9A                    *    lea rcx, [rbx+asm_tok] 
00000D9E                    *    call TextItemError
                                invoke TextItemError( &[rbx+asm_tok] )
00000DA3                                                .elseif ( ModuleInfo.token_count > 2 )
00000DA3                    *   jmp @C00A7
00000DA5                    *   @C00A4:
00000DA5                    *   cmp ModuleInfo.token_count , 2 
00000DAC                    *   jng @C00A8
00000DAE                    *   invoke asmerr, 2008, [rbx+asm_tok*2].tokpos 
00000DAE                    *    mov rdx, [rbx+asm_tok*2].tokpos 
00000DB2                    *    mov ecx, 2008
00000DB7                    *    call asmerr
                                invoke asmerr( 2008, [rbx+asm_tok*2].tokpos )
00000DBC                                                .elseif ( _out ) ; return value buffer may be NULL ( loop directives )
00000DBC                    *   jmp @C00A7
00000DBE                    *   @C00A8:
00000DBE                    *   cmp ( _out ), 0
00000DC3                    *   jz  @C00A9
                                                            ;
                                                            ; v2.08a: the <>-literal behind EXITM is handled specifically,
                                                            ; macro operator '!' within the literal is only handled
                                                            ; if it contains a placeholder (macro argument, macro local ).
                                                            ;
                                                            ; v2.09: handle '!' inside literal if ANY expansion occurred.
                                                            ; To determine text macro or macro function expansion,
                                                            ; check if there's a literal in the original line.
                                                            ;
00000DC5                                                    mov rdi,_out
00000DC9                                                    mov rdx,mi.currline
00000DD0                                                    mov rax,[rbx+asm_tok].tokpos
00000DD4                                                    sub rax,ModuleInfo.currsource
00000DDB                                                    mov al,[rdx].srcline.line[rax]

00000DDF                                                    .if ( !_retm && [rbx].tokval == T_RETM )
00000DDF                    *   cmp _retm , 0
00000DE3                    *   jnz @C00AA
00000DE5                    *   cmp [rbx].tokval , T_RETM 
00000DEC                    *   jnz @C00AA

00000DEE                                                        mov rax,_out
00000DF2                                                        mov byte ptr [rax],0

00000DF5                                                    .elseif ( [rdx].srcline.ph_count || al != '<' )
00000DF5                    *   jmp @C00AB
00000DF7                    *   @C00AA:
00000DF7                    *   cmp [rdx].srcline.ph_count , 0
00000DFB                    *   jnz @C00AD
00000DFD                    *   @C00AE:
00000DFD                    *   cmp al , '<' 
00000DFF                    *   jz  @C00AC
00000E01                    *   @C00AD:

00000E01                                                        mov ecx,[rbx+asm_tok].stringlen
00000E04                                                        inc ecx
00000E06                                                        mov rsi,[rbx+asm_tok].string_ptr
00000E0A                                                        rep movsb

00000E0C                                                    .else
00000E0C                    *   jmp @C00AB
00000E0E                    *   @C00AC:
                                                                ;
                                                                ; since the string_ptr member has the !-operator stripped, it
                                                                ; cannot be used. To get the original value of the literal,
                                                                ; use tokpos.
                                                                ;
00000E0E                                                        mov rsi,[rbx+asm_tok].tokpos
00000E12                                                        inc rsi
00000E15                                                        mov rcx,[rbx+asm_tok*2].tokpos
00000E19                                                        sub rcx,rsi
00000E1C                                                        rep movsb
00000E1E                                                        dec rdi
00000E21                                                        .while( byte ptr [rdi] != '>' )
00000E21                    *   jmp @C00B0
00000E23                    *   @C00AF:
00000E23                                                            dec rdi
00000E26                                                        .endw
00000E26                    *   @C00B0:
00000E26                    *   cmp byte ptr [rdi] , '>' 
00000E29                    *   jnz @C00AF
00000E2B                                                        mov byte ptr [rdi],0
00000E2E                                                    .endif
00000E2E                    *   @C00AB:
00000E2E                                                .endif
00000E2E                    *   @C00A9:
00000E31                    *   @C00A7:
00000E31                                            .endif
00000E35                    *   @C00A3:

                                                    ; v2.10: if a goto had occured, rescan the full macro to ensure that
                                                    ; the "if"-nesting level is ok.

00000E35                                            .if cntgoto
00000E35                    *   cmp cntgoto, 0
00000E3C                    *   jz  @C00B1
00000E3E                                                mov mi.currline,NULL
00000E49                    *   invoke SetLineNumber, 0 
00000E49                    *    xor ecx, ecx
00000E4B                    *    call SetLineNumber
                                invoke SetLineNumber( 0 )
00000E50                    *   invoke SetIfNestLevel, oldifnesting 
00000E50                    *    mov ecx, oldifnesting 
00000E56                    *    call SetIfNestLevel
                                invoke SetIfNestLevel( oldifnesting )
00000E5B                                            .endif
00000E5B                    *   @C00B1:

00000E5B                    *   invoke SkipMacro, tokenarray 
00000E5B                    *    mov rcx, tokenarray 
00000E5F                    *    call SkipMacro
                                invoke SkipMacro( tokenarray )
00000E64                                            mov rax,is_exitm
00000E68                                            mov dword ptr [rax],TRUE
00000E6E                                            .break
00000E6E                    *    jmp @C00B2

00000E70                                        .elseif ( [rbx].tokval == T_GOTO )
00000E70                    *   jmp @C00B3
00000E76                    *   @C009F:
00000E76                    *   cmp [rbx].tokval , T_GOTO 
00000E7D                    *   jnz @C00B4

00000E7F                                            .if ( [rbx+asm_tok].token != T_FINAL )
00000E7F                    *   cmp [rbx+asm_tok].token , T_FINAL 
00000E83                    *   jz  @C00B5

00000E85                                                mov len,tstrlen( [rbx+asm_tok].string_ptr )
00000E85                    *   invoke tstrlen, [rbx+asm_tok].string_ptr 
00000E85                    *    mov rcx, [rbx+asm_tok].string_ptr 
00000E89                    *    call tstrlen
00000E8E                    *   mov len, eax

                                                        ;; search for the destination line
                                                        assume rdi:srcline_t

00000E94                                                .for ( i = 1, rdi = mi.startline: rdi != NULL: rdi = [rdi].next, i++ )
00000E94                    *   mov i, 1
00000E9B                    *   mov rdi, mi.startline
00000EA2                    *   @C00B6:
00000EA2                    *   test rdi , rdi 
00000EA5                    *   jz  @C00B8
00000EA7                                                    lea rsi,[rdi].line
00000EAB                                                    .if ( byte ptr [rsi] == ':' )
00000EAB                    *   cmp byte ptr [rsi] , ':' 
00000EAE                    *   jnz @C00B9
00000EB0                                                        .if ( [rdi].ph_count )
00000EB0                    *   cmp ( [rdi].ph_count ), 0
00000EB4                    *   jz  @C00BA
00000EB6                    *   invoke fill_placeholders, ModuleInfo.stringbufferend, rsi, mi.parmcnt,mi.localstart, mi.parm_array 
00000EB6                    *    mov rax, mi.parm_array 
00000EBD                    *    mov [rsp+32], rax
00000EC2                    *    mov r9d, mi.localstart
00000EC9                    *    mov r8d, mi.parmcnt
00000ED0                    *    mov rdx, rsi
00000ED3                    *    mov rcx, ModuleInfo.stringbufferend
00000EDA                    *    call fill_placeholders
                                invoke fill_placeholders( ModuleInfo.stringbufferend, rsi, mi.parmcnt,mi.localstart, mi.parm_array )
00000EDF                                                            mov rsi,ModuleInfo.stringbufferend
00000EE6                                                        .endif
00000EE6                    *   @C00BA:
00000EE6                                                        inc rsi
00000EE9                                                        .while islspace( [rsi] )
00000EE9                    *   jmp @C00BC
00000EEB                    *   @C00BB:
00000EEB                                                            inc rsi
00000EEE                                                        .endw
00000EEE                    *   @C00BC:
00000EEE                    *   invoke islspace, [rsi] 
00000EEE                    *    movzx eax, byte ptr [rsi] 
00000EF1                    *   test byte ptr [r15+rax+1] , _SPACE
00000EF7                    *   jne @C00BB
00000EF9                                                        .ifd !tmemicmp( rsi, [rbx+asm_tok].string_ptr, len )
00000EF9                    *   invoke tmemicmp, rsi, [rbx+asm_tok].string_ptr, len 
00000EF9                    *    mov r8d, len 
00000F00                    *    mov rdx, [rbx+asm_tok].string_ptr
00000F04                    *    mov rcx, rsi
00000F07                    *    call tmemicmp
00000F0C                    *   test eax, eax
00000F0E                    *   jnz @C00BD
00000F10                                                            mov ecx,len ; label found!
00000F16                                                           .break .if !islabel( [rsi+rcx] )
00000F16                    *   invoke islabel, [rsi+rcx] 
00000F16                    *    movzx eax, byte ptr [rsi+rcx] 
00000F1A                    *   test byte ptr [r15+rax+1] , (_LABEL or _DIGIT)
00000F20                    *   je  @C00B8
00000F22                                                        .endif
00000F22                    *   @C00BD:
00000F22                                                    .endif
00000F22                    *   @C00B9:
00000F22                                                .endf
00000F22                    *   @C00B7:
00000F22                    *   mov rdi, [rdi].next
00000F25                    *   inc i
00000F28                    *   jmp @C00B6
00000F31                    *   @C00B8:
00000F31                                                .if !rdi
00000F31                    *   test rdi, rdi
00000F34                    *   jnz @C00BE
                                                            ; v2.05: display error msg BEFORE SkipMacro()!
00000F36                    *   invoke asmerr, 2147, [rbx+asm_tok].string_ptr 
00000F36                    *    mov rdx, [rbx+asm_tok].string_ptr 
00000F3A                    *    mov ecx, 2147
00000F3F                    *    call asmerr
                                invoke asmerr( 2147, [rbx+asm_tok].string_ptr )
00000F44                                                .else
00000F44                    *   jmp @C00BF
00000F46                    *   @C00BE:
                                                            ; v2.10: rewritten, "if"-nesting-level handling added
00000F46                                                    mov mi.currline,rdi
00000F4D                    *   invoke SetLineNumber, i
00000F4D                    *    mov ecx, i
00000F50                    *    call SetLineNumber
                                invoke SetLineNumber(i)
00000F55                    *   invoke SetIfNestLevel, oldifnesting 
00000F55                    *    mov ecx, oldifnesting 
00000F5B                    *    call SetIfNestLevel
                                invoke SetIfNestLevel( oldifnesting )
00000F60                                                    inc cntgoto
00000F66                                                   .continue
00000F66                    *    jmp @C0099
00000F68                                                .endif
00000F68                    *   @C00BF:
00000F68                                            .else
00000F68                    *   jmp @C00C0
00000F6E                    *   @C00B5:
00000F6E                    *   invoke asmerr, 2008, [rbx].tokpos 
00000F6E                    *    mov rdx, [rbx].tokpos 
00000F72                    *    mov ecx, 2008
00000F77                    *    call asmerr
                                invoke asmerr( 2008, [rbx].tokpos )
00000F7C                                            .endif
00000F7C                    *   @C00C0:
00000F7C                    *   invoke SkipMacro, tokenarray 
00000F7C                    *    mov rcx, tokenarray 
00000F80                    *    call SkipMacro
                                invoke SkipMacro( tokenarray )
00000F85                                           .break
00000F85                    *    jmp @C00B2
00000F87                                        .endif
00000F8B                    *   @C00B4:
00000F8E                    *   @C00B3:
00000F8E                                    .endif
00000F92                    *   @C009E:
00000F92                    *   invoke ParseLine, tokenarray
00000F92                    *    mov rcx, tokenarray
00000F96                    *    call ParseLine
                                invoke ParseLine(tokenarray)
00000F9B                                    .if ( Options.preprocessor_stdout == TRUE )
00000F9B                    *   cmp Options.preprocessor_stdout , TRUE 
00000FA2                    *   jnz @C00C1
00000FA4                    *   invoke WritePreprocessedLine, ModuleInfo.currsource
00000FA4                    *    mov rcx, ModuleInfo.currsource
00000FAB                    *    call WritePreprocessedLine
                                invoke WritePreprocessedLine(ModuleInfo.currsource)
00000FB0                                    .endif
00000FB0                    *   @C00C1:

                                            ; the macro might contain an END directive.
                                            ; v2.08: this doesn't mean the macro is to be cancelled.
                                            ; Masm continues to run it and the assembly is stopped
                                            ; when the top source level is reached again.

00000FB0                                .endw
00000FBA                    *   @C0099:
00000FBA                    *   invoke GetTextLine, ModuleInfo.currsource 
00000FBA                    *    mov rcx, ModuleInfo.currsource 
00000FC1                    *    call GetTextLine
00000FC6                    *   test (  rax ), (  rax )
00000FC9                    *   jnz @C0098
00000FD2                    *   @C00B2:

00000FD2                                dec MacroLevel
00000FD8                                .if ( !( mflags & MF_NOSAVE ) )
00000FD8                    *   test mflags , MF_NOSAVE 
00000FDF                    *   jne @C00C2
00000FE1                    *   invoke PopInputStatus, addr oldstat
00000FE1                    *    lea rcx, oldstat
00000FE8                    *    call PopInputStatus
                                invoke PopInputStatus(&oldstat)
00000FED                                .endif
00000FED                    *   @C00C2:

                                        ; don't use tokenarray from here on, it's invalid after PopInputStatus()

00000FED                            .endif
00000FF1                    *   @C0095:
00000FF1                            .return( idx )
00000FF1                    *   mov eax,( idx )
00000FF4                    *   jmp @C000D

                            *   org $ - 2
00000FF4                    *   ret
00001009                    *   @C000D:
00001009                    *   leave
0000100A                    *   pop rbx
0000100B                    *   pop rdi
0000100C                    *   pop rsi
0000100D                    *   retn 
0000100E                        RunMacro endp

                                    assume rsi:nothing
                                    assume rdi:nothing


                                ; make room (or delete items) in the token buffer at position <start>

0000100E                        AddTokens proc fastcall private uses rbx tokenarray:token_t, start:int_t, count:int_t, _end:int_t

0000100E                    *   mov [rsp+8], rcx
00001013                    *   mov [rsp+16], rdx
00001018                    *   mov [rsp+24], r8
0000101D                    *   mov [rsp+32], r9
00001022                    *   push rbx
00001023                    *   push rbp
00001024                    *   mov rbp, rsp
00001027                    *   sub rsp, 40
0000102B                            mov     rbx,tokenarray
                                ifdef _WIN64
0000102F                            movsxd  rax,count
                                endif
00001033                            imul    rcx,rax,asm_tok
00001037                            mov     edx,start

0000103A                            .ifs ( eax > 0 )
0000103A                    *   cmp eax , 0 
0000103D                    *   jng @C00C3

0000103F                                imul eax,_end,asm_tok
00001043                                add  rbx,rax

00001046                                .for ( : _end >= edx : _end--, rbx -= asm_tok )
00001046                    *   @C00C4:
00001046                    *   cmp _end , edx
00001049                    *   jl  @C00C6

0000104B                                    mov [rbx+rcx],asm_tok ptr [rbx]
0000104B                    *    mov rax, qword ptr asm_tok ptr [rbx][0]
0000104E                    *    mov qword ptr [rbx+rcx][0], rax
00001052                    *    mov rax, qword ptr asm_tok ptr [rbx][8]
00001056                    *    mov qword ptr [rbx+rcx][8], rax
0000105B                    *    mov eax, dword ptr asm_tok ptr [rbx][16]
0000105E                    *    mov dword ptr [rbx+rcx][16], eax
00001062                    *    mov al, byte ptr asm_tok ptr [rbx][20]
00001065                    *    mov byte ptr [rbx+rcx][20], al
00001069                    *    mov al, byte ptr asm_tok ptr [rbx][21]
0000106C                    *    mov byte ptr [rbx+rcx][21], al
00001070                    *    mov al, byte ptr asm_tok ptr [rbx][22]
00001073                    *    mov byte ptr [rbx+rcx][22], al
00001077                                .endf
00001077                    *   @C00C5:
00001077                    *   dec _end
0000107A                    *   sub rbx, asm_tok
0000107E                    *   jmp @C00C4
00001080                    *   @C00C6:

00001080                            .elseifs ( eax < 0 )
00001080                    *   jmp @C00C7
00001082                    *   @C00C3:
00001082                    *   cmp eax , 0 
00001085                    *   jnl @C00C8

00001087                                sub  edx,eax
00001089                                imul eax,edx,asm_tok
0000108C                                add  rbx,rax

0000108F                                .for ( : edx <= _end : edx++, rbx += asm_tok )
0000108F                    *   @C00C9:
0000108F                    *   cmp edx , _end
00001092                    *   jg  @C00CB

00001094                                    mov [rbx+rcx],asm_tok ptr [rbx]
00001094                    *    mov rax, qword ptr asm_tok ptr [rbx][0]
00001097                    *    mov qword ptr [rbx+rcx][0], rax
0000109B                    *    mov rax, qword ptr asm_tok ptr [rbx][8]
0000109F                    *    mov qword ptr [rbx+rcx][8], rax
000010A4                    *    mov eax, dword ptr asm_tok ptr [rbx][16]
000010A7                    *    mov dword ptr [rbx+rcx][16], eax
000010AB                    *    mov al, byte ptr asm_tok ptr [rbx][20]
000010AE                    *    mov byte ptr [rbx+rcx][20], al
000010B2                    *    mov al, byte ptr asm_tok ptr [rbx][21]
000010B5                    *    mov byte ptr [rbx+rcx][21], al
000010B9                    *    mov al, byte ptr asm_tok ptr [rbx][22]
000010BC                    *    mov byte ptr [rbx+rcx][22], al
000010C0                                .endf
000010C0                    *   @C00CA:
000010C0                    *   inc edx
000010C2                    *   add rbx, asm_tok
000010C6                    *   jmp @C00C9
000010C8                    *   @C00CB:
000010C8                            .endif
000010C8                    *   @C00C8:
000010C8                    *   @C00C7:
000010C8                            ret
000010C8                    *   leave
000010C9                    *   pop rbx
000010CA                    *   retn 

000010CB                        AddTokens endp


                                ; ExpandText() is called if
                                ; - the evaluation operator '%' has been found as first char of the line.
                                ; - the % operator is found in a macro argument.
                                ; if substitute is TRUE, scanning for the substitution character '&' is active!
                                ; Both text macros and macro functions are expanded!


000010CB                        ExpandText proc fastcall uses rsi rdi rbx line:string_t, tokenarray:token_t, substitute:uint_t

                                    local pIdent:string_t
                                    local lvl:int_t
                                    local is_exitm:int_t
                                    local old_tokencount:int_t
                                    local old_stringbufferend:string_t
                                    local rc:int_t
                                    local sym:asym_t
                                    local _sp[MAX_TEXTMACRO_NESTING]:string_t
                                    local i:int_t
                                    local cnt:int_t
                                    local quoted_string:char_t
                                    local macro_proc:char_t

000010CB                    *   mov [rsp+8], rcx
000010D0                    *   mov [rsp+16], rdx
000010D5                    *   mov [rsp+24], r8
000010DA                    *   push rsi
000010DB                    *   push rdi
000010DC                    *   push rbx
000010DD                    *   push rbp
000010DE                    *   mov rbp, rsp
000010E1                    *   sub rsp, 264
000010E8                            mov old_tokencount,ModuleInfo.token_count
000010E8                    *    mov eax, ModuleInfo.token_count
000010EE                    *    mov old_tokencount, eax
000010F1                            mov old_stringbufferend,ModuleInfo.stringbufferend
000010F1                    *    mov rax, ModuleInfo.stringbufferend
000010F8                    *    mov old_stringbufferend, rax
000010FC                            mov quoted_string,0
00001103                            mov macro_proc,FALSE

0000110A                            mov _sp[0],line
0000110A                    *    mov rax, line
0000110E                    *    mov _sp[0], rax
00001115                            mov rdi,ModuleInfo.stringbufferend
0000111C                            add ModuleInfo.stringbufferend,ModuleInfo.max_line_len
0000111C                    *    mov eax, ModuleInfo.max_line_len
00001122                    *    add ModuleInfo.stringbufferend, rax

00001129                            mov rc,NOT_ERROR

00001130                            .for ( lvl = 0 : lvl >= 0 : lvl-- )
00001130                    *   mov lvl, 0
00001137                    *   @C00CC:
00001137                    *   cmp lvl , 0
0000113B                    *   jl  @C00CE

0000113D                                mov eax,lvl
00001140                                mov rsi,_sp[rax*string_t]

00001148                                .while ( byte ptr [rsi] )
00001148                    *   jmp @C00D0
0000114A                    *   @C00CF:

0000114A                                    .if ( isdotlabel( [rsi], ModuleInfo.dotname ) && ( substitute || !quoted_string ) )
0000114A                    *   invoke isdotlabel, [rsi], ModuleInfo.dotname 
0000114A                    *    movzx edx, byte ptr ModuleInfo.dotname 
00001151                    *    movzx eax, byte ptr [rsi]
00001154                    *   cmp al , '.' 
00001156                    *   jnz @C00D3
00001158                    *   test dl, dl
0000115A                    *   jnz @C00D2
0000115C                    *   @C00D3:
0000115C                    *   test byte ptr [r15+rax+1] , _LABEL
00001162                    *   je  @C00D1
00001164                    *   @C00D2:
00001164                    *   cmp substitute , 0
00001168                    *   jnz @C00D4
0000116A                    *   @C00D5:
0000116A                    *   cmp quoted_string , 0
00001171                    *   jnz @C00D1
00001173                    *   @C00D4:

00001173                                        mov pIdent,rdi
00001177                                        .repeat
00001177                    *   @C00D6:
00001177                                            stosb
00001178                                            inc rsi
0000117B                                        .until !islabel( [rsi] )
0000117B                    *   invoke islabel, [rsi] 
0000117B                    *    movzx eax, byte ptr [rsi] 
0000117E                    *   test byte ptr [r15+rax+1] , (_LABEL or _DIGIT)
00001184                    *   jne @C00D6
00001186                                        mov byte ptr [rdi],0

00001189                                        mov sym,SymFind(pIdent)
00001189                    *   invoke SymFind, pIdent
00001189                    *    mov rcx, pIdent
0000118D                    *    call SymFind
00001192                    *   mov sym, rax
00001196                                        .if ( rax && [rax].asym.flags & S_ISDEFINED )
00001196                    *   test rax , rax 
00001199                    *   jz  @C00D7
0000119B                    *   test [rax].asym.flags , S_ISDEFINED 
0000119F                    *   je  @C00D7
000011A1                                            .if ( [rax].asym.state == SYM_TMACRO )
000011A1                    *   cmp [rax].asym.state , SYM_TMACRO 
000011A5                    *   jnz @C00D8

                                                        ;
                                                        ; v2.08: no expansion inside quoted strings without &
                                                        ;
000011A7                                                mov rdx,pIdent
000011AB                                                .continue .if ( quoted_string &&byte ptr [rdx-1] != '&' && byte ptr [rsi] != '&' )
000011AB                    *   cmp quoted_string , 0
000011B2                    *   jz  @C00D9
000011B4                    *   @C00DA:
000011B4                    *   cmp byte ptr [rdx-1] , '&' 
000011B8                    *   jz  @C00D9
000011BA                    *   @C00DB:
000011BA                    *   cmp byte ptr [rsi] , '&' 
000011BD                    *   jnz @C00D0
000011BF                    *   @C00D9:

000011BF                                                .if ( substitute )
000011BF                    *   cmp ( substitute ), 0
000011C3                    *   jz  @C00DC
000011C5                                                    .if ( byte ptr [rdx-1] == '&' )
000011C5                    *   cmp byte ptr [rdx-1] , '&' 
000011C9                    *   jnz @C00DD
000011CB                                                        dec pIdent
000011CF                                                    .endif
000011CF                    *   @C00DD:
000011CF                                                    .if ( byte ptr [rsi] == '&' )
000011CF                    *   cmp byte ptr [rsi] , '&' 
000011D2                    *   jnz @C00DE
000011D4                                                        inc rsi
000011D7                                                    .endif
000011D7                    *   @C00DE:
000011D7                                                .elseif ( pIdent > old_stringbufferend && byte ptr [rdx-1] == '%' )
000011D7                    *   jmp @C00DF
000011D9                    *   @C00DC:
000011D9                    *   cmp pIdent , old_stringbufferend 
000011D9                    *    mov rax,  old_stringbufferend 
000011DD                    *    cmp pIdent , rax
000011E1                    *   jna @C00E0
000011E3                    *   cmp byte ptr [rdx-1] , '%' 
000011E7                    *   jnz @C00E0
000011E9                                                    dec pIdent
000011ED                                                .endif
000011ED                    *   @C00E0:
000011ED                    *   @C00DF:

000011ED                                                mov eax,lvl
000011F0                                                inc lvl
000011F3                                                mov _sp[rax*string_t],rsi
000011FB                                                mov rsi,ModuleInfo.stringbufferend
00001202                                                mov rax,sym
00001206                    *   invoke tstrcpy, rsi, [rax].asym.string_ptr 
00001206                    *    mov rdx, [rax].asym.string_ptr 
0000120A                    *    mov rcx, rsi
0000120D                    *    call tstrcpy
00001212                    *   invoke tstrlen, rax 
00001212                    *    mov rcx, rax 
00001215                    *    call tstrlen
                                invoke tstrlen( tstrcpy( rsi, [rax].asym.string_ptr ) )
0000121A                                                mov ModuleInfo.stringbufferend,GetAlignedPointer( rsi, eax )
0000121A                    *   invoke GetAlignedPointer, rsi, eax 
0000121A                    *    mov edx, eax
0000121C                    *    mov rax, rsi
0000121F                    *1  add edx,size_t
00001222                    *1  and edx,not ( size_t - 1 )
00001225                    *1  add rax,rdx
00001228                    *   mov ModuleInfo.stringbufferend, rax
0000122F                                                mov rdi,pIdent
00001233                                                mov rc,STRING_EXPANDED

0000123A                                            .elseif ( [rax].asym.state == SYM_MACRO && [rax].asym.mac_flag & M_ISFUNC )
0000123A                    *   jmp @C00E1
00001240                    *   @C00D8:
00001240                    *   cmp [rax].asym.state , SYM_MACRO 
00001244                    *   jnz @C00E2
00001246                    *   test [rax].asym.mac_flag , M_ISFUNC 
0000124A                    *   je  @C00E2

                                                        ; expand macro functions.

0000124C                                                mov rcx,rsi
0000124F                                                .while islspace( [rcx] )
0000124F                    *   jmp @C00E4
00001251                    *   @C00E3:
00001251                                                    inc rcx
00001254                                                .endw
00001254                    *   @C00E4:
00001254                    *   invoke islspace, [rcx] 
00001254                    *    movzx eax, byte ptr [rcx] 
00001257                    *   test byte ptr [r15+rax+1] , _SPACE
0000125D                    *   jne @C00E3
                                                        ;
                                                        ; no macro function invokation if the '(' is missing!
                                                        ;
0000125F                                                .if ( al == '(' )
0000125F                    *   cmp al , '(' 
00001261                    *   jnz @C00E5

00001263                                                    mov i,ModuleInfo.token_count
00001263                    *    mov eax, ModuleInfo.token_count
00001269                    *    mov i, eax
0000126F                                                    inc i
00001275                                                    mov ModuleInfo.token_count,Tokenize( rcx, i, tokenarray, TOK_RESCAN )
00001275                    *   invoke Tokenize, rcx, i, tokenarray, TOK_RESCAN 
00001275                    *    mov r9d, TOK_RESCAN 
0000127B                    *    mov r8, tokenarray
0000127F                    *    mov edx, i
00001285                    *    call Tokenize
0000128A                    *   mov ModuleInfo.token_count, eax

00001290                                                    mov  edx,i
00001296                                                    imul ecx,edx,asm_tok
00001299                                                    add  rcx,tokenarray
0000129D                                                    .for ( eax = 0 : edx < ModuleInfo.token_count : edx++, rcx += asm_tok )
0000129D                    *   xor eax, eax
0000129F                    *   @C00E6:
0000129F                    *   cmp edx , ModuleInfo.token_count
000012A5                    *   jnl @C00E8
000012A7                                                        .if [rcx].asm_tok.token == T_OP_BRACKET
000012A7                    *   cmp [rcx].asm_tok.token , T_OP_BRACKET
000012AA                    *   jnz @C00E9
000012AC                                                            inc eax
000012AE                                                        .elseif [rcx].asm_tok.token == T_CL_BRACKET
000012AE                    *   jmp @C00EA
000012B0                    *   @C00E9:
000012B0                    *   cmp [rcx].asm_tok.token , T_CL_BRACKET
000012B3                    *   jnz @C00EB
000012B5                                                            dec eax
000012B7                                                            .ifz
000012B7                    *   jne @C00EC
000012B9                                                                add rcx,asm_tok
000012BD                                                                .break
000012BD                    *    jmp @C00E8
000012BF                                                            .endif
000012BF                    *   @C00EC:
000012BF                                                        .endif
000012BF                    *   @C00EB:
000012BF                    *   @C00EA:
000012BF                                                    .endf
000012BF                    *   @C00E7:
000012BF                    *   inc edx
000012C1                    *   add rcx, asm_tok
000012C5                    *   jmp @C00E6
000012C7                    *   @C00E8:

                                                            ; don't substitute inside quoted strings if there's no '&'

000012C7                                                    mov rdx,pIdent
000012CB                                                    .if ( quoted_string && byte ptr [rdx-1] != '&' && [rcx].asm_tok.token != '&' )
000012CB                    *   cmp quoted_string , 0
000012D2                    *   jz  @C00ED
000012D4                    *   cmp byte ptr [rdx-1] , '&' 
000012D8                    *   jz  @C00ED
000012DA                    *   cmp [rcx].asm_tok.token , '&' 
000012DD                    *   jz  @C00ED
000012DF                                                        mov ModuleInfo.token_count,old_tokencount
000012DF                    *    mov eax, old_tokencount
000012E2                    *    mov ModuleInfo.token_count, eax
000012E8                                                        .continue
000012E8                    *    jmp @C00D0
000012EA                                                    .endif
000012EA                    *   @C00ED:
000012EA                                                    .if substitute
000012EA                    *   cmp substitute, 0
000012EE                    *   jz  @C00EE
000012F0                                                        .if byte ptr [rdx-1] == '&'
000012F0                    *   cmp byte ptr [rdx-1] , '&'
000012F4                    *   jnz @C00EF
000012F6                                                            dec pIdent
000012FA                                                        .endif
000012FA                    *   @C00EF:
000012FA                                                    .elseif rdx > old_stringbufferend && byte ptr [rdx-1] == '%'
000012FA                    *   jmp @C00F0
000012FC                    *   @C00EE:
000012FC                    *   cmp rdx , old_stringbufferend 
00001300                    *   jna @C00F1
00001302                    *   cmp byte ptr [rdx-1] , '%'
00001306                    *   jnz @C00F1
00001308                                                        dec pIdent
0000130C                                                    .endif
0000130C                    *   @C00F1:
0000130C                    *   @C00F0:
0000130C                                                    mov i,RunMacro( sym, i, tokenarray, rdi, 0, &is_exitm )
0000130C                    *   invoke RunMacro, sym, i, tokenarray, rdi, 0, addr is_exitm 
0000130C                    *    lea rax, is_exitm 
00001310                    *    mov [rsp+40], rax
00001315                    *    mov dword ptr [rsp+32], 0
0000131D                    *    mov r9, rdi
00001320                    *    mov r8, tokenarray
00001324                    *    mov edx, i
0000132A                    *    mov rcx, sym
0000132E                    *    call RunMacro
00001333                    *   mov i, eax
00001339                                                    mov ecx,old_tokencount
0000133C                                                    mov ModuleInfo.token_count,ecx
00001342                                                    .return .if eax == -1
00001342                    *   cmp eax , -1
00001345                    *   jz  @C00F2

00001347                                                    imul ebx,eax,asm_tok
0000134A                                                    add rbx,tokenarray
0000134E                                                    mov rsi,[rbx-asm_tok].tokpos
00001352                                                    add rsi,tstrlen( [rbx-asm_tok].string_ptr )
00001352                    *   invoke tstrlen, [rbx-asm_tok].string_ptr 
00001352                    *    mov rcx, [rbx-asm_tok].string_ptr 
00001356                    *    call tstrlen
0000135B                    *   add rsi, rax
0000135E                                                    .if ( substitute && byte ptr [rsi] == '&' )
0000135E                    *   cmp substitute , 0
00001362                    *   jz  @C00F3
00001364                    *   cmp byte ptr [rsi] , '&' 
00001367                    *   jnz @C00F3
00001369                                                        inc rsi
0000136C                                                    .endif
0000136C                    *   @C00F3:
0000136C                                                    mov eax,lvl
0000136F                                                    inc lvl
00001372                                                    mov _sp[rax*string_t],rsi
0000137A                    *   invoke tstrlen, rdi 
0000137A                    *    mov rcx, rdi 
0000137D                    *    call tstrlen
                                invoke tstrlen( rdi )
00001382                                                    mov rsi,rdi
00001385                                                    mov rdi,ModuleInfo.stringbufferend
0000138C                                                    lea rcx,[rax+1]
00001390                                                    rep movsb
00001392                                                    mov rsi,ModuleInfo.stringbufferend
00001399                                                    mov ModuleInfo.stringbufferend,GetAlignedPointer( rsi, eax )
00001399                    *   invoke GetAlignedPointer, rsi, eax 
00001399                    *    mov edx, eax
0000139B                    *    mov rax, rsi
0000139E                    *1  add edx,size_t
000013A1                    *1  and edx,not ( size_t - 1 )
000013A4                    *1  add rax,rdx
000013A7                    *   mov ModuleInfo.stringbufferend, rax
000013AE                                                    mov rdi,pIdent
000013B2                                                    mov rc,STRING_EXPANDED
000013B9                                                .endif
000013BD                    *   @C00E5:
000013BD                                            .elseif [rax].asym.state == SYM_MACRO
000013BD                    *   jmp @C00E1
000013C7                    *   @C00E2:
000013C7                    *   cmp [rax].asym.state , SYM_MACRO
000013CB                    *   jnz @C00F4
000013CD                                                mov macro_proc,TRUE
000013D4                                            .endif
000013D4                    *   @C00F4:
000013D7                    *   @C00E1:
000013D7                                            .if lvl == MAX_TEXTMACRO_NESTING
000013D7                    *   cmp lvl , MAX_TEXTMACRO_NESTING
000013DB                    *   jnz @C00F5
000013DD                    *   invoke asmerr, 2123 
000013DD                    *    mov ecx, 2123 
000013E2                    *    call asmerr
                                invoke asmerr( 2123 )
000013E7                                                .break
000013E7                    *    jmp @C00F6
000013E9                                            .endif
000013E9                    *   @C00F5:
000013E9                                        .endif
000013F1                    *   @C00D7:
000013F1                                    .else
000013F1                    *   jmp @C00F7
000013FB                    *   @C00D1:
000013FB                                        mov al,[rsi]
000013FD                                        .if ( al == '"' || al == "'" )
000013FD                    *   cmp al , '"' 
000013FF                    *   jz  @C00F9
00001401                    *   @C00FA:
00001401                    *   cmp al , "'" 
00001403                    *   jnz @C00F8
00001405                    *   @C00F9:
00001405                                            .if ( quoted_string == 0 )
00001405                    *   cmp quoted_string , 0 
0000140C                    *   jnz @C00FB
0000140E                                                mov quoted_string,al
00001414                                            .elseif ( al == quoted_string )
00001414                    *   jmp @C00FC
00001416                    *   @C00FB:
00001416                    *   cmp al , quoted_string 
0000141C                    *   jnz @C00FD
0000141E                                                mov quoted_string,0
00001425                                            .endif
00001425                    *   @C00FD:
00001425                    *   @C00FC:
00001425                                        .endif
00001425                    *   @C00F8:
00001425                                        movsb
00001426                                    .endif
00001426                    *   @C00F7:
00001426                                .endw
00001430                    *   @C00D0:
00001430                    *   cmp ( byte ptr [rsi] ), 0
00001433                    *   jnz @C00CF
00001439                    *   @C00F6:
00001439                            .endf
00001439                    *   @C00CD:
00001439                    *   dec lvl
0000143C                    *   jmp @C00CC
00001445                    *   @C00CE:

00001445                            mov byte ptr [rdi],0
00001448                            inc rdi
0000144B                            mov ModuleInfo.stringbufferend,old_stringbufferend
0000144B                    *    mov rax, old_stringbufferend
0000144F                    *    mov ModuleInfo.stringbufferend, rax

00001456                            .if ( rc == STRING_EXPANDED )
00001456                    *   cmp rc , STRING_EXPANDED 
0000145A                    *   jnz @C00FE

0000145C                                mov rcx,rdi
0000145F                                sub rcx,rax
00001462                                mov rsi,rax
00001465                                mov rdi,line
00001469                                rep movsb
0000146B                            .endif
0000146B                    *   @C00FE:

0000146B                            .if ( substitute )
0000146B                    *   cmp ( substitute ), 0
0000146F                    *   jz  @C00FF

00001471                                mov rbx,tokenarray
00001475                                .if rc == STRING_EXPANDED
00001475                    *   cmp rc , STRING_EXPANDED
00001479                    *   jnz @C0100
0000147B                                    mov ModuleInfo.token_count,Tokenize( [rbx].tokpos, 0, rbx, TOK_RESCAN )
0000147B                    *   invoke Tokenize, [rbx].tokpos, 0, rbx, TOK_RESCAN 
0000147B                    *    mov r9d, TOK_RESCAN 
00001481                    *    mov r8, rbx
00001484                    *    xor edx, edx
00001486                    *    mov rcx, [rbx].tokpos
0000148A                    *    call Tokenize
0000148F                    *   mov ModuleInfo.token_count, eax
00001495                                .endif
00001495                    *   @C0100:
00001495                                .if rc == STRING_EXPANDED || macro_proc
00001495                    *   cmp rc , STRING_EXPANDED 
00001499                    *   jz  @C0102
0000149B                    *   @C0103:
0000149B                    *   cmp macro_proc, 0
000014A2                    *   jz  @C0101
000014A4                    *   @C0102:
000014A4                                    .return 0 .if DelayExpand(rbx)
000014A4                    *   invoke DelayExpand, rbx
000014A4                    *    mov rcx, rbx
000014A7                    *    call DelayExpand
000014AC                    *   test rax, rax
000014AF                    *   jz  @C0104
000014B1                    *   xor eax,eax
000014B3                    *   jmp @C00F2
000014B5                    *   @C0104:
000014B5                                    .return ExpandLine( [rbx].tokpos, rbx )
000014B5                    *   invoke ExpandLine, [rbx].tokpos, rbx 
000014B5                    *    mov rdx, rbx 
000014B8                    *    mov rcx, [rbx].tokpos
000014BC                    *    call ExpandLine
000014C1                    *   jmp @C00F2
000014C3                                .endif
000014C3                    *   @C0101:
000014C3                            .endif
000014C3                    *   @C00FF:
000014C3                            .return( rc )
000014C3                    *   mov eax,( rc )
000014C6                    *   jmp @C00F2

                            *   org $ - 2
000014C6                    *   ret
000014CA                    *   @C00F2:
000014CA                    *   leave
000014CB                    *   pop rbx
000014CC                    *   pop rdi
000014CD                    *   pop rsi
000014CE                    *   retn 
000014CF                        ExpandText endp


                                ; replace text macros and macro functions by their values, recursively
                                ; outbuf in: text macro or macro function value
                                ; outbuf out: expanded value
                                ; equmode: if 1, don't expand macro functions

000014CF                        ExpandTMacro proc fastcall private uses rsi rdi rbx outbuf:string_t,tokenarray:token_t, equmode:int_t, level:int_t

                                    local old_tokencount:int_t
                                    local i:int_t
                                    local len:int_t
                                    local is_exitm:int_t
                                    local sym:asym_t
                                    local buffer:ptr char_t
                                    local expanded:char_t

000014CF                    *   mov [rsp+8], rcx
000014D4                    *   mov [rsp+16], rdx
000014D9                    *   mov [rsp+24], r8
000014DE                    *   mov [rsp+32], r9
000014E3                    *   push rsi
000014E4                    *   push rdi
000014E5                    *   push rbx
000014E6                    *   push rbp
000014E7                    *   mov rbp, rsp
000014EA                    *   sub rsp, 72
000014EE                            mov buffer,alloca(ModuleInfo.max_line_len)
000014EE                    *   invoke alloca, ModuleInfo.max_line_len
000014EE                    *   mov eax, ModuleInfo.max_line_len
000014F4                    *1  add     eax,16-1
000014F7                    *1  and     eax,-16
000014FA                    *1  sub     rsp,rax
000014FD                    *1  lea     rax,[rsp+@ReservedStack]
00001502                    *   mov buffer, rax
00001506                            mov old_tokencount,ModuleInfo.token_count
00001506                    *    mov eax, ModuleInfo.token_count
0000150C                    *    mov old_tokencount, eax
0000150F                            mov expanded,TRUE

00001513                            .if ( level >= MAX_TEXTMACRO_NESTING )
00001513                    *   cmp level , MAX_TEXTMACRO_NESTING 
00001517                    *   jl  @C0105
00001519                                .return( asmerr( 2123 ) )
00001519                    *   invoke asmerr, 2123 
00001519                    *    mov ecx, 2123 
0000151E                    *    call asmerr
00001523                    *   jmp @C0106
00001525                            .endif
00001525                    *   @C0105:

00001525                            .while ( expanded == TRUE )
00001525                    *   jmp @C0108
00001527                    *   @C0107:

00001527                                mov i,old_tokencount
00001527                    *    mov eax, old_tokencount
0000152A                    *    mov i, eax
0000152D                                inc i
00001530                                mov ModuleInfo.token_count,Tokenize( outbuf, i, tokenarray, TOK_RESCAN )
00001530                    *   invoke Tokenize, outbuf, i, tokenarray, TOK_RESCAN 
00001530                    *    mov r9d, TOK_RESCAN 
00001536                    *    mov r8, tokenarray
0000153A                    *    mov edx, i
0000153D                    *    mov rcx, outbuf
00001541                    *    call Tokenize
00001546                    *   mov ModuleInfo.token_count, eax
0000154C                                mov expanded,FALSE

00001550                                .for ( : i < ModuleInfo.token_count: i++ )
00001550                    *   @C0109:
00001550                    *   cmp i , ModuleInfo.token_count
00001550                    *    mov eax,  ModuleInfo.token_count
00001556                    *    cmp i , eax
00001559                    *   jnl @C010B

0000155B                                    imul ebx,i,asm_tok
0000155F                                    add  rbx,tokenarray
00001563                                    .if [rbx].token == T_ID
00001563                    *   cmp [rbx].token , T_ID
00001566                    *   jnz @C010C
00001568                                        mov sym,SymFind([rbx].string_ptr)
00001568                    *   invoke SymFind, [rbx].string_ptr
00001568                    *    mov rcx, [rbx].string_ptr
0000156C                    *    call SymFind
00001571                    *   mov sym, rax

                                                ; expand macro functions

00001575                                        .if ( rax && [rax].asym.state == SYM_MACRO &&[rax].asym.flags & S_ISDEFINED && [rax].asym.mac_flag & M_ISFUNC &&[rbx+asm_tok].token == T_OP_BRACKET && equmode == FALSE )
00001575                    *   test rax , rax 
00001578                    *   jz  @C010D
0000157A                    *   cmp [rax].asym.state , SYM_MACRO 
0000157E                    *   jnz @C010D
00001580                    *   test [rax].asym.flags , S_ISDEFINED 
00001584                    *   je  @C010D
00001586                    *   test [rax].asym.mac_flag , M_ISFUNC 
0000158A                    *   je  @C010D
0000158C                    *   cmp [rbx+asm_tok].token , T_OP_BRACKET 
00001590                    *   jnz @C010D
00001592                    *   cmp equmode , FALSE 
00001596                    *   jnz @C010D

00001598                                            mov rcx,[rbx].tokpos
0000159C                                            sub rcx,outbuf
000015A0                                            mov rdi,buffer
000015A4                                            mov rsi,outbuf
000015A8                                            rep movsb
000015AA                                            mov edx,i
000015AD                                            inc edx
000015AF                                            mov i,RunMacro( sym, edx, tokenarray, rdi, 0, &is_exitm )
000015AF                    *   invoke RunMacro, sym, edx, tokenarray, rdi, 0, addr is_exitm 
000015AF                    *    lea rax, is_exitm 
000015B3                    *    mov [rsp+40], rax
000015B8                    *    mov dword ptr [rsp+32], 0
000015C0                    *    mov r9, rdi
000015C3                    *    mov r8, tokenarray
000015C7                    *    mov rcx, sym
000015CB                    *    call RunMacro
000015D0                    *   mov i, eax
000015D3                                            .if i < 0
000015D3                    *   cmp i , 0
000015D7                    *   jnl @C010E
000015D9                                                mov ModuleInfo.token_count,old_tokencount
000015D9                    *    mov eax, old_tokencount
000015DC                    *    mov ModuleInfo.token_count, eax
000015E2                                                .return ERROR
000015E2                    *   mov rax,ERROR
000015E9                    *   jmp @C0106
000015EB                                            .endif
000015EB                    *   @C010E:
000015EB                                            imul ebx,i,asm_tok
000015EF                                            add  rbx,tokenarray
000015F3                    *   invoke tstrcat, rdi, [rbx].tokpos 
000015F3                    *    mov rdx, [rbx].tokpos 
000015F7                    *    mov rcx, rdi
000015FA                    *    call tstrcat
                                invoke tstrcat( rdi, [rbx].tokpos )
000015FF                    *   invoke tstrcpy, outbuf, buffer 
000015FF                    *    mov rdx, buffer 
00001603                    *    mov rcx, outbuf
00001607                    *    call tstrcpy
                                invoke tstrcpy( outbuf, buffer )
0000160C                                            mov expanded,TRUE
                                                    ; is i to be decremented here?
00001610                                            .break
00001610                    *    jmp @C010B
00001612                                        .elseif ( rax && [rax].asym.state == SYM_TMACRO && [rax].asym.flags & S_ISDEFINED )
00001612                    *   jmp @C010F
00001628                    *   @C010D:
00001628                    *   test rax , rax 
0000162B                    *   jz  @C0110
0000162D                    *   cmp [rax].asym.state , SYM_TMACRO 
00001631                    *   jnz @C0110
00001633                    *   test [rax].asym.flags , S_ISDEFINED 
00001637                    *   je  @C0110

00001639                                            mov rsi,outbuf
0000163D                                            mov rdi,buffer
00001641                                            mov rcx,[rbx].tokpos
00001645                                            sub rcx,rsi
00001648                                            rep movsb
0000164A                    *   invoke tstrcpy, rdi, [rax].asym.string_ptr 
0000164A                    *    mov rdx, [rax].asym.string_ptr 
0000164E                    *    mov rcx, rdi
00001651                    *    call tstrcpy
                                invoke tstrcpy( rdi, [rax].asym.string_ptr )
00001656                                            mov ecx,level
00001659                                            inc ecx
0000165B                                            .ifd ExpandTMacro( rdi, tokenarray, equmode, ecx ) == ERROR
0000165B                    *   invoke ExpandTMacro, rdi, tokenarray, equmode, ecx 
0000165B                    *    mov r9d, ecx 
0000165E                    *    mov r8d, equmode
00001662                    *    mov rdx, tokenarray
00001666                    *    mov rcx, rdi
00001669                    *    call ExpandTMacro
0000166E                    *   cmp eax , ERROR
00001671                    *   jnz @C0111
00001673                                                mov ModuleInfo.token_count,old_tokencount
00001673                    *    mov eax, old_tokencount
00001676                    *    mov ModuleInfo.token_count, eax
0000167C                                                .return( ERROR )
0000167C                    *   mov rax,( ERROR )
00001683                    *   jmp @C0106
00001685                                            .endif
00001685                    *   @C0111:
00001685                                            mov rax,sym
00001689                                            mov edx,[rax].asym.name_size
0000168C                                            add rdx,[rbx].tokpos
00001690                    *   invoke tstrcat, rdi, rdx 
00001690                    *    mov rcx, rdi
00001693                    *    call tstrcat
                                invoke tstrcat( rdi, rdx )
00001698                    *   invoke tstrcpy, outbuf, buffer 
00001698                    *    mov rdx, buffer 
0000169C                    *    mov rcx, outbuf
000016A0                    *    call tstrcpy
                                invoke tstrcpy( outbuf, buffer )
000016A5                                            mov expanded,TRUE
000016A9                                            .break
000016A9                    *    jmp @C010B
000016AB                                        .endif
000016AB                    *   @C0110:
000016AE                    *   @C010F:
000016AE                                    .endif
000016B2                    *   @C010C:
000016B2                                .endf
000016B2                    *   @C010A:
000016B2                    *   inc i
000016B5                    *   jmp @C0109
000016C1                    *   @C010B:
000016C1                            .endw
000016C4                    *   @C0108:
000016C4                    *   cmp expanded , TRUE 
000016C8                    *   jz  @C0107
000016CE                            mov ModuleInfo.token_count,old_tokencount
000016CE                    *    mov eax, old_tokencount
000016D1                    *    mov ModuleInfo.token_count, eax
000016D7                           .return( NOT_ERROR )
000016D7                    *   xor eax,eax
000016D9                    *   jmp @C0106

                            *   org $ - 2
000016D9                    *   ret
000016DF                    *   @C0106:
000016DF                    *   leave
000016E0                    *   pop rbx
000016E1                    *   pop rdi
000016E2                    *   pop rsi
000016E3                    *   retn 
000016E4                        ExpandTMacro endp


                                ; rebuild a source line
                                ; adjust all "pos" values behind the current pos
                                ; - newstring = new value of item i
                                ; - i = token buffer index of item to replace
                                ; - outbuf = start of source line to rebuild
                                ; - oldlen = old length of item i
                                ; - pos_line = position of item in source line

000016E4                        RebuildLine proc fastcall private uses rsi rdi rbx newstring:string_t, i:int_t,tokenarray:token_t, oldlen:uint_t, pos_line:uint_t, addbrackets:int_t

                                    local dest:string_t
                                    local src:string_t
                                    local newlen:uint_t
                                    local rest:uint_t
                                    local buffer:ptr char_t

000016E4                    *   mov [rsp+8], rcx
000016E9                    *   mov [rsp+16], rdx
000016EE                    *   mov [rsp+24], r8
000016F3                    *   mov [rsp+32], r9
000016F8                    *   push rsi
000016F9                    *   push rdi
000016FA                    *   push rbx
000016FB                    *   push rbp
000016FC                    *   mov rbp, rsp
000016FF                    *   sub rsp, 72
00001703                            mov buffer,alloca(ModuleInfo.max_line_len)
00001703                    *   invoke alloca, ModuleInfo.max_line_len
00001703                    *   mov eax, ModuleInfo.max_line_len
00001709                    *1  add     eax,16-1
0000170C                    *1  and     eax,-16
0000170F                    *1  sub     rsp,rax
00001712                    *1  lea     rax,[rsp+@ReservedStack]
00001717                    *   mov buffer, rax
0000171B                            imul ebx,i,asm_tok
0000171F                            add rbx,tokenarray

00001723                            mov esi,oldlen
00001726                            add rsi,[rbx].tokpos
0000172A                            inc tstrlen( rsi )
0000172A                    *   invoke tstrlen, rsi 
0000172A                    *    mov rcx, rsi 
0000172D                    *    call tstrlen
00001732                    *   inc  rax
00001735                            mov rest,eax
00001738                            mov rdi,buffer
0000173C                            mov ecx,eax
0000173E                            rep movsb ; save content of line behind item

00001740                            mov rdi,[rbx].tokpos
00001744                            mov newlen,tstrlen( newstring )
00001744                    *   invoke tstrlen, newstring 
00001744                    *    mov rcx, newstring 
00001748                    *    call tstrlen
0000174D                    *   mov newlen, eax

00001750                            .if ( addbrackets )
00001750                    *   cmp ( addbrackets ), 0
00001754                    *   jz  @C0112

00001756                                add newlen,2 ; count '<' and '>'

0000175A                                .for ( rsi = newstring, al = [rsi] : al : rsi++, al = [rsi] )
0000175A                    *   mov rsi, newstring
0000175E                    *   mov al, [rsi]
00001760                    *   @C0113:
00001760                    *   test al, al
00001762                    *   jz  @C0115

00001764                                    .if ( al == '<' || al == '>' || al == '!' ) ; count '!' operator
00001764                    *   cmp al , '<' 
00001766                    *   jz  @C0117
00001768                    *   @C0118:
00001768                    *   cmp al , '>' 
0000176A                    *   jz  @C0117
0000176C                    *   @C0119:
0000176C                    *   cmp al , '!' 
0000176E                    *   jnz @C0116
00001770                    *   @C0117:
00001770                                        inc newlen
00001773                                    .endif
00001773                    *   @C0116:
00001773                                .endf
00001773                    *   @C0114:
00001773                    *   inc rsi
00001776                    *   mov al, [rsi]
00001778                    *   jmp @C0113
0000177A                    *   @C0115:
0000177A                            .endif
0000177A                    *   @C0112:

0000177A                            .if ( newlen > oldlen )
0000177A                    *   cmp newlen , oldlen 
0000177A                    *    mov eax,  oldlen 
0000177D                    *    cmp newlen , eax
00001780                    *   jna @C011A

00001782                                mov eax,pos_line
00001785                                add eax,newlen
00001788                                sub eax,oldlen
0000178B                                add eax,rest
0000178E                                .if ( eax >= ModuleInfo.max_line_len )
0000178E                    *   cmp eax , ModuleInfo.max_line_len 
00001794                    *   jb  @C011B
00001796                                    .return asmerr( 2039 )
00001796                    *   invoke asmerr, 2039 
00001796                    *    mov ecx, 2039 
0000179B                    *    call asmerr
000017A0                    *   jmp @C011C
000017A2                                .endif
000017A2                    *   @C011B:
000017A2                            .endif
000017A2                    *   @C011A:

000017A2                            .if ( addbrackets )
000017A2                    *   cmp ( addbrackets ), 0
000017A6                    *   jz  @C011D

000017A8                                mov byte ptr [rdi],'<'
000017AB                                inc rdi

000017AE                                .for ( rsi = newstring: byte ptr [rsi] : rsi++ )
000017AE                    *   mov rsi, newstring
000017B2                    *   @C011E:
000017B2                    *   cmp byte ptr [rsi], 0
000017B5                    *   jz  @C0120

000017B7                                    mov al,[rsi]
000017B9                                    .if ( al == '<' || al == '>' || al == '!' )
000017B9                    *   cmp al , '<' 
000017BB                    *   jz  @C0122
000017BD                    *   @C0123:
000017BD                    *   cmp al , '>' 
000017BF                    *   jz  @C0122
000017C1                    *   @C0124:
000017C1                    *   cmp al , '!' 
000017C3                    *   jnz @C0121
000017C5                    *   @C0122:
000017C5                                        mov byte ptr [rdi],'!'
000017C8                                        inc rdi
000017CB                                    .endif
000017CB                    *   @C0121:
000017CB                                    mov [rdi],al
000017CD                                    inc rdi
000017D0                                .endf
000017D0                    *   @C011F:
000017D0                    *   inc rsi
000017D3                    *   jmp @C011E
000017D5                    *   @C0120:
000017D5                                mov byte ptr [rdi],'>'
000017D8                                inc rdi
000017DB                            .else
000017DB                    *   jmp @C0125
000017DD                    *   @C011D:
000017DD                                mov ecx,newlen
000017E0                                mov rsi,newstring
000017E4                                rep movsb
000017E6                            .endif
000017E6                    *   @C0125:

000017E6                            mov ecx,rest
000017E9                            mov rsi,buffer
000017ED                            rep movsb ; add rest of line

                                    ; v2.05: changed '<' to '<='

000017EF                            .for ( ecx = i, ecx++,rbx += asm_tok,eax = oldlen,edx = newlen : ecx <= ModuleInfo.token_count : ecx++, rbx += asm_tok )
000017EF                    *   mov ecx, i
000017F2                    *   inc ecx
000017F4                    *   add rbx, asm_tok
000017F8                    *   mov eax, oldlen
000017FB                    *   mov edx, newlen
000017FE                    *   @C0126:
000017FE                    *   cmp ecx , ModuleInfo.token_count
00001804                    *   jg  @C0128

00001806                                sub [rbx].tokpos,rax
0000180A                                add [rbx].tokpos,rdx
0000180E                            .endf
0000180E                    *   @C0127:
0000180E                    *   inc ecx
00001810                    *   add rbx, asm_tok
00001814                    *   jmp @C0126
00001816                    *   @C0128:
00001816                            .return( NOT_ERROR )
00001816                    *   xor eax,eax
00001818                    *   jmp @C011C

                            *   org $ - 2
00001818                    *   ret
00001818                    *   @C011C:
00001818                    *   leave
00001819                    *   pop rbx
0000181A                    *   pop rdi
0000181B                    *   pop rsi
0000181C                    *   retn 
0000181D                        RebuildLine endp


                                ; expand one token
                                ; line: full source line
                                ; *pi: index of token in tokenarray
                                ; equmode: if 1, dont expand macro functions

0000181D                        ExpandToken proc fastcall private uses rsi rdi rbx line:string_t, pi:ptr int_t, tokenarray:token_t,max:int_t, bracket_flags:int_t, equmode:int_t, buffer:ptr char_t

                                    local pos:int_t
                                    local i2:int_t
                                    local i:int_t
                                    local size:int_t
                                    local addbrackets:int_t
                                    local evaluate:char_t
                                    local is_exitm:int_t
                                    local opndx:expr
                                    local rc:int_t
                                    local old_tokencount:int_t

0000181D                    *   mov [rsp+8], rcx
00001822                    *   mov [rsp+16], rdx
00001827                    *   mov [rsp+24], r8
0000182C                    *   mov [rsp+32], r9
00001831                    *   push rsi
00001832                    *   push rdi
00001833                    *   push rbx
00001834                    *   push rbp
00001835                    *   mov rbp, rsp
00001838                    *   sub rsp, 168
0000183F                            mov rdx,pi
00001843                            mov i,[rdx]
00001843                    *    mov eax, [rdx]
00001845                    *    mov i, eax
00001848                            mov addbrackets,bracket_flags
00001848                    *    mov eax, bracket_flags
0000184B                    *    mov addbrackets, eax
0000184E                            mov evaluate,FALSE
00001852                            mov rc,NOT_ERROR

0000185C                            .for ( : i < max : i++ )
0000185C                    *   @C0129:
0000185C                    *   cmp i , max
0000185C                    *    mov eax,  max
0000185F                    *    cmp i , eax
00001862                    *   jnl @C012B

00001864                                imul ebx,i,asm_tok
00001868                                add rbx,tokenarray

0000186C                                .break .if ( [rbx].token == T_COMMA )
0000186C                    *   cmp [rbx].token , T_COMMA 
0000186F                    *   jz  @C012B

                                        ; v2.05: the '%' should only be handled as an operator if addbrackets==TRUE,
                                        ; which means that the current directive is a preprocessor directive and the
                                        ; expected argument is a literal (or text macro).

00001871                                .if ( [rbx].token == T_PERCENT && addbrackets && evaluate == FALSE )
00001871                    *   cmp [rbx].token , T_PERCENT 
00001874                    *   jnz @C012C
00001876                    *   cmp addbrackets , 0
0000187A                    *   jz  @C012C
0000187C                    *   cmp evaluate , FALSE 
00001880                    *   jnz @C012C

00001882                                    mov evaluate,TRUE
00001886                                    mov addbrackets,FALSE
0000188D                                    mov equmode,FALSE
00001894                                    mov pos,i
00001894                    *    mov eax, i
00001897                    *    mov pos, eax
0000189A                                   .continue
0000189A                    *    jmp @C012A
0000189C                                .endif
0000189C                    *   @C012C:

0000189C                                .if ( [rbx].token == T_ID )
0000189C                    *   cmp [rbx].token , T_ID 
0000189F                    *   jnz @C012D

000018A1                                    mov rsi,SymFind([rbx].string_ptr)
000018A1                    *   invoke SymFind, [rbx].string_ptr
000018A1                    *    mov rcx, [rbx].string_ptr
000018A5                    *    call SymFind
000018AA                    *   mov rsi, rax

                                            ; don't check isdefined flag (which cannot occur in pass one, and this code usually runs
                                            ; in pass one only!

000018AD                                    .if ( rsi )
000018AD                    *   test ( rsi ), ( rsi )
000018B0                    *   jz  @C012E

000018B2                                        .if ( [rsi].asym.state == SYM_MACRO )
000018B2                    *   cmp [rsi].asym.state , SYM_MACRO 
000018B6                    *   jnz @C012F

000018B8                                            mov ecx,i
000018BB                                            mov edi,ecx ;; save index of macro name

000018BD                                            .if ( [rsi].asym.mac_flag & M_ISFUNC )
000018BD                    *   test [rsi].asym.mac_flag , M_ISFUNC 
000018C1                    *   je  @C0130

                                                        ; ignore macro functions without a following '('

000018C3                                                .continue .if ( [rbx+asm_tok].token != T_OP_BRACKET )
000018C3                    *   cmp [rbx+asm_tok].token , T_OP_BRACKET 
000018C7                    *   jnz @C012A

000018C9                                                inc i
000018CC                                                add rbx,asm_tok

000018D0                                                .if ( equmode == TRUE )
000018D0                    *   cmp equmode , TRUE 
000018D4                    *   jnz @C0131

000018D6                                                    inc i ; skip '('
000018D9                                                    add rbx,asm_tok

                                                            ; go beyond the ')'

000018DD                                                    .for ( ecx = 1: i < max: i++, rbx += asm_tok )
000018DD                    *   mov ecx, 1
000018E2                    *   @C0132:
000018E2                    *   cmp i , max
000018E2                    *    mov eax,  max
000018E5                    *    cmp i , eax
000018E8                    *   jnl @C0134
000018EA                                                        .if ( [rbx].token == T_OP_BRACKET )
000018EA                    *   cmp [rbx].token , T_OP_BRACKET 
000018ED                    *   jnz @C0135
000018EF                                                            inc ecx
000018F1                                                        .elseif ( [rbx].token == T_CL_BRACKET )
000018F1                    *   jmp @C0136
000018F3                    *   @C0135:
000018F3                    *   cmp [rbx].token , T_CL_BRACKET 
000018F6                    *   jnz @C0137
000018F8                                                            dec ecx
000018FA                                                            .break .ifz
000018FA                    *   je  @C0134
000018FC                                                        .endif
000018FC                    *   @C0137:
000018FC                    *   @C0136:
000018FC                                                    .endf
000018FC                    *   @C0133:
000018FC                    *   inc i
000018FF                    *   add rbx, asm_tok
00001903                    *   jmp @C0132
00001905                    *   @C0134:
00001905                                                    dec i
00001908                                                    sub rbx,asm_tok
0000190C                                                   .continue
0000190C                    *    jmp @C012A
0000190E                                                .endif
0000190E                    *   @C0131:

0000190E                                                xor edx,edx
00001910                                                .if edi == 1
00001910                    *   cmp edi , 1
00001913                    *   jnz @C0138
00001915                                                    mov edx,MF_LABEL
0000191A                                                .endif
0000191A                    *   @C0138:

0000191A                                                mov i,RunMacro( rsi, i, tokenarray, buffer, edx, &is_exitm )
0000191A                    *   invoke RunMacro, rsi, i, tokenarray, buffer, edx, addr is_exitm 
0000191A                    *    lea rax, is_exitm 
0000191E                    *    mov [rsp+40], rax
00001923                    *    mov [rsp+32], edx
00001927                    *    mov r9, buffer
0000192B                    *    mov r8, tokenarray
0000192F                    *    mov edx, i
00001932                    *    mov rcx, rsi
00001935                    *    call RunMacro
0000193A                    *   mov i, eax
0000193D                                                .return .if ( eax == -1 )
0000193D                    *   cmp eax , -1 
00001940                    *   jz  @C0139

00001942                                                imul ebx,i,asm_tok
00001946                                                add rbx,tokenarray

                                                        ; expand text, but don't if macro was at position 0 (might be a text macro definition directive
                                                        ; v2.09: don't expand further if addbrackets is set

0000194A                                                .if edi && !addbrackets
0000194A                    *   test edi , edi 
0000194C                    *   jz  @C013A
0000194E                    *   cmp addbrackets, 0
00001952                    *   jnz @C013A
00001954                                                    .return .ifd ExpandTMacro( buffer, tokenarray, equmode, 0 ) == ERROR
00001954                    *   invoke ExpandTMacro, buffer, tokenarray, equmode, 0 
00001954                    *    xor r9d, r9d
00001957                    *    mov r8d, equmode
0000195B                    *    mov rdx, tokenarray
0000195F                    *    mov rcx, buffer
00001963                    *    call ExpandTMacro
00001968                    *   cmp eax , ERROR
0000196B                    *   jz  @C0139
0000196D                                                .endif
0000196D                    *   @C013A:

                                                        ; get size of string to replace ( must be done before AddTokens()

0000196D                                                imul ecx,edi,asm_tok
00001970                                                mov rax,[rbx-asm_tok].tokpos
00001974                                                inc rax
00001977                                                add rcx,tokenarray
0000197B                                                sub rax,[rcx].asm_tok.tokpos
0000197F                                                mov size,eax
00001982                                                mov edx,edi
00001984                                                inc edx
00001986                                                mov ecx,edx
00001988                                                sub ecx,i
0000198B                    *   invoke AddTokens, tokenarray, edx, ecx, ModuleInfo.token_count 
0000198B                    *    mov r9d, ModuleInfo.token_count 
00001992                    *    mov r8d, ecx
00001995                    *    mov rcx, tokenarray
00001999                    *    call AddTokens
                                invoke AddTokens( tokenarray, edx, ecx, ModuleInfo.token_count )

0000199E                                                mov eax,edi
000019A0                                                inc eax
000019A2                                                sub eax,i
000019A5                                                add ModuleInfo.token_count,eax
000019AB                                                .if ( ModuleInfo.token_count < max ) ; take care not to read beyond T_FINAL
000019AB                    *   cmp ModuleInfo.token_count , max 
000019AB                    *    mov eax,  max 
000019AE                    *    cmp ModuleInfo.token_count , eax
000019B4                    *   jnl @C013B
000019B6                                                    mov max,ModuleInfo.token_count
000019B6                    *    mov eax, ModuleInfo.token_count
000019BC                    *    mov max, eax
000019BF                                                .endif
000019BF                    *   @C013B:
000019BF                                                imul ecx,edi,asm_tok
000019C2                                                add rcx,tokenarray
000019C6                                                mov rdx,[rcx].asm_tok.tokpos
000019CA                                                sub rdx,line
000019CE                                                .return .ifd RebuildLine( buffer, edi, tokenarray, size, edx, addbrackets ) == ERROR
000019CE                    *   invoke RebuildLine, buffer, edi, tokenarray, size, edx, addbrackets 
000019CE                    *    mov eax, addbrackets 
000019D1                    *    mov [rsp+40], eax
000019D5                    *    mov [rsp+32], edx
000019D9                    *    mov r9d, size
000019DD                    *    mov r8, tokenarray
000019E1                    *    mov edx, edi
000019E3                    *    mov rcx, buffer
000019E7                    *    call RebuildLine
000019EC                    *   cmp eax , ERROR
000019EF                    *   jz  @C0139
000019F1                                                mov rc,STRING_EXPANDED
000019FB                                                mov i,edi

000019FE                                            .else
000019FE                    *   jmp @C013C
00001A04                    *   @C0130:

                                                        ; a macro proc is expanded at pos 0 or pos 2
                                                        ; (or at pos 1 if sym->label is on)

00001A04                                                mov edx,i
00001A07                                                mov rcx,tokenarray
00001A0B                                                .if ( edx == 0 || ( edx == 2 && ( [rcx+asm_tok].asm_tok.token == T_COLON ||[rcx+asm_tok].asm_tok.token == T_DBL_COLON ) ) ||( edx == 1 && [rsi].asym.mac_flag & M_LABEL ) )
00001A0B                    *   test edx , edx 
00001A0D                    *   jz  @C013E
00001A0F                    *   @C013F:
00001A0F                    *   cmp edx , 2 
00001A12                    *   jnz @C0142
00001A14                    *   cmp [rcx+asm_tok].asm_tok.token , T_COLON 
00001A18                    *   jz  @C013E
00001A1A                    *   @C0141:
00001A1A                    *   cmp [rcx+asm_tok].asm_tok.token , T_DBL_COLON 
00001A1E                    *   jz  @C013E
00001A20                    *   @C0142:
00001A20                    *   cmp edx , 1 
00001A23                    *   jnz @C013D
00001A25                    *   test [rsi].asym.mac_flag , M_LABEL 
00001A29                    *   je  @C013D
00001A2B                    *   @C013E:
00001A2B                                                .else
00001A2B                    *   jmp @C0143
00001A2D                    *   @C013D:
00001A2D                                                    .continue
00001A2D                    *    jmp @C012A
00001A2F                                                .endif
00001A2F                    *   @C0143:

                                                        ; v2.08: write optional code label. This has been
                                                        ; moved out from RunMacro().

00001A2F                                                .if ( edx == 2 )
00001A2F                    *   cmp edx , 2 
00001A32                    *   jnz @C0144
00001A34                                                    .return .ifd WriteCodeLabel( line, tokenarray ) == ERROR
00001A34                    *   invoke WriteCodeLabel, line, tokenarray 
00001A34                    *    mov rdx, tokenarray 
00001A38                    *    mov rcx, line
00001A3C                    *    call WriteCodeLabel
00001A41                    *   cmp eax , ERROR
00001A44                    *   jz  @C0139
00001A46                                                    mov edx,i
00001A49                                                .endif
00001A49                    *   @C0144:

00001A49                                                mov ecx,MF_NOSAVE
00001A4E                                                .if ( edx == 1 )
00001A4E                    *   cmp edx , 1 
00001A51                    *   jnz @C0145
00001A53                                                    or ecx,MF_LABEL
00001A56                                                .endif
00001A56                    *   @C0145:
00001A56                                                inc edx

00001A58                                                .ifd ( RunMacro( rsi, edx, tokenarray, NULL, ecx, &is_exitm ) == -1 )
00001A58                    *   invoke RunMacro, rsi, edx, tokenarray, NULL, ecx, addr is_exitm 
00001A58                    *    lea rax, is_exitm 
00001A5C                    *    mov [rsp+40], rax
00001A61                    *    mov [rsp+32], ecx
00001A65                    *    xor r9d, r9d
00001A68                    *    mov r8, tokenarray
00001A6C                    *    mov rcx, rsi
00001A6F                    *    call RunMacro
00001A74                    *   cmp eax , -1 
00001A77                    *   jnz @C0146
00001A79                                                    .return
00001A79                    *   jmp @C0139
00001A7B                                                .endif
00001A7B                    *   @C0146:
00001A7B                                                .return EMPTY ; no further processing
00001A7B                    *   mov rax,EMPTY
00001A82                    *   jmp @C0139
00001A84                                            .endif
00001A87                    *   @C013C:

00001A87                                        .elseif ( [rsi].asym.state == SYM_TMACRO )
00001A87                    *   jmp @C0147
00001A8D                    *   @C012F:
00001A8D                    *   cmp [rsi].asym.state , SYM_TMACRO 
00001A91                    *   jnz @C0148

00001A93                                            .if ( [rbx-asm_tok].token == T_DOT )
00001A93                    *   cmp [rbx-asm_tok].token , T_DOT 
00001A97                    *   jnz @C0149

                                                        ; v2.34.01 - Name conflict with register param and stuct members
                                                        ;
                                                        ; This apply to SYSCALL-64, WATCALL-32, and FASTCALL-32
                                                        ;

00001A99                                                mov ecx,i
00001A9C                                                sub ecx,2
00001A9F                                                lea rdx,[rbx-asm_tok*2]

                                                        ; [reg].type.name

00001AA3                                                .while ( [rdx-asm_tok].asm_tok.token == T_DOT )
00001AA3                    *   jmp @C014B
00001AA5                    *   @C014A:

00001AA5                                                    sub ecx,2
00001AA8                                                    lea rdx,[rdx-asm_tok*2]
00001AAC                                                .endw
00001AAC                    *   @C014B:
00001AAC                    *   cmp [rdx-asm_tok].asm_tok.token , T_DOT 
00001AB0                    *   jz  @C014A

00001AB2                                                .if ( [rdx].asm_tok.token == T_CL_SQ_BRACKET )
00001AB2                    *   cmp [rdx].asm_tok.token , T_CL_SQ_BRACKET 
00001AB5                    *   jnz @C014C

00001AB7                                                    .for ( eax = 0 : rdx > tokenarray : rdx -= asm_tok, ecx-- )
00001AB7                    *   xor eax, eax
00001AB9                    *   @C014D:
00001AB9                    *   cmp rdx , tokenarray
00001ABD                    *   jna @C014F

00001ABF                                                        .if ( [rdx].asm_tok.token == T_OP_SQ_BRACKET )
00001ABF                    *   cmp [rdx].asm_tok.token , T_OP_SQ_BRACKET 
00001AC2                    *   jnz @C0150
00001AC4                                                            dec eax
00001AC6                                                           .break .ifz
00001AC6                    *   je  @C014F
00001AC8                                                        .elseif ( [rdx].asm_tok.token == T_CL_SQ_BRACKET )
00001AC8                    *   jmp @C0151
00001ACA                    *   @C0150:
00001ACA                    *   cmp [rdx].asm_tok.token , T_CL_SQ_BRACKET 
00001ACD                    *   jnz @C0152
00001ACF                                                            inc eax
00001AD1                                                        .endif
00001AD1                    *   @C0152:
00001AD1                    *   @C0151:
00001AD1                                                    .endf
00001AD1                    *   @C014E:
00001AD1                    *   sub rdx, asm_tok
00001AD5                    *   dec ecx
00001AD7                    *   jmp @C014D
00001AD9                    *   @C014F:
00001AD9                                                .endif
00001AD9                    *   @C014C:

00001AD9                                                mov i2,ecx
00001ADC                                                .ifd ( EvalOperand( &i2, tokenarray, ModuleInfo.token_count, &opndx, EXPF_NOERRMSG ) != ERROR )
00001ADC                    *   invoke EvalOperand, addr i2, tokenarray, ModuleInfo.token_count, addr opndx, EXPF_NOERRMSG 
00001ADC                    *    mov byte ptr [rsp+32], EXPF_NOERRMSG 
00001AE1                    *    lea r9, opndx
00001AE5                    *    mov r8d, ModuleInfo.token_count
00001AEC                    *    mov rdx, tokenarray
00001AF0                    *    lea rcx, i2
00001AF4                    *    call EvalOperand
00001AF9                    *   cmp eax , ERROR 
00001AFC                    *   jz  @C0153

00001AFE                                                    .if ( opndx.kind == EXPR_ADDR && opndx.mbr )
00001AFE                    *   cmp opndx.kind , EXPR_ADDR 
00001B02                    *   jnz @C0154
00001B04                    *   cmp opndx.mbr , 0
00001B09                    *   jz  @C0154
00001B0B                                                        .continue
00001B0B                    *    jmp @C012A
00001B0D                                                    .endif
00001B0D                    *   @C0154:
00001B0D                                                .endif
00001B0D                    *   @C0153:
00001B0D                                            .endif
00001B0D                    *   @C0149:

00001B0D                    *   invoke tstrcpy, buffer, [rsi].asym.string_ptr 
00001B0D                    *    mov rdx, [rsi].asym.string_ptr 
00001B11                    *    mov rcx, buffer
00001B15                    *    call tstrcpy
                                invoke tstrcpy( buffer, [rsi].asym.string_ptr )
00001B1A                                            .ifd ( ExpandTMacro( buffer, tokenarray, equmode, 0 ) == ERROR )
00001B1A                    *   invoke ExpandTMacro, buffer, tokenarray, equmode, 0 
00001B1A                    *    xor r9d, r9d
00001B1D                    *    mov r8d, equmode
00001B21                    *    mov rdx, tokenarray
00001B25                    *    mov rcx, buffer
00001B29                    *    call ExpandTMacro
00001B2E                    *   cmp eax , ERROR 
00001B31                    *   jnz @C0155
00001B33                                                .return
00001B33                    *   jmp @C0139
00001B35                                            .endif
00001B35                    *   @C0155:

00001B35                                            mov edx,tstrlen( [rbx].string_ptr )
00001B35                    *   invoke tstrlen, [rbx].string_ptr 
00001B35                    *    mov rcx, [rbx].string_ptr 
00001B39                    *    call tstrlen
00001B3E                    *   mov edx, eax
00001B40                                            mov rcx,[rbx].tokpos
00001B44                                            sub rcx,line
00001B48                                            .ifd ( RebuildLine( buffer, i, tokenarray, edx, ecx, addbrackets ) == ERROR )
00001B48                    *   invoke RebuildLine, buffer, i, tokenarray, edx, ecx, addbrackets 
00001B48                    *    mov eax, addbrackets 
00001B4B                    *    mov [rsp+40], eax
00001B4F                    *    mov [rsp+32], ecx
00001B53                    *    mov r9d, edx
00001B56                    *    mov r8, tokenarray
00001B5A                    *    mov edx, i
00001B5D                    *    mov rcx, buffer
00001B61                    *    call RebuildLine
00001B66                    *   cmp eax , ERROR 
00001B69                    *   jnz @C0156
00001B6B                                                .return
00001B6B                    *   jmp @C0139
00001B6D                                            .endif
00001B6D                    *   @C0156:
00001B6D                                            mov rc,STRING_EXPANDED
00001B77                                        .endif
00001B7B                    *   @C0148:
00001B7E                    *   @C0147:
00001B7E                                    .endif
00001B82                    *   @C012E:
00001B82                                .endif
00001B86                    *   @C012D:
00001B86                            .endf
00001B93                    *   @C012A:
00001B93                    *   inc i
00001B96                    *   jmp @C0129
00001BA3                    *   @C012B:

00001BA3                            mov ecx,i
00001BA6                            mov rax,pi
00001BAA                            mov [rax],ecx

00001BAC                            .if ( evaluate )
00001BAC                    *   cmp ( evaluate ), 0
00001BB0                    *   jz  @C0157

00001BB2                                mov old_tokencount,ModuleInfo.token_count
00001BB2                    *    mov eax, ModuleInfo.token_count
00001BB8                    *    mov old_tokencount, eax
00001BBE                                mov rbx,tokenarray
00001BC2                                mov edx,pos
00001BC5                                lea rax,[rdx+1]

00001BC9                                .if ( eax == i ) ; just a single %?
00001BC9                    *   cmp eax , i 
00001BCC                    *   jnz @C0158

00001BCE                                    mov opndx.value,0
00001BD5                                    mov i,edx

00001BD8                                .else
00001BD8                    *   jmp @C0159
00001BDA                    *   @C0158:

00001BDA                                    mov i,edx
00001BDD                                    inc edx
00001BDF                                    imul ecx,ecx,asm_tok
00001BE2                                    imul edx,edx,asm_tok
00001BE5                                    mov rcx,[rbx+rcx].tokpos
00001BEA                                    mov rsi,[rbx+rdx].tokpos
00001BEF                                    mov rdi,buffer
00001BF3                                    sub rcx,rsi
00001BF6                                    rep movsb
00001BF8                                    mov byte ptr [rdi],0
00001BFB                                    mov edi,old_tokencount
00001C01                                    inc edi
00001C03                                    mov ModuleInfo.token_count,Tokenize( buffer, edi, tokenarray, TOK_RESCAN )
00001C03                    *   invoke Tokenize, buffer, edi, tokenarray, TOK_RESCAN 
00001C03                    *    mov r9d, TOK_RESCAN 
00001C09                    *    mov r8, tokenarray
00001C0D                    *    mov edx, edi
00001C0F                    *    mov rcx, buffer
00001C13                    *    call Tokenize
00001C18                    *   mov ModuleInfo.token_count, eax

00001C1E                                    mov i2,edi
00001C21                                    .ifd EvalOperand( &i2, tokenarray, ModuleInfo.token_count, &opndx, EXPF_NOUNDEF ) == ERROR
00001C21                    *   invoke EvalOperand, addr i2, tokenarray, ModuleInfo.token_count, addr opndx, EXPF_NOUNDEF 
00001C21                    *    mov byte ptr [rsp+32], EXPF_NOUNDEF 
00001C26                    *    lea r9, opndx
00001C2A                    *    mov r8d, ModuleInfo.token_count
00001C31                    *    mov rdx, tokenarray
00001C35                    *    lea rcx, i2
00001C39                    *    call EvalOperand
00001C3E                    *   cmp eax , ERROR
00001C41                    *   jnz @C015A
00001C43                                        mov opndx.value,0 ; v2.09: assume value 0, don't return with ERROR
00001C4A                                    .elseif opndx.kind != EXPR_CONST
00001C4A                    *   jmp @C015B
00001C4C                    *   @C015A:
00001C4C                    *   cmp opndx.kind , EXPR_CONST
00001C50                    *   jz  @C015C
00001C52                    *   invoke asmerr, 2026 
00001C52                    *    mov ecx, 2026 
00001C57                    *    call asmerr
                                invoke asmerr( 2026 )
00001C5C                                        mov opndx.value,0 ; assume value 0
00001C63                                    .endif
00001C63                    *   @C015C:
00001C63                    *   @C015B:
00001C63                                    mov ModuleInfo.token_count,old_tokencount
00001C63                    *    mov eax, old_tokencount
00001C69                    *    mov ModuleInfo.token_count, eax
00001C6F                                .endif
00001C72                    *   @C0159:

                                if TEVALUE_UNSIGNED

                                        ; v2.03: Masm compatible: returns an unsigned value

00001C72                                mov opndx.hvalue,0
00001C79                    *   invoke myltoa, opndx.llvalue, ModuleInfo.stringbufferend, ModuleInfo.radix, FALSE, FALSE 
00001C79                    *    mov dword ptr [rsp+32], FALSE 
00001C81                    *    xor r9d, r9d
00001C84                    *    movzx r8d, ModuleInfo.radix
00001C8C                    *    mov rdx, ModuleInfo.stringbufferend
00001C93                    *    mov rcx, opndx.llvalue
00001C97                    *    call myltoa
                                invoke myltoa( opndx.llvalue, ModuleInfo.stringbufferend, ModuleInfo.radix, FALSE, FALSE )

                                endif
                                        ; v2.05: get size of string to be "replaced"

00001C9C                                mov rsi,pi
00001CA0                                mov esi,[rsi]
00001CA2                                imul eax,esi,asm_tok
00001CA5                                imul edx,i,asm_tok
00001CA9                                mov rdi,[rbx+rax].tokpos
00001CAE                                sub rdi,[rbx+rdx].tokpos
00001CB3                                add rbx,rdx
00001CB6                                mov [rbx].string_ptr,ModuleInfo.stringbufferend
00001CB6                    *    mov rax, ModuleInfo.stringbufferend
00001CBD                    *    mov [rbx].string_ptr, rax
00001CC1                                mov eax,i
00001CC4                                inc eax
00001CC6                                mov edx,eax
00001CC8                                sub edx,esi
00001CCA                    *   invoke AddTokens, tokenarray, eax, edx, ModuleInfo.token_count 
00001CCA                    *    mov r9d, ModuleInfo.token_count 
00001CD1                    *    mov r8d, edx
00001CD4                    *    mov edx, eax
00001CD6                    *    mov rcx, tokenarray
00001CDA                    *    call AddTokens
                                invoke AddTokens( tokenarray, eax, edx, ModuleInfo.token_count )
00001CDF                                mov eax,i
00001CE2                                inc eax
00001CE4                                sub eax,esi
00001CE6                                add ModuleInfo.token_count,eax
00001CEC                                mov rcx,[rbx].tokpos
00001CF0                                sub rcx,line
00001CF4                                .return .ifd RebuildLine( ModuleInfo.stringbufferend, i, tokenarray, edi, ecx, bracket_flags ) == ERROR
00001CF4                    *   invoke RebuildLine, ModuleInfo.stringbufferend, i, tokenarray, edi, ecx, bracket_flags 
00001CF4                    *    mov eax, bracket_flags 
00001CF7                    *    mov [rsp+40], eax
00001CFB                    *    mov [rsp+32], ecx
00001CFF                    *    mov r9d, edi
00001D02                    *    mov r8, tokenarray
00001D06                    *    mov edx, i
00001D09                    *    mov rcx, ModuleInfo.stringbufferend
00001D10                    *    call RebuildLine
00001D15                    *   cmp eax , ERROR
00001D18                    *   jz  @C0139
00001D1A                                mov rc,STRING_EXPANDED
00001D24                            .endif
00001D28                    *   @C0157:
00001D28                            .return( rc )
00001D28                    *   mov eax,( rc )
00001D2E                    *   jmp @C0139

                            *   org $ - 2
00001D2E                    *   ret
00001D4A                    *   @C0139:
00001D4A                    *   leave
00001D4B                    *   pop rbx
00001D4C                    *   pop rdi
00001D4D                    *   pop rsi
00001D4E                    *   retn 
00001D4F                        ExpandToken endp


                                ; used by EQU ( may also be used by directives flagged with DF_NOEXPAND
                                ; if they have to partially expand their arguments ).
                                ; equmode: 1=don't expand macro functions

00001D4F                        ExpandLineItems proc fastcall uses rsi rdi line:string_t, i:int_t, tokenarray:token_t,addbrackets:int_t, equmode:int_t

                                  local k:int_t
                                  local buffer:string_t

00001D4F                    *   mov [rsp+8], rcx
00001D54                    *   mov [rsp+16], rdx
00001D59                    *   mov [rsp+24], r8
00001D5E                    *   mov [rsp+32], r9
00001D63                    *   push rsi
00001D64                    *   push rdi
00001D65                    *   push rbp
00001D66                    *   mov rbp, rsp
00001D69                    *   sub rsp, 48
00001D6D                            mov buffer,alloca(ModuleInfo.max_line_len)
00001D6D                    *   invoke alloca, ModuleInfo.max_line_len
00001D6D                    *   mov eax, ModuleInfo.max_line_len
00001D73                    *1  add     eax,16-1
00001D76                    *1  and     eax,-16
00001D79                    *1  sub     rsp,rax
00001D7C                    *1  lea     rax,[rsp+@ReservedStack]
00001D81                    *   mov buffer, rax

00001D85                            .for ( esi = 0 :: esi++ )
00001D85                    *   xor esi, esi
00001D87                    *   @C015D:

00001D87                                mov edi,NOT_ERROR
00001D8C                                .for ( k = i : k < ModuleInfo.token_count : )
00001D8C                    *   mov k, i
00001D8C                    *    mov eax,  i
00001D8F                    *    mov k, eax
00001D92                    *   @C0160:
00001D92                    *   cmp k , ModuleInfo.token_count
00001D92                    *    mov eax,  ModuleInfo.token_count
00001D98                    *    cmp k , eax
00001D9B                    *   jnl @C0162

00001D9D                    *   invoke ExpandToken, line, addr k, tokenarray, ModuleInfo.token_count, addbrackets, equmode, buffer
00001D9D                    *    mov rax, buffer
00001DA1                    *    mov [rsp+48], rax
00001DA6                    *    mov eax, equmode
00001DA9                    *    mov [rsp+40], eax
00001DAD                    *    mov eax, addbrackets
00001DB0                    *    mov [rsp+32], eax
00001DB4                    *    mov r9d, ModuleInfo.token_count
00001DBB                    *    mov r8, tokenarray
00001DBF                    *    lea rdx, k
00001DC3                    *    mov rcx, line
00001DC7                    *    call ExpandToken
                                invoke ExpandToken(line, &k, tokenarray, ModuleInfo.token_count, addbrackets, equmode, buffer)
00001DCC                                    .break(1) .if eax == ERROR
00001DCC                    *   cmp eax , ERROR
00001DCF                    *   jz  @C015F
00001DD1                                    .if eax == STRING_EXPANDED
00001DD1                    *   cmp eax , STRING_EXPANDED
00001DD4                    *   jnz @C0163
00001DD6                                        mov edi,eax
00001DD8                                    .endif
00001DD8                    *   @C0163:
00001DD8                                    imul eax,k,asm_tok
00001DDC                                    add rax,tokenarray
00001DE0                                    .if ( [rax].asm_tok.token == T_COMMA )
00001DE0                    *   cmp [rax].asm_tok.token , T_COMMA 
00001DE3                    *   jnz @C0164
00001DE5                                        inc k
00001DE8                                    .endif
00001DE8                    *   @C0164:
00001DE8                                .endf
00001DE8                    *   @C0161:
00001DE8                    *   jmp @C0160
00001DEA                    *   @C0162:
00001DEA                                .break .if edi == NOT_ERROR
00001DEA                    *   test edi , edi 
00001DEC                    *   jz  @C015F

                                        ; expansion happened, re-tokenize and continue!

00001DEE                                mov ModuleInfo.token_count,Tokenize( line, i, tokenarray, TOK_RESCAN )
00001DEE                    *   invoke Tokenize, line, i, tokenarray, TOK_RESCAN 
00001DEE                    *    mov r9d, TOK_RESCAN 
00001DF4                    *    mov r8, tokenarray
00001DF8                    *    mov edx, i
00001DFB                    *    mov rcx, line
00001DFF                    *    call Tokenize
00001E04                    *   mov ModuleInfo.token_count, eax

00001E0A                                .if esi == MAX_TEXTMACRO_NESTING
00001E0A                    *   cmp esi , MAX_TEXTMACRO_NESTING
00001E0D                    *   jnz @C0165

00001E0F                    *   invoke asmerr, 2123 
00001E0F                    *    mov ecx, 2123 
00001E14                    *    call asmerr
                                invoke asmerr( 2123 )
00001E19                                   .break
00001E19                    *    jmp @C015F
00001E1B                                .endif
00001E1B                    *   @C0165:
00001E1B                            .endf
00001E1B                    *   @C015E:
00001E1B                    *   inc esi
00001E1D                    *   jmp @C015D
00001E22                    *   @C015F:
00001E22                            .return esi
00001E22                    *   mov eax,esi
00001E24                    *   jmp @C0166

                            *   org $ - 2
00001E24                    *   ret
00001E24                    *   @C0166:
00001E24                    *   leave
00001E25                    *   pop rdi
00001E26                    *   pop rsi
00001E27                    *   retn 
00001E28                        ExpandLineItems endp


                                ; v2.09: added, expand literals for structured data items.
                                ; since 2.09, initialization of structure members is no longer
                                ; done by generated code, but more directly inside data.c.
                                ; This improves Masm-compatibility, but OTOH requires to expand
                                ; the literals explicitly.


00001E28                        ExpandLiterals proc fastcall uses rbx i:int_t, tokenarray:token_t

00001E28                    *   mov [rsp+8], rcx
00001E2D                    *   mov [rsp+16], rdx
00001E32                    *   push rbx
00001E33                    *   push rbp
00001E34                    *   mov rbp, rsp
00001E37                    *   sub rsp, 40
00001E3B                            xor eax,eax
00001E3D                            mov rbx,tokenarray

                                    ; count non-empty literals
00001E41                            .for ( : ecx < ModuleInfo.token_count: ecx++ )
00001E41                    *   @C0167:
00001E41                    *   cmp ecx , ModuleInfo.token_count
00001E47                    *   jnl @C0169

00001E49                                imul edx,ecx,asm_tok
00001E4C                                .if ( [rbx+rdx].token == T_STRING && [rbx+rdx].stringlen &&( [rbx+rdx].string_delim == '<' || [rbx+rdx].string_delim == '{' ) )
00001E4C                    *   cmp [rbx+rdx].token , T_STRING 
00001E50                    *   jnz @C016A
00001E52                    *   cmp [rbx+rdx].stringlen , 0
00001E57                    *   jz  @C016A
00001E59                    *   cmp [rbx+rdx].string_delim , '<' 
00001E5E                    *   jz  @C016B
00001E60                    *   @C016C:
00001E60                    *   cmp [rbx+rdx].string_delim , '{' 
00001E65                    *   jnz @C016A
00001E67                    *   @C016B:
00001E67                                    inc eax
00001E69                                .endif
00001E69                    *   @C016A:
00001E69                            .endf
00001E69                    *   @C0168:
00001E69                    *   inc ecx
00001E6B                    *   jmp @C0167
00001E6D                    *   @C0169:

                                    ; if non-empty literals are found, expand the line. if the line
                                    ; was expanded, re-tokenize it.

00001E6D                            .if ( eax )
00001E6D                    *   test ( eax ), ( eax )
00001E6F                    *   jz  @C016D

00001E71                                imul ecx,i,asm_tok
00001E75                                add rbx,rcx

00001E78                                .if ExpandText( [rbx].tokpos, tokenarray, FALSE ) == STRING_EXPANDED
00001E78                    *   invoke ExpandText, [rbx].tokpos, tokenarray, FALSE 
00001E78                    *    xor r8d, r8d
00001E7B                    *    mov rdx, tokenarray
00001E7F                    *    mov rcx, [rbx].tokpos
00001E83                    *    call ExpandText
00001E88                    *   cmp rax , STRING_EXPANDED
00001E8C                    *   jnz @C016E

00001E8E                    *   invoke Tokenize, [rbx].tokpos, i, tokenarray, TOK_RESCAN 
00001E8E                    *    mov r9d, TOK_RESCAN 
00001E94                    *    mov r8, tokenarray
00001E98                    *    mov edx, i
00001E9B                    *    mov rcx, [rbx].tokpos
00001E9F                    *    call Tokenize
                                invoke Tokenize( [rbx].tokpos, i, tokenarray, TOK_RESCAN )
00001EA4                                .endif
00001EA4                    *   @C016E:
00001EA4                            .endif
00001EA4                    *   @C016D:
00001EA4                            ret
00001EA4                    *   leave
00001EA5                    *   pop rbx
00001EA6                    *   retn 

00001EA7                        ExpandLiterals endp


00001EA7                        ExpandProc proc fastcall private string:string_t, buffer:string_t

00001EA7                    *   mov [rsp+8], rcx
00001EAC                    *   mov [rsp+16], rdx
00001EB1                    *   push rbp
00001EB2                    *   mov rbp, rsp
00001EB5                    *   sub rsp, 32
00000000                        .data
                            *   _TEXT ends
00000017                    *   _DATA segment
                            *   assume cs:ERROR
00000017                         DS0003 sbyte "invoke ",0
00000000                        .code
                            *   _DATA ends
00001EB9                    *   _TEXT segment
                            *   assume cs:FLAT
00001EB9                            lea rsi,DS0003
00001EC0                    *   invoke SymFind, [rbx].string_ptr
00001EC0                    *    mov rcx, [rbx].string_ptr
00001EC4                    *    call SymFind
                                invoke SymFind([rbx].string_ptr)
00001EC9                            .if ( rax && [rax].asym.state == SYM_TYPE )
00001EC9                    *   test rax , rax 
00001ECC                    *   jz  @C016F
00001ECE                    *   cmp [rax].asym.state , SYM_TYPE 
00001ED2                    *   jnz @C016F
00000000                        .data
                            *   _TEXT ends
0000001F                    *   _DATA segment
                            *   assume cs:ERROR
0000001F                         DS0004 sbyte ".new ",0
00000000                        .code
                            *   _DATA ends
00001ED4                    *   _TEXT segment
                            *   assume cs:FLAT
00001ED4                                lea rsi,DS0004
00001EDB                            .endif
00001EDB                    *   @C016F:
00001EDB                    *   invoke tstrcpy, buffer, rsi 
00001EDB                    *    mov rdx, rsi 
00001EDE                    *    mov rcx, buffer
00001EE2                    *    call tstrcpy
00001EE7                    *   invoke tstrcat, rax , [rbx].tokpos 
00001EE7                    *    mov rdx, [rbx].tokpos 
00001EEB                    *    mov rcx, rax 
00001EEE                    *    call tstrcat
                                invoke tstrcat( tstrcpy( buffer, rsi ), [rbx].tokpos )
00001EF3                            mov ModuleInfo.token_count,Tokenize( tstrcpy( string, buffer ), 0, rbx, TOK_DEFAULT )
00001EF3                    *   invoke tstrcpy, string, buffer 
00001EF3                    *    mov rdx, buffer 
00001EF7                    *    mov rcx, string
00001EFB                    *    call tstrcpy
00001F00                    *   invoke Tokenize, rax , 0, rbx, TOK_DEFAULT 
00001F00                    *    xor r9d, r9d
00001F03                    *    mov r8, rbx
00001F06                    *    xor edx, edx
00001F08                    *    mov rcx, rax 
00001F0B                    *    call Tokenize
00001F10                    *   mov ModuleInfo.token_count, eax
00001F16                            ret
00001F16                    *   leave
00001F17                    *   retn 

00001F18                        ExpandProc endp

                                ; scan current line for (text) macros and expand them.
                                ; this is only called when the % operator is not the first item.

00001F18                        ExpandLine proc fastcall uses rsi rdi rbx string:string_t, tokenarray:token_t

                                  local count         : int_t
                                  local bracket_flags : uint_t
                                  local flags         : int_t
                                  local lvl           : int_t
                                  local rc            : int_t
                                  local addbrackets   : int_t
                                  local buffer        : string_t

00001F18                    *   mov [rsp+8], rcx
00001F1D                    *   mov [rsp+16], rdx
00001F22                    *   push rsi
00001F23                    *   push rdi
00001F24                    *   push rbx
00001F25                    *   push rbp
00001F26                    *   mov rbp, rsp
00001F29                    *   sub rsp, 72
00001F2D                            mov buffer,alloca(ModuleInfo.max_line_len)
00001F2D                    *   invoke alloca, ModuleInfo.max_line_len
00001F2D                    *   mov eax, ModuleInfo.max_line_len
00001F33                    *1  add     eax,16-1
00001F36                    *1  and     eax,-16
00001F39                    *1  sub     rsp,rax
00001F3C                    *1  lea     rax,[rsp+@ReservedStack]
00001F41                    *   mov buffer, rax
                                    ;
                                    ; filter certain conditions.
                                    ; bracket_flags: for (preprocessor) directives that expect a literal
                                    ; parameter, the expanded argument has to be enclosed in '<>' again.
                                    ;
00001F45                            .for ( lvl = 0: lvl < MAX_TEXTMACRO_NESTING: lvl++ )
00001F45                    *   mov lvl, 0
00001F4C                    *   @C0170:
00001F4C                    *   cmp lvl , MAX_TEXTMACRO_NESTING
00001F50                    *   jnl @C0172

00001F52                                xor esi,esi
00001F54                                mov bracket_flags,esi
00001F57                                mov count,esi
00001F5A                                mov rc,esi
00001F5D                                mov rbx,tokenarray

00001F61                                .if ( ModuleInfo.token_count > 2 )
00001F61                    *   cmp ModuleInfo.token_count , 2 
00001F68                    *   jng @C0173

00001F6A                                    .if ( [rbx+asm_tok].token == T_COLON || [rbx+asm_tok].token == T_DBL_COLON )
00001F6A                    *   cmp [rbx+asm_tok].token , T_COLON 
00001F6E                    *   jz  @C0175
00001F70                    *   @C0176:
00001F70                    *   cmp [rbx+asm_tok].token , T_DBL_COLON 
00001F74                    *   jnz @C0174
00001F76                    *   @C0175:

                                                ; no expansion right of label:[:]

00001F76                                        .if ( [rbx].token != T_ID ||[rbx+asm_tok].token == T_COLON ||[rbx+asm_tok*2].token != T_ID )
00001F76                    *   cmp [rbx].token , T_ID 
00001F79                    *   jnz @C0178
00001F7B                    *   @C0179:
00001F7B                    *   cmp [rbx+asm_tok].token , T_COLON 
00001F7F                    *   jz  @C0178
00001F81                    *   @C017A:
00001F81                    *   cmp [rbx+asm_tok*2].token , T_ID 
00001F85                    *   jz  @C0177
00001F87                    *   @C0178:
00001F87                                            .return 0
00001F87                    *   xor eax,eax
00001F89                    *   jmp @C017B
00001F8B                                        .endif
00001F8B                    *   @C0177:

00001F8B                                        .if ( SymFind( [rbx+asm_tok*2].string_ptr ) )
00001F8B                    *   invoke SymFind, [rbx+asm_tok*2].string_ptr 
00001F8B                    *    mov rcx, [rbx+asm_tok*2].string_ptr 
00001F8F                    *    call SymFind
00001F94                    *   test (  rax ), (  rax )
00001F97                    *   jz  @C017C
00001F99                                            .if ( [rax].asym.state == SYM_MACRO )
00001F99                    *   cmp [rax].asym.state , SYM_MACRO 
00001F9D                    *   jnz @C017D
00001F9F                                                .return 0
00001F9F                    *   xor eax,eax
00001FA1                    *   jmp @C017B
00001FA3                                            .endif
00001FA3                    *   @C017D:
00001FA3                                        .endif
00001FA3                    *   @C017C:
00001FA3                                        .if ( [rbx+asm_tok*2].token == T_DIRECTIVE )
00001FA3                    *   cmp [rbx+asm_tok*2].token , T_DIRECTIVE 
00001FA7                    *   jnz @C017E
00001FA9                                            add rbx,asm_tok*2
00001FAD                                        .endif
00001FAD                    *   @C017E:
00001FAD                                    .endif
00001FAD                    *   @C0174:
00001FAD                                .endif
00001FAD                    *   @C0173:

00001FAD                                mov rdx,tokenarray
00001FB1                                .if ( [rbx].token == T_DIRECTIVE )
00001FB1                    *   cmp [rbx].token , T_DIRECTIVE 
00001FB4                    *   jnz @C017F

00001FB6                     1  	 lea  r11,SpecialTable
00001FBD                     1  	 imul eax,[rbx].tokval,special_item
00001FC1                                    mov flags,[r11+rax].special_item.value
00001FC1                    *    mov eax, [r11+rax].special_item.value
00001FC5                    *    mov flags, eax
00001FC8                                    .if ( eax & DF_STRPARM )
00001FC8                    *   test eax , DF_STRPARM 
00001FCD                    *   je  @C0180

00001FCF                                        mov bracket_flags,-1

                                                ; v2.08 handle .ERRDEF and .ERRNDEF here. Previously
                                                ; expansion for these directives was handled in condasm.asm,
                                                ; and the directives were flagged as DF_NOEXPAND.

00001FD6                                        .if ( [rbx].dirtype == DRT_ERRDIR )
00001FD6                    *   cmp [rbx].dirtype , DRT_ERRDIR 
00001FDA                    *   jnz @C0181
00001FDC                                            .if ( [rbx].tokval == T_DOT_ERRDEF ||[rbx].tokval == T_DOT_ERRNDEF )
00001FDC                    *   cmp [rbx].tokval , T_DOT_ERRDEF 
00001FE3                    *   jz  @C0183
00001FE5                    *   @C0184:
00001FE5                    *   cmp [rbx].tokval , T_DOT_ERRNDEF 
00001FEC                    *   jnz @C0182
00001FEE                    *   @C0183:

00001FEE                                                .if esi
00001FEE                    *   test esi, esi
00001FF0                    *   jz  @C0185
00001FF2                                                    mov rc,ExpandToken( string, &count, tokenarray, 1, FALSE, FALSE, buffer )
00001FF2                    *   invoke ExpandToken, string, addr count, tokenarray, 1, FALSE, FALSE, buffer 
00001FF2                    *    mov rax, buffer 
00001FF6                    *    mov [rsp+48], rax
00001FFB                    *    mov dword ptr [rsp+40], FALSE
00002003                    *    mov dword ptr [rsp+32], FALSE
0000200B                    *    mov r9d, 1
00002011                    *    mov r8, tokenarray
00002015                    *    lea rdx, count
00002019                    *    mov rcx, string
0000201D                    *    call ExpandToken
00002022                    *   mov rc, eax
00002025                                                .endif
00002025                    *   @C0185:
00002025                                                .while [rbx].token != T_FINAL && [rbx].token != T_COMMA
00002025                    *   jmp @C0189
00002027                    *   @C0186:
00002027                                                    inc esi
00002029                                                    add rbx,asm_tok
0000202D                                                .endw
0000202D                    *   @C0189:
0000202D                    *   cmp [rbx].token , T_FINAL 
00002030                    *   jz  @C0187
00002032                    *   @C0188:
00002032                    *   cmp [rbx].token , T_COMMA
00002035                    *   jnz @C0186
00002037                    *   @C0187:
00002037                                                mov count,esi ; don't expand the symbol name
0000203A                                            .endif
0000203A                    *   @C0182:
0000203A                                        .endif
0000203A                    *   @C0181:

0000203A                                    .elseif ( eax & DF_NOEXPAND )
0000203A                    *   jmp @C018A
0000203C                    *   @C0180:
0000203C                    *   test eax , DF_NOEXPAND 
00002041                    *   je  @C018B

                                                ; [ELSE]IF[N]DEF, ECHO, FOR[C]
                                                ; .[NO|X]CREF, INCLUDE
                                                ; don't expand arguments
00002043                                        .return NOT_ERROR
00002043                    *   xor eax,eax
00002045                    *   jmp @C017B
00002047                                    .endif
00002047                    *   @C018B:
00002047                    *   @C018A:

00002047                                .elseif ModuleInfo.token_count > 1 && [rdx+asm_tok].asm_tok.token == T_DIRECTIVE
00002047                    *   jmp @C018C
0000204D                    *   @C017F:
0000204D                    *   cmp ModuleInfo.token_count , 1 
00002054                    *   jng @C018D
00002056                    *   cmp [rdx+asm_tok].asm_tok.token , T_DIRECTIVE
0000205A                    *   jnz @C018D

0000205C                                    mov al,[rdx+asm_tok].asm_tok.dirtype
0000205F                                    .switch al
0000205F                                    .case DRT_CATSTR
0000205F                    *    jmp @C018E
00002061                    *   @C018F:
00002061                                        mov bracket_flags,-1
00002068                                        mov count,2
0000206F                                        .endc
0000206F                    *    jmp @C0190
00002071                                    .case DRT_SUBSTR
00002071                    *   @C0191:
                                                ; syntax: name SUBSTR <literal>, pos [, size]
00002071                                        mov bracket_flags,0x1
00002078                                        mov count,2
0000207F                                        .endc
0000207F                    *    jmp @C0190
00002081                                    .case DRT_SIZESTR
00002081                    *   @C0192:
                                                ; syntax: label SIZESTR literal
00002081                                        mov rc,ExpandToken( string, &count, tokenarray, 1, FALSE, FALSE, buffer )
00002081                    *   invoke ExpandToken, string, addr count, tokenarray, 1, FALSE, FALSE, buffer 
00002081                    *    mov rax, buffer 
00002085                    *    mov [rsp+48], rax
0000208A                    *    mov dword ptr [rsp+40], FALSE
00002092                    *    mov dword ptr [rsp+32], FALSE
0000209A                    *    mov r9d, 1
000020A0                    *    mov r8, tokenarray
000020A4                    *    lea rdx, count
000020A8                    *    mov rcx, string
000020AC                    *    call ExpandToken
000020B1                    *   mov rc, eax
000020B4                                        mov bracket_flags,0x1
000020BB                                        mov count,2
000020C2                                        .endc
000020C2                    *    jmp @C0190
000020C4                                    .case DRT_INSTR
000020C4                    *   @C0193:
                                                ; syntax: label INSTR [number,] literal, literal
000020C4                                        mov rc,ExpandToken( string, &count, tokenarray, 1, FALSE, FALSE, buffer )
000020C4                    *   invoke ExpandToken, string, addr count, tokenarray, 1, FALSE, FALSE, buffer 
000020C4                    *    mov rax, buffer 
000020C8                    *    mov [rsp+48], rax
000020CD                    *    mov dword ptr [rsp+40], FALSE
000020D5                    *    mov dword ptr [rsp+32], FALSE
000020DD                    *    mov r9d, 1
000020E3                    *    mov r8, tokenarray
000020E7                    *    lea rdx, count
000020EB                    *    mov rcx, string
000020EF                    *    call ExpandToken
000020F4                    *   mov rc, eax
                                                ; check if the optional <number> argument is given
000020F7                                        .for esi = 2, eax = 0, ecx = 0: esi < ModuleInfo.token_count: esi++
000020F7                    *   mov esi, 2
000020FC                    *   xor eax, eax
000020FE                    *   xor ecx, ecx
00002100                    *   @C0194:
00002100                    *   cmp esi , ModuleInfo.token_count
00002106                    *   jnl @C0196
00002108                                            imul ebx,esi,asm_tok
0000210B                                            add rbx,tokenarray
0000210F                                            .if [rbx].token == T_OP_BRACKET
0000210F                    *   cmp [rbx].token , T_OP_BRACKET
00002112                    *   jnz @C0197
00002114                                                inc eax
00002116                                            .elseif [rbx].token == T_CL_BRACKET
00002116                    *   jmp @C0198
00002118                    *   @C0197:
00002118                    *   cmp [rbx].token , T_CL_BRACKET
0000211B                    *   jnz @C0199
0000211D                                                dec eax
0000211F                                            .elseif [rbx].token == T_COMMA && eax == 0
0000211F                    *   jmp @C0198
00002121                    *   @C0199:
00002121                    *   cmp [rbx].token , T_COMMA 
00002124                    *   jnz @C019A
00002126                    *   test eax , eax 
00002128                    *   jnz @C019A
0000212A                                                inc ecx
0000212C                                            .endif
0000212C                    *   @C019A:
0000212C                    *   @C0198:
0000212C                                        .endf
0000212C                    *   @C0195:
0000212C                    *   inc esi
0000212E                    *   jmp @C0194
00002130                    *   @C0196:
00002130                                        mov eax,3
00002135                                        .if ecx > 1
00002135                    *   cmp ecx , 1
00002138                    *   jna @C019B
0000213A                                            mov eax,6
0000213F                                        .endif
0000213F                    *   @C019B:
0000213F                                        mov bracket_flags,eax
00002142                                        mov count,2
00002149                                        .endc
00002149                    *    jmp @C0190
0000214B                                    .case DRT_MACRO
0000214B                    *   @C019C:
0000214B                    *   invoke SymFind, [rdx].asm_tok.string_ptr
0000214B                    *    mov rcx, [rdx].asm_tok.string_ptr
0000214F                    *    call SymFind
                                invoke SymFind([rdx].asm_tok.string_ptr)
                                                ; don't expand macro DEFINITIONs!
                                                ; the name is an exception, if it's not the macro itself

00002154                                        .if ( rax && [rax].asym.state != SYM_MACRO )
00002154                    *   test rax , rax 
00002157                    *   jz  @C019D
00002159                    *   cmp [rax].asym.state , SYM_MACRO 
0000215D                    *   jz  @C019D
0000215F                                            mov rc,ExpandToken( string, &count, tokenarray, 1, FALSE, FALSE, buffer )
0000215F                    *   invoke ExpandToken, string, addr count, tokenarray, 1, FALSE, FALSE, buffer 
0000215F                    *    mov rax, buffer 
00002163                    *    mov [rsp+48], rax
00002168                    *    mov dword ptr [rsp+40], FALSE
00002170                    *    mov dword ptr [rsp+32], FALSE
00002178                    *    mov r9d, 1
0000217E                    *    mov r8, tokenarray
00002182                    *    lea rdx, count
00002186                    *    mov rcx, string
0000218A                    *    call ExpandToken
0000218F                    *   mov rc, eax
00002192                                        .endif
00002192                    *   @C019D:
00002192                                        mov count,ModuleInfo.token_count ; stop further expansion
00002192                    *    mov eax, ModuleInfo.token_count
00002198                    *    mov count, eax
0000219B                                        .endc
0000219B                    *    jmp @C0190
0000219D                                    .case DRT_EQU
0000219D                    *   @C019E:
                                                ; EQU is a special case. If the - expanded - expression is
                                                ; a number, then the value for EQU is numeric. Else the
                                                ; expression isn't expanded at all. This effectively makes it
                                                ; impossible to expand EQU lines here.

0000219D                                        .return NOT_ERROR
0000219D                    *   xor eax,eax
0000219F                    *   jmp @C017B
000021A1                                    .endsw
000021A1                    *    jmp @C0190
000021A6                    *   @C018E:
000021A6                    *    cmp al, DRT_CATSTR
000021A8                    *    je @C018F
000021AE                    *    cmp al, DRT_SUBSTR
000021B0                    *    je @C0191
000021B6                    *    cmp al, DRT_SIZESTR
000021B8                    *    je @C0192
000021BE                    *    cmp al, DRT_INSTR
000021C0                    *    je @C0193
000021C6                    *    cmp al, DRT_MACRO
000021C8                    *    je @C019C
000021CA                    *    cmp al, DRT_EQU
000021CC                    *    je @C019E
000021DA                    *   @C0190:
000021DA                                .else
000021DA                    *   jmp @C018C
000021E4                    *   @C018D:
                                            ; v2.08: expand the very first token and then ...
000021E4                                    mov rc,ExpandToken( string, &count, tokenarray, 1, FALSE, FALSE, buffer )
000021E4                    *   invoke ExpandToken, string, addr count, tokenarray, 1, FALSE, FALSE, buffer 
000021E4                    *    mov rax, buffer 
000021E8                    *    mov [rsp+48], rax
000021ED                    *    mov dword ptr [rsp+40], FALSE
000021F5                    *    mov dword ptr [rsp+32], FALSE
000021FD                    *    mov r9d, 1
00002203                    *    mov r8, tokenarray
00002207                    *    lea rdx, count
0000220B                    *    mov rcx, string
0000220F                    *    call ExpandToken
00002214                    *   mov rc, eax
00002217                                    .return .if eax == ERROR || eax == EMPTY
00002217                    *   cmp eax , ERROR 
0000221A                    *   jz  @C017B
0000221C                    *   cmp eax , EMPTY
0000221F                    *   jz  @C017B

00002221                                    .if ( rc == STRING_EXPANDED )
00002221                    *   cmp rc , STRING_EXPANDED 
00002225                    *   jnz @C019F
                                                ;
                                                ; ... fully retokenize - the expansion might have revealed a
                                                ; conditional assembly directive
                                                ;
00002227                                        mov ModuleInfo.token_count,Tokenize( string, 0, tokenarray, TOK_DEFAULT )
00002227                    *   invoke Tokenize, string, 0, tokenarray, TOK_DEFAULT 
00002227                    *    xor r9d, r9d
0000222A                    *    mov r8, tokenarray
0000222E                    *    xor edx, edx
00002230                    *    mov rcx, string
00002234                    *    call Tokenize
00002239                    *   mov ModuleInfo.token_count, eax
0000223F                                       .continue
0000223F                    *    jmp @C0171
00002241                                    .endif
00002241                    *   @C019F:
00002241                                    mov rax,tokenarray
00002245                                    .if ( count == 1 && [rax].asm_tok.token == T_ID && [rax+asm_tok].asm_tok.token == T_ID )
00002245                    *   cmp count , 1 
00002249                    *   jnz @C01A0
0000224B                    *   cmp [rax].asm_tok.token , T_ID 
0000224E                    *   jnz @C01A0
00002250                    *   cmp [rax+asm_tok].asm_tok.token , T_ID 
00002254                    *   jnz @C01A0
00002256                                        mov rc,ExpandToken( string, &count, tokenarray, 2, FALSE, FALSE, buffer )
00002256                    *   invoke ExpandToken, string, addr count, tokenarray, 2, FALSE, FALSE, buffer 
00002256                    *    mov rax, buffer 
0000225A                    *    mov [rsp+48], rax
0000225F                    *    mov dword ptr [rsp+40], FALSE
00002267                    *    mov dword ptr [rsp+32], FALSE
0000226F                    *    mov r9d, 2
00002275                    *    mov r8, tokenarray
00002279                    *    lea rdx, count
0000227D                    *    mov rcx, string
00002281                    *    call ExpandToken
00002286                    *   mov rc, eax
00002289                                        .return .if eax == ERROR || eax == EMPTY
00002289                    *   cmp eax , ERROR 
0000228C                    *   jz  @C017B
0000228E                    *   cmp eax , EMPTY
00002291                    *   jz  @C017B
00002293                                        .if rc == STRING_EXPANDED
00002293                    *   cmp rc , STRING_EXPANDED
00002297                    *   jnz @C01A1
00002299                                            mov ModuleInfo.token_count,Tokenize( string, 0, tokenarray, TOK_DEFAULT )
00002299                    *   invoke Tokenize, string, 0, tokenarray, TOK_DEFAULT 
00002299                    *    xor r9d, r9d
0000229C                    *    mov r8, tokenarray
000022A0                    *    xor edx, edx
000022A2                    *    mov rcx, string
000022A6                    *    call Tokenize
000022AB                    *   mov ModuleInfo.token_count, eax
000022B1                                            .continue
000022B1                    *    jmp @C0171
000022B3                                        .endif
000022B3                    *   @C01A1:
000022B3                                    .endif
000022B3                    *   @C01A0:
000022B3                                .endif
000022B9                    *   @C018C:
                                        ;
                                        ; scan the line from left to right for (text) macros.
                                        ; it's currently not quite correct. a macro proc should only
                                        ; be evaluated in the following cases:
                                        ; 1. it is the first token of a line
                                        ; 2. it is the second token, and the first one is an ID
                                        ; 3. it is the third token, the first one is an ID and
                                        ;    the second is a ':' or '::'.
                                        ;
000022B9                                .while ( count < ModuleInfo.token_count )
000022B9                    *   jmp @C01A3
000022BB                    *   @C01A2:

000022BB                                    mov eax,bracket_flags
000022BE                                    and eax,1
000022C1                                    mov addbrackets,eax
000022C4                                    .if bracket_flags != -1
000022C4                    *   cmp bracket_flags , -1
000022C8                    *   jz  @C01A4
000022CA                                        shr bracket_flags,1
000022CD                                    .endif
000022CD                    *   @C01A4:
000022CD                    *   invoke ExpandToken, string, addr count, tokenarray, ModuleInfo.token_count, addbrackets, FALSE, buffer 
000022CD                    *    mov rax, buffer 
000022D1                    *    mov [rsp+48], rax
000022D6                    *    mov dword ptr [rsp+40], FALSE
000022DE                    *    mov eax, addbrackets
000022E1                    *    mov [rsp+32], eax
000022E5                    *    mov r9d, ModuleInfo.token_count
000022EC                    *    mov r8, tokenarray
000022F0                    *    lea rdx, count
000022F4                    *    mov rcx, string
000022F8                    *    call ExpandToken
                                invoke ExpandToken( string, &count, tokenarray, ModuleInfo.token_count, addbrackets, FALSE, buffer )
000022FD                                    .return .ifs ( eax < NOT_ERROR ) ; ERROR or EMPTY?
000022FD                    *   cmp eax , NOT_ERROR 
00002300                    *   jl  @C017B
00002302                                    .if eax == STRING_EXPANDED
00002302                    *   cmp eax , STRING_EXPANDED
00002305                    *   jnz @C01A5
00002307                                        mov rc,STRING_EXPANDED
0000230E                                    .endif
0000230E                    *   @C01A5:
0000230E                                    imul ebx,count,asm_tok
00002312                                    add rbx,tokenarray
00002316                                    .if ( [rbx].token == T_COMMA )
00002316                    *   cmp [rbx].token , T_COMMA 
00002319                    *   jnz @C01A6
0000231B                                        inc count
0000231E                                    .endif
0000231E                    *   @C01A6:
0000231E                                .endw
0000231E                    *   @C01A3:
0000231E                    *   cmp count , ModuleInfo.token_count 
0000231E                    *    mov eax,  ModuleInfo.token_count 
00002324                    *    cmp count , eax
00002327                    *   jl  @C01A2

00002329                                .if rc == STRING_EXPANDED
00002329                    *   cmp rc , STRING_EXPANDED
0000232D                    *   jnz @C01A7
0000232F                                    mov ModuleInfo.token_count,Tokenize( string, 0, tokenarray, TOK_RESCAN or TOK_LINE )
0000232F                    *   invoke Tokenize, string, 0, tokenarray, TOK_RESCAN or TOK_LINE 
0000232F                    *    mov r9d, TOK_RESCAN or TOK_LINE 
00002335                    *    mov r8, tokenarray
00002339                    *    xor edx, edx
0000233B                    *    mov rcx, string
0000233F                    *    call Tokenize
00002344                    *   mov ModuleInfo.token_count, eax
0000234A                                .endif
0000234A                    *   @C01A7:

0000234A                                mov rbx,tokenarray
0000234E                                .if ( ModuleInfo.token_count > 2 && [rbx].flags & T_EXPAND )
0000234E                    *   cmp ModuleInfo.token_count , 2 
00002355                    *   jng @C01A8
00002357                    *   test [rbx].flags , T_EXPAND 
0000235B                    *   je  @C01A8

0000235D                                    .if ( [rbx].flags & T_ISPROC )
0000235D                    *   test [rbx].flags , T_ISPROC 
00002361                    *   je  @C01A9

00002363                    *   invoke ExpandProc, string, buffer
00002363                    *    mov rdx, buffer
00002367                    *    mov rcx, string
0000236B                    *    call ExpandProc
                                invoke ExpandProc(string, buffer)
00002370                                    .endif
00002370                    *   @C01A9:

00002370                                    .for ( : [rbx].token != T_FINAL : rbx += asm_tok )
00002370                    *   @C01AA:
00002370                    *   cmp [rbx].token , T_FINAL
00002373                    *   jz  @C01AC

00002375                                        .if ( [rbx+asm_tok].token == T_DBL_COLON )
00002375                    *   cmp [rbx+asm_tok].token , T_DBL_COLON 
00002379                    *   jnz @C01AD

0000237B                                            xor edi,edi
0000237D                                            .if ( [rbx+3*asm_tok].token == T_DIRECTIVE &&( [rbx+3*asm_tok].tokval == T_PROC || [rbx+3*asm_tok].tokval == T_PROTO ) )
0000237D                    *   cmp [rbx+3*asm_tok].token , T_DIRECTIVE 
00002381                    *   jnz @C01AE
00002383                    *   cmp [rbx+3*asm_tok].tokval , T_PROC 
0000238A                    *   jz  @C01AF
0000238C                    *   @C01B0:
0000238C                    *   cmp [rbx+3*asm_tok].tokval , T_PROTO 
00002393                    *   jnz @C01AE
00002395                    *   @C01AF:

                                                        ; if 'class::name proto|proc'

00002395                                                inc edi
00002397                                                .if ( SymFind([rbx].string_ptr) )
00002397                    *   invoke SymFind, [rbx].string_ptr
00002397                    *    mov rcx, [rbx].string_ptr
0000239B                    *    call SymFind
000023A0                    *   test (  rax ), (  rax )
000023A3                    *   jz  @C01B1
000023A5                                                    .if ( [rax].asym.flag2 & S_CLASS )
000023A5                    *   test [rax].asym.flag2 , S_CLASS 
000023A9                    *   je  @C01B2

                                                                ; - add 'this:ptr class' as first argument

000023AB                                                        inc edi
000023AD                                                    .endif
000023AD                    *   @C01B2:
000023AD                                                .endif
000023AD                    *   @C01B1:

000023AD                                            .else
000023AD                    *   jmp @C01B3
000023AF                    *   @C01AE:

000023AF                                                mov al,[rbx].token
000023B1                                                mov ah,[rbx+asm_tok*2].token
000023B4                                                .if ( ( al != T_REG && [rbx+3*asm_tok].token == T_OP_BRACKET ) ||( al < T_STRING && al > T_REG &&ah < T_STRING && ah > T_REG ) )
000023B4                    *   cmp al , T_REG 
000023B6                    *   jz  @C01B6
000023B8                    *   cmp [rbx+3*asm_tok].token , T_OP_BRACKET 
000023BC                    *   jz  @C01B5
000023BE                    *   @C01B6:
000023BE                    *   cmp al , T_STRING 
000023C0                    *   jnb @C01B4
000023C2                    *   cmp al , T_REG 
000023C4                    *   jna @C01B4
000023C6                    *   cmp ah , T_STRING 
000023C9                    *   jnb @C01B4
000023CB                    *   cmp ah , T_REG 
000023CE                    *   jna @C01B4
000023D0                    *   @C01B5:
000023D0                                                    inc edi
000023D2                                                .endif
000023D2                    *   @C01B4:

000023D2                                            .endif
000023D2                    *   @C01B3:

000023D2                                            .if ( edi == 1 )
000023D2                    *   cmp edi , 1 
000023D5                    *   jnz @C01B7

000023D7                                                mov rdi,[rbx+asm_tok].tokpos
000023DB                                                .while ( byte ptr [rdi-1] <= ' ' )
000023DB                    *   jmp @C01B9
000023DD                    *   @C01B8:
000023DD                                                    dec rdi
000023E0                                                .endw
000023E0                    *   @C01B9:
000023E0                    *   cmp byte ptr [rdi-1] , ' ' 
000023E4                    *   jna @C01B8
000023E6                                                mov rsi,[rbx+asm_tok*2].tokpos
000023EA                                                mov al,'_'
000023EC                                                stosb
000023ED                                                mov ecx,tstrlen(rsi)
000023ED                    *   invoke tstrlen, rsi
000023ED                    *    mov rcx, rsi
000023F0                    *    call tstrlen
000023F5                    *   mov ecx, eax
000023F7                                                inc ecx
000023F9                                                rep movsb

000023FB                                            .elseif ( edi > 1 )
000023FB                    *   jmp @C01BA
000023FD                    *   @C01B7:
000023FD                    *   cmp edi , 1 
00002400                    *   jna @C01BB

00002402                                                mov rdi,buffer
00002406                                                mov rdx,tokenarray
0000240A                                                mov rsi,[rdx].asm_tok.tokpos
0000240E                                                mov rcx,[rbx+asm_tok].tokpos
00002412                                                sub rcx,rsi
00002415                                                rep movsb
00002417                                                mov al,'_'
00002419                                                stosb
0000241A                                                mov rsi,[rbx+asm_tok*2].tokpos

                                                        ;
                                                        ; class::name proc syscall private uses regs name:dword,..
                                                        ;
0000241E                                                .for ( edx = 3*asm_tok : [rbx+rdx].token != T_FINAL : rdx+=asm_tok )
0000241E                    *   mov edx, 3*asm_tok
00002423                    *   @C01BC:
00002423                    *   cmp [rbx+rdx].token , T_FINAL
00002427                    *   jz  @C01BE
00002429                                                    .break .if ( [rbx+rdx].token == T_COLON )
00002429                    *   cmp [rbx+rdx].token , T_COLON 
0000242D                    *   jz  @C01BE
0000242F                                                    .break .if ( [rbx+rdx].token == T_STRING )
0000242F                    *   cmp [rbx+rdx].token , T_STRING 
00002433                    *   jz  @C01BE
00002435                                                .endf
00002435                    *   @C01BD:
00002435                    *   add rdx, asm_tok
00002439                    *   jmp @C01BC
0000243B                    *   @C01BE:

0000243B                                                .if ( [rbx+rdx].token == T_COLON && [rbx+rdx-asm_tok].token == T_ID )
0000243B                    *   cmp [rbx+rdx].token , T_COLON 
0000243F                    *   jnz @C01BF
00002441                    *   cmp [rbx+rdx-asm_tok].token , T_ID 
00002446                    *   jnz @C01BF

00002448                                                    sub rdx,asm_tok
0000244C                                                .endif
0000244C                    *   @C01BF:

0000244C                                                mov rcx,[rbx+rdx].tokpos
00002451                                                sub rcx,rsi
00002454                                                rep movsb

00002456                                                .if ( byte ptr [rdi-1] == ' ' )
00002456                    *   cmp byte ptr [rdi-1] , ' ' 
0000245A                    *   jnz @C01C0
0000245C                                                    dec rdi
0000245F                                                .endif
0000245F                    *   @C01C0:

                                                        ; add " this:ptr class"

0000245F                                                mov eax,'iht '
00002464                                                stosd
00002465                                                mov eax,'tp:s'
0000246A                                                stosd
0000246B                                                mov ax,' r'
0000246F                                                stosw
00002471                                                mov rcx,[rbx].string_ptr
00002475                                                mov al,[rcx]
00002477                                                .while al
00002477                    *   jmp @C01C2
00002479                    *   @C01C1:
00002479                                                    stosb
0000247A                                                    inc rcx
0000247D                                                    mov al,[rcx]
0000247F                                                .endw
0000247F                    *   @C01C2:
0000247F                    *   test al, al
00002481                    *   jnz @C01C1

00002483                                                .if ( [rbx+rdx].token == T_COLON || [rbx+rdx+asm_tok].token == T_COLON )
00002483                    *   cmp [rbx+rdx].token , T_COLON 
00002487                    *   jz  @C01C4
00002489                    *   @C01C5:
00002489                    *   cmp [rbx+rdx+asm_tok].token , T_COLON 
0000248E                    *   jnz @C01C3
00002490                    *   @C01C4:
00002490                                                    mov eax,' ,'
00002495                                                    stosw
00002497                                                .endif
00002497                    *   @C01C3:
00002497                                                mov ecx,tstrlen(rsi)
00002497                    *   invoke tstrlen, rsi
00002497                    *    mov rcx, rsi
0000249A                    *    call tstrlen
0000249F                    *   mov ecx, eax
000024A1                                                inc ecx
000024A3                                                rep movsb
000024A5                    *   invoke tstrcpy, string, buffer
000024A5                    *    mov rdx, buffer
000024A9                    *    mov rcx, string
000024AD                    *    call tstrcpy
                                invoke tstrcpy(string, buffer)
000024B2                                            .endif
000024B6                    *   @C01BB:
000024B9                    *   @C01BA:

000024B9                                            .if ( edi )
000024B9                    *   test ( edi ), ( edi )
000024BB                    *   jz  @C01C6

000024BD                                                mov ModuleInfo.token_count,Tokenize( string, 0, tokenarray, TOK_DEFAULT )
000024BD                    *   invoke Tokenize, string, 0, tokenarray, TOK_DEFAULT 
000024BD                    *    xor r9d, r9d
000024C0                    *    mov r8, tokenarray
000024C4                    *    xor edx, edx
000024C6                    *    mov rcx, string
000024CA                    *    call Tokenize
000024CF                    *   mov ModuleInfo.token_count, eax
000024D5                                                sub rbx,asm_tok
000024D9                                            .endif
000024D9                    *   @C01C6:
000024D9                                        .endif
000024DD                    *   @C01AD:
000024DD                                    .endf
000024DD                    *   @C01AB:
000024DD                    *   add rbx, asm_tok
000024E1                    *   jmp @C01AA
000024EA                    *   @C01AC:
000024EA                                .endif
000024F2                    *   @C01A8:
000024F2                                .break .if ( rc != STRING_EXPANDED )
000024F2                    *   cmp rc , STRING_EXPANDED 
000024F6                    *   jnz @C0172
000024F8                            .endf
000024FE                    *   @C0171:
000024FE                    *   inc lvl
00002501                    *   jmp @C0170
0000250A                    *   @C0172:

0000250A                            .return asmerr( 2123 ) .if ( lvl == MAX_TEXTMACRO_NESTING )
0000250A                    *   cmp lvl , MAX_TEXTMACRO_NESTING 
0000250E                    *   jnz @C01C7
00002510                    *   invoke asmerr, 2123 
00002510                    *    mov ecx, 2123 
00002515                    *    call asmerr
0000251A                    *   jmp @C017B
0000251C                    *   @C01C7:
0000251C                            .return rc
0000251C                    *   mov eax,rc
0000251F                    *   jmp @C017B

                            *   org $ - 2
0000251F                    *   ret
0000253F                    *   @C017B:
0000253F                    *   leave
00002540                    *   pop rbx
00002541                    *   pop rdi
00002542                    *   pop rsi
00002543                    *   retn 
00002544                        ExpandLine endp

                                    end
                            *   _TEXT ends

Asmc Macro Assembler (x64) Version 2.34.27  04/04/23 04:57:19
C:\Asmc\source\asmc\src\expans.asm

 = 0                          C define __MEMALLOC_INC
 = 0                          C define _INC_MALLOC
 = 0                          C define __PARSER_INC
 = 0                          C define OPERANDS_H
 = 0                          C OP_NONE		equ 0x00000000
 = 1                          C OP_R8		equ 0x00000001
 = 2                          C OP_R16		equ 0x00000002
 = 4                          C OP_R32		equ 0x00000004
 = 8                          C OP_R64		equ 0x00000008
 = 10                         C OP_XMM		equ 0x00000010
 = 20                         C OP_YMM		equ 0x00000020
 = 40                         C OP_ZMM		equ 0x00000040
 = 80                         C OP_A		equ 0x00000080
 = 100                        C OP_M08		equ 0x00000100
 = 200                        C OP_M16		equ 0x00000200
 = 400                        C OP_M32		equ 0x00000400
 = 800                        C OP_M64		equ 0x00000800
 = 1000                       C OP_M128		equ 0x00001000
 = 2000                       C OP_M256		equ 0x00002000
 = 4000                       C OP_M512		equ 0x00004000
 = 8000                       C OP_MMX		equ 0x00008000
 = 10000                      C OP_I8		equ 0x00010000
 = 20000                      C OP_I16		equ 0x00020000
 = 40000                      C OP_I32		equ 0x00040000
 = 80000                      C OP_I64		equ 0x00080000
 = 100000                     C OP_K		equ 0x00100000
 = 200000                     C OP_M48		equ 0x00200000
 = 400000                     C OP_M80		equ 0x00400000
 = 800000                     C OP_CL_ONLY	equ 0x00800000
 = 1000000                    C OP_DX_ONLY	equ 0x01000000
 = 2000000                    C OP_RSPEC	equ 0x02000000
 = 4000000                    C OP_SR86		equ 0x04000000
 = 8000000                    C OP_SR386	equ 0x08000000
 = 10000000                   C OP_ST		equ 0x10000000
 = 20000000                   C OP_ST_REG	equ 0x20000000
 = 40000000                   C OP_I48		equ 0x40000000
 = 210000                     C OP_I_1		equ 0x00200000 or OP_I8
 = 410000                     C OP_I_3		equ 0x00400000 or OP_I8
 = 870000                     C OP_I8_U		equ 0x00800000 or OP_I8 or OP_I16 or OP_I32
 = 81                         C OP_AL		equ OP_A or OP_R8
 = 82                         C OP_AX		equ OP_A or OP_R16
 = 84                         C OP_EAX		equ OP_A or OP_R32
 = 88                         C OP_RAX		equ OP_A or OP_R64
 = 2000010                    C OP_RIP		equ 16 or OP_RSPEC
 = 800001                     C OP_CL		equ OP_CL_ONLY or OP_R8
 = 1000002                    C OP_DX		equ OP_DX_ONLY or OP_R16
 = E                          C OP_RGT8		equ OP_R16 or OP_R32 or OP_R64
 = C                          C OP_RGT16	equ OP_R32 or OP_R64
 = F                          C OP_R		equ OP_R8 or OP_R16 or OP_R32 or OP_R64
 = C000000                    C OP_SR		equ OP_SR86 or OP_SR386
 = 30000000                   C OP_STI		equ OP_ST or OP_ST_REG
 = 70000                      C OP_I		equ OP_I8 or OP_I16 or OP_I32
 = 70000                      C OP_IGE8		equ OP_I8 or OP_I16 or OP_I32
 = 60000                      C OP_IGE16	equ OP_I16 or OP_I32
 = 400F0000                   C OP_I_ANY	equ OP_I or OP_I64 or OP_I48
 = E00                        C OP_MGT8		equ OP_M16 or OP_M32 or OP_M64
 = C00                        C OP_MGT16	equ OP_M32 or OP_M64
 = 600400                     C OP_MFPTR	equ OP_M32 or OP_M48 or OP_M80
 = 607F00                     C OP_M_ANY	equ OP_M08 or OP_M16 or OP_M32 or OP_M64 or OP_M128 or OP_M256 or OP_M512 or OP_M48 or OP_M80
 = 401F00                     C OP_M		equ OP_M08 or OP_M16 or OP_M32 or OP_M64 or OP_M80 or OP_M128
 = F00                        C OP_MS		equ OP_M08 or OP_M16 or OP_M32 or OP_M64
 = 0                          C OP3_NONE	equ 0
 = 1                          C OP3_CL		equ 1
 = 2                          C OP3_I8_U	equ 2
 = 3                          C OP3_XMM0	equ 3
 = 4                          C OP3_I		equ 4
 = 5                          C OP3_HID		equ 5
 = 3                          C OP3_XMM		equ OP3_XMM0
 = 3                          C OP3_YMM		equ OP3_XMM0
 = 3                          C OP3_ZMM		equ OP3_XMM0
 = 3                          C OP3_K		equ OP3_XMM0
 = 3                          C OP3_RGT16	equ OP3_XMM0
 = 3                          C OP3_R_MS	equ OP3_XMM0
 = 0                          C define __FIXUP_inc
 = 0                          C BIN_DISALLOWED		equ 0x0000
 = 0                          C OMF_DISALLOWED		equ 0x0000
 = E12                        C COFF32_DISALLOWED	equ 0x0E12
 = E12                        C COFF64_DISALLOWED	equ 0x0E12
 = F00                        C ELF32_DISALLOWED	equ 0x0F00
 = F00                        C ELF64_DISALLOWED	equ 0x0F00
 = 2                          C FX_ORGOCCURED		equ 0x02
 = 1                          C FX_LOADER_RESOLVED	equ 0x01
00000000                      C fixup struct
00000000                      C  nextbp		ptr fixup ?
00000008                      C  nextrlc	ptr fixup ?
00000010                      C  offs		dd ?
00000014                      C  locofs		dd ?
00000018                      C  type		db ?
00000019                      C  options	db ?
00000034                      C  union
00000000                      C   flags		dw ?
00000002                      C   struct
00000000                      C    addbytes	db ?
00000001                      C    fx_flag	db ?
00000002                      C   ends
00000002                      C  ends
00000034                      C  union
00000008                      C   struct
00000000                      C    frame_type	char_t ?
00000001                      C    frame_datum	ushort_t ?
00000003                      C   ends
00000000                      C   segment_var	ptr asym ?
00000008                      C  ends
00000024                      C  def_seg	ptr dsym ?
0000002C                      C  sym		ptr asym ?
00000034                      C fixup ends
 = 525                        C VEX_START equ T_VBROADCASTSS
                              C .template symbol_queue
00000000                    * C symbol_queue struct
00000000                      C     head ptr dsym ?
00000008                      C     tail ptr dsym ?
                              C    .ends
00000010                    * C symbol_queue ends
00000000                      C opnd_class	STRUC
00000000                      C opnd_type	dd 2 dup(?)
00000008                      C opnd_type_3rd	db ?
00000009                      C opnd_class	ENDS
 = 7                          C II_ALLOWED_PREFIX equ 0x07
 = 8                          C II_FIRST	equ 0x08
 = 70                         C II_RM_INFO	equ 0x70
 = 80                         C II_OPND_DIR	equ 0x80
00000000                      C instr_item	STRUC
00000000                      C opclsidx	db ?
00000001                      C byte1_info	db ?
00000002                      C flags		db ?
00000003                      C evex		db ?
00000004                      C cpu		dw ?
00000006                      C opcode		db ?
00000007                      C rm_byte		db ?
00000008                      C instr_item	ENDS
00000000                      C special_item	STRUC
00000000                      C value		dd ?
00000004                      C sflags		dd ?
00000008                      C cpu		dw ?
0000000A                      C bytval		db ?
0000000B                      C type		db ?
0000000C                      C special_item	ENDS
 = 3                          C MAX_OPND	equ 3
00000000                      C opnd_item	STRUC
00000000                      C type		uint_t ?
00000004                      C InsFixup	fixup_t ?
00000014                      C UNION
00000008                      C  STRUC
00000000                      C   data32l	int_t ?
00000004                      C   data32h	int_t ?
00000008                      C  ENDS
00000000                      C  data64		uint64_t ?
00000008                      C ENDS
00000014                      C opnd_item	ENDS
 = 80                         C VX1_R		equ 0x80
 = 40                         C VX1_X		equ 0x40
 = 20                         C VX1_B		equ 0x20
 = 10                         C VX1_R1		equ 0x10
 = 2                          C VX1_M1		equ 0x02
 = 1                          C VX1_M2		equ 0x01
 = 80                         C VX2_W		equ 0x80
 = 40                         C VX2_V3		equ 0x40
 = 20                         C VX2_V2		equ 0x20
 = 10                         C VX2_V1		equ 0x10
 = 8                          C VX2_V0		equ 0x08
 = 4                          C VX2_1		equ 0x04
 = 2                          C VX2_P1		equ 0x02
 = 1                          C VX2_P0		equ 0x01
 = 80                         C VX3_Z		equ 0x80
 = 40                         C VX3_L1		equ 0x40
 = 20                         C VX3_L0		equ 0x20
 = 10                         C VX3_B		equ 0x10
 = 8                          C VX3_V		equ 0x08
 = 4                          C VX3_A2		equ 0x04
 = 2                          C VX3_A1		equ 0x02
 = 1                          C VX3_A0		equ 0x01
 = 1                          C VX_OP1V		equ 0x01
 = 2                          C VX_OP2V		equ 0x02
 = 4                          C VX_OP3V		equ 0x04
 = 8                          C VX_OP3		equ 0x08
 = 10                         C VX_ZMM		equ 0x10
 = 20                         C VX_SAE		equ 0x20
 = 40                         C VX_ZMM8		equ 0x40
 = 80                         C VX_ZMM24	equ 0x80
 = F                          C VX_RXB		equ 0x0F
 = 8                          C VX_XMMI		equ 0x08
 = 4                          C VX_NV0		equ 0x04
 = 2                          C VX_W1		equ 0x02
 = 1                          C CI_ISWIDE	equ 0x01
 = 2                          C CI_ISDIRECT	equ 0x02
 = 4                          C CI_ISFAR	equ 0x04
 = 8                          C CI_CONST_SIZE_FIXED equ 0x08
 = 10                         C CI_X86HI_USED	equ 0x10
 = 20                         C CI_x64LO_USED	equ 0x20
 = 40                         C CI_UNDEF_SYM	equ 0x40
 = 80                         C CI_BASE_RIP	equ 0x80
00000000                      C code_info	STRUC
00000000                      C inst		int_t ?
00000004                      C RegOverride	int_t ?
00000008                      C rex		db ?
00000009                      C adrsiz		db ?
0000000A                      C opsiz		db ?
0000000B                      C evex		db ?
0000000C                      C evexP3		db ?
0000000D                      C vflags		db ?
0000000E                      C token		dw ?
00000010                      C opnd		opnd_item MAX_OPND dup(<>)
0000004C                      C pinstr		instr_t ?
00000054                      C mem_type	db ?
00000055                      C rm_byte		db ?
00000056                      C sib		db ?
00000057                      C Ofssize		db ?
00000058                      C opc_or		db ?
00000059                      C vexregop	db ?
0000005A                      C flags		db ?
0000005B                      C code_info	ENDS
 = 0                          C OPND1		equ 0
 = 1                          C OPND2		equ 1
 = 2                          C OPND3		equ 2
 = 14                         C OPNI2		equ OPND2 * sizeof(opnd_item)
 = 28                         C OPNI3		equ OPND3 * sizeof(opnd_item)
 = 0                          C define __PREPROC_INC
 = 0                          C define __EXPREVAL_INC
 = 1                          C define E_INDIRECT	0x01
 = 2                          C define E_EXPLICIT	0x02
 = 4                          C define E_IS_ABS		0x04
 = 8                          C define E_IS_TYPE	0x08
 = 10                         C define E_IS_OPEATTR	0x10
 = 20                         C define E_NEGATIVE	0x20
 = 40                         C define E_ASSUMECHECK	0x40
 = 80                         C define E_IS_DOT		0x80
00000000                      C expr		struct
00000064                      C union
00000010                      C  struct
00000000                      C   value		int_t ?
00000004                      C   hvalue	int_t ?
00000008                      C  ends
00000010                      C  struct
00000010                      C   union
00000000                      C    llvalue	uint64_t ?
00000008                      C    struct
00000000                      C     l64_l	uint_t ?
00000004                      C     l64_h	uint_t ?
00000008                      C    ends
00000008                      C   ends
00000010                      C   union
00000000                      C    hlvalue	uint64_t ?
00000008                      C    struct
00000000                      C     h64_l	uint_t ?
00000004                      C     h64_h	uint_t ?
00000008                      C    ends
00000008                      C   ends
00000010                      C  ends
00000000                      C  uvalue		uint_t ?
00000000                      C  value64	int64_t ?
00000000                      C  dvalue		real8 ?
00000000                      C  fvalue		real4 ?
00000000                      C  st_idx		int_t ?
00000000                      C  chararray	uchar_t 16 dup(?)
00000010                      C ends
00000064                      C union
00000000                      C  quoted_string	token_t ?
00000000                      C  float_tok	token_t ?
00000008                      C ends
00000018                      C base_reg	token_t ?
00000020                      C idx_reg		token_t ?
00000064                      C union
00000000                      C  label_tok	token_t ?
00000000                      C  type_tok	token_t ?
00000008                      C ends
00000030                      C override	token_t ?
00000038                      C inst		int_t ?
0000003C                      C kind		int_t ?
00000040                      C mem_type	uchar_t ?
00000041                      C scale		uchar_t ?
00000042                      C Ofssize		uchar_t ?
00000043                      C flags		uchar_t ?
00000044                      C op		ptr opinfo ?
0000004C                      C sym		asym_t ?
00000054                      C mbr		asym_t ?
0000005C                      C type		asym_t ?
00000064                      C expr		ends
 = 0                          C define __EQUATE_INC
 = 0                          C define __INPUT_INC
00000000                      C macro_instance	struct
00000000                      C currline	srcline_t ?
00000008                      C startline	srcline_t ?
00000010                      C localstart	uint_t ?
00000014                      C parm_array	array_t ?
0000001C                      C _macro		asym_t ?
00000024                      C parmcnt		uint_t ?
00000028                      C macro_instance	ends
00000000                      C file_seq	struct
00000000                      C next		fileseq_t ?
00000008                      C file		ushort_t ?
0000000A                      C file_seq	ends
00000000                      C input_status	struct
00000000                      C token_stringbuf string_t ?
00000008                      C currsource	string_t ?
00000010                      C CurrComment	string_t ?
00000018                      C token_count	int_t ?
0000001C                      C line_flags	char_t ?
0000001D                      C input_status	ends
 = 0                          C define __TOKENIZE_INC
00000000                      C line_status	    struc
00000000                      C input		    string_t ?
00000008                      C output		    string_t ?
00000010                      C start		    string_t ?
00000018                      C index		    uint_t ?
0000001C                      C flags		    char_t ?
0000001D                      C flags2		    char_t ?
0000001E                      C flags3		    char_t ?
0000001F                      C brachets	    char_t ?
00000020                      C tokenarray	    token_t ?
00000028                      C outbuf		    string_t ?
00000030                      C cstring		    char_t ?
00000031                      C line_status	    ends
 = 0                          C TOK_DEFAULT	    equ 0x00
 = 1                          C TOK_RESCAN	    equ 0x01
 = 2                          C TOK_NOCURLBRACES    equ 0x02
 = 4                          C TOK_LINE	    equ 0x04
 = 1                          C TF3_ISCONCAT	    equ 0x01
 = 2                          C TF3_EXPANSION	    equ 0x02
 = 0                          C define __MACRO_INC
 = A                          C PLACEHOLDER_CHAR	equ 10
 = 1                          C MF_LABEL		equ 0x01
 = 2                          C MF_NOSAVE		equ 0x02
 = 4                          C MF_IGNARGS		equ 0x04
 = 0                          C define __CONDASM_INC
 = 0                          C define __LISTING_INC
 = 0                          C define __QFLOAT_INC
 = 0                          C define __LQUEUE_INC
 = 0                          C define __TYPES_INC
                              C .template qualified_type
00000000                    * C qualified_type struct
00000000                      C     size		int_t ?
00000004                      C     symtype		ptr asym ?
0000000C                      C     mem_type		db ?
0000000D                      C     is_ptr		db ?
0000000E                      C     is_far		db ?
0000000F                      C     Ofssize		db ?
00000010                      C     ptr_memtype		db ?
                              C    .ends
00000011                    * C qualified_type ends
 = 1                            TEVALUE_UNSIGNED equ 1
 = 14                           MAX_TEXTMACRO_NESTING equ 20
                                .data
00000000                    *   _DATA segment
                            *   assume cs:ERROR
00000000  00000000               MacroLocals int_t 0
00000004  00000000               MacroLevel  dd 0
00000000                        .code
00000008                    *   _DATA ends
00000000                    *   _TEXT segment
                            *   assume cs:FLAT
00000000                        myltoa proc fastcall uses rsi rdi rbx value:qword, buffer:string_t, radix:uint_t, sign:int_t, addzero:int_t
00000000  4889542410        *   mov [rsp+16], rdx
00000005  56                *   push rsi
00000006  57                *   push rdi
00000007  53                *   push rbx
00000008  55                *   push rbp
00000009  488BEC            *   mov rbp, rsp
0000000C  4883EC68          *   sub rsp, 104
00000010  488BFA                    mov rdi,rdx
00000013  488BC1                    mov rax,rcx
00000016                            .if ( r9d )
00000016  4585C9            *   test ( r9d ), ( r9d )
00000019  740B              *   jz  @C0001
0000001B  C6072D                        mov byte ptr [rdi],'-'
0000001E  48FFC7                        inc rdi
00000021  48F7D8                        neg rax
00000024                            .elseif ( rax == 0 )
00000024  EB11              *   jmp @C0002
00000026                    *   @C0001:
00000026  4885C0            *   test rax , rax 
00000029  750C              *   jnz @C0003
0000002B  66C7073000                    mov word ptr [rdi],'0'
00000030                               .return 1
00000030  B801000000        *   mov eax,1
00000035  EB47              *   jmp @C0004
00000037                            .endif
00000037                    *   @C0003:
00000037                    *   @C0002:
00000037                            .for ( rsi = &tmpbuf[63] : rax : rsi-- )
00000037  488D75FF          *   lea rsi, tmpbuf[63]
0000003B                    *   @C0005:
0000003B  4885C0            *   test rax, rax
0000003E  7417              *   jz  @C0007
00000040  33D2                          xor edx,edx
00000042  49F7F0                        div r8
00000045  80C230                        add dl,'0'
00000048                                .if dl > '9'
00000048  80FA39            *   cmp dl , '9'
0000004B  7603              *   jna @C0008
0000004D  80C207                            add dl,'A'-'9'-1
00000050                                .endif
00000050                    *   @C0008:
00000050  8816                          mov [rsi],dl
00000052                            .endf
00000052                    *   @C0006:
00000052  48FFCE            *   dec rsi
00000055  EBE4              *   jmp @C0005
00000057                    *   @C0007:
00000057  48FFC6                    inc rsi
0000005A                            .if ( addzero && byte ptr [rsi] > '9' )
0000005A  837D4800          *   cmp addzero , 0
0000005E  740B              *   jz  @C0009
00000060  803E39            *   cmp byte ptr [rsi] , '9' 
00000063  7606              *   jna @C0009
00000065  C60730                        mov byte ptr [rdi],'0'
00000068  48FFC7                        inc rdi
0000006B                            .endif
0000006B                    *   @C0009:
0000006B  488D4D00                  lea rcx,tmpbuf[64]
0000006F  482BCE                    sub rcx,rsi
00000072  F3A4                      rep movsb
00000074  C60700                    mov byte ptr [rdi],0
00000077  488BC7                    mov rax,rdi
0000007A  482B4530                  sub rax,buffer
0000007E                            ret
0000007E                    *   @C0004:
0000007E  C9                *   leave
0000007F  5B                *   pop rbx
00000080  5F                *   pop rdi
00000081  5E                *   pop rsi
00000082  C3                *   retn 
00000083                        myltoa endp
00000083                        SkipMacro proc fastcall private tokenarray:token_t
00000083  48894C2408        *   mov [rsp+8], rcx
00000088  55                *   push rbp
00000089  488BEC            *   mov rbp, rsp
0000008C  4883EC30          *   sub rsp, 48
00000090                            mov buffer,alloca( ModuleInfo.max_line_len )
00000090                    *   invoke alloca, ModuleInfo.max_line_len 
00000090  8B0568010000      *   mov eax, ModuleInfo.max_line_len 
00000096  83C00F            *1  add     eax,16-1
00000099  83E0F0            *1  and     eax,-16
0000009C  482BE0            *1  sub     rsp,rax
0000009F  488D442420        *1  lea     rax,[rsp+@ReservedStack]
000000A4  488945F8          *   mov buffer, rax
000000A8                            .while GetTextLine( buffer )
000000A8  EB12              *   jmp @C000B
000000AA                    *   @C000A:
000000AA                    *   invoke Tokenize, buffer, 0, tokenarray, TOK_DEFAULT 
000000AA  4533C9            *    xor r9d, r9d
000000AD  4C8B4510          *    mov r8, tokenarray
000000B1  33D2              *    xor edx, edx
000000B3  488B4DF8          *    mov rcx, buffer
000000B7  E800000000        *    call Tokenize
000000BC                            .endw
000000BC                    *   @C000B:
000000BC                    *   invoke GetTextLine, buffer 
000000BC  488B4DF8          *    mov rcx, buffer 
000000C0  E800000000        *    call GetTextLine
000000C5  4885C0            *   test rax, rax
000000C8  75E0              *   jnz @C000A
000000CA                            ret
000000CA  C9                *   leave
000000CB  C3                *   retn 
000000CC                        SkipMacro endp
000000CC                        RunMacro proc fastcall uses rsi rdi rbx mac:dsym_t, idx:int_t, tokenarray:token_t,_out:string_t, mflags:int_t, is_exitm:ptr int_t
000000CC  48894C2408        *   mov [rsp+8], rcx
000000D1  4889542410        *   mov [rsp+16], rdx
000000D6  4C89442418        *   mov [rsp+24], r8
000000DB  4C894C2420        *   mov [rsp+32], r9
000000E0  56                *   push rsi
000000E1  57                *   push rdi
000000E2  53                *   push rbx
000000E3  55                *   push rbp
000000E4  488BEC            *   mov rbp, rsp
000000E7  4881EC98010000    *   sub rsp, 408
000000EE                            mov savedStringBuffer,ModuleInfo.stringbufferend
000000EE  488B0508020000    *    mov rax, ModuleInfo.stringbufferend
000000F5  488945F0          *    mov savedStringBuffer, rax
000000F9  C745E800000000            mov _retm,0
00000100                            .if idx > 1
00000100  837D3001          *   cmp idx , 1
00000104  7E03              *   jng @C000C
00000106  FF45E8                        inc _retm
00000109                            .endif
00000109                    *   @C000C:
00000109  C745D8FFFFFFFF            mov bracket_level,-1
00000110                            .return asmerr( 2123 ) .if MacroLevel == MAX_MACRO_NESTING
00000110  833D0000000064    *   cmp MacroLevel , MAX_MACRO_NESTING
00000117  750F              *   jnz @C000E
00000119                    *   invoke asmerr, 2123 
00000119  B94B080000        *    mov ecx, 2123 
0000011E  E800000000        *    call asmerr
00000123  E9D20E0000        *   jmp @C000D
00000128                    *   @C000E:
00000128  48C7852CFFFFFF0000        mov  mi.parm_array,NULL
00000133  488B7528                  mov  rsi,mac
00000137  488B7E5C                  mov  rdi,[rsi].macroinfo
0000013B  48897DB8                  mov  info,rdi
0000013F  6B5D3017                  imul ebx,idx,asm_tok
00000143  48035D38                  add  rbx,tokenarray
00000147  C745D400000000            mov parm_end_delim,T_FINAL
0000014E                            .if ( [rsi].mac_flag & M_ISFUNC )
0000014E  F6463402          *   test [rsi].mac_flag , M_ISFUNC 
00000152  7421              *   je  @C000F
00000154                                .if ( [rbx].token == T_OP_BRACKET );; should be always true
00000154  803B28            *   cmp [rbx].token , T_OP_BRACKET 
00000157  7515              *   jnz @C0010
00000159  FF4530                            inc idx
0000015C  4883C317                          add rbx,asm_tok
00000160  C745D429000000                    mov parm_end_delim,T_CL_BRACKET
00000167  C745D801000000                    mov bracket_level,1
0000016E                                .endif
0000016E                    *   @C0010:
0000016E  488B4540                      mov rax,_out
00000172  C60000                        mov byte ptr [rax],0
00000175                            .endif
00000175                    *   @C000F:
00000175                            .if ( [rsi].mac_flag & M_PURGED )
00000175  F6463410          *   test [rsi].mac_flag , M_PURGED 
00000179  743F              *   je  @C0011
0000017B                                .if ( bracket_level > 0 )
0000017B  837DD800          *   cmp bracket_level , 0 
0000017F  7E28              *   jng @C0012
00000181                                    .for ( : bracket_level && [rbx].token != T_FINAL: idx++, rbx += asm_tok )
00000181                    *   @C0013:
00000181  837DD800          *   cmp bracket_level , 0
00000185  7420              *   jz  @C0015
00000187  803B00            *   cmp [rbx].token , T_FINAL
0000018A  741B              *   jz  @C0015
0000018C                                        .if [rbx].token == T_OP_BRACKET
0000018C  803B28            *   cmp [rbx].token , T_OP_BRACKET
0000018F  7505              *   jnz @C0016
00000191  FF45D8                                    inc bracket_level
00000194                                        .elseif [rbx].token == T_CL_BRACKET
00000194  EB08              *   jmp @C0017
00000196                    *   @C0016:
00000196  803B29            *   cmp [rbx].token , T_CL_BRACKET
00000199  7503              *   jnz @C0018
0000019B  FF4DD8                                    dec bracket_level
0000019E                                        .endif
0000019E                    *   @C0018:
0000019E                    *   @C0017:
0000019E                                    .endf
0000019E                    *   @C0014:
0000019E  FF4530            *   inc idx
000001A1  4883C317          *   add rbx, asm_tok
000001A5  EBDA              *   jmp @C0013
000001A7                    *   @C0015:
000001A7                                .else
000001A7  EB09              *   jmp @C0019
000001A9                    *   @C0012:
000001A9                                    mov idx,ModuleInfo.token_count
000001A9  8B0510020000      *    mov eax, ModuleInfo.token_count
000001AF  894530            *    mov idx, eax
000001B2                                .endif
000001B2                    *   @C0019:
000001B2                                .return idx
000001B2  8B4530            *   mov eax,idx
000001B5  E9400E0000        *   jmp @C000D
000001BA                            .endif
000001BA                    *   @C0011:
000001BA                            .if [rdi].parmcnt
000001BA  66833F00          *   cmp [rdi].parmcnt, 0
000001BE  7433              *   jz  @C001A
000001C0  0FB70F                        movzx   ecx,[rdi].parmcnt
000001C3  8B0568010000                  mov     eax,ModuleInfo.max_line_len
000001C9  03C0                          add     eax,eax
000001CB  488D04C8                      lea     rax,[rax+rcx*size_t]
000001CF                                mov     mi.parm_array,alloca(eax)
000001CF                    *   invoke alloca, eax
000001CF  83C00F            *1  add     eax,16-1
000001D2  83E0F0            *1  and     eax,-16
000001D5  482BE0            *1  sub     rsp,rax
000001D8  488D442430        *1  lea     rax,[rsp+@ReservedStack]
000001DD  4889852CFFFFFF    *   mov     mi.parm_array, rax
000001E4  0FB70F                        movzx   ecx,[rdi].parmcnt
000001E7  488D04C8                      lea     rax,[rax+rcx*size_t]
000001EB  488945C0                      mov     parmstrings,rax
000001EF  488945F8                      mov     currparm,rax
000001F3                            .endif
000001F3                    *   @C001A:
000001F3  488B5D38                  mov rbx,tokenarray
000001F7  C745E400000000            mov parmidx,0
000001FE                            .if ( [rsi].mac_flag & M_LABEL )
000001FE  F6463404          *   test [rsi].mac_flag , M_LABEL 
00000202  7460              *   je  @C001B
00000204                                .if ( mflags & MF_LABEL )
00000204  F7454801000000    *   test mflags , MF_LABEL 
0000020B  743F              *   je  @C001C
0000020D                                    mov i,tstrlen( [rbx].string_ptr )
0000020D                    *   invoke tstrlen, [rbx].string_ptr 
0000020D  488B4B07          *    mov rcx, [rbx].string_ptr 
00000211  E800000000        *    call tstrlen
00000216  8945EC            *   mov i, eax
00000219  8B4DE4                            mov ecx,parmidx
0000021C  488B952CFFFFFF                    mov rdx,mi.parm_array
00000223  488B7DF8                          mov rdi,currparm
00000227  48893CCA                          mov [rdx+rcx*size_t],rdi
0000022B  8B4DEC                            mov ecx,i
0000022E  FFC1                              inc ecx
00000230  488B7307                          mov rsi,[rbx].string_ptr
00000234  F3A4                              rep movsb
00000236                                    mov currparm,GetAlignedPointer( currparm, i )
00000236                    *   invoke GetAlignedPointer, currparm, i 
00000236  8B55EC            *   mov edx, i 
00000239  488B45F8          *   mov rax, currparm
0000023D  83C208            *1  add edx,size_t
00000240  83E2F8            *1  and edx,not ( size_t - 1 )
00000243  4803C2            *1  add rax,rdx
00000246  488945F8          *   mov currparm, rax
0000024A                                .else
0000024A  EB15              *   jmp @C001D
0000024C                    *   @C001C:
0000024C  8B4DE4                            mov ecx,parmidx
0000024F  488B952CFFFFFF                    mov rdx,mi.parm_array
00000000                        .data
00000256                    *   _TEXT ends
00000008                    *   _DATA segment
                            *   assume cs:ERROR
00000008  00                     DS0000 sbyte 0
00000000                        .code
00000009                    *   _DATA ends
00000256                    *   _TEXT segment
                            *   assume cs:FLAT
00000256  488D0500000000                    lea rax,DS0000
0000025D  488904CA                          mov [rdx+rcx*size_t],rax
00000261                                .endif
00000261                    *   @C001D:
00000261  FF45E4                        inc parmidx
00000264                            .endif
00000264                    *   @C001B:
00000264  488B4550                  mov rax,is_exitm
00000268  C70000000000              mov dword ptr [rax],FALSE
0000026E  6B051002000017            imul eax,ModuleInfo.token_count,asm_tok
00000275  C744030300000000          mov  [rbx+rax].lastidx,0
0000027D  6B453017                  imul eax,idx,asm_tok
00000281  4803D8                    add  rbx,rax
00000284                            .for ( varargcnt = 0, skipcomma = 0 : : parmidx++ )
00000284  C745DC00000000    *   mov varargcnt, 0
0000028B  C745E000000000    *   mov skipcomma, 0
00000292                    *   @C001E:
00000292  488B7528                      mov rsi,mac
00000296  488B7DB8                      mov rdi,info
0000029A  0FB70F                        movzx ecx,[rdi].parmcnt
0000029D                                .break .if parmidx >= ecx
0000029D  394DE4            *   cmp parmidx , ecx
000002A0  0F8D11090000      *   jnl @C0020
000002A6  6B5D3017                      imul ebx,idx,asm_tok
000002AA  48035D38                      add  rbx,tokenarray
000002AE                                .if [rbx].token == T_COMMA && skipcomma
000002AE  803B2C            *   cmp [rbx].token , T_COMMA 
000002B1  750D              *   jnz @C0021
000002B3  837DE000          *   cmp skipcomma, 0
000002B7  7407              *   jz  @C0021
000002B9  FF4530                            inc idx
000002BC  4883C317                          add rbx,asm_tok
000002C0                                .endif
000002C0                    *   @C0021:
000002C0  C745E001000000                mov skipcomma,1
000002C7  FFC9                          dec ecx
000002C9                                .if ( [rbx].token == T_FINAL || [rbx].token == parm_end_delim ||( [rbx].token == T_COMMA &&( !( [rsi].mac_flag & M_ISVARARG ) || parmidx != ecx ) ) )
000002C9  803B00            *   cmp [rbx].token , T_FINAL 
000002CC  7417              *   jz  @C0023
000002CE                    *   @C0024:
000002CE                    *   cmp [rbx].token , parm_end_delim 
000002CE  8B45D4            *    mov eax,  parm_end_delim 
000002D1  3803              *    cmp [rbx].token , al
000002D3  7410              *   jz  @C0023
000002D5                    *   @C0025:
000002D5  803B2C            *   cmp [rbx].token , T_COMMA 
000002D8  7547              *   jnz @C0022
000002DA  F6463401          *   test [rsi].mac_flag , M_ISVARARG 
000002DE  7405              *   je  @C0023
000002E0                    *   @C0027:
000002E0  394DE4            *   cmp parmidx , ecx 
000002E3  743C              *   jz  @C0022
000002E5                    *   @C0023:
000002E5  6B45E409                          imul eax,parmidx,mparm_list
000002E9  488B4F04                          mov rcx,[rdi].parmlist
000002ED  4803C8                            add rcx,rax
000002F0                                    .if [rcx].mparm_list.required
000002F0  80790800          *   cmp [rcx].mparm_list.required, 0
000002F4  740F              *   jz  @C0028
000002F6                                        .return asmerr( 2125 )
000002F6                    *   invoke asmerr, 2125 
000002F6  B94D080000        *    mov ecx, 2125 
000002FB  E800000000        *    call asmerr
00000300  E9F50C0000        *   jmp @C000D
00000305                                    .endif
00000305                    *   @C0028:
00000305                                    .if varargcnt == 0
00000305  837DDC00          *   cmp varargcnt , 0
00000309  7511              *   jnz @C0029
0000030B  6B55E408                              imul edx,parmidx,ptr_t
0000030F  4803952CFFFFFF                        add rdx,mi.parm_array
00000316                                        mov [rdx],[rcx].mparm_list.deflt
00000316  488B01            *    mov rax, [rcx].mparm_list.deflt
00000319  488902            *    mov [rdx], rax
0000031C                                    .endif
0000031C                    *   @C0029:
0000031C                                .else
0000031C  E98E080000        *   jmp @C002A
00000321                    *   @C0022:
00000321  C785ECFEFFFF000000                mov inside_literal,0
0000032B  C785E8FEFFFF000000                mov inside_angle_brackets,0
00000335                                    mov old_tokencount,ModuleInfo.token_count
00000335  8B0510020000      *    mov eax, ModuleInfo.token_count
0000033B  8985E4FEFFFF      *    mov old_tokencount, eax
00000341  488B55F8                          mov rdx,currparm
00000345  C60200                            mov byte ptr [rdx],0
00000348                                    .for ( p = rdx : : idx++ )
00000348  488955C8          *   mov p, rdx
0000034C                    *   @C002B:
0000034C  6B5D3017                              imul ebx,idx,asm_tok
00000350  48035D38                              add  rbx,tokenarray
00000354                                        .break .if ( [rbx].token == T_FINAL || [rbx].token == T_COMMA ) && !inside_literal
00000354  803B00            *   cmp [rbx].token , T_FINAL 
00000357  7405              *   jz  @C002F
00000359  803B2C            *   cmp [rbx].token , T_COMMA 
0000035C  750D              *   jnz @C002E
0000035E                    *   @C002F:
0000035E  83BDECFEFFFF00    *   cmp inside_literal, 0
00000365  0F8456070000      *   jz  @C002D
0000036B                    *   @C002E:
0000036B                                        .if [rbx].token == T_FINAL
0000036B  803B00            *   cmp [rbx].token , T_FINAL
0000036E  7535              *   jnz @C0030
00000370                                            mov  idx,[rbx].lastidx
00000370  8B4303            *    mov eax, [rbx].lastidx
00000373  894530            *    mov idx, eax
00000376  6BD817                                    imul ebx,eax,asm_tok
00000379  48035D38                                  add  rbx,tokenarray
0000037D  FF8DECFEFFFF                              dec inside_literal
00000383                                            .if [rbx].string_delim == '<'
00000383  807B013C          *   cmp [rbx].string_delim , '<'
00000387  750C              *   jnz @C0031
00000389  C785E8FEFFFF000000                            mov inside_angle_brackets,0
00000393                                            .else
00000393  EB0B              *   jmp @C0032
00000395                    *   @C0031:
00000395  488B45C8                                      mov rax,p
00000399  48FF45C8                                      inc p
0000039D  C6007D                                        mov byte ptr [rax],'}'
000003A0                                            .endif
000003A0                    *   @C0032:
000003A0                                            .continue
000003A0  E914070000        *    jmp @C002C
000003A5                                        .endif
000003A5                    *   @C0030:
000003A5                                        .if ( [rbx].token == T_PERCENT )
000003A5  803B25            *   cmp [rbx].token , T_PERCENT 
000003A8  0F8502040000      *   jnz @C0033
000003AE  FF4530                                    inc idx
000003B1  4883C317                                  add rbx,asm_tok
000003B5                                            .while [rbx].token == T_PERCENT
000003B5  EB07              *   jmp @C0035
000003B7                    *   @C0034:
000003B7  FF4530                                        inc idx
000003BA  4883C317                                      add rbx,asm_tok
000003BE                                            .endw
000003BE                    *   @C0035:
000003BE  803B25            *   cmp [rbx].token , T_PERCENT
000003C1  74F4              *   jz  @C0034
000003C3                                            mov i,idx
000003C3  8B4530            *    mov eax, idx
000003C6  8945EC            *    mov i, eax
000003C9  C785D8FEFFFF010000                        mov cnt_opnum,1
000003D3                                            .if [rbx].token == T_ID
000003D3  803B08            *   cmp [rbx].token , T_ID
000003D6  753A              *   jnz @C0036
000003D8                                                mov sym,SymFind([rbx].string_ptr)
000003D8                    *   invoke SymFind, [rbx].string_ptr
000003D8  488B4B07          *    mov rcx, [rbx].string_ptr
000003DC  E800000000        *    call SymFind
000003E1  488945A8          *   mov sym, rax
000003E5                                                .if ( rax && [rax].asym.flags & S_ISDEFINED && ( [rax].asym.state == SYM_TMACRO ||( [rax].asym.state == SYM_MACRO && ( [rax].asym.mac_flag & M_ISFUNC ) &&[rbx+asm_tok].token == T_OP_BRACKET ) ) )
000003E5  4885C0            *   test rax , rax 
000003E8  7428              *   jz  @C0037
000003EA  F6401702          *   test [rax].asym.flags , S_ISDEFINED 
000003EE  7422              *   je  @C0037
000003F0  8078140A          *   cmp [rax].asym.state , SYM_TMACRO 
000003F4  7412              *   jz  @C0038
000003F6                    *   @C0039:
000003F6  80781409          *   cmp [rax].asym.state , SYM_MACRO 
000003FA  7516              *   jnz @C0037
000003FC  F6403402          *   test [rax].asym.mac_flag , M_ISFUNC 
00000400  7410              *   je  @C0037
00000402  807B1728          *   cmp [rbx+asm_tok].token , T_OP_BRACKET 
00000406  750A              *   jnz @C0037
00000408                    *   @C0038:
00000408  C785D8FEFFFF000000                                mov cnt_opnum,0
00000412                                                .endif
00000412                    *   @C0037:
00000412                                            .endif
00000412                    *   @C0036:
00000412                                            .for ( cnt = 0 :: i++ )
00000412  C785DCFEFFFF000000*   mov cnt, 0
0000041C                    *   @C003A:
0000041C  6B5DEC17                                      imul ebx,i,asm_tok
00000420  48035D38                                      add  rbx,tokenarray
00000424                                                .break .if [rbx].token == T_FINAL || [rbx].token == T_COMMA
00000424  803B00            *   cmp [rbx].token , T_FINAL 
00000427  0F84B0000000      *   jz  @C003C
0000042D  803B2C            *   cmp [rbx].token , T_COMMA
00000430  0F84A7000000      *   jz  @C003C
00000436  488B4B07                                      mov rcx,[rbx].string_ptr
0000043A                                                .if ( isdotlabel( [rcx], ModuleInfo.dotname ) )
0000043A                    *   invoke isdotlabel, [rcx], ModuleInfo.dotname 
0000043A  0FB615B0010000    *    movzx edx, byte ptr ModuleInfo.dotname 
00000441  0FB601            *    movzx eax, byte ptr [rcx]
00000444  3C2E              *   cmp al , '.' 
00000446  7504              *   jnz @C003F
00000448  84D2              *   test dl, dl
0000044A  7508              *   jnz @C003E
0000044C                    *   @C003F:
0000044C  41F644070140      *   test byte ptr [r15+rax+1] , _LABEL
00000452  743A              *   je  @C003D
00000454                    *   @C003E:
00000454                                                    .if ( [rbx+asm_tok].token == T_OP_BRACKET )
00000454  807B1728          *   cmp [rbx+asm_tok].token , T_OP_BRACKET 
00000458  7532              *   jnz @C0040
0000045A  8345EC02                                              add i,2
0000045E  4883C32E                                              add rbx,asm_tok*2
00000462                                                        .for ( ecx = 1: ecx && [rbx].token != T_FINAL: i++, rbx += asm_tok )
00000462  B901000000        *   mov ecx, 1
00000467                    *   @C0041:
00000467  85C9              *   test ecx , ecx 
00000469  741E              *   jz  @C0043
0000046B  803B00            *   cmp [rbx].token , T_FINAL
0000046E  7419              *   jz  @C0043
00000470                                                            .if [rbx].token == T_OP_BRACKET
00000470  803B28            *   cmp [rbx].token , T_OP_BRACKET
00000473  7504              *   jnz @C0044
00000475  FFC1                                                          inc ecx
00000477                                                            .elseif [rbx].token == T_CL_BRACKET
00000477  EB07              *   jmp @C0045
00000479                    *   @C0044:
00000479  803B29            *   cmp [rbx].token , T_CL_BRACKET
0000047C  7502              *   jnz @C0046
0000047E  FFC9                                                          dec ecx
00000480                                                            .endif
00000480                    *   @C0046:
00000480                    *   @C0045:
00000480                                                        .endf
00000480                    *   @C0042:
00000480  FF45EC            *   inc i
00000483  4883C317          *   add rbx, asm_tok
00000487  EBDE              *   jmp @C0041
00000489                    *   @C0043:
00000489  FF4DEC                                                dec i
0000048C                                                    .endif
0000048C                    *   @C0040:
0000048C                                                    .continue
0000048C  EB47              *    jmp @C003B
0000048E                                                .endif
0000048E                    *   @C003D:
0000048E                                                .if parm_end_delim == T_CL_BRACKET
0000048E  837DD429          *   cmp parm_end_delim , T_CL_BRACKET
00000492  7521              *   jnz @C0047
00000494                                                    .if [rbx].token == T_OP_BRACKET
00000494  803B28            *   cmp [rbx].token , T_OP_BRACKET
00000497  7508              *   jnz @C0048
00000499  FF85DCFEFFFF                                          inc cnt
0000049F                                                    .elseif [rbx].token == T_CL_BRACKET
0000049F  EB14              *   jmp @C0049
000004A1                    *   @C0048:
000004A1  803B29            *   cmp [rbx].token , T_CL_BRACKET
000004A4  750F              *   jnz @C004A
000004A6                                                        .break .if cnt == 0
000004A6  83BDDCFEFFFF00    *   cmp cnt , 0
000004AD  742E              *   jz  @C003C
000004AF  FF8DDCFEFFFF                                          dec cnt
000004B5                                                    .endif
000004B5                    *   @C004A:
000004B5                    *   @C0049:
000004B5                                                .endif
000004B5                    *   @C0047:
000004B5                                                .break .if ( [rbx].token == T_STRING && [rbx].string_delim == 0 )
000004B5  803B09            *   cmp [rbx].token , T_STRING 
000004B8  7506              *   jnz @C004B
000004BA                    *   @C004C:
000004BA  807B0100          *   cmp [rbx].string_delim , 0 
000004BE  741D              *   jz  @C003C
000004C0                    *   @C004B:
000004C0                                                .if !( [rbx].token == T_DOT || [rbx].token == '&' || [rbx].token == '%' )
000004C0  803B2E            *   cmp [rbx].token , T_DOT 
000004C3  7410              *   jz  @C004D
000004C5  803B26            *   cmp [rbx].token , '&' 
000004C8  740B              *   jz  @C004D
000004CA  803B25            *   cmp [rbx].token , '%' 
000004CD  7406              *   jz  @C004D
000004CF  FF85D8FEFFFF                                      inc cnt_opnum
000004D5                                                .endif
000004D5                    *   @C004D:
000004D5                                            .endf
000004D5                    *   @C003B:
000004D5  FF45EC            *   inc i
000004D8  E93FFFFFFF        *   jmp @C003A
000004DD                    *   @C003C:
000004DD                                            .if i == idx;;; no items except %?
000004DD                    *   cmp i , idx
000004DD  8B4530            *    mov eax,  idx
000004E0  3945EC            *    cmp i , eax
000004E3  7508              *   jnz @C004E
000004E5  FF4D30                                        dec idx
000004E8                                                .continue
000004E8  E9CC050000        *    jmp @C002C
000004ED                                            .endif
000004ED                    *   @C004E:
000004ED  488B4B0F                                  mov   rcx,[rbx].tokpos
000004F1  6B5D3017                                  imul  ebx,idx,asm_tok
000004F5  48035D38                                  add   rbx,tokenarray
000004F9  488B730F                                  mov   rsi,[rbx].tokpos
000004FD  482BCE                                    sub   rcx,rsi
00000500                                            .while islspace( [rsi+rcx-1] )
00000500  EB02              *   jmp @C0050
00000502                    *   @C004F:
00000502  FFC9                                          dec ecx
00000504                                            .endw
00000504                    *   @C0050:
00000504                    *   invoke islspace, [rsi+rcx-1] 
00000504  0FB6440EFF        *    movzx eax, byte ptr [rsi+rcx-1] 
00000509  41F644070108      *   test byte ptr [r15+rax+1] , _SPACE
0000050F  75F1              *   jne @C004F
00000511  898DDCFEFFFF                              mov cnt,ecx
00000517  488B7DC8                                  mov rdi,p
0000051B  F3A4                                      rep movsb
0000051D  C60700                                    mov byte ptr [rdi],0
00000520                                            .ifd ExpandText( p, tokenarray, FALSE ) == ERROR
00000520                    *   invoke ExpandText, p, tokenarray, FALSE 
00000520  4533C0            *    xor r8d, r8d
00000523  488B5538          *    mov rdx, tokenarray
00000527  488B4DC8          *    mov rcx, p
0000052B  E8880B0000        *    call ExpandText
00000530  83F8FF            *   cmp eax , ERROR
00000533  7510              *   jnz @C0051
00000535  488B4DF0                                      mov rcx,savedStringBuffer
00000539  48890D08020000                                mov ModuleInfo.stringbufferend,rcx
00000540                                               .return
00000540  E9B50A0000        *   jmp @C000D
00000545                                            .endif
00000545                    *   @C0051:
00000545                                            mov idx,i
00000545  8B45EC            *    mov eax, i
00000548  894530            *    mov idx, eax
0000054B  FF4D30                                    dec idx
0000054E                                            .if cnt_opnum
0000054E  83BDD8FEFFFF00    *   cmp cnt_opnum, 0
00000555  0F8443020000      *   jz  @C0052
0000055B  8B1510020000                                  mov edx,ModuleInfo.token_count
00000561  FFC2                                          inc edx
00000563                                                mov max,Tokenize( p, edx, tokenarray, TOK_RESCAN )
00000563                    *   invoke Tokenize, p, edx, tokenarray, TOK_RESCAN 
00000563  41B901000000      *    mov r9d, TOK_RESCAN 
00000569  4C8B4538          *    mov r8, tokenarray
0000056D  488B4DC8          *    mov rcx, p
00000571  E800000000        *    call Tokenize
00000576  8985E0FEFFFF      *   mov max, eax
0000057C                                                mov i,ModuleInfo.token_count
0000057C  8B0510020000      *    mov eax, ModuleInfo.token_count
00000582  8945EC            *    mov i, eax
00000585  FF45EC                                        inc i
00000588                                                .ifd EvalOperand( &i, tokenarray, max, &opndx, EXPF_NOUNDEF ) == ERROR
00000588                    *   invoke EvalOperand, addr i, tokenarray, max, addr opndx, EXPF_NOUNDEF 
00000588  C644242002        *    mov byte ptr [rsp+32], EXPF_NOUNDEF 
0000058D  4C8D8D40FFFFFF    *    lea r9, opndx
00000594  448B85E0FEFFFF    *    mov r8d, max
0000059B  488B5538          *    mov rdx, tokenarray
0000059F  488D4DEC          *    lea rcx, i
000005A3  E800000000        *    call EvalOperand
000005A8  83F8FF            *   cmp eax , ERROR
000005AB  7516              *   jnz @C0053
000005AD  C78540FFFFFF000000                                mov opndx.value,0
000005B7  C78544FFFFFF000000                                mov opndx.hvalue,0
000005C1                                                .elseif ( opndx.kind != EXPR_CONST &&!( opndx.kind == EXPR_FLOAT && opndx.mem_type == MT_REAL16 ) )
000005C1  EB36              *   jmp @C0054
000005C3                    *   @C0053:
000005C3  83BD7CFFFFFF00    *   cmp opndx.kind , EXPR_CONST 
000005CA  742D              *   jz  @C0055
000005CC  83BD7CFFFFFF03    *   cmp opndx.kind , EXPR_FLOAT 
000005D3  7506              *   jnz @C0056
000005D5                    *   @C0057:
000005D5  807D802F          *   cmp opndx.mem_type , MT_REAL16 
000005D9  741E              *   jz  @C0055
000005DB                    *   @C0056:
000005DB                    *   invoke asmerr, 2026 
000005DB  B9EA070000        *    mov ecx, 2026 
000005E0  E800000000        *    call asmerr
000005E5  C78540FFFFFF000000                                mov opndx.value,0
000005EF  C78544FFFFFF000000                                mov opndx.hvalue,0
000005F9                                                .endif
000005F9                    *   @C0055:
000005F9                    *   @C0054:
000005F9                                                .if opndx.kind == EXPR_CONST
000005F9  83BD7CFFFFFF00    *   cmp opndx.kind , EXPR_CONST
00000600  7537              *   jnz @C0058
00000602  33C0                                              xor eax,eax
00000604  83BD44FFFFFF00                                    cmp opndx.hvalue,0
0000060B  0F9CC0                                            setl al
0000060E                    *   invoke myltoa, opndx.llvalue, ModuleInfo.stringbufferend, ModuleInfo.radix, eax, FALSE 
0000060E  C744242000000000  *    mov dword ptr [rsp+32], FALSE 
00000616  448BC8            *    mov r9d, eax
00000619  440FB605A0010000  *    movzx r8d, ModuleInfo.radix
00000621  488B1508020000    *    mov rdx, ModuleInfo.stringbufferend
00000628  488B8D40FFFFFF    *    mov rcx, opndx.llvalue
0000062F  E8CCF9FFFF        *    call myltoa
00000634                                                .elseif ( opndx.kind == EXPR_FLOAT && opndx.mem_type == MT_REAL16 )
00000634  E932010000        *   jmp @C0059
00000639                    *   @C0058:
00000639  83BD7CFFFFFF03    *   cmp opndx.kind , EXPR_FLOAT 
00000640  0F8525010000      *   jnz @C005A
00000646  807D802F          *   cmp opndx.mem_type , MT_REAL16 
0000064A  0F851B010000      *   jnz @C005A
00000650                                                    .if ( ( opndx.value == 16 && opndx.h64_h == 0 ) )
00000650  83BD40FFFFFF10    *   cmp opndx.value , 16 
00000657  7521              *   jnz @C005B
00000659  83BD4CFFFFFF00    *   cmp opndx.h64_h , 0 
00000660  7518              *   jnz @C005B
00000000                        .data
00000662                    *   _TEXT ends
00000009                    *   _DATA segment
                            *   assume cs:ERROR
00000009  313600                 DS0001 sbyte "16",0
0000000C                        _DATA ends
00000662                        _TEXT segment
00000662                    *   invoke tstrcpy, ModuleInfo.stringbufferend, addr DS0001
00000662  488D1500000000    *    lea rdx, DS0001
00000669  488B0D08020000    *    mov rcx, ModuleInfo.stringbufferend
00000670  E800000000        *    call tstrcpy
00000675                                                    .elseif ( ModuleInfo.floatformat == 'x' )
00000675  E9F1000000        *   jmp @C005C
0000067A                    *   @C005B:
0000067A  803D3C03000078    *   cmp ModuleInfo.floatformat , 'x' 
00000681  7526              *   jnz @C005D
00000000                        .data
00000683                    *   _TEXT ends
0000000C                    *   _DATA segment
                            *   assume cs:ERROR
0000000C  2531366C782531366C     DS0002 sbyte "%16lx%16lx",0
00000017                        _DATA ends
00000683                        _TEXT segment
00000683                    *   invoke tsprintf, ModuleInfo.stringbufferend, addr DS0002 , opndx.hlvalue, opndx.llvalue 
00000683  4C8B8D40FFFFFF    *    mov r9, opndx.llvalue 
0000068A  4C8B8548FFFFFF    *    mov r8, opndx.hlvalue
00000691  488D1500000000    *    lea rdx, DS0002 
00000698  488B0D08020000    *    mov rcx, ModuleInfo.stringbufferend
0000069F  E800000000        *    call tsprintf
000006A4                                                    .else
000006A4  E9C2000000        *   jmp @C005C
000006A9                    *   @C005D:
000006A9  C785ACFEFFFF650000                                    mov cvt.expchar,'e'
000006B3  C785B0FEFFFF030000                                    mov cvt.expwidth,3
000006BD                                                        mov cvt.ndigits,ModuleInfo.floatdigits
000006BD  8B0538030000      *    mov eax, ModuleInfo.floatdigits
000006C3  8985A0FEFFFF      *    mov cvt.ndigits, eax
000006C9                                                        mov cvt.bufsize,ModuleInfo.max_line_len
000006C9  8B0568010000      *    mov eax, ModuleInfo.max_line_len
000006CF  8985CCFEFFFF      *    mov cvt.bufsize, eax
000006D5                                                        .if ( ModuleInfo.floatformat == 'e' )
000006D5  803D3C03000065    *   cmp ModuleInfo.floatformat , 'e' 
000006DC  7516              *   jnz @C005E
000006DE  C785A4FEFFFF010000                                        mov cvt.scale,1
000006E8  C785A8FEFFFF001000                                        mov cvt.flags,_ST_E
000006F2                                                        .elseif ( ModuleInfo.floatformat == 'g' )
000006F2  EB33              *   jmp @C005F
000006F4                    *   @C005E:
000006F4  803D3C03000067    *   cmp ModuleInfo.floatformat , 'g' 
000006FB  7516              *   jnz @C0060
000006FD  C785A4FEFFFF010000                                        mov cvt.scale,1
00000707  C785A8FEFFFF004000                                        mov cvt.flags,_ST_G
00000711                                                        .else
00000711  EB14              *   jmp @C005F
00000713                    *   @C0060:
00000713  C785A4FEFFFF000000                                        mov cvt.scale,0
0000071D  C785A8FEFFFF002000                                        mov cvt.flags,_ST_F
00000727                                                        .endif
00000727                    *   @C005F:
00000727  488B3508020000                                        mov rsi,ModuleInfo.stringbufferend
0000072E  48FFC6                                                inc rsi
00000731                    *   invoke _flttostr, addr opndx, addr cvt, rsi, _ST_QUADFLOAT 
00000731  41B900002000      *    mov r9d, _ST_QUADFLOAT 
00000737  4C8BC6            *    mov r8, rsi
0000073A  488D95A0FEFFFF    *    lea rdx, cvt
00000741  488D8D40FFFFFF    *    lea rcx, opndx
00000748  E800000000        *    call _flttostr
0000074D                                                        .if ( cvt.sign == -1 )
0000074D  83BDB4FEFFFFFF    *   cmp cvt.sign , -1 
00000754  7506              *   jnz @C0061
00000756  C646FF2D                                                  mov byte ptr [rsi-1],'-'
0000075A                                                        .else
0000075A  EB0F              *   jmp @C0062
0000075C                    *   @C0061:
0000075C                    *   invoke tstrcpy, ModuleInfo.stringbufferend, rsi 
0000075C  488BD6            *    mov rdx, rsi 
0000075F  488B0D08020000    *    mov rcx, ModuleInfo.stringbufferend
00000766  E800000000        *    call tstrcpy
0000076B                                                        .endif
0000076B                    *   @C0062:
0000076B                                                    .endif
0000076B                    *   @C005C:
0000076B                                                .endif
0000076B                    *   @C005A:
0000076B                    *   @C0059:
0000076B                                                .if ( i != max )
0000076B                    *   cmp i , max 
0000076B  8B85E0FEFFFF      *    mov eax,  max 
00000771  3945EC            *    cmp i , eax
00000774  7418              *   jz  @C0063
00000776  6B5DEC17                                          imul ebx,i,asm_tok
0000077A  48035D38                                          add  rbx,tokenarray
0000077E                    *   invoke tstrcat, ModuleInfo.stringbufferend, [rbx].tokpos 
0000077E  488B530F          *    mov rdx, [rbx].tokpos 
00000782  488B0D08020000    *    mov rcx, ModuleInfo.stringbufferend
00000789  E800000000        *    call tstrcat
0000078E                                                .endif
0000078E                    *   @C0063:
0000078E                    *   invoke tstrcpy, p, ModuleInfo.stringbufferend 
0000078E  488B1508020000    *    mov rdx, ModuleInfo.stringbufferend 
00000795  488B4DC8          *    mov rcx, p
00000799  E800000000        *    call tstrcpy
0000079E                                            .endif
0000079E                    *   @C0052:
0000079E                                            add p,tstrlen( p )
0000079E                    *   invoke tstrlen, p 
0000079E  488B4DC8          *    mov rcx, p 
000007A2  E800000000        *    call tstrlen
000007A7  480145C8          *   add p, rax
000007AB                                            .continue
000007AB  E909030000        *    jmp @C002C
000007B0                                        .endif
000007B0                    *   @C0033:
000007B0  6B5D3017                              imul ebx,idx,asm_tok
000007B4  48035D38                              add  rbx,tokenarray
000007B8                                        .if ( [rbx].token == T_STRING && [rbx].string_delim == '{' )
000007B8  803B09            *   cmp [rbx].token , T_STRING 
000007BB  754E              *   jnz @C0064
000007BD  807B017B          *   cmp [rbx].string_delim , '{' 
000007C1  7548              *   jnz @C0064
000007C3  488B4B07                                  mov rcx,[rbx].string_ptr
000007C7  8B5D30                                    mov ebx,idx
000007CA  488B45C8                                  mov rax,p
000007CE  48FF45C8                                  inc p
000007D2  C6007B                                    mov byte ptr [rax],'{'
000007D5  FF85ECFEFFFF                              inc inside_literal
000007DB                                            mov idx,ModuleInfo.token_count
000007DB  8B0510020000      *    mov eax, ModuleInfo.token_count
000007E1  894530            *    mov idx, eax
000007E4                                            mov ModuleInfo.token_count,Tokenize( rcx, &[rax+1], tokenarray, TOK_RESCAN or TOK_NOCURLBRACES )
000007E4                    *   invoke Tokenize, rcx, addr [rax+1], tokenarray, TOK_RESCAN or TOK_NOCURLBRACES 
000007E4  41B903000000      *    mov r9d, TOK_RESCAN or TOK_NOCURLBRACES 
000007EA  4C8B4538          *    mov r8, tokenarray
000007EE  8D5001            *    lea edx, [rax+1]
000007F1  E800000000        *    call Tokenize
000007F6  890510020000      *   mov ModuleInfo.token_count, eax
000007FC  6BC017                                    imul eax,eax,asm_tok
000007FF  48034538                                  add rax,tokenarray
00000803  895803                                    mov [rax].asm_tok.lastidx,ebx
00000806                                            .continue
00000806  E9AE020000        *    jmp @C002C
0000080B                                        .endif
0000080B                    *   @C0064:
0000080B                                        .if inside_angle_brackets == 0
0000080B  83BDE8FEFFFF00    *   cmp inside_angle_brackets , 0
00000812  0F853A020000      *   jnz @C0065
00000818                                            .if bracket_level > 0
00000818  837DD800          *   cmp bracket_level , 0
0000081C  7E18              *   jng @C0066
0000081E                                                .if [rbx].token == T_OP_BRACKET
0000081E  803B28            *   cmp [rbx].token , T_OP_BRACKET
00000821  7505              *   jnz @C0067
00000823  FF45D8                                            inc bracket_level
00000826                                                .elseif [rbx].token == T_CL_BRACKET
00000826  EB0E              *   jmp @C0068
00000828                    *   @C0067:
00000828  803B29            *   cmp [rbx].token , T_CL_BRACKET
0000082B  7509              *   jnz @C0069
0000082D  FF4DD8                                            dec bracket_level
00000830                                                    .break .ifz;;; ( bracket_level == 0 )
00000830  0F848B020000      *   je  @C002D
00000836                                                .endif
00000836                    *   @C0069:
00000836                    *   @C0068:
00000836                                            .endif
00000836                    *   @C0066:
00000836                                            .if ( [rbx].token == T_STRING && [rbx].string_delim == '<' && inside_angle_brackets == 0 )
00000836  803B09            *   cmp [rbx].token , T_STRING 
00000839  0F85BC000000      *   jnz @C006A
0000083F  807B013C          *   cmp [rbx].string_delim , '<' 
00000843  0F85B2000000      *   jnz @C006A
00000849  83BDE8FEFFFF00    *   cmp inside_angle_brackets , 0 
00000850  0F85A5000000      *   jnz @C006A
00000856  488B730F                                      mov rsi,[rbx].tokpos
0000085A  48FFC6                                        inc rsi
0000085D  488B4B26                                      mov rcx,[rbx+asm_tok].tokpos
00000861  482BCE                                        sub rcx,rsi
00000864  8BD1                                          mov edx,ecx
00000866  488B3D08020000                                mov rdi,ModuleInfo.stringbufferend
0000086D  F3A4                                          rep movsb
0000086F  488B3D08020000                                mov rdi,ModuleInfo.stringbufferend
00000876                                                .while byte ptr [rdi+rdx-1] != '>'
00000876  EB02              *   jmp @C006C
00000878                    *   @C006B:
00000878  FFCA                                              dec edx
0000087A                                                .endw
0000087A                    *   @C006C:
0000087A  807C17FF3E        *   cmp byte ptr [rdi+rdx-1] , '>'
0000087F  75F7              *   jnz @C006B
00000881  C64417FF00                                    mov byte ptr [rdi+rdx-1],0
00000886                                                mov ModuleInfo.stringbufferend,GetAlignedPointer( rdi, edx )
00000886                    *   invoke GetAlignedPointer, rdi, edx 
00000886  488BC7            *    mov rax, rdi
00000889  83C208            *1  add edx,size_t
0000088C  83E2F8            *1  and edx,not ( size_t - 1 )
0000088F  4803C2            *1  add rax,rdx
00000892  48890508020000    *   mov ModuleInfo.stringbufferend, rax
00000899  FF85ECFEFFFF                                  inc inside_literal
0000089F  C785E8FEFFFF010000                            mov inside_angle_brackets,1
000008A9  8B5D30                                        mov ebx,idx
000008AC                                                mov idx,ModuleInfo.token_count
000008AC  8B0510020000      *    mov eax, ModuleInfo.token_count
000008B2  894530            *    mov idx, eax
000008B5                                                mov ModuleInfo.token_count,Tokenize( rdi, &[rax+1], tokenarray, TOK_RESCAN )
000008B5                    *   invoke Tokenize, rdi, addr [rax+1], tokenarray, TOK_RESCAN 
000008B5  41B901000000      *    mov r9d, TOK_RESCAN 
000008BB  4C8B4538          *    mov r8, tokenarray
000008BF  8D5001            *    lea edx, [rax+1]
000008C2  488BCF            *    mov rcx, rdi
000008C5  E800000000        *    call Tokenize
000008CA  890510020000      *   mov ModuleInfo.token_count, eax
000008D0  6BC017                                        imul eax,eax,asm_tok
000008D3  48034538                                      add rax,tokenarray
000008D7  895803                                        mov [rax].asm_tok.lastidx,ebx
000008DA  6B5D3017                                      imul ebx,idx,asm_tok
000008DE  48035D38                                      add rbx,tokenarray
000008E2  488B4B26                                      mov rcx,[rbx+asm_tok].tokpos
000008E6  482BCF                                        sub rcx,rdi
000008E9  488BF7                                        mov rsi,rdi
000008EC  488B7DC8                                      mov rdi,p
000008F0  F3A4                                          rep movsb
000008F2  48897DC8                                      mov p,rdi
000008F6                                                .continue
000008F6  E9BE010000        *    jmp @C002C
000008FB                                            .endif
000008FB                    *   @C006A:
000008FB                                            .if ( [rbx].token == T_ID )
000008FB  803B08            *   cmp [rbx].token , T_ID 
000008FE  0F854E010000      *   jnz @C006D
00000904                                                .if SymFind([rbx].string_ptr)
00000904                    *   invoke SymFind, [rbx].string_ptr
00000904  488B4B07          *    mov rcx, [rbx].string_ptr
00000908  E800000000        *    call SymFind
0000090D  4885C0            *   test rax, rax
00000910  0F843C010000      *   jz  @C006E
00000916  488945A8                                          mov sym,rax
0000091A                                                    .if ( [rax].asym.state == SYM_MACRO && [rax].asym.flags & S_ISDEFINED &&[rax].asym.mac_flag & M_ISFUNC && [rbx+asm_tok].token == T_OP_BRACKET )
0000091A  80781409          *   cmp [rax].asym.state , SYM_MACRO 
0000091E  0F85AD000000      *   jnz @C006F
00000924  F6401702          *   test [rax].asym.flags , S_ISDEFINED 
00000928  0F84A3000000      *   je  @C006F
0000092E  F6403402          *   test [rax].asym.mac_flag , M_ISFUNC 
00000932  0F8499000000      *   je  @C006F
00000938  807B1728          *   cmp [rbx+asm_tok].token , T_OP_BRACKET 
0000093C  0F858F000000      *   jnz @C006F
00000942  FF4530                                                inc idx
00000945                                                        mov idx,RunMacro( sym, idx, tokenarray, p, 0, &is_exitm2 )
00000945                    *   invoke RunMacro, sym, idx, tokenarray, p, 0, addr is_exitm2 
00000945  488D85D4FEFFFF    *    lea rax, is_exitm2 
0000094C  4889442428        *    mov [rsp+40], rax
00000951  C744242000000000  *    mov dword ptr [rsp+32], 0
00000959  4C8B4DC8          *    mov r9, p
0000095D  4C8B4538          *    mov r8, tokenarray
00000961  8B5530            *    mov edx, idx
00000964  488B4DA8          *    mov rcx, sym
00000968  E85FF7FFFF        *    call RunMacro
0000096D  894530            *   mov idx, eax
00000970                                                        .if idx < 0
00000970  837D3000          *   cmp idx , 0
00000974  7D13              *   jnl @C0070
00000976                                                            mov ModuleInfo.stringbufferend,savedStringBuffer
00000976  488B45F0          *    mov rax, savedStringBuffer
0000097A  48890508020000    *    mov ModuleInfo.stringbufferend, rax
00000981                                                            .return idx
00000981  8B4530            *   mov eax,idx
00000984  E971060000        *   jmp @C000D
00000989                                                        .endif
00000989                    *   @C0070:
00000989                                                        add p,tstrlen(p)
00000989                    *   invoke tstrlen, p
00000989  488B4DC8          *    mov rcx, p
0000098D  E800000000        *    call tstrlen
00000992  480145C8          *   add p, rax
00000996  6B5D3017                                              imul ebx,idx,asm_tok
0000099A  48035D38                                              add  rbx,tokenarray
0000099E                                                        .if [rbx].token != T_FINAL && [rbx].token != T_COMMA
0000099E  803B00            *   cmp [rbx].token , T_FINAL 
000009A1  741D              *   jz  @C0071
000009A3  803B2C            *   cmp [rbx].token , T_COMMA
000009A6  7418              *   jz  @C0071
000009A8  488B73F8                                                  mov rsi,[rbx-asm_tok].tokpos
000009AC  48FFC6                                                    inc rsi
000009AF  488B4B0F                                                  mov rcx,[rbx].tokpos
000009B3  482BCE                                                    sub rcx,rsi
000009B6  488B7DC8                                                  mov rdi,p
000009BA  F3A4                                                      rep movsb
000009BC  48897DC8                                                  mov p,rdi
000009C0                                                        .endif
000009C0                    *   @C0071:
000009C0  FF4D30                                                dec idx
000009C3  4883EB17                                              sub rbx,asm_tok
000009C7                                                        .continue
000009C7  E9ED000000        *    jmp @C002C
000009CC                                                    .elseif ( [rax].asym.state == SYM_TMACRO && [rax].asym.flags & S_ISDEFINED )
000009CC  E981000000        *   jmp @C0072
000009D1                    *   @C006F:
000009D1  8078140A          *   cmp [rax].asym.state , SYM_TMACRO 
000009D5  757B              *   jnz @C0073
000009D7  F6401702          *   test [rax].asym.flags , S_ISDEFINED 
000009DB  7475              *   je  @C0073
000009DD  8B4DE4                                                mov ecx,parmidx
000009E0  BA01000000                                            mov edx,1
000009E5  D3E2                                                  shl edx,cl
000009E7  488B7DB8                                              mov rdi,info
000009EB  488B7528                                              mov rsi,mac
000009EF                                                        .if ( [rsi].flags & S_PREDEFINED && ( [rdi].autoexp & dx ) )
000009EF  F6461720          *   test [rsi].flags , S_PREDEFINED 
000009F3  745D              *   je  @C0074
000009F5  66855702          *   test [rdi].autoexp , dx 
000009F9  7457              *   je  @C0074
000009FB                    *   invoke tstrcpy, p, [rax].asym.string_ptr 
000009FB  488B5024          *    mov rdx, [rax].asym.string_ptr 
000009FF  488B4DC8          *    mov rcx, p
00000A03  E800000000        *    call tstrcpy
00000A08                    *   invoke ExpandTMacro, p, tokenarray, FALSE, 0 
00000A08  4533C9            *    xor r9d, r9d
00000A0B  4533C0            *    xor r8d, r8d
00000A0E  488B5538          *    mov rdx, tokenarray
00000A12  488B4DC8          *    mov rcx, p
00000A16  E8A10A0000        *    call ExpandTMacro
00000A1B                                                            add p,tstrlen( p )
00000A1B                    *   invoke tstrlen, p 
00000A1B  488B4DC8          *    mov rcx, p 
00000A1F  E800000000        *    call tstrlen
00000A24  480145C8          *   add p, rax
00000A28                                                            .if ( [rbx+asm_tok].token != T_FINAL && [rbx+asm_tok].token != T_COMMA )
00000A28  807B1700          *   cmp [rbx+asm_tok].token , T_FINAL 
00000A2C  7422              *   jz  @C0075
00000A2E  807B172C          *   cmp [rbx+asm_tok].token , T_COMMA 
00000A32  741C              *   jz  @C0075
00000A34  488B55A8                                                      mov rdx,sym
00000A38  8B7210                                                        mov esi,[rdx].asym.name_size
00000A3B  4803730F                                                      add rsi,[rbx].tokpos
00000A3F  488B4B26                                                      mov rcx,[rbx+asm_tok].tokpos
00000A43  482BCE                                                        sub rcx,rsi
00000A46  488B7DC8                                                      mov rdi,p
00000A4A  F3A4                                                          rep movsb
00000A4C  48897DC8                                                      mov p,rdi
00000A50                                                            .endif
00000A50                    *   @C0075:
00000A50                                                            .continue
00000A50  EB67              *    jmp @C002C
00000A52                                                        .endif
00000A52                    *   @C0074:
00000A52                                                    .endif
00000A52                    *   @C0073:
00000A52                    *   @C0072:
00000A52                                                .endif
00000A52                    *   @C006E:
00000A52                                            .endif
00000A52                    *   @C006D:
00000A52                                        .endif
00000A52                    *   @C0065:
00000A52  488B4B26                              mov rcx,[rbx+asm_tok].tokpos
00000A56  482B4B0F                              sub rcx,[rbx].tokpos
00000A5A                                        .if ( !inside_literal &&( [rbx+asm_tok].token == T_COMMA || [rbx+asm_tok].token == parm_end_delim ) )
00000A5A  83BDECFEFFFF00    *   cmp inside_literal , 0
00000A61  7524              *   jnz @C0076
00000A63  807B172C          *   cmp [rbx+asm_tok].token , T_COMMA 
00000A67  7408              *   jz  @C0077
00000A69                    *   @C0078:
00000A69                    *   cmp [rbx+asm_tok].token , parm_end_delim 
00000A69  8B45D4            *    mov eax,  parm_end_delim 
00000A6C  384317            *    cmp [rbx+asm_tok].token , al
00000A6F  7516              *   jnz @C0076
00000A71                    *   @C0077:
00000A71  488B530F                                  mov rdx,[rbx].tokpos
00000A75                                            .while islspace( [rdx+rcx-1] )
00000A75  EB03              *   jmp @C007A
00000A77                    *   @C0079:
00000A77  48FFC9                                        dec rcx
00000A7A                                            .endw
00000A7A                    *   @C007A:
00000A7A                    *   invoke islspace, [rdx+rcx-1] 
00000A7A  0FB6440AFF        *    movzx eax, byte ptr [rdx+rcx-1] 
00000A7F  41F644070108      *   test byte ptr [r15+rax+1] , _SPACE
00000A85  75F0              *   jne @C0079
00000A87                                        .endif
00000A87                    *   @C0076:
00000A87  488B7DC8                              mov rdi,p
00000A8B  488B730F                              mov rsi,[rbx].tokpos
00000A8F                                        .if ( [rbx].token == T_STRING && [rbx].string_delim == 0 )
00000A8F  803B09            *   cmp [rbx].token , T_STRING 
00000A92  751F              *   jnz @C007B
00000A94  807B0100          *   cmp [rbx].string_delim , 0 
00000A98  7519              *   jnz @C007B
00000A9A  4803CE                                    add rcx,rsi
00000A9D                                            .for ( : rsi < rcx : )
00000A9D                    *   @C007C:
00000A9D  483BF1            *   cmp rsi , rcx
00000AA0  730B              *   jnb @C007E
00000AA2                                                .if ( byte ptr [rsi] == '!' )
00000AA2  803E21            *   cmp byte ptr [rsi] , '!' 
00000AA5  7503              *   jnz @C007F
00000AA7  48FFC6                                            inc rsi
00000AAA                                                .endif
00000AAA                    *   @C007F:
00000AAA  A4                                            movsb
00000AAB                                            .endf
00000AAB                    *   @C007D:
00000AAB  EBF0              *   jmp @C007C
00000AAD                    *   @C007E:
00000AAD  48897DC8                                  mov p,rdi
00000AB1                                            .continue
00000AB1  EB06              *    jmp @C002C
00000AB3                                        .endif
00000AB3                    *   @C007B:
00000AB3  F3A4                                  rep movsb
00000AB5  48897DC8                              mov p,rdi
00000AB9                                    .endf
00000AB9                    *   @C002C:
00000AB9  FF4530            *   inc idx
00000ABC  E98BF8FFFF        *   jmp @C002B
00000AC1                    *   @C002D:
00000AC1  488B45C8                          mov rax,p
00000AC5  C60000                            mov byte ptr [rax],0
00000AC8                                    mov ModuleInfo.token_count,old_tokencount
00000AC8  8B85E4FEFFFF      *    mov eax, old_tokencount
00000ACE  890510020000      *    mov ModuleInfo.token_count, eax
00000AD4                                    mov ModuleInfo.stringbufferend,savedStringBuffer
00000AD4  488B45F0          *    mov rax, savedStringBuffer
00000AD8  48890508020000    *    mov ModuleInfo.stringbufferend, rax
00000ADF  488B7DB8                          mov rdi,info
00000AE3  488B7528                          mov rsi,mac
00000AE7  0FB707                            movzx eax,[rdi].parmcnt
00000AEA  FFC8                              dec eax
00000AEC  488B55F8                          mov rdx,currparm
00000AF0                                    .if ( [rsi].mac_flag & M_ISVARARG && parmidx == eax )
00000AF0  F6463401          *   test [rsi].mac_flag , M_ISVARARG 
00000AF4  7478              *   je  @C0080
00000AF6  3945E4            *   cmp parmidx , eax 
00000AF9  7573              *   jnz @C0080
00000AFB                                        .if ( varargcnt == 0 )
00000AFB  837DDC00          *   cmp varargcnt , 0 
00000AFF  750E              *   jnz @C0081
00000B01  488B852CFFFFFF                            mov rax,mi.parm_array
00000B08  8B4DE4                                    mov ecx,parmidx
00000B0B  488914C8                                  mov [rax+rcx*size_t],rdx
00000B0F                                        .endif
00000B0F                    *   @C0081:
00000B0F  488B45C8                              mov rax,p
00000B13                                        .if ( [rsi].flags & S_PREDEFINED )
00000B13  F6461720          *   test [rsi].flags , S_PREDEFINED 
00000B17  7413              *   je  @C0082
00000B19  482B45F8                                  sub rax,currparm
00000B1D                    *   invoke GetAlignedPointer, currparm, eax 
00000B1D  8BD0              *    mov edx, eax
00000B1F  488B45F8          *   mov rax, currparm
00000B23  83C208            *1  add edx,size_t
00000B26  83E2F8            *1  and edx,not ( size_t - 1 )
00000B29  4803C2            *1  add rax,rdx
00000B2C                                        .endif
00000B2C                    *   @C0082:
00000B2C  488945F8                              mov currparm,rax
00000B30                                        .if ( [rbx].token == T_COMMA )
00000B30  803B2C            *   cmp [rbx].token , T_COMMA 
00000B33  7534              *   jnz @C0083
00000B35  FF4530                                    inc idx
00000B38  4883C317                                  add rbx,asm_tok
00000B3C  488BD0                                    mov rdx,rax
00000B3F                                            .if ( !( [rsi].mac_flag & M_ISFUNC ) || [rbx].token != parm_end_delim )
00000B3F  F6463402          *   test [rsi].mac_flag , M_ISFUNC 
00000B43  7407              *   je  @C0085
00000B45                    *   @C0086:
00000B45                    *   cmp [rbx].token , parm_end_delim 
00000B45  8B45D4            *    mov eax,  parm_end_delim 
00000B48  3803              *    cmp [rbx].token , al
00000B4A  7416              *   jz  @C0084
00000B4C                    *   @C0085:
00000B4C  FF4DE4                                        dec parmidx
00000B4F                                                .if ( !( [rsi].flags & S_PREDEFINED ) )
00000B4F  F6461720          *   test [rsi].flags , S_PREDEFINED 
00000B53  750A              *   jne @C0087
00000B55  C6022C                                            mov byte ptr [rdx],','
00000B58  48FFC2                                            inc rdx
00000B5B  48FF45F8                                          inc currparm
00000B5F                                                .endif
00000B5F                    *   @C0087:
00000B5F  C60200                                        mov byte ptr [rdx],0
00000B62                                            .endif
00000B62                    *   @C0084:
00000B62  C745E000000000                            mov skipcomma,0
00000B69                                        .endif
00000B69                    *   @C0083:
00000B69  FF45DC                                inc varargcnt
00000B6C                                    .elseif byte ptr [rdx]
00000B6C  EB41              *   jmp @C0088
00000B6E                    *   @C0080:
00000B6E  803A00            *   cmp byte ptr [rdx], 0
00000B71  7427              *   jz  @C0089
00000B73  488BC2                                mov rax,rdx
00000B76  488B8D2CFFFFFF                        mov rcx,mi.parm_array
00000B7D  8B55E4                                mov edx,parmidx
00000B80  488904D1                              mov [rcx+rdx*size_t],rax
00000B84  488B55C8                              mov rdx,p
00000B88  482BD0                                sub rdx,rax
00000B8B                                        mov currparm,GetAlignedPointer( rax, edx )
00000B8B                    *   invoke GetAlignedPointer, rax, edx 
00000B8B  83C208            *1  add edx,size_t
00000B8E  83E2F8            *1  and edx,not ( size_t - 1 )
00000B91  4803C2            *1  add rax,rdx
00000B94  488945F8          *   mov currparm, rax
00000B98                                    .else
00000B98  EB15              *   jmp @C0088
00000B9A                    *   @C0089:
00000B9A  488B952CFFFFFF                        mov rdx,mi.parm_array
00000BA1  8B4DE4                                mov ecx,parmidx
00000BA4  488D050A000000                        lea rax,DS0002[10]
00000BAB  488904CA                              mov [rdx+rcx*size_t],rax
00000BAF                                    .endif
00000BAF                    *   @C0088:
00000BAF                                .endif
00000BAF                    *   @C002A:
00000BAF                            .endf
00000BAF                    *   @C001F:
00000BAF  FF45E4            *   inc parmidx
00000BB2  E9DBF6FFFF        *   jmp @C001E
00000BB7                    *   @C0020:
00000BB7                            .if ( bracket_level >= 0 )
00000BB7  837DD800          *   cmp bracket_level , 0 
00000BBB  7C6A              *   jl  @C008A
00000BBD                                .if ( [rbx].token != T_CL_BRACKET )
00000BBD  803B29            *   cmp [rbx].token , T_CL_BRACKET 
00000BC0  745C              *   jz  @C008B
00000BC2                                    .for ( i = idx: idx < ModuleInfo.token_count && [rbx].token != T_CL_BRACKET: idx++, rbx += asm_tok )
00000BC2                    *   mov i, idx
00000BC2  8B4530            *    mov eax,  idx
00000BC5  8945EC            *    mov i, eax
00000BC8                    *   @C008C:
00000BC8                    *   cmp idx , ModuleInfo.token_count 
00000BC8  8B0510020000      *    mov eax,  ModuleInfo.token_count 
00000BCE  394530            *    cmp idx , eax
00000BD1  7D0E              *   jnl @C008E
00000BD3  803B29            *   cmp [rbx].token , T_CL_BRACKET
00000BD6  7409              *   jz  @C008E
00000BD8                                    .endf
00000BD8                    *   @C008D:
00000BD8  FF4530            *   inc idx
00000BDB  4883C317          *   add rbx, asm_tok
00000BDF  EBE7              *   jmp @C008C
00000BE1                    *   @C008E:
00000BE1                                    .if ( idx == ModuleInfo.token_count )
00000BE1                    *   cmp idx , ModuleInfo.token_count 
00000BE1  8B0510020000      *    mov eax,  ModuleInfo.token_count 
00000BE7  394530            *    cmp idx , eax
00000BEA  7518              *   jnz @C008F
00000BEC                    *   invoke asmerr, 2157 
00000BEC  B96D080000        *    mov ecx, 2157 
00000BF1  E800000000        *    call asmerr
00000BF6                                        .return( -1 )
00000BF6  48C7C0FFFFFFFF    *   mov rax,( -1 )
00000BFD  E9F8030000        *   jmp @C000D
00000C02                                    .else
00000C02  EB1A              *   jmp @C0090
00000C04                    *   @C008F:
00000C04  6B45EC17                              imul eax,i,asm_tok
00000C08  48034538                              add rax,tokenarray
00000C0C                    *   invoke asmerr, 4006, [rsi].name, [rax].asm_tok.tokpos 
00000C0C  4C8B400F          *    mov r8, [rax].asm_tok.tokpos 
00000C10  488B5608          *    mov rdx, [rsi].name
00000C14  B9A60F0000        *    mov ecx, 4006
00000C19  E800000000        *    call asmerr
00000C1E                                    .endif
00000C1E                    *   @C0090:
00000C1E                                .endif
00000C1E                    *   @C008B:
00000C1E  FF4530                        inc idx
00000C21  4883C317                      add rbx,asm_tok
00000C25                            .elseif ( [rbx].token != T_FINAL )
00000C25  EB20              *   jmp @C0091
00000C27                    *   @C008A:
00000C27  803B00            *   cmp [rbx].token , T_FINAL 
00000C2A  741B              *   jz  @C0092
00000C2C                                .if ( !( mflags & MF_IGNARGS ) )
00000C2C  F7454804000000    *   test mflags , MF_IGNARGS 
00000C33  7512              *   jne @C0093
00000C35                    *   invoke asmerr, 4006, [rsi].name, [rbx].tokpos 
00000C35  4C8B430F          *    mov r8, [rbx].tokpos 
00000C39  488B5608          *    mov rdx, [rsi].name
00000C3D  B9A60F0000        *    mov ecx, 4006
00000C42  E800000000        *    call asmerr
00000C47                                .endif
00000C47                    *   @C0093:
00000C47                            .endif
00000C47                    *   @C0092:
00000C47                    *   @C0091:
00000C47                            .if ( [rsi].flags & S_PREDEFINED && [rsi].func_ptr )
00000C47  F6461720          *   test [rsi].flags , S_PREDEFINED 
00000C4B  7434              *   je  @C0094
00000C4D  48837E2400        *   cmp [rsi].func_ptr , 0
00000C52  742D              *   jz  @C0094
00000C54                                mov mi.parmcnt,varargcnt
00000C54  8B45DC            *    mov eax, varargcnt
00000C57  89853CFFFFFF      *    mov mi.parmcnt, eax
00000C5D                    *   invoke [rsi].func_ptr, addr mi, _out, tokenarray 
00000C5D  4C8B4538          *    mov r8, tokenarray 
00000C61  488B5540          *    mov rdx, _out
00000C65  488D8D18FFFFFF    *    lea rcx, mi
00000C6C  FF5624            *    call [rsi].func_ptr
00000C6F  488B4550                      mov rax,is_exitm
00000C73  C70001000000                  mov dword ptr [rax],TRUE
00000C79                               .return idx
00000C79  8B4530            *   mov eax,idx
00000C7C  E979030000        *   jmp @C000D
00000C81                            .endif
00000C81                    *   @C0094:
00000C81                            mov mi.localstart,MacroLocals
00000C81  8B0500000000      *    mov eax, MacroLocals
00000C87  898528FFFFFF      *    mov mi.localstart, eax
00000C8D                            add MacroLocals,[rdi].localcnt
00000C8D  0FB74702          *    movzx eax, [rdi].localcnt
00000C91  010500000000      *    add MacroLocals, eax
00000C97                            mov mi.startline,[rdi].lines
00000C97  488B470C          *    mov rax, [rdi].lines
00000C9B  48898520FFFFFF    *    mov mi.startline, rax
00000CA2  48C78518FFFFFF0000        mov mi.currline,NULL
00000CAD                            mov mi.parmcnt,[rdi].parmcnt
00000CAD  0FB707            *    movzx eax, [rdi].parmcnt
00000CB0  89853CFFFFFF      *    mov mi.parmcnt, eax
00000CB6                            .if mi.startline
00000CB6  4883BD20FFFFFF00  *   cmp mi.startline, 0
00000CBE  0F8433030000      *   jz  @C0095
00000CC4  488B4608                      mov rax,[rsi].name
00000CC8                                .if ( !( [rsi].mac_flag & M_ISFUNC ) && byte ptr [rax] )
00000CC8  F6463402          *   test [rsi].mac_flag , M_ISFUNC 
00000CCC  750A              *   jne @C0096
00000CCE  803800            *   cmp byte ptr [rax] , 0
00000CD1  7405              *   jz  @C0096
00000CD3  E800000000        *   call LstWriteSrcLine
00000CD8                                .endif
00000CD8                    *   @C0096:
00000CD8                                .if ( !( mflags & MF_NOSAVE ) )
00000CD8  F7454802000000    *   test mflags , MF_NOSAVE 
00000CDF  7510              *   jne @C0097
00000CE1                                    mov tokenarray,PushInputStatus( &oldstat )
00000CE1                    *   invoke PushInputStatus, addr oldstat 
00000CE1  488D8DF8FEFFFF    *    lea rcx, oldstat 
00000CE8  E800000000        *    call PushInputStatus
00000CED  48894538          *   mov tokenarray, rax
00000CF1                                .endif
00000CF1                    *   @C0097:
00000CF1  4889B534FFFFFF                mov mi._macro,rsi
00000CF8                    *   invoke PushMacro, addr mi 
00000CF8  488D8D18FFFFFF    *    lea rcx, mi 
00000CFF  E800000000        *    call PushMacro
00000D04  FF0500000000                  inc MacroLevel
00000D0A                                mov oldifnesting,GetIfNestLevel()
00000D0A  E800000000        *   call GetIfNestLevel
00000D0F  8985F4FEFFFF      *   mov oldifnesting, eax
00000D15  C785F0FEFFFF000000            mov cntgoto,0
00000D1F                                .while ( GetTextLine( ModuleInfo.currsource ) )
00000D1F  E9A3020000        *   jmp @C0099
00000D24                    *   @C0098:
00000D24                                    .continue .if ( PreprocessLine( tokenarray ) == 0 )
00000D24                    *   invoke PreprocessLine, tokenarray 
00000D24  488B4D38          *    mov rcx, tokenarray 
00000D28  E800000000        *    call PreprocessLine
00000D2D  4885C0            *   test rax , rax 
00000D30  0F8491020000      *   jz  @C0099
00000D36  488B5D38                          mov rbx,tokenarray
00000D3A                                    .if ( [rbx].token == T_COLON )
00000D3A  803B3A            *   cmp [rbx].token , T_COLON 
00000D3D  752F              *   jnz @C009A
00000D3F                                        .if ( [rbx+asm_tok].token != T_ID )
00000D3F  807B1708          *   cmp [rbx+asm_tok].token , T_ID 
00000D43  7410              *   jz  @C009B
00000D45                    *   invoke asmerr, 2008, [rbx].tokpos 
00000D45  488B530F          *    mov rdx, [rbx].tokpos 
00000D49  B9D8070000        *    mov ecx, 2008
00000D4E  E800000000        *    call asmerr
00000D53                                        .elseif ( [rbx+asm_tok*2].token != T_FINAL )
00000D53  EB14              *   jmp @C009C
00000D55                    *   @C009B:
00000D55  807B2E00          *   cmp [rbx+asm_tok*2].token , T_FINAL 
00000D59  740E              *   jz  @C009D
00000D5B                    *   invoke asmerr, 2008, [rbx+asm_tok*2].tokpos 
00000D5B  488B533D          *    mov rdx, [rbx+asm_tok*2].tokpos 
00000D5F  B9D8070000        *    mov ecx, 2008
00000D64  E800000000        *    call asmerr
00000D69                                        .endif
00000D69                    *   @C009D:
00000D69                    *   @C009C:
00000D69                                        .continue
00000D69  E959020000        *    jmp @C0099
00000D6E                                    .endif
00000D6E                    *   @C009A:
00000D6E                                    .if ( [rbx].token == T_DIRECTIVE )
00000D6E  803B03            *   cmp [rbx].token , T_DIRECTIVE 
00000D71  0F8532020000      *   jnz @C009E
00000D77                                        .if ( [rbx].tokval == T_EXITM || [rbx].tokval == T_RETM )
00000D77  817B03F2010000    *   cmp [rbx].tokval , T_EXITM 
00000D7E  740D              *   jz  @C00A0
00000D80                    *   @C00A1:
00000D80  817B03AF010000    *   cmp [rbx].tokval , T_RETM 
00000D87  0F8507010000      *   jnz @C009F
00000D8D                    *   @C00A0:
00000D8D                                            .if ( ModuleInfo.list && ModuleInfo.list_macro == LM_LISTMACROALL )
00000D8D  803DB701000000    *   cmp ModuleInfo.list , 0
00000D94  740E              *   jz  @C00A2
00000D96  833DA401000002    *   cmp ModuleInfo.list_macro , LM_LISTMACROALL 
00000D9D  7505              *   jnz @C00A2
00000D9F  E800000000        *   call LstWriteSrcLine
00000DA4                                            .endif
00000DA4                    *   @C00A2:
00000DA4                                            .if ( [rbx+asm_tok].token != T_FINAL )
00000DA4  807B1700          *   cmp [rbx+asm_tok].token , T_FINAL 
00000DA8  0F84A3000000      *   jz  @C00A3
00000DAE                                                .if ( [rbx+asm_tok].token != T_STRING || [rbx+asm_tok].string_delim != '<' )
00000DAE  807B1709          *   cmp [rbx+asm_tok].token , T_STRING 
00000DB2  7506              *   jnz @C00A5
00000DB4                    *   @C00A6:
00000DB4  807B183C          *   cmp [rbx+asm_tok].string_delim , '<' 
00000DB8  740E              *   jz  @C00A4
00000DBA                    *   @C00A5:
00000DBA                    *   invoke TextItemError, addr [rbx+asm_tok] 
00000DBA  488D4B17          *    lea rcx, [rbx+asm_tok] 
00000DBE  E800000000        *    call TextItemError
00000DC3                                                .elseif ( ModuleInfo.token_count > 2 )
00000DC3  E989000000        *   jmp @C00A7
00000DC8                    *   @C00A4:
00000DC8  833D1002000002    *   cmp ModuleInfo.token_count , 2 
00000DCF  7E10              *   jng @C00A8
00000DD1                    *   invoke asmerr, 2008, [rbx+asm_tok*2].tokpos 
00000DD1  488B533D          *    mov rdx, [rbx+asm_tok*2].tokpos 
00000DD5  B9D8070000        *    mov ecx, 2008
00000DDA  E800000000        *    call asmerr
00000DDF                                                .elseif ( _out );; return value buffer may be NULL ( loop directives )
00000DDF  EB70              *   jmp @C00A7
00000DE1                    *   @C00A8:
00000DE1  48837D4000        *   cmp ( _out ), 0
00000DE6  7469              *   jz  @C00A9
00000DE8  488B7D40                                          mov rdi,_out
00000DEC  488B9518FFFFFF                                    mov rdx,mi.currline
00000DF3  488B4326                                          mov rax,[rbx+asm_tok].tokpos
00000DF7  482B05F0010000                                    sub rax,ModuleInfo.currsource
00000DFE  8A440209                                          mov al,[rdx].srcline.line[rax]
00000E02                                                    .if ( !_retm && [rbx].tokval == T_RETM )
00000E02  837DE800          *   cmp _retm , 0
00000E06  7512              *   jnz @C00AA
00000E08  817B03AF010000    *   cmp [rbx].tokval , T_RETM 
00000E0F  7509              *   jnz @C00AA
00000E11  488B4540                                              mov rax,_out
00000E15  C60000                                                mov byte ptr [rax],0
00000E18                                                    .elseif ( [rdx].srcline.ph_count || al != '<' )
00000E18  EB37              *   jmp @C00AB
00000E1A                    *   @C00AA:
00000E1A  807A0800          *   cmp [rdx].srcline.ph_count , 0
00000E1E  7504              *   jnz @C00AD
00000E20                    *   @C00AE:
00000E20  3C3C              *   cmp al , '<' 
00000E22  740D              *   jz  @C00AC
00000E24                    *   @C00AD:
00000E24  8B4B1A                                                mov ecx,[rbx+asm_tok].stringlen
00000E27  FFC1                                                  inc ecx
00000E29  488B731E                                              mov rsi,[rbx+asm_tok].string_ptr
00000E2D  F3A4                                                  rep movsb
00000E2F                                                    .else
00000E2F  EB20              *   jmp @C00AB
00000E31                    *   @C00AC:
00000E31  488B7326                                              mov rsi,[rbx+asm_tok].tokpos
00000E35  48FFC6                                                inc rsi
00000E38  488B4B3D                                              mov rcx,[rbx+asm_tok*2].tokpos
00000E3C  482BCE                                                sub rcx,rsi
00000E3F  F3A4                                                  rep movsb
00000E41  48FFCF                                                dec rdi
00000E44                                                        .while( byte ptr [rdi] != '>' )
00000E44  EB03              *   jmp @C00B0
00000E46                    *   @C00AF:
00000E46  48FFCF                                                    dec rdi
00000E49                                                        .endw
00000E49                    *   @C00B0:
00000E49  803F3E            *   cmp byte ptr [rdi] , '>' 
00000E4C  75F8              *   jnz @C00AF
00000E4E  C60700                                                mov byte ptr [rdi],0
00000E51                                                    .endif
00000E51                    *   @C00AB:
00000E51                                                .endif
00000E51                    *   @C00A9:
00000E51                    *   @C00A7:
00000E51                                            .endif
00000E51                    *   @C00A3:
00000E51                                            .if cntgoto
00000E51  83BDF0FEFFFF00    *   cmp cntgoto, 0
00000E58  741D              *   jz  @C00B1
00000E5A  48C78518FFFFFF0000                            mov mi.currline,NULL
00000E65                    *   invoke SetLineNumber, 0 
00000E65  33C9              *    xor ecx, ecx
00000E67  E800000000        *    call SetLineNumber
00000E6C                    *   invoke SetIfNestLevel, oldifnesting 
00000E6C  8B8DF4FEFFFF      *    mov ecx, oldifnesting 
00000E72  E800000000        *    call SetIfNestLevel
00000E77                                            .endif
00000E77                    *   @C00B1:
00000E77                    *   invoke SkipMacro, tokenarray 
00000E77  488B4D38          *    mov rcx, tokenarray 
00000E7B  E803F2FFFF        *    call SkipMacro
00000E80  488B4550                                  mov rax,is_exitm
00000E84  C70001000000                              mov dword ptr [rax],TRUE
00000E8A                                            .break
00000E8A  E94D010000        *    jmp @C00B2
00000E8F                                        .elseif ( [rbx].tokval == T_GOTO )
00000E8F  E915010000        *   jmp @C00B3
00000E94                    *   @C009F:
00000E94  817B03F4010000    *   cmp [rbx].tokval , T_GOTO 
00000E9B  0F8508010000      *   jnz @C00B4
00000EA1                                            .if ( [rbx+asm_tok].token != T_FINAL )
00000EA1  807B1700          *   cmp [rbx+asm_tok].token , T_FINAL 
00000EA5  0F84E5000000      *   jz  @C00B5
00000EAB                                                mov len,tstrlen( [rbx+asm_tok].string_ptr )
00000EAB                    *   invoke tstrlen, [rbx+asm_tok].string_ptr 
00000EAB  488B4B1E          *    mov rcx, [rbx+asm_tok].string_ptr 
00000EAF  E800000000        *    call tstrlen
00000EB4  8985D0FEFFFF      *   mov len, eax
00000EBA                                                .for ( i = 1, rdi = mi.startline: rdi != NULL: rdi = [rdi].next, i++ )
00000EBA  C745EC01000000    *   mov i, 1
00000EC1  488BBD20FFFFFF    *   mov rdi, mi.startline
00000EC8                    *   @C00B6:
00000EC8  4885FF            *   test rdi , rdi 
00000ECB  0F8486000000      *   jz  @C00B8
00000ED1  488D7709                                          lea rsi,[rdi].line
00000ED5                                                    .if ( byte ptr [rsi] == ':' )
00000ED5  803E3A            *   cmp byte ptr [rsi] , ':' 
00000ED8  7572              *   jnz @C00B9
00000EDA                                                        .if ( [rdi].ph_count )
00000EDA  807F0800          *   cmp ( [rdi].ph_count ), 0
00000EDE  7430              *   jz  @C00BA
00000EE0                    *   invoke fill_placeholders, ModuleInfo.stringbufferend, rsi, mi.parmcnt,mi.localstart, mi.parm_array 
00000EE0  488B852CFFFFFF    *    mov rax, mi.parm_array 
00000EE7  4889442420        *    mov [rsp+32], rax
00000EEC  448B8D28FFFFFF    *    mov r9d, mi.localstart
00000EF3  448B853CFFFFFF    *    mov r8d, mi.parmcnt
00000EFA  488BD6            *    mov rdx, rsi
00000EFD  488B0D08020000    *    mov rcx, ModuleInfo.stringbufferend
00000F04  E800000000        *    call fill_placeholders
00000F09  488B3508020000                                            mov rsi,ModuleInfo.stringbufferend
00000F10                                                        .endif
00000F10                    *   @C00BA:
00000F10  48FFC6                                                inc rsi
00000F13                                                        .while islspace( [rsi] )
00000F13  EB03              *   jmp @C00BC
00000F15                    *   @C00BB:
00000F15  48FFC6                                                    inc rsi
00000F18                                                        .endw
00000F18                    *   @C00BC:
00000F18                    *   invoke islspace, [rsi] 
00000F18  0FB606            *    movzx eax, byte ptr [rsi] 
00000F1B  41F644070108      *   test byte ptr [r15+rax+1] , _SPACE
00000F21  75F2              *   jne @C00BB
00000F23                                                        .ifd !tmemicmp( rsi, [rbx+asm_tok].string_ptr, len )
00000F23                    *   invoke tmemicmp, rsi, [rbx+asm_tok].string_ptr, len 
00000F23  448B85D0FEFFFF    *    mov r8d, len 
00000F2A  488B531E          *    mov rdx, [rbx+asm_tok].string_ptr
00000F2E  488BCE            *    mov rcx, rsi
00000F31  E800000000        *    call tmemicmp
00000F36  85C0              *   test eax, eax
00000F38  7512              *   jnz @C00BD
00000F3A  8B8DD0FEFFFF                                              mov ecx,len
00000F40                                                           .break .if !islabel( [rsi+rcx] )
00000F40                    *   invoke islabel, [rsi+rcx] 
00000F40  0FB6040E          *    movzx eax, byte ptr [rsi+rcx] 
00000F44  41F644070144      *   test byte ptr [r15+rax+1] , (_LABEL or _DIGIT)
00000F4A  740B              *   je  @C00B8
00000F4C                                                        .endif
00000F4C                    *   @C00BD:
00000F4C                                                    .endif
00000F4C                    *   @C00B9:
00000F4C                                                .endf
00000F4C                    *   @C00B7:
00000F4C  488B3F            *   mov rdi, [rdi].next
00000F4F  FF45EC            *   inc i
00000F52  E971FFFFFF        *   jmp @C00B6
00000F57                    *   @C00B8:
00000F57                                                .if !rdi
00000F57  4885FF            *   test rdi, rdi
00000F5A  7510              *   jnz @C00BE
00000F5C                    *   invoke asmerr, 2147, [rbx+asm_tok].string_ptr 
00000F5C  488B531E          *    mov rdx, [rbx+asm_tok].string_ptr 
00000F60  B963080000        *    mov ecx, 2147
00000F65  E800000000        *    call asmerr
00000F6A                                                .else
00000F6A  EB22              *   jmp @C00BF
00000F6C                    *   @C00BE:
00000F6C  4889BD18FFFFFF                                    mov mi.currline,rdi
00000F73                    *   invoke SetLineNumber, i
00000F73  8B4DEC            *    mov ecx, i
00000F76  E800000000        *    call SetLineNumber
00000F7B                    *   invoke SetIfNestLevel, oldifnesting 
00000F7B  8B8DF4FEFFFF      *    mov ecx, oldifnesting 
00000F81  E800000000        *    call SetIfNestLevel
00000F86  FF85F0FEFFFF                                      inc cntgoto
00000F8C                                                   .continue
00000F8C  EB39              *    jmp @C0099
00000F8E                                                .endif
00000F8E                    *   @C00BF:
00000F8E                                            .else
00000F8E  EB0E              *   jmp @C00C0
00000F90                    *   @C00B5:
00000F90                    *   invoke asmerr, 2008, [rbx].tokpos 
00000F90  488B530F          *    mov rdx, [rbx].tokpos 
00000F94  B9D8070000        *    mov ecx, 2008
00000F99  E800000000        *    call asmerr
00000F9E                                            .endif
00000F9E                    *   @C00C0:
00000F9E                    *   invoke SkipMacro, tokenarray 
00000F9E  488B4D38          *    mov rcx, tokenarray 
00000FA2  E8DCF0FFFF        *    call SkipMacro
00000FA7                                           .break
00000FA7  EB33              *    jmp @C00B2
00000FA9                                        .endif
00000FA9                    *   @C00B4:
00000FA9                    *   @C00B3:
00000FA9                                    .endif
00000FA9                    *   @C009E:
00000FA9                    *   invoke ParseLine, tokenarray
00000FA9  488B4D38          *    mov rcx, tokenarray
00000FAD  E800000000        *    call ParseLine
00000FB2                                    .if ( Options.preprocessor_stdout == TRUE )
00000FB2  803D7D00000001    *   cmp Options.preprocessor_stdout , TRUE 
00000FB9  750C              *   jnz @C00C1
00000FBB                    *   invoke WritePreprocessedLine, ModuleInfo.currsource
00000FBB  488B0DF0010000    *    mov rcx, ModuleInfo.currsource
00000FC2  E800000000        *    call WritePreprocessedLine
00000FC7                                    .endif
00000FC7                    *   @C00C1:
00000FC7                                .endw
00000FC7                    *   @C0099:
00000FC7                    *   invoke GetTextLine, ModuleInfo.currsource 
00000FC7  488B0DF0010000    *    mov rcx, ModuleInfo.currsource 
00000FCE  E800000000        *    call GetTextLine
00000FD3  4885C0            *   test (  rax ), (  rax )
00000FD6  0F8548FDFFFF      *   jnz @C0098
00000FDC                    *   @C00B2:
00000FDC  FF0D00000000                  dec MacroLevel
00000FE2                                .if ( !( mflags & MF_NOSAVE ) )
00000FE2  F7454802000000    *   test mflags , MF_NOSAVE 
00000FE9  750C              *   jne @C00C2
00000FEB                    *   invoke PopInputStatus, addr oldstat
00000FEB  488D8DF8FEFFFF    *    lea rcx, oldstat
00000FF2  E800000000        *    call PopInputStatus
00000FF7                                .endif
00000FF7                    *   @C00C2:
00000FF7                            .endif
00000FF7                    *   @C0095:
00000FF7                            .return( idx )
00000FF7  8B4530            *   mov eax,( idx )
00000FFA  EBFE              *   jmp @C000D
                            *   org $ - 2
00000FFA                    *   ret
00000FFA                    *   @C000D:
00000FFA  C9                *   leave
00000FFB  5B                *   pop rbx
00000FFC  5F                *   pop rdi
00000FFD  5E                *   pop rsi
00000FFE  C3                *   retn 
00000FFF                        RunMacro endp
00000FFF                        AddTokens proc fastcall private uses rbx tokenarray:token_t, start:int_t, count:int_t, _end:int_t
00000FFF  48894C2408        *   mov [rsp+8], rcx
00001004  4889542410        *   mov [rsp+16], rdx
00001009  4C89442418        *   mov [rsp+24], r8
0000100E  4C894C2420        *   mov [rsp+32], r9
00001013  53                *   push rbx
00001014  55                *   push rbp
00001015  488BEC            *   mov rbp, rsp
00001018  488B5D18                  mov     rbx,tokenarray
0000101C  48634528                  movsxd  rax,count
00001020  486BC817                  imul    rcx,rax,asm_tok
00001024  8B5520                    mov     edx,start
00001027                            .ifs ( eax > 0 )
00001027  83F800            *   cmp eax , 0 
0000102A  7E43              *   jng @C00C3
0000102C  6B453017                      imul eax,_end,asm_tok
00001030  4803D8                        add  rbx,rax
00001033                                .for ( : _end >= edx : _end--, rbx -= asm_tok )
00001033                    *   @C00C4:
00001033  395530            *   cmp _end , edx
00001036  7C35              *   jl  @C00C6
00001038                                    mov [rbx+rcx],asm_tok ptr [rbx]
00001038  488B03            *    mov rax, qword ptr asm_tok ptr [rbx][0]
0000103B  4889040B          *    mov qword ptr [rbx+rcx][0], rax
0000103F  488B4308          *    mov rax, qword ptr asm_tok ptr [rbx][8]
00001043  4889440B08        *    mov qword ptr [rbx+rcx][8], rax
00001048  8B4310            *    mov eax, dword ptr asm_tok ptr [rbx][16]
0000104B  89440B10          *    mov dword ptr [rbx+rcx][16], eax
0000104F  8A4314            *    mov al, byte ptr asm_tok ptr [rbx][20]
00001052  88440B14          *    mov byte ptr [rbx+rcx][20], al
00001056  8A4315            *    mov al, byte ptr asm_tok ptr [rbx][21]
00001059  88440B15          *    mov byte ptr [rbx+rcx][21], al
0000105D  8A4316            *    mov al, byte ptr asm_tok ptr [rbx][22]
00001060  88440B16          *    mov byte ptr [rbx+rcx][22], al
00001064                                .endf
00001064                    *   @C00C5:
00001064  FF4D30            *   dec _end
00001067  4883EB17          *   sub rbx, asm_tok
0000106B  EBC6              *   jmp @C00C4
0000106D                    *   @C00C6:
0000106D                            .elseifs ( eax < 0 )
0000106D  EB46              *   jmp @C00C7
0000106F                    *   @C00C3:
0000106F  83F800            *   cmp eax , 0 
00001072  7D41              *   jnl @C00C8
00001074  2BD0                          sub  edx,eax
00001076  6BC217                        imul eax,edx,asm_tok
00001079  4803D8                        add  rbx,rax
0000107C                                .for ( : edx <= _end : edx++, rbx += asm_tok )
0000107C                    *   @C00C9:
0000107C  3B5530            *   cmp edx , _end
0000107F  7F34              *   jg  @C00CB
00001081                                    mov [rbx+rcx],asm_tok ptr [rbx]
00001081  488B03            *    mov rax, qword ptr asm_tok ptr [rbx][0]
00001084  4889040B          *    mov qword ptr [rbx+rcx][0], rax
00001088  488B4308          *    mov rax, qword ptr asm_tok ptr [rbx][8]
0000108C  4889440B08        *    mov qword ptr [rbx+rcx][8], rax
00001091  8B4310            *    mov eax, dword ptr asm_tok ptr [rbx][16]
00001094  89440B10          *    mov dword ptr [rbx+rcx][16], eax
00001098  8A4314            *    mov al, byte ptr asm_tok ptr [rbx][20]
0000109B  88440B14          *    mov byte ptr [rbx+rcx][20], al
0000109F  8A4315            *    mov al, byte ptr asm_tok ptr [rbx][21]
000010A2  88440B15          *    mov byte ptr [rbx+rcx][21], al
000010A6  8A4316            *    mov al, byte ptr asm_tok ptr [rbx][22]
000010A9  88440B16          *    mov byte ptr [rbx+rcx][22], al
000010AD                                .endf
000010AD                    *   @C00CA:
000010AD  FFC2              *   inc edx
000010AF  4883C317          *   add rbx, asm_tok
000010B3  EBC7              *   jmp @C00C9
000010B5                    *   @C00CB:
000010B5                            .endif
000010B5                    *   @C00C8:
000010B5                    *   @C00C7:
000010B5                            ret
000010B5  C9                *   leave
000010B6  5B                *   pop rbx
000010B7  C3                *   retn 
000010B8                        AddTokens endp
000010B8                        ExpandText proc fastcall uses rsi rdi rbx line:string_t, tokenarray:token_t, substitute:uint_t
000010B8  48894C2408        *   mov [rsp+8], rcx
000010BD  4889542410        *   mov [rsp+16], rdx
000010C2  4C89442418        *   mov [rsp+24], r8
000010C7  56                *   push rsi
000010C8  57                *   push rdi
000010C9  53                *   push rbx
000010CA  55                *   push rbp
000010CB  488BEC            *   mov rbp, rsp
000010CE  4881EC18010000    *   sub rsp, 280
000010D5                            mov old_tokencount,ModuleInfo.token_count
000010D5  8B0510020000      *    mov eax, ModuleInfo.token_count
000010DB  8945EC            *    mov old_tokencount, eax
000010DE                            mov old_stringbufferend,ModuleInfo.stringbufferend
000010DE  488B0508020000    *    mov rax, ModuleInfo.stringbufferend
000010E5  488945E0          *    mov old_stringbufferend, rax
000010E9  C68527FFFFFF00            mov quoted_string,0
000010F0  C68526FFFFFF00            mov macro_proc,FALSE
000010F7                            mov _sp[0],line
000010F7  488B4528          *    mov rax, line
000010FB  48898530FFFFFF    *    mov _sp[0], rax
00001102  488B3D08020000            mov rdi,ModuleInfo.stringbufferend
00001109                            add ModuleInfo.stringbufferend,ModuleInfo.max_line_len
00001109  8B0568010000      *    mov eax, ModuleInfo.max_line_len
0000110F  48010508020000    *    add ModuleInfo.stringbufferend, rax
00001116  C745DC00000000            mov rc,NOT_ERROR
0000111D                            .for ( lvl = 0 : lvl >= 0 : lvl-- )
0000111D  C745F400000000    *   mov lvl, 0
00001124                    *   @C00CC:
00001124  837DF400          *   cmp lvl , 0
00001128  0F8C08030000      *   jl  @C00CE
0000112E  8B45F4                        mov eax,lvl
00001131  488BB4C530FFFFFF              mov rsi,_sp[rax*string_t]
00001139                                .while ( byte ptr [rsi] )
00001139  E9E7020000        *   jmp @C00D0
0000113E                    *   @C00CF:
0000113E                                    .if ( isdotlabel( [rsi], ModuleInfo.dotname ) && ( substitute || !quoted_string ) )
0000113E                    *   invoke isdotlabel, [rsi], ModuleInfo.dotname 
0000113E  0FB615B0010000    *    movzx edx, byte ptr ModuleInfo.dotname 
00001145  0FB606            *    movzx eax, byte ptr [rsi]
00001148  3C2E              *   cmp al , '.' 
0000114A  7504              *   jnz @C00D3
0000114C  84D2              *   test dl, dl
0000114E  750C              *   jnz @C00D2
00001150                    *   @C00D3:
00001150  41F644070140      *   test byte ptr [r15+rax+1] , _LABEL
00001156  0F849E020000      *   je  @C00D1
0000115C                    *   @C00D2:
0000115C  837D3800          *   cmp substitute , 0
00001160  750D              *   jnz @C00D4
00001162                    *   @C00D5:
00001162  80BD27FFFFFF00    *   cmp quoted_string , 0
00001169  0F858B020000      *   jnz @C00D1
0000116F                    *   @C00D4:
0000116F  48897DF8                              mov pIdent,rdi
00001173                                        .repeat
00001173                    *   @C00D6:
00001173  AA                                        stosb
00001174  48FFC6                                    inc rsi
00001177                                        .until !islabel( [rsi] )
00001177                    *   invoke islabel, [rsi] 
00001177  0FB606            *    movzx eax, byte ptr [rsi] 
0000117A  41F644070144      *   test byte ptr [r15+rax+1] , (_LABEL or _DIGIT)
00001180  75F1              *   jne @C00D6
00001182  C60700                                mov byte ptr [rdi],0
00001185                                        mov sym,SymFind(pIdent)
00001185                    *   invoke SymFind, pIdent
00001185  488B4DF8          *    mov rcx, pIdent
00001189  E800000000        *    call SymFind
0000118E  488945D0          *   mov sym, rax
00001192                                        .if ( rax && [rax].asym.flags & S_ISDEFINED )
00001192  4885C0            *   test rax , rax 
00001195  0F845D020000      *   jz  @C00D7
0000119B  F6401702          *   test [rax].asym.flags , S_ISDEFINED 
0000119F  0F8453020000      *   je  @C00D7
000011A5                                            .if ( [rax].asym.state == SYM_TMACRO )
000011A5  8078140A          *   cmp [rax].asym.state , SYM_TMACRO 
000011A9  0F859C000000      *   jnz @C00D8
000011AF  488B55F8                                      mov rdx,pIdent
000011B3                                                .continue .if ( quoted_string &&byte ptr [rdx-1] != '&' && byte ptr [rsi] != '&' )
000011B3  80BD27FFFFFF00    *   cmp quoted_string , 0
000011BA  740F              *   jz  @C00D9
000011BC                    *   @C00DA:
000011BC  807AFF26          *   cmp byte ptr [rdx-1] , '&' 
000011C0  7409              *   jz  @C00D9
000011C2                    *   @C00DB:
000011C2  803E26            *   cmp byte ptr [rsi] , '&' 
000011C5  0F855A020000      *   jnz @C00D0
000011CB                    *   @C00D9:
000011CB                                                .if ( substitute )
000011CB  837D3800          *   cmp ( substitute ), 0
000011CF  7414              *   jz  @C00DC
000011D1                                                    .if ( byte ptr [rdx-1] == '&' )
000011D1  807AFF26          *   cmp byte ptr [rdx-1] , '&' 
000011D5  7504              *   jnz @C00DD
000011D7  48FF4DF8                                              dec pIdent
000011DB                                                    .endif
000011DB                    *   @C00DD:
000011DB                                                    .if ( byte ptr [rsi] == '&' )
000011DB  803E26            *   cmp byte ptr [rsi] , '&' 
000011DE  7503              *   jnz @C00DE
000011E0  48FFC6                                                inc rsi
000011E3                                                    .endif
000011E3                    *   @C00DE:
000011E3                                                .elseif ( pIdent > old_stringbufferend && byte ptr [rdx-1] == '%' )
000011E3  EB14              *   jmp @C00DF
000011E5                    *   @C00DC:
000011E5                    *   cmp pIdent , old_stringbufferend 
000011E5  488B45E0          *    mov rax,  old_stringbufferend 
000011E9  483945F8          *    cmp pIdent , rax
000011ED  760A              *   jna @C00E0
000011EF  807AFF25          *   cmp byte ptr [rdx-1] , '%' 
000011F3  7504              *   jnz @C00E0
000011F5  48FF4DF8                                          dec pIdent
000011F9                                                .endif
000011F9                    *   @C00E0:
000011F9                    *   @C00DF:
000011F9  8B45F4                                        mov eax,lvl
000011FC  FF45F4                                        inc lvl
000011FF  4889B4C530FFFFFF                              mov _sp[rax*string_t],rsi
00001207  488B3508020000                                mov rsi,ModuleInfo.stringbufferend
0000120E  488B45D0                                      mov rax,sym
00001212                    *   invoke tstrcpy, rsi, [rax].asym.string_ptr 
00001212  488B5024          *    mov rdx, [rax].asym.string_ptr 
00001216  488BCE            *    mov rcx, rsi
00001219  E800000000        *    call tstrcpy
0000121E                    *   invoke tstrlen, rax 
0000121E  488BC8            *    mov rcx, rax 
00001221  E800000000        *    call tstrlen
00001226                                                mov ModuleInfo.stringbufferend,GetAlignedPointer( rsi, eax )
00001226                    *   invoke GetAlignedPointer, rsi, eax 
00001226  8BD0              *    mov edx, eax
00001228  488BC6            *    mov rax, rsi
0000122B  83C208            *1  add edx,size_t
0000122E  83E2F8            *1  and edx,not ( size_t - 1 )
00001231  4803C2            *1  add rax,rdx
00001234  48890508020000    *   mov ModuleInfo.stringbufferend, rax
0000123B  488B7DF8                                      mov rdi,pIdent
0000123F  C745DC01000000                                mov rc,STRING_EXPANDED
00001246                                            .elseif ( [rax].asym.state == SYM_MACRO && [rax].asym.mac_flag & M_ISFUNC )
00001246  E99B010000        *   jmp @C00E1
0000124B                    *   @C00D8:
0000124B  80781409          *   cmp [rax].asym.state , SYM_MACRO 
0000124F  0F8584010000      *   jnz @C00E2
00001255  F6403402          *   test [rax].asym.mac_flag , M_ISFUNC 
00001259  0F847A010000      *   je  @C00E2
0000125F  488BCE                                        mov rcx,rsi
00001262                                                .while islspace( [rcx] )
00001262  EB03              *   jmp @C00E4
00001264                    *   @C00E3:
00001264  48FFC1                                            inc rcx
00001267                                                .endw
00001267                    *   @C00E4:
00001267                    *   invoke islspace, [rcx] 
00001267  0FB601            *    movzx eax, byte ptr [rcx] 
0000126A  41F644070108      *   test byte ptr [r15+rax+1] , _SPACE
00001270  75F2              *   jne @C00E3
00001272                                                .if ( al == '(' )
00001272  3C28              *   cmp al , '(' 
00001274  0F855D010000      *   jnz @C00E5
0000127A                                                    mov i,ModuleInfo.token_count
0000127A  8B0510020000      *    mov eax, ModuleInfo.token_count
00001280  89852CFFFFFF      *    mov i, eax
00001286  FF852CFFFFFF                                      inc i
0000128C                                                    mov ModuleInfo.token_count,Tokenize( rcx, i, tokenarray, TOK_RESCAN )
0000128C                    *   invoke Tokenize, rcx, i, tokenarray, TOK_RESCAN 
0000128C  41B901000000      *    mov r9d, TOK_RESCAN 
00001292  4C8B4530          *    mov r8, tokenarray
00001296  8B952CFFFFFF      *    mov edx, i
0000129C  E800000000        *    call Tokenize
000012A1  890510020000      *   mov ModuleInfo.token_count, eax
000012A7  8B952CFFFFFF                                      mov  edx,i
000012AD  6BCA17                                            imul ecx,edx,asm_tok
000012B0  48034D30                                          add  rcx,tokenarray
000012B4                                                    .for ( eax = 0 : edx < ModuleInfo.token_count : edx++, rcx += asm_tok )
000012B4  33C0              *   xor eax, eax
000012B6                    *   @C00E6:
000012B6  3B1510020000      *   cmp edx , ModuleInfo.token_count
000012BC  7D20              *   jnl @C00E8
000012BE                                                        .if [rcx].asm_tok.token == T_OP_BRACKET
000012BE  803928            *   cmp [rcx].asm_tok.token , T_OP_BRACKET
000012C1  7504              *   jnz @C00E9
000012C3  FFC0                                                      inc eax
000012C5                                                        .elseif [rcx].asm_tok.token == T_CL_BRACKET
000012C5  EB0F              *   jmp @C00EA
000012C7                    *   @C00E9:
000012C7  803929            *   cmp [rcx].asm_tok.token , T_CL_BRACKET
000012CA  750A              *   jnz @C00EB
000012CC  FFC8                                                      dec eax
000012CE                                                            .ifz
000012CE  7506              *   jne @C00EC
000012D0  4883C117                                                      add rcx,asm_tok
000012D4                                                                .break
000012D4  EB08              *    jmp @C00E8
000012D6                                                            .endif
000012D6                    *   @C00EC:
000012D6                                                        .endif
000012D6                    *   @C00EB:
000012D6                    *   @C00EA:
000012D6                                                    .endf
000012D6                    *   @C00E7:
000012D6  FFC2              *   inc edx
000012D8  4883C117          *   add rcx, asm_tok
000012DC  EBD8              *   jmp @C00E6
000012DE                    *   @C00E8:
000012DE  488B55F8                                          mov rdx,pIdent
000012E2                                                    .if ( quoted_string && byte ptr [rdx-1] != '&' && [rcx].asm_tok.token != '&' )
000012E2  80BD27FFFFFF00    *   cmp quoted_string , 0
000012E9  7419              *   jz  @C00ED
000012EB  807AFF26          *   cmp byte ptr [rdx-1] , '&' 
000012EF  7413              *   jz  @C00ED
000012F1  803926            *   cmp [rcx].asm_tok.token , '&' 
000012F4  740E              *   jz  @C00ED
000012F6                                                        mov ModuleInfo.token_count,old_tokencount
000012F6  8B45EC            *    mov eax, old_tokencount
000012F9  890510020000      *    mov ModuleInfo.token_count, eax
000012FF                                                        .continue
000012FF  E921010000        *    jmp @C00D0
00001304                                                    .endif
00001304                    *   @C00ED:
00001304                                                    .if substitute
00001304  837D3800          *   cmp substitute, 0
00001308  740C              *   jz  @C00EE
0000130A                                                        .if byte ptr [rdx-1] == '&'
0000130A  807AFF26          *   cmp byte ptr [rdx-1] , '&'
0000130E  7504              *   jnz @C00EF
00001310  48FF4DF8                                                  dec pIdent
00001314                                                        .endif
00001314                    *   @C00EF:
00001314                                                    .elseif rdx > old_stringbufferend && byte ptr [rdx-1] == '%'
00001314  EB10              *   jmp @C00F0
00001316                    *   @C00EE:
00001316  483B55E0          *   cmp rdx , old_stringbufferend 
0000131A  760A              *   jna @C00F1
0000131C  807AFF25          *   cmp byte ptr [rdx-1] , '%'
00001320  7504              *   jnz @C00F1
00001322  48FF4DF8                                              dec pIdent
00001326                                                    .endif
00001326                    *   @C00F1:
00001326                    *   @C00F0:
00001326                                                    mov i,RunMacro( sym, i, tokenarray, rdi, 0, &is_exitm )
00001326                    *   invoke RunMacro, sym, i, tokenarray, rdi, 0, addr is_exitm 
00001326  488D45F0          *    lea rax, is_exitm 
0000132A  4889442428        *    mov [rsp+40], rax
0000132F  C744242000000000  *    mov dword ptr [rsp+32], 0
00001337  4C8BCF            *    mov r9, rdi
0000133A  4C8B4530          *    mov r8, tokenarray
0000133E  8B952CFFFFFF      *    mov edx, i
00001344  488B4DD0          *    mov rcx, sym
00001348  E87FEDFFFF        *    call RunMacro
0000134D  89852CFFFFFF      *   mov i, eax
00001353  8B4DEC                                            mov ecx,old_tokencount
00001356  890D10020000                                      mov ModuleInfo.token_count,ecx
0000135C                                                    .return .if eax == -1
0000135C  83F8FF            *   cmp eax , -1
0000135F  0F8452010000      *   jz  @C00F2
00001365  6BD817                                            imul ebx,eax,asm_tok
00001368  48035D30                                          add rbx,tokenarray
0000136C  488B73F8                                          mov rsi,[rbx-asm_tok].tokpos
00001370                                                    add rsi,tstrlen( [rbx-asm_tok].string_ptr )
00001370                    *   invoke tstrlen, [rbx-asm_tok].string_ptr 
00001370  488B4BF0          *    mov rcx, [rbx-asm_tok].string_ptr 
00001374  E800000000        *    call tstrlen
00001379  4803F0            *   add rsi, rax
0000137C                                                    .if ( substitute && byte ptr [rsi] == '&' )
0000137C  837D3800          *   cmp substitute , 0
00001380  7408              *   jz  @C00F3
00001382  803E26            *   cmp byte ptr [rsi] , '&' 
00001385  7503              *   jnz @C00F3
00001387  48FFC6                                                inc rsi
0000138A                                                    .endif
0000138A                    *   @C00F3:
0000138A  8B45F4                                            mov eax,lvl
0000138D  FF45F4                                            inc lvl
00001390  4889B4C530FFFFFF                                  mov _sp[rax*string_t],rsi
00001398                    *   invoke tstrlen, rdi 
00001398  488BCF            *    mov rcx, rdi 
0000139B  E800000000        *    call tstrlen
000013A0  488BF7                                            mov rsi,rdi
000013A3  488B3D08020000                                    mov rdi,ModuleInfo.stringbufferend
000013AA  488D4801                                          lea rcx,[rax+1]
000013AE  F3A4                                              rep movsb
000013B0  488B3508020000                                    mov rsi,ModuleInfo.stringbufferend
000013B7                                                    mov ModuleInfo.stringbufferend,GetAlignedPointer( rsi, eax )
000013B7                    *   invoke GetAlignedPointer, rsi, eax 
000013B7  8BD0              *    mov edx, eax
000013B9  488BC6            *    mov rax, rsi
000013BC  83C208            *1  add edx,size_t
000013BF  83E2F8            *1  and edx,not ( size_t - 1 )
000013C2  4803C2            *1  add rax,rdx
000013C5  48890508020000    *   mov ModuleInfo.stringbufferend, rax
000013CC  488B7DF8                                          mov rdi,pIdent
000013D0  C745DC01000000                                    mov rc,STRING_EXPANDED
000013D7                                                .endif
000013D7                    *   @C00E5:
000013D7                                            .elseif [rax].asym.state == SYM_MACRO
000013D7  EB0D              *   jmp @C00E1
000013D9                    *   @C00E2:
000013D9  80781409          *   cmp [rax].asym.state , SYM_MACRO
000013DD  7507              *   jnz @C00F4
000013DF  C68526FFFFFF01                                mov macro_proc,TRUE
000013E6                                            .endif
000013E6                    *   @C00F4:
000013E6                    *   @C00E1:
000013E6                                            .if lvl == MAX_TEXTMACRO_NESTING
000013E6  837DF414          *   cmp lvl , MAX_TEXTMACRO_NESTING
000013EA  750C              *   jnz @C00F5
000013EC                    *   invoke asmerr, 2123 
000013EC  B94B080000        *    mov ecx, 2123 
000013F1  E800000000        *    call asmerr
000013F6                                                .break
000013F6  EB36              *    jmp @C00F6
000013F8                                            .endif
000013F8                    *   @C00F5:
000013F8                                        .endif
000013F8                    *   @C00D7:
000013F8                                    .else
000013F8  EB2B              *   jmp @C00F7
000013FA                    *   @C00D1:
000013FA  8A06                                  mov al,[rsi]
000013FC                                        .if ( al == '"' || al == "'" )
000013FC  3C22              *   cmp al , '"' 
000013FE  7404              *   jz  @C00F9
00001400                    *   @C00FA:
00001400  3C27              *   cmp al , "'" 
00001402  7520              *   jnz @C00F8
00001404                    *   @C00F9:
00001404                                            .if ( quoted_string == 0 )
00001404  80BD27FFFFFF00    *   cmp quoted_string , 0 
0000140B  7508              *   jnz @C00FB
0000140D  888527FFFFFF                                  mov quoted_string,al
00001413                                            .elseif ( al == quoted_string )
00001413  EB0F              *   jmp @C00FC
00001415                    *   @C00FB:
00001415  3A8527FFFFFF      *   cmp al , quoted_string 
0000141B  7507              *   jnz @C00FD
0000141D  C68527FFFFFF00                                mov quoted_string,0
00001424                                            .endif
00001424                    *   @C00FD:
00001424                    *   @C00FC:
00001424                                        .endif
00001424                    *   @C00F8:
00001424  A4                                    movsb
00001425                                    .endif
00001425                    *   @C00F7:
00001425                                .endw
00001425                    *   @C00D0:
00001425  803E00            *   cmp ( byte ptr [rsi] ), 0
00001428  0F8510FDFFFF      *   jnz @C00CF
0000142E                    *   @C00F6:
0000142E                            .endf
0000142E                    *   @C00CD:
0000142E  FF4DF4            *   dec lvl
00001431  E9EEFCFFFF        *   jmp @C00CC
00001436                    *   @C00CE:
00001436  C60700                    mov byte ptr [rdi],0
00001439  48FFC7                    inc rdi
0000143C                            mov ModuleInfo.stringbufferend,old_stringbufferend
0000143C  488B45E0          *    mov rax, old_stringbufferend
00001440  48890508020000    *    mov ModuleInfo.stringbufferend, rax
00001447                            .if ( rc == STRING_EXPANDED )
00001447  837DDC01          *   cmp rc , STRING_EXPANDED 
0000144B  750F              *   jnz @C00FE
0000144D  488BCF                        mov rcx,rdi
00001450  482BC8                        sub rcx,rax
00001453  488BF0                        mov rsi,rax
00001456  488B7D28                      mov rdi,line
0000145A  F3A4                          rep movsb
0000145C                            .endif
0000145C                    *   @C00FE:
0000145C                            .if ( substitute )
0000145C  837D3800          *   cmp ( substitute ), 0
00001460  7452              *   jz  @C00FF
00001462  488B5D30                      mov rbx,tokenarray
00001466                                .if rc == STRING_EXPANDED
00001466  837DDC01          *   cmp rc , STRING_EXPANDED
0000146A  751A              *   jnz @C0100
0000146C                                    mov ModuleInfo.token_count,Tokenize( [rbx].tokpos, 0, rbx, TOK_RESCAN )
0000146C                    *   invoke Tokenize, [rbx].tokpos, 0, rbx, TOK_RESCAN 
0000146C  41B901000000      *    mov r9d, TOK_RESCAN 
00001472  4C8BC3            *    mov r8, rbx
00001475  33D2              *    xor edx, edx
00001477  488B4B0F          *    mov rcx, [rbx].tokpos
0000147B  E800000000        *    call Tokenize
00001480  890510020000      *   mov ModuleInfo.token_count, eax
00001486                                .endif
00001486                    *   @C0100:
00001486                                .if rc == STRING_EXPANDED || macro_proc
00001486  837DDC01          *   cmp rc , STRING_EXPANDED 
0000148A  7409              *   jz  @C0102
0000148C                    *   @C0103:
0000148C  80BD26FFFFFF00    *   cmp macro_proc, 0
00001493  741F              *   jz  @C0101
00001495                    *   @C0102:
00001495                                    .return 0 .if DelayExpand(rbx)
00001495                    *   invoke DelayExpand, rbx
00001495  488BCB            *    mov rcx, rbx
00001498  E800000000        *    call DelayExpand
0000149D  4885C0            *   test rax, rax
000014A0  7404              *   jz  @C0104
000014A2  33C0              *   xor eax,eax
000014A4  EB11              *   jmp @C00F2
000014A6                    *   @C0104:
000014A6                                    .return ExpandLine( [rbx].tokpos, rbx )
000014A6                    *   invoke ExpandLine, [rbx].tokpos, rbx 
000014A6  488BD3            *    mov rdx, rbx 
000014A9  488B4B0F          *    mov rcx, [rbx].tokpos
000014AD  E85B0A0000        *    call ExpandLine
000014B2  EB03              *   jmp @C00F2
000014B4                                .endif
000014B4                    *   @C0101:
000014B4                            .endif
000014B4                    *   @C00FF:
000014B4                            .return( rc )
000014B4  8B45DC            *   mov eax,( rc )
000014B7  EBFE              *   jmp @C00F2
                            *   org $ - 2
000014B7                    *   ret
000014B7                    *   @C00F2:
000014B7  C9                *   leave
000014B8  5B                *   pop rbx
000014B9  5F                *   pop rdi
000014BA  5E                *   pop rsi
000014BB  C3                *   retn 
000014BC                        ExpandText endp
000014BC                        ExpandTMacro proc fastcall private uses rsi rdi rbx outbuf:string_t,tokenarray:token_t, equmode:int_t, level:int_t
000014BC  48894C2408        *   mov [rsp+8], rcx
000014C1  4889542410        *   mov [rsp+16], rdx
000014C6  4C89442418        *   mov [rsp+24], r8
000014CB  4C894C2420        *   mov [rsp+32], r9
000014D0  56                *   push rsi
000014D1  57                *   push rdi
000014D2  53                *   push rbx
000014D3  55                *   push rbp
000014D4  488BEC            *   mov rbp, rsp
000014D7  4883EC58          *   sub rsp, 88
000014DB                            mov buffer,alloca(ModuleInfo.max_line_len)
000014DB                    *   invoke alloca, ModuleInfo.max_line_len
000014DB  8B0568010000      *   mov eax, ModuleInfo.max_line_len
000014E1  83C00F            *1  add     eax,16-1
000014E4  83E0F0            *1  and     eax,-16
000014E7  482BE0            *1  sub     rsp,rax
000014EA  488D442430        *1  lea     rax,[rsp+@ReservedStack]
000014EF  488945E0          *   mov buffer, rax
000014F3                            mov old_tokencount,ModuleInfo.token_count
000014F3  8B0510020000      *    mov eax, ModuleInfo.token_count
000014F9  8945FC            *    mov old_tokencount, eax
000014FC  C645DF01                  mov expanded,TRUE
00001500                            .if ( level >= MAX_TEXTMACRO_NESTING )
00001500  837D4014          *   cmp level , MAX_TEXTMACRO_NESTING 
00001504  7C0F              *   jl  @C0105
00001506                                .return( asmerr( 2123 ) )
00001506                    *   invoke asmerr, 2123 
00001506  B94B080000        *    mov ecx, 2123 
0000150B  E800000000        *    call asmerr
00001510  E9BF010000        *   jmp @C0106
00001515                            .endif
00001515                    *   @C0105:
00001515                            .while ( expanded == TRUE )
00001515  E9A5010000        *   jmp @C0108
0000151A                    *   @C0107:
0000151A                                mov i,old_tokencount
0000151A  8B45FC            *    mov eax, old_tokencount
0000151D  8945F8            *    mov i, eax
00001520  FF45F8                        inc i
00001523                                mov ModuleInfo.token_count,Tokenize( outbuf, i, tokenarray, TOK_RESCAN )
00001523                    *   invoke Tokenize, outbuf, i, tokenarray, TOK_RESCAN 
00001523  41B901000000      *    mov r9d, TOK_RESCAN 
00001529  4C8B4530          *    mov r8, tokenarray
0000152D  8B55F8            *    mov edx, i
00001530  488B4D28          *    mov rcx, outbuf
00001534  E800000000        *    call Tokenize
00001539  890510020000      *   mov ModuleInfo.token_count, eax
0000153F  C645DF00                      mov expanded,FALSE
00001543                                .for ( : i < ModuleInfo.token_count: i++ )
00001543                    *   @C0109:
00001543                    *   cmp i , ModuleInfo.token_count
00001543  8B0510020000      *    mov eax,  ModuleInfo.token_count
00001549  3945F8            *    cmp i , eax
0000154C  0F8D6D010000      *   jnl @C010B
00001552  6B5DF817                          imul ebx,i,asm_tok
00001556  48035D30                          add  rbx,tokenarray
0000155A                                    .if [rbx].token == T_ID
0000155A  803B08            *   cmp [rbx].token , T_ID
0000155D  0F8554010000      *   jnz @C010C
00001563                                        mov sym,SymFind([rbx].string_ptr)
00001563                    *   invoke SymFind, [rbx].string_ptr
00001563  488B4B07          *    mov rcx, [rbx].string_ptr
00001567  E800000000        *    call SymFind
0000156C  488945E8          *   mov sym, rax
00001570                                        .if ( rax && [rax].asym.state == SYM_MACRO &&[rax].asym.flags & S_ISDEFINED && [rax].asym.mac_flag & M_ISFUNC &&[rbx+asm_tok].token == T_OP_BRACKET && equmode == FALSE )
00001570  4885C0            *   test rax , rax 
00001573  0F84B7000000      *   jz  @C010D
00001579  80781409          *   cmp [rax].asym.state , SYM_MACRO 
0000157D  0F85AD000000      *   jnz @C010D
00001583  F6401702          *   test [rax].asym.flags , S_ISDEFINED 
00001587  0F84A3000000      *   je  @C010D
0000158D  F6403402          *   test [rax].asym.mac_flag , M_ISFUNC 
00001591  0F8499000000      *   je  @C010D
00001597  807B1728          *   cmp [rbx+asm_tok].token , T_OP_BRACKET 
0000159B  0F858F000000      *   jnz @C010D
000015A1  837D3800          *   cmp equmode , FALSE 
000015A5  0F8585000000      *   jnz @C010D
000015AB  488B4B0F                                  mov rcx,[rbx].tokpos
000015AF  482B4D28                                  sub rcx,outbuf
000015B3  488B7DE0                                  mov rdi,buffer
000015B7  488B7528                                  mov rsi,outbuf
000015BB  F3A4                                      rep movsb
000015BD  8B55F8                                    mov edx,i
000015C0  FFC2                                      inc edx
000015C2                                            mov i,RunMacro( sym, edx, tokenarray, rdi, 0, &is_exitm )
000015C2                    *   invoke RunMacro, sym, edx, tokenarray, rdi, 0, addr is_exitm 
000015C2  488D45F0          *    lea rax, is_exitm 
000015C6  4889442428        *    mov [rsp+40], rax
000015CB  C744242000000000  *    mov dword ptr [rsp+32], 0
000015D3  4C8BCF            *    mov r9, rdi
000015D6  4C8B4530          *    mov r8, tokenarray
000015DA  488B4DE8          *    mov rcx, sym
000015DE  E8E9EAFFFF        *    call RunMacro
000015E3  8945F8            *   mov i, eax
000015E6                                            .if i < 0
000015E6  837DF800          *   cmp i , 0
000015EA  7D15              *   jnl @C010E
000015EC                                                mov ModuleInfo.token_count,old_tokencount
000015EC  8B45FC            *    mov eax, old_tokencount
000015EF  890510020000      *    mov ModuleInfo.token_count, eax
000015F5                                                .return ERROR
000015F5  48C7C0FFFFFFFF    *   mov rax,ERROR
000015FC  E9D3000000        *   jmp @C0106
00001601                                            .endif
00001601                    *   @C010E:
00001601  6B5DF817                                  imul ebx,i,asm_tok
00001605  48035D30                                  add  rbx,tokenarray
00001609                    *   invoke tstrcat, rdi, [rbx].tokpos 
00001609  488B530F          *    mov rdx, [rbx].tokpos 
0000160D  488BCF            *    mov rcx, rdi
00001610  E800000000        *    call tstrcat
00001615                    *   invoke tstrcpy, outbuf, buffer 
00001615  488B55E0          *    mov rdx, buffer 
00001619  488B4D28          *    mov rcx, outbuf
0000161D  E800000000        *    call tstrcpy
00001622  C645DF01                                  mov expanded,TRUE
00001626                                            .break
00001626  E994000000        *    jmp @C010B
0000162B                                        .elseif ( rax && [rax].asym.state == SYM_TMACRO && [rax].asym.flags & S_ISDEFINED )
0000162B  E987000000        *   jmp @C010F
00001630                    *   @C010D:
00001630  4885C0            *   test rax , rax 
00001633  0F847E000000      *   jz  @C0110
00001639  8078140A          *   cmp [rax].asym.state , SYM_TMACRO 
0000163D  7578              *   jnz @C0110
0000163F  F6401702          *   test [rax].asym.flags , S_ISDEFINED 
00001643  7472              *   je  @C0110
00001645  488B7528                                  mov rsi,outbuf
00001649  488B7DE0                                  mov rdi,buffer
0000164D  488B4B0F                                  mov rcx,[rbx].tokpos
00001651  482BCE                                    sub rcx,rsi
00001654  F3A4                                      rep movsb
00001656                    *   invoke tstrcpy, rdi, [rax].asym.string_ptr 
00001656  488B5024          *    mov rdx, [rax].asym.string_ptr 
0000165A  488BCF            *    mov rcx, rdi
0000165D  E800000000        *    call tstrcpy
00001662  8B4D40                                    mov ecx,level
00001665  FFC1                                      inc ecx
00001667                                            .ifd ExpandTMacro( rdi, tokenarray, equmode, ecx ) == ERROR
00001667                    *   invoke ExpandTMacro, rdi, tokenarray, equmode, ecx 
00001667  448BC9            *    mov r9d, ecx 
0000166A  448B4538          *    mov r8d, equmode
0000166E  488B5530          *    mov rdx, tokenarray
00001672  488BCF            *    mov rcx, rdi
00001675  E842FEFFFF        *    call ExpandTMacro
0000167A  83F8FF            *   cmp eax , ERROR
0000167D  7512              *   jnz @C0111
0000167F                                                mov ModuleInfo.token_count,old_tokencount
0000167F  8B45FC            *    mov eax, old_tokencount
00001682  890510020000      *    mov ModuleInfo.token_count, eax
00001688                                                .return( ERROR )
00001688  48C7C0FFFFFFFF    *   mov rax,( ERROR )
0000168F  EB43              *   jmp @C0106
00001691                                            .endif
00001691                    *   @C0111:
00001691  488B45E8                                  mov rax,sym
00001695  8B5010                                    mov edx,[rax].asym.name_size
00001698  4803530F                                  add rdx,[rbx].tokpos
0000169C                    *   invoke tstrcat, rdi, rdx 
0000169C  488BCF            *    mov rcx, rdi
0000169F  E800000000        *    call tstrcat
000016A4                    *   invoke tstrcpy, outbuf, buffer 
000016A4  488B55E0          *    mov rdx, buffer 
000016A8  488B4D28          *    mov rcx, outbuf
000016AC  E800000000        *    call tstrcpy
000016B1  C645DF01                                  mov expanded,TRUE
000016B5                                            .break
000016B5  EB08              *    jmp @C010B
000016B7                                        .endif
000016B7                    *   @C0110:
000016B7                    *   @C010F:
000016B7                                    .endif
000016B7                    *   @C010C:
000016B7                                .endf
000016B7                    *   @C010A:
000016B7  FF45F8            *   inc i
000016BA  E984FEFFFF        *   jmp @C0109
000016BF                    *   @C010B:
000016BF                            .endw
000016BF                    *   @C0108:
000016BF  807DDF01          *   cmp expanded , TRUE 
000016C3  0F8451FEFFFF      *   jz  @C0107
000016C9                            mov ModuleInfo.token_count,old_tokencount
000016C9  8B45FC            *    mov eax, old_tokencount
000016CC  890510020000      *    mov ModuleInfo.token_count, eax
000016D2                           .return( NOT_ERROR )
000016D2  33C0              *   xor eax,eax
000016D4  EBFE              *   jmp @C0106
                            *   org $ - 2
000016D4                    *   ret
000016D4                    *   @C0106:
000016D4  C9                *   leave
000016D5  5B                *   pop rbx
000016D6  5F                *   pop rdi
000016D7  5E                *   pop rsi
000016D8  C3                *   retn 
000016D9                        ExpandTMacro endp
000016D9                        RebuildLine proc fastcall private uses rsi rdi rbx newstring:string_t, i:int_t,tokenarray:token_t, oldlen:uint_t, pos_line:uint_t, addbrackets:int_t
000016D9  48894C2408        *   mov [rsp+8], rcx
000016DE  4889542410        *   mov [rsp+16], rdx
000016E3  4C89442418        *   mov [rsp+24], r8
000016E8  4C894C2420        *   mov [rsp+32], r9
000016ED  56                *   push rsi
000016EE  57                *   push rdi
000016EF  53                *   push rbx
000016F0  55                *   push rbp
000016F1  488BEC            *   mov rbp, rsp
000016F4  4883EC48          *   sub rsp, 72
000016F8                            mov buffer,alloca(ModuleInfo.max_line_len)
000016F8                    *   invoke alloca, ModuleInfo.max_line_len
000016F8  8B0568010000      *   mov eax, ModuleInfo.max_line_len
000016FE  83C00F            *1  add     eax,16-1
00001701  83E0F0            *1  and     eax,-16
00001704  482BE0            *1  sub     rsp,rax
00001707  488D442420        *1  lea     rax,[rsp+@ReservedStack]
0000170C  488945E0          *   mov buffer, rax
00001710  6B5D3017                  imul ebx,i,asm_tok
00001714  48035D38                  add rbx,tokenarray
00001718  8B7540                    mov esi,oldlen
0000171B  4803730F                  add rsi,[rbx].tokpos
0000171F                            inc tstrlen( rsi )
0000171F                    *   invoke tstrlen, rsi 
0000171F  488BCE            *    mov rcx, rsi 
00001722  E800000000        *    call tstrlen
00001727  48FFC0            *   inc  rax
0000172A  8945E8                    mov rest,eax
0000172D  488B7DE0                  mov rdi,buffer
00001731  8BC8                      mov ecx,eax
00001733  F3A4                      rep movsb
00001735  488B7B0F                  mov rdi,[rbx].tokpos
00001739                            mov newlen,tstrlen( newstring )
00001739                    *   invoke tstrlen, newstring 
00001739  488B4D28          *    mov rcx, newstring 
0000173D  E800000000        *    call tstrlen
00001742  8945EC            *   mov newlen, eax
00001745                            .if ( addbrackets )
00001745  837D5000          *   cmp ( addbrackets ), 0
00001749  7424              *   jz  @C0112
0000174B  8345EC02                      add newlen,2
0000174F                                .for ( rsi = newstring, al = [rsi] : al : rsi++, al = [rsi] )
0000174F  488B7528          *   mov rsi, newstring
00001753  8A06              *   mov al, [rsi]
00001755                    *   @C0113:
00001755  84C0              *   test al, al
00001757  7416              *   jz  @C0115
00001759                                    .if ( al == '<' || al == '>' || al == '!' );; count '!' operator
00001759  3C3C              *   cmp al , '<' 
0000175B  7408              *   jz  @C0117
0000175D                    *   @C0118:
0000175D  3C3E              *   cmp al , '>' 
0000175F  7404              *   jz  @C0117
00001761                    *   @C0119:
00001761  3C21              *   cmp al , '!' 
00001763  7503              *   jnz @C0116
00001765                    *   @C0117:
00001765  FF45EC                                inc newlen
00001768                                    .endif
00001768                    *   @C0116:
00001768                                .endf
00001768                    *   @C0114:
00001768  48FFC6            *   inc rsi
0000176B  8A06              *   mov al, [rsi]
0000176D  EBE6              *   jmp @C0113
0000176F                    *   @C0115:
0000176F                            .endif
0000176F                    *   @C0112:
0000176F                            .if ( newlen > oldlen )
0000176F                    *   cmp newlen , oldlen 
0000176F  8B4540            *    mov eax,  oldlen 
00001772  3945EC            *    cmp newlen , eax
00001775  7620              *   jna @C011A
00001777  8B4548                        mov eax,pos_line
0000177A  0345EC                        add eax,newlen
0000177D  2B4540                        sub eax,oldlen
00001780  0345E8                        add eax,rest
00001783                                .if ( eax >= ModuleInfo.max_line_len )
00001783  3B0568010000      *   cmp eax , ModuleInfo.max_line_len 
00001789  720C              *   jb  @C011B
0000178B                                    .return asmerr( 2039 )
0000178B                    *   invoke asmerr, 2039 
0000178B  B9F7070000        *    mov ecx, 2039 
00001790  E800000000        *    call asmerr
00001795  EB76              *   jmp @C011C
00001797                                .endif
00001797                    *   @C011B:
00001797                            .endif
00001797                    *   @C011A:
00001797                            .if ( addbrackets )
00001797  837D5000          *   cmp ( addbrackets ), 0
0000179B  7435              *   jz  @C011D
0000179D  C6073C                        mov byte ptr [rdi],'<'
000017A0  48FFC7                        inc rdi
000017A3                                .for ( rsi = newstring: byte ptr [rsi] : rsi++ )
000017A3  488B7528          *   mov rsi, newstring
000017A7                    *   @C011E:
000017A7  803E00            *   cmp byte ptr [rsi], 0
000017AA  741E              *   jz  @C0120
000017AC  8A06                              mov al,[rsi]
000017AE                                    .if ( al == '<' || al == '>' || al == '!' )
000017AE  3C3C              *   cmp al , '<' 
000017B0  7408              *   jz  @C0122
000017B2                    *   @C0123:
000017B2  3C3E              *   cmp al , '>' 
000017B4  7404              *   jz  @C0122
000017B6                    *   @C0124:
000017B6  3C21              *   cmp al , '!' 
000017B8  7506              *   jnz @C0121
000017BA                    *   @C0122:
000017BA  C60721                                mov byte ptr [rdi],'!'
000017BD  48FFC7                                inc rdi
000017C0                                    .endif
000017C0                    *   @C0121:
000017C0  8807                              mov [rdi],al
000017C2  48FFC7                            inc rdi
000017C5                                .endf
000017C5                    *   @C011F:
000017C5  48FFC6            *   inc rsi
000017C8  EBDD              *   jmp @C011E
000017CA                    *   @C0120:
000017CA  C6073E                        mov byte ptr [rdi],'>'
000017CD  48FFC7                        inc rdi
000017D0                            .else
000017D0  EB09              *   jmp @C0125
000017D2                    *   @C011D:
000017D2  8B4DEC                        mov ecx,newlen
000017D5  488B7528                      mov rsi,newstring
000017D9  F3A4                          rep movsb
000017DB                            .endif
000017DB                    *   @C0125:
000017DB  8B4DE8                    mov ecx,rest
000017DE  488B75E0                  mov rsi,buffer
000017E2  F3A4                      rep movsb
000017E4                            .for ( ecx = i, ecx++,rbx += asm_tok,eax = oldlen,edx = newlen : ecx <= ModuleInfo.token_count : ecx++, rbx += asm_tok )
000017E4  8B4D30            *   mov ecx, i
000017E7  FFC1              *   inc ecx
000017E9  4883C317          *   add rbx, asm_tok
000017ED  8B4540            *   mov eax, oldlen
000017F0  8B55EC            *   mov edx, newlen
000017F3                    *   @C0126:
000017F3  3B0D10020000      *   cmp ecx , ModuleInfo.token_count
000017F9  7F10              *   jg  @C0128
000017FB  4829430F                      sub [rbx].tokpos,rax
000017FF  4801530F                      add [rbx].tokpos,rdx
00001803                            .endf
00001803                    *   @C0127:
00001803  FFC1              *   inc ecx
00001805  4883C317          *   add rbx, asm_tok
00001809  EBE8              *   jmp @C0126
0000180B                    *   @C0128:
0000180B                            .return( NOT_ERROR )
0000180B  33C0              *   xor eax,eax
0000180D  EBFE              *   jmp @C011C
                            *   org $ - 2
0000180D                    *   ret
0000180D                    *   @C011C:
0000180D  C9                *   leave
0000180E  5B                *   pop rbx
0000180F  5F                *   pop rdi
00001810  5E                *   pop rsi
00001811  C3                *   retn 
00001812                        RebuildLine endp
00001812                        ExpandToken proc fastcall private uses rsi rdi rbx line:string_t, pi:ptr int_t, tokenarray:token_t,max:int_t, bracket_flags:int_t, equmode:int_t, buffer:ptr char_t
00001812  48894C2408        *   mov [rsp+8], rcx
00001817  4889542410        *   mov [rsp+16], rdx
0000181C  4C89442418        *   mov [rsp+24], r8
00001821  4C894C2420        *   mov [rsp+32], r9
00001826  56                *   push rsi
00001827  57                *   push rdi
00001828  53                *   push rbx
00001829  55                *   push rbp
0000182A  488BEC            *   mov rbp, rsp
0000182D  4881ECB8000000    *   sub rsp, 184
00001834  488B5530                  mov rdx,pi
00001838                            mov i,[rdx]
00001838  8B02              *    mov eax, [rdx]
0000183A  8945F4            *    mov i, eax
0000183D                            mov addbrackets,bracket_flags
0000183D  8B4548            *    mov eax, bracket_flags
00001840  8945EC            *    mov addbrackets, eax
00001843  C645EB00                  mov evaluate,FALSE
00001847  C7857CFFFFFF000000        mov rc,NOT_ERROR
00001851                            .for ( : i < max : i++ )
00001851                    *   @C0129:
00001851                    *   cmp i , max
00001851  8B4540            *    mov eax,  max
00001854  3945F4            *    cmp i , eax
00001857  0F8D57030000      *   jnl @C012B
0000185D  6B5DF417                      imul ebx,i,asm_tok
00001861  48035D38                      add rbx,tokenarray
00001865                                .break .if ( [rbx].token == T_COMMA )
00001865  803B2C            *   cmp [rbx].token , T_COMMA 
00001868  0F8446030000      *   jz  @C012B
0000186E                                .if ( [rbx].token == T_PERCENT && addbrackets && evaluate == FALSE )
0000186E  803B25            *   cmp [rbx].token , T_PERCENT 
00001871  7529              *   jnz @C012C
00001873  837DEC00          *   cmp addbrackets , 0
00001877  7423              *   jz  @C012C
00001879  807DEB00          *   cmp evaluate , FALSE 
0000187D  751D              *   jnz @C012C
0000187F  C645EB01                          mov evaluate,TRUE
00001883  C745EC00000000                    mov addbrackets,FALSE
0000188A  C7455000000000                    mov equmode,FALSE
00001891                                    mov pos,i
00001891  8B45F4            *    mov eax, i
00001894  8945FC            *    mov pos, eax
00001897                                   .continue
00001897  E910030000        *    jmp @C012A
0000189C                                .endif
0000189C                    *   @C012C:
0000189C                                .if ( [rbx].token == T_ID )
0000189C  803B08            *   cmp [rbx].token , T_ID 
0000189F  0F8507030000      *   jnz @C012D
000018A5                                    mov rsi,SymFind([rbx].string_ptr)
000018A5                    *   invoke SymFind, [rbx].string_ptr
000018A5  488B4B07          *    mov rcx, [rbx].string_ptr
000018A9  E800000000        *    call SymFind
000018AE  488BF0            *   mov rsi, rax
000018B1                                    .if ( rsi )
000018B1  4885F6            *   test ( rsi ), ( rsi )
000018B4  0F84F2020000      *   jz  @C012E
000018BA                                        .if ( [rsi].asym.state == SYM_MACRO )
000018BA  807E1409          *   cmp [rsi].asym.state , SYM_MACRO 
000018BE  0F85F4010000      *   jnz @C012F
000018C4  8B4DF4                                    mov ecx,i
000018C7  8BF9                                      mov edi,ecx
000018C9                                            .if ( [rsi].asym.mac_flag & M_ISFUNC )
000018C9  F6463402          *   test [rsi].asym.mac_flag , M_ISFUNC 
000018CD  0F8453010000      *   je  @C0130
000018D3                                                .continue .if ( [rbx+asm_tok].token != T_OP_BRACKET )
000018D3  807B1728          *   cmp [rbx+asm_tok].token , T_OP_BRACKET 
000018D7  0F85CF020000      *   jnz @C012A
000018DD  FF45F4                                        inc i
000018E0  4883C317                                      add rbx,asm_tok
000018E4                                                .if ( equmode == TRUE )
000018E4  837D5001          *   cmp equmode , TRUE 
000018E8  753B              *   jnz @C0131
000018EA  FF45F4                                            inc i
000018ED  4883C317                                          add rbx,asm_tok
000018F1                                                    .for ( ecx = 1: i < max: i++, rbx += asm_tok )
000018F1  B901000000        *   mov ecx, 1
000018F6                    *   @C0132:
000018F6                    *   cmp i , max
000018F6  8B4540            *    mov eax,  max
000018F9  3945F4            *    cmp i , eax
000018FC  7D1B              *   jnl @C0134
000018FE                                                        .if ( [rbx].token == T_OP_BRACKET )
000018FE  803B28            *   cmp [rbx].token , T_OP_BRACKET 
00001901  7504              *   jnz @C0135
00001903  FFC1                                                      inc ecx
00001905                                                        .elseif ( [rbx].token == T_CL_BRACKET )
00001905  EB09              *   jmp @C0136
00001907                    *   @C0135:
00001907  803B29            *   cmp [rbx].token , T_CL_BRACKET 
0000190A  7504              *   jnz @C0137
0000190C  FFC9                                                      dec ecx
0000190E                                                            .break .ifz
0000190E  7409              *   je  @C0134
00001910                                                        .endif
00001910                    *   @C0137:
00001910                    *   @C0136:
00001910                                                    .endf
00001910                    *   @C0133:
00001910  FF45F4            *   inc i
00001913  4883C317          *   add rbx, asm_tok
00001917  EBDD              *   jmp @C0132
00001919                    *   @C0134:
00001919  FF4DF4                                            dec i
0000191C  4883EB17                                          sub rbx,asm_tok
00001920                                                   .continue
00001920  E987020000        *    jmp @C012A
00001925                                                .endif
00001925                    *   @C0131:
00001925  33D2                                          xor edx,edx
00001927                                                .if edi == 1
00001927  83FF01            *   cmp edi , 1
0000192A  7505              *   jnz @C0138
0000192C  BA01000000                                        mov edx,MF_LABEL
00001931                                                .endif
00001931                    *   @C0138:
00001931                                                mov i,RunMacro( rsi, i, tokenarray, buffer, edx, &is_exitm )
00001931                    *   invoke RunMacro, rsi, i, tokenarray, buffer, edx, addr is_exitm 
00001931  488D45E4          *    lea rax, is_exitm 
00001935  4889442428        *    mov [rsp+40], rax
0000193A  89542420          *    mov [rsp+32], edx
0000193E  4C8B4D58          *    mov r9, buffer
00001942  4C8B4538          *    mov r8, tokenarray
00001946  8B55F4            *    mov edx, i
00001949  488BCE            *    mov rcx, rsi
0000194C  E87BE7FFFF        *    call RunMacro
00001951  8945F4            *   mov i, eax
00001954                                                .return .if ( eax == -1 )
00001954  83F8FF            *   cmp eax , -1 
00001957  0F84E2030000      *   jz  @C0139
0000195D  6B5DF417                                      imul ebx,i,asm_tok
00001961  48035D38                                      add rbx,tokenarray
00001965                                                .if edi && !addbrackets
00001965  85FF              *   test edi , edi 
00001967  7423              *   jz  @C013A
00001969  837DEC00          *   cmp addbrackets, 0
0000196D  751D              *   jnz @C013A
0000196F                                                    .return .ifd ExpandTMacro( buffer, tokenarray, equmode, 0 ) == ERROR
0000196F                    *   invoke ExpandTMacro, buffer, tokenarray, equmode, 0 
0000196F  4533C9            *    xor r9d, r9d
00001972  448B4550          *    mov r8d, equmode
00001976  488B5538          *    mov rdx, tokenarray
0000197A  488B4D58          *    mov rcx, buffer
0000197E  E839FBFFFF        *    call ExpandTMacro
00001983  83F8FF            *   cmp eax , ERROR
00001986  0F84B3030000      *   jz  @C0139
0000198C                                                .endif
0000198C                    *   @C013A:
0000198C  6BCF17                                        imul ecx,edi,asm_tok
0000198F  488B43F8                                      mov rax,[rbx-asm_tok].tokpos
00001993  48FFC0                                        inc rax
00001996  48034D38                                      add rcx,tokenarray
0000199A  482B410F                                      sub rax,[rcx].asm_tok.tokpos
0000199E  8945F0                                        mov size,eax
000019A1  8BD7                                          mov edx,edi
000019A3  FFC2                                          inc edx
000019A5  8BCA                                          mov ecx,edx
000019A7  2B4DF4                                        sub ecx,i
000019AA                    *   invoke AddTokens, tokenarray, edx, ecx, ModuleInfo.token_count 
000019AA  448B0D10020000    *    mov r9d, ModuleInfo.token_count 
000019B1  448BC1            *    mov r8d, ecx
000019B4  488B4D38          *    mov rcx, tokenarray
000019B8  E842F6FFFF        *    call AddTokens
000019BD  8BC7                                          mov eax,edi
000019BF  FFC0                                          inc eax
000019C1  2B45F4                                        sub eax,i
000019C4  010510020000                                  add ModuleInfo.token_count,eax
000019CA                                                .if ( ModuleInfo.token_count < max );; take care not to read beyond T_FINAL
000019CA                    *   cmp ModuleInfo.token_count , max 
000019CA  8B4540            *    mov eax,  max 
000019CD  390510020000      *    cmp ModuleInfo.token_count , eax
000019D3  7D09              *   jnl @C013B
000019D5                                                    mov max,ModuleInfo.token_count
000019D5  8B0510020000      *    mov eax, ModuleInfo.token_count
000019DB  894540            *    mov max, eax
000019DE                                                .endif
000019DE                    *   @C013B:
000019DE  6BCF17                                        imul ecx,edi,asm_tok
000019E1  48034D38                                      add rcx,tokenarray
000019E5  488B510F                                      mov rdx,[rcx].asm_tok.tokpos
000019E9  482B5528                                      sub rdx,line
000019ED                                                .return .ifd RebuildLine( buffer, edi, tokenarray, size, edx, addbrackets ) == ERROR
000019ED                    *   invoke RebuildLine, buffer, edi, tokenarray, size, edx, addbrackets 
000019ED  8B45EC            *    mov eax, addbrackets 
000019F0  89442428          *    mov [rsp+40], eax
000019F4  89542420          *    mov [rsp+32], edx
000019F8  448B4DF0          *    mov r9d, size
000019FC  4C8B4538          *    mov r8, tokenarray
00001A00  8BD7              *    mov edx, edi
00001A02  488B4D58          *    mov rcx, buffer
00001A06  E8CEFCFFFF        *    call RebuildLine
00001A0B  83F8FF            *   cmp eax , ERROR
00001A0E  0F842B030000      *   jz  @C0139
00001A14  C7857CFFFFFF010000                            mov rc,STRING_EXPANDED
00001A1E  897DF4                                        mov i,edi
00001A21                                            .else
00001A21  E98D000000        *   jmp @C013C
00001A26                    *   @C0130:
00001A26  8B55F4                                        mov edx,i
00001A29  488B4D38                                      mov rcx,tokenarray
00001A2D                                                .if ( edx == 0 || ( edx == 2 && ( [rcx+asm_tok].asm_tok.token == T_COLON ||[rcx+asm_tok].asm_tok.token == T_DBL_COLON ) ) ||( edx == 1 && [rsi].asym.mac_flag & M_LABEL ) )
00001A2D  85D2              *   test edx , edx 
00001A2F  741C              *   jz  @C013E
00001A31                    *   @C013F:
00001A31  83FA02            *   cmp edx , 2 
00001A34  750C              *   jnz @C0142
00001A36  8079173A          *   cmp [rcx+asm_tok].asm_tok.token , T_COLON 
00001A3A  7411              *   jz  @C013E
00001A3C                    *   @C0141:
00001A3C  8079170D          *   cmp [rcx+asm_tok].asm_tok.token , T_DBL_COLON 
00001A40  740B              *   jz  @C013E
00001A42                    *   @C0142:
00001A42  83FA01            *   cmp edx , 1 
00001A45  7508              *   jnz @C013D
00001A47  F6463404          *   test [rsi].asym.mac_flag , M_LABEL 
00001A4B  7402              *   je  @C013D
00001A4D                    *   @C013E:
00001A4D                                                .else
00001A4D  EB05              *   jmp @C0143
00001A4F                    *   @C013D:
00001A4F                                                    .continue
00001A4F  E958010000        *    jmp @C012A
00001A54                                                .endif
00001A54                    *   @C0143:
00001A54                                                .if ( edx == 2 )
00001A54  83FA02            *   cmp edx , 2 
00001A57  7519              *   jnz @C0144
00001A59                                                    .return .ifd WriteCodeLabel( line, tokenarray ) == ERROR
00001A59                    *   invoke WriteCodeLabel, line, tokenarray 
00001A59  488B5538          *    mov rdx, tokenarray 
00001A5D  488B4D28          *    mov rcx, line
00001A61  E800000000        *    call WriteCodeLabel
00001A66  83F8FF            *   cmp eax , ERROR
00001A69  0F84D0020000      *   jz  @C0139
00001A6F  8B55F4                                            mov edx,i
00001A72                                                .endif
00001A72                    *   @C0144:
00001A72  B902000000                                    mov ecx,MF_NOSAVE
00001A77                                                .if ( edx == 1 )
00001A77  83FA01            *   cmp edx , 1 
00001A7A  7503              *   jnz @C0145
00001A7C  83C901                                            or ecx,MF_LABEL
00001A7F                                                .endif
00001A7F                    *   @C0145:
00001A7F  FFC2                                          inc edx
00001A81                                                .ifd ( RunMacro( rsi, edx, tokenarray, NULL, ecx, &is_exitm ) == -1 )
00001A81                    *   invoke RunMacro, rsi, edx, tokenarray, NULL, ecx, addr is_exitm 
00001A81  488D45E4          *    lea rax, is_exitm 
00001A85  4889442428        *    mov [rsp+40], rax
00001A8A  894C2420          *    mov [rsp+32], ecx
00001A8E  4533C9            *    xor r9d, r9d
00001A91  4C8B4538          *    mov r8, tokenarray
00001A95  488BCE            *    mov rcx, rsi
00001A98  E82FE6FFFF        *    call RunMacro
00001A9D  83F8FF            *   cmp eax , -1 
00001AA0  7505              *   jnz @C0146
00001AA2                                                    .return
00001AA2  E998020000        *   jmp @C0139
00001AA7                                                .endif
00001AA7                    *   @C0146:
00001AA7                                                .return EMPTY;; no further processing
00001AA7  48C7C0FEFFFFFF    *   mov rax,EMPTY
00001AAE  E98C020000        *   jmp @C0139
00001AB3                                            .endif
00001AB3                    *   @C013C:
00001AB3                                        .elseif ( [rsi].asym.state == SYM_TMACRO )
00001AB3  E9F4000000        *   jmp @C0147
00001AB8                    *   @C012F:
00001AB8  807E140A          *   cmp [rsi].asym.state , SYM_TMACRO 
00001ABC  0F85EA000000      *   jnz @C0148
00001AC2                                            .if ( [rbx-asm_tok].token == T_DOT )
00001AC2  807BE92E          *   cmp [rbx-asm_tok].token , T_DOT 
00001AC6  7574              *   jnz @C0149
00001AC8  8B4DF4                                        mov ecx,i
00001ACB  83E902                                        sub ecx,2
00001ACE  488D53D2                                      lea rdx,[rbx-asm_tok*2]
00001AD2                                                .while ( [rdx-asm_tok].asm_tok.token == T_DOT )
00001AD2  EB07              *   jmp @C014B
00001AD4                    *   @C014A:
00001AD4  83E902                                            sub ecx,2
00001AD7  488D52D2                                          lea rdx,[rdx-asm_tok*2]
00001ADB                                                .endw
00001ADB                    *   @C014B:
00001ADB  807AE92E          *   cmp [rdx-asm_tok].asm_tok.token , T_DOT 
00001ADF  74F3              *   jz  @C014A
00001AE1                                                .if ( [rdx].asm_tok.token == T_CL_SQ_BRACKET )
00001AE1  803A5D            *   cmp [rdx].asm_tok.token , T_CL_SQ_BRACKET 
00001AE4  7522              *   jnz @C014C
00001AE6                                                    .for ( eax = 0 : rdx > tokenarray : rdx -= asm_tok, ecx-- )
00001AE6  33C0              *   xor eax, eax
00001AE8                    *   @C014D:
00001AE8  483B5538          *   cmp rdx , tokenarray
00001AEC  761A              *   jna @C014F
00001AEE                                                        .if ( [rdx].asm_tok.token == T_OP_SQ_BRACKET )
00001AEE  803A5B            *   cmp [rdx].asm_tok.token , T_OP_SQ_BRACKET 
00001AF1  7506              *   jnz @C0150
00001AF3  FFC8                                                      dec eax
00001AF5                                                           .break .ifz
00001AF5  7411              *   je  @C014F
00001AF7                                                        .elseif ( [rdx].asm_tok.token == T_CL_SQ_BRACKET )
00001AF7  EB07              *   jmp @C0151
00001AF9                    *   @C0150:
00001AF9  803A5D            *   cmp [rdx].asm_tok.token , T_CL_SQ_BRACKET 
00001AFC  7502              *   jnz @C0152
00001AFE  FFC0                                                      inc eax
00001B00                                                        .endif
00001B00                    *   @C0152:
00001B00                    *   @C0151:
00001B00                                                    .endf
00001B00                    *   @C014E:
00001B00  4883EA17          *   sub rdx, asm_tok
00001B04  FFC9              *   dec ecx
00001B06  EBE0              *   jmp @C014D
00001B08                    *   @C014F:
00001B08                                                .endif
00001B08                    *   @C014C:
00001B08  894DF8                                        mov i2,ecx
00001B0B                                                .ifd ( EvalOperand( &i2, tokenarray, ModuleInfo.token_count, &opndx, EXPF_NOERRMSG ) != ERROR )
00001B0B                    *   invoke EvalOperand, addr i2, tokenarray, ModuleInfo.token_count, addr opndx, EXPF_NOERRMSG 
00001B0B  C644242001        *    mov byte ptr [rsp+32], EXPF_NOERRMSG 
00001B10  4C8D4D80          *    lea r9, opndx
00001B14  448B0510020000    *    mov r8d, ModuleInfo.token_count
00001B1B  488B5538          *    mov rdx, tokenarray
00001B1F  488D4DF8          *    lea rcx, i2
00001B23  E800000000        *    call EvalOperand
00001B28  83F8FF            *   cmp eax , ERROR 
00001B2B  740F              *   jz  @C0153
00001B2D                                                    .if ( opndx.kind == EXPR_ADDR && opndx.mbr )
00001B2D  837DBC01          *   cmp opndx.kind , EXPR_ADDR 
00001B31  7509              *   jnz @C0154
00001B33  48837DD400        *   cmp opndx.mbr , 0
00001B38  7402              *   jz  @C0154
00001B3A                                                        .continue
00001B3A  EB70              *    jmp @C012A
00001B3C                                                    .endif
00001B3C                    *   @C0154:
00001B3C                                                .endif
00001B3C                    *   @C0153:
00001B3C                                            .endif
00001B3C                    *   @C0149:
00001B3C                    *   invoke tstrcpy, buffer, [rsi].asym.string_ptr 
00001B3C  488B5624          *    mov rdx, [rsi].asym.string_ptr 
00001B40  488B4D58          *    mov rcx, buffer
00001B44  E800000000        *    call tstrcpy
00001B49                                            .ifd ( ExpandTMacro( buffer, tokenarray, equmode, 0 ) == ERROR )
00001B49                    *   invoke ExpandTMacro, buffer, tokenarray, equmode, 0 
00001B49  4533C9            *    xor r9d, r9d
00001B4C  448B4550          *    mov r8d, equmode
00001B50  488B5538          *    mov rdx, tokenarray
00001B54  488B4D58          *    mov rcx, buffer
00001B58  E85FF9FFFF        *    call ExpandTMacro
00001B5D  83F8FF            *   cmp eax , ERROR 
00001B60  7505              *   jnz @C0155
00001B62                                                .return
00001B62  E9D8010000        *   jmp @C0139
00001B67                                            .endif
00001B67                    *   @C0155:
00001B67                                            mov edx,tstrlen( [rbx].string_ptr )
00001B67                    *   invoke tstrlen, [rbx].string_ptr 
00001B67  488B4B07          *    mov rcx, [rbx].string_ptr 
00001B6B  E800000000        *    call tstrlen
00001B70  8BD0              *   mov edx, eax
00001B72  488B4B0F                                  mov rcx,[rbx].tokpos
00001B76  482B4D28                                  sub rcx,line
00001B7A                                            .ifd ( RebuildLine( buffer, i, tokenarray, edx, ecx, addbrackets ) == ERROR )
00001B7A                    *   invoke RebuildLine, buffer, i, tokenarray, edx, ecx, addbrackets 
00001B7A  8B45EC            *    mov eax, addbrackets 
00001B7D  89442428          *    mov [rsp+40], eax
00001B81  894C2420          *    mov [rsp+32], ecx
00001B85  448BCA            *    mov r9d, edx
00001B88  4C8B4538          *    mov r8, tokenarray
00001B8C  8B55F4            *    mov edx, i
00001B8F  488B4D58          *    mov rcx, buffer
00001B93  E841FBFFFF        *    call RebuildLine
00001B98  83F8FF            *   cmp eax , ERROR 
00001B9B  7505              *   jnz @C0156
00001B9D                                                .return
00001B9D  E99D010000        *   jmp @C0139
00001BA2                                            .endif
00001BA2                    *   @C0156:
00001BA2  C7857CFFFFFF010000                        mov rc,STRING_EXPANDED
00001BAC                                        .endif
00001BAC                    *   @C0148:
00001BAC                    *   @C0147:
00001BAC                                    .endif
00001BAC                    *   @C012E:
00001BAC                                .endif
00001BAC                    *   @C012D:
00001BAC                            .endf
00001BAC                    *   @C012A:
00001BAC  FF45F4            *   inc i
00001BAF  E99DFCFFFF        *   jmp @C0129
00001BB4                    *   @C012B:
00001BB4  8B4DF4                    mov ecx,i
00001BB7  488B4530                  mov rax,pi
00001BBB  8908                      mov [rax],ecx
00001BBD                            .if ( evaluate )
00001BBD  807DEB00          *   cmp ( evaluate ), 0
00001BC1  0F8472010000      *   jz  @C0157
00001BC7                                mov old_tokencount,ModuleInfo.token_count
00001BC7  8B0510020000      *    mov eax, ModuleInfo.token_count
00001BCD  898578FFFFFF      *    mov old_tokencount, eax
00001BD3  488B5D38                      mov rbx,tokenarray
00001BD7  8B55FC                        mov edx,pos
00001BDA  488D4201                      lea rax,[rdx+1]
00001BDE                                .if ( eax == i );; just a single %?
00001BDE  3B45F4            *   cmp eax , i 
00001BE1  750F              *   jnz @C0158
00001BE3  C7458000000000                    mov opndx.value,0
00001BEA  8955F4                            mov i,edx
00001BED                                .else
00001BED  E995000000        *   jmp @C0159
00001BF2                    *   @C0158:
00001BF2  8955F4                            mov i,edx
00001BF5  FFC2                              inc edx
00001BF7  6BC917                            imul ecx,ecx,asm_tok
00001BFA  6BD217                            imul edx,edx,asm_tok
00001BFD  488B4C0B0F                        mov rcx,[rbx+rcx].tokpos
00001C02  488B74130F                        mov rsi,[rbx+rdx].tokpos
00001C07  488B7D58                          mov rdi,buffer
00001C0B  482BCE                            sub rcx,rsi
00001C0E  F3A4                              rep movsb
00001C10  C60700                            mov byte ptr [rdi],0
00001C13  8BBD78FFFFFF                      mov edi,old_tokencount
00001C19  FFC7                              inc edi
00001C1B                                    mov ModuleInfo.token_count,Tokenize( buffer, edi, tokenarray, TOK_RESCAN )
00001C1B                    *   invoke Tokenize, buffer, edi, tokenarray, TOK_RESCAN 
00001C1B  41B901000000      *    mov r9d, TOK_RESCAN 
00001C21  4C8B4538          *    mov r8, tokenarray
00001C25  8BD7              *    mov edx, edi
00001C27  488B4D58          *    mov rcx, buffer
00001C2B  E800000000        *    call Tokenize
00001C30  890510020000      *   mov ModuleInfo.token_count, eax
00001C36  897DF8                            mov i2,edi
00001C39                                    .ifd EvalOperand( &i2, tokenarray, ModuleInfo.token_count, &opndx, EXPF_NOUNDEF ) == ERROR
00001C39                    *   invoke EvalOperand, addr i2, tokenarray, ModuleInfo.token_count, addr opndx, EXPF_NOUNDEF 
00001C39  C644242002        *    mov byte ptr [rsp+32], EXPF_NOUNDEF 
00001C3E  4C8D4D80          *    lea r9, opndx
00001C42  448B0510020000    *    mov r8d, ModuleInfo.token_count
00001C49  488B5538          *    mov rdx, tokenarray
00001C4D  488D4DF8          *    lea rcx, i2
00001C51  E800000000        *    call EvalOperand
00001C56  83F8FF            *   cmp eax , ERROR
00001C59  7509              *   jnz @C015A
00001C5B  C7458000000000                        mov opndx.value,0
00001C62                                    .elseif opndx.kind != EXPR_CONST
00001C62  EB17              *   jmp @C015B
00001C64                    *   @C015A:
00001C64  837DBC00          *   cmp opndx.kind , EXPR_CONST
00001C68  7411              *   jz  @C015C
00001C6A                    *   invoke asmerr, 2026 
00001C6A  B9EA070000        *    mov ecx, 2026 
00001C6F  E800000000        *    call asmerr
00001C74  C7458000000000                        mov opndx.value,0
00001C7B                                    .endif
00001C7B                    *   @C015C:
00001C7B                    *   @C015B:
00001C7B                                    mov ModuleInfo.token_count,old_tokencount
00001C7B  8B8578FFFFFF      *    mov eax, old_tokencount
00001C81  890510020000      *    mov ModuleInfo.token_count, eax
00001C87                                .endif
00001C87                    *   @C0159:
00001C87  C7458400000000                mov opndx.hvalue,0
00001C8E                    *   invoke myltoa, opndx.llvalue, ModuleInfo.stringbufferend, ModuleInfo.radix, FALSE, FALSE 
00001C8E  C744242000000000  *    mov dword ptr [rsp+32], FALSE 
00001C96  4533C9            *    xor r9d, r9d
00001C99  440FB605A0010000  *    movzx r8d, ModuleInfo.radix
00001CA1  488B1508020000    *    mov rdx, ModuleInfo.stringbufferend
00001CA8  488B4D80          *    mov rcx, opndx.llvalue
00001CAC  E84FE3FFFF        *    call myltoa
00001CB1  488B7530                      mov rsi,pi
00001CB5  8B36                          mov esi,[rsi]
00001CB7  6BC617                        imul eax,esi,asm_tok
00001CBA  6B55F417                      imul edx,i,asm_tok
00001CBE  488B7C030F                    mov rdi,[rbx+rax].tokpos
00001CC3  482B7C130F                    sub rdi,[rbx+rdx].tokpos
00001CC8  4803DA                        add rbx,rdx
00001CCB                                mov [rbx].string_ptr,ModuleInfo.stringbufferend
00001CCB  488B0508020000    *    mov rax, ModuleInfo.stringbufferend
00001CD2  48894307          *    mov [rbx].string_ptr, rax
00001CD6  8B45F4                        mov eax,i
00001CD9  FFC0                          inc eax
00001CDB  8BD0                          mov edx,eax
00001CDD  2BD6                          sub edx,esi
00001CDF                    *   invoke AddTokens, tokenarray, eax, edx, ModuleInfo.token_count 
00001CDF  448B0D10020000    *    mov r9d, ModuleInfo.token_count 
00001CE6  448BC2            *    mov r8d, edx
00001CE9  8BD0              *    mov edx, eax
00001CEB  488B4D38          *    mov rcx, tokenarray
00001CEF  E80BF3FFFF        *    call AddTokens
00001CF4  8B45F4                        mov eax,i
00001CF7  FFC0                          inc eax
00001CF9  2BC6                          sub eax,esi
00001CFB  010510020000                  add ModuleInfo.token_count,eax
00001D01  488B4B0F                      mov rcx,[rbx].tokpos
00001D05  482B4D28                      sub rcx,line
00001D09                                .return .ifd RebuildLine( ModuleInfo.stringbufferend, i, tokenarray, edi, ecx, bracket_flags ) == ERROR
00001D09                    *   invoke RebuildLine, ModuleInfo.stringbufferend, i, tokenarray, edi, ecx, bracket_flags 
00001D09  8B4548            *    mov eax, bracket_flags 
00001D0C  89442428          *    mov [rsp+40], eax
00001D10  894C2420          *    mov [rsp+32], ecx
00001D14  448BCF            *    mov r9d, edi
00001D17  4C8B4538          *    mov r8, tokenarray
00001D1B  8B55F4            *    mov edx, i
00001D1E  488B0D08020000    *    mov rcx, ModuleInfo.stringbufferend
00001D25  E8AFF9FFFF        *    call RebuildLine
00001D2A  83F8FF            *   cmp eax , ERROR
00001D2D  7410              *   jz  @C0139
00001D2F  C7857CFFFFFF010000            mov rc,STRING_EXPANDED
00001D39                            .endif
00001D39                    *   @C0157:
00001D39                            .return( rc )
00001D39  8B857CFFFFFF      *   mov eax,( rc )
00001D3F  EBFE              *   jmp @C0139
                            *   org $ - 2
00001D3F                    *   ret
00001D3F                    *   @C0139:
00001D3F  C9                *   leave
00001D40  5B                *   pop rbx
00001D41  5F                *   pop rdi
00001D42  5E                *   pop rsi
00001D43  C3                *   retn 
00001D44                        ExpandToken endp
00001D44                        ExpandLineItems proc fastcall uses rsi rdi line:string_t, i:int_t, tokenarray:token_t,addbrackets:int_t, equmode:int_t
00001D44  48894C2408        *   mov [rsp+8], rcx
00001D49  4889542410        *   mov [rsp+16], rdx
00001D4E  4C89442418        *   mov [rsp+24], r8
00001D53  4C894C2420        *   mov [rsp+32], r9
00001D58  56                *   push rsi
00001D59  57                *   push rdi
00001D5A  55                *   push rbp
00001D5B  488BEC            *   mov rbp, rsp
00001D5E  4883EC50          *   sub rsp, 80
00001D62                            mov buffer,alloca(ModuleInfo.max_line_len)
00001D62                    *   invoke alloca, ModuleInfo.max_line_len
00001D62  8B0568010000      *   mov eax, ModuleInfo.max_line_len
00001D68  83C00F            *1  add     eax,16-1
00001D6B  83E0F0            *1  and     eax,-16
00001D6E  482BE0            *1  sub     rsp,rax
00001D71  488D442440        *1  lea     rax,[rsp+@ReservedStack]
00001D76  488945F0          *   mov buffer, rax
00001D7A                            .for ( esi = 0 :: esi++ )
00001D7A  33F6              *   xor esi, esi
00001D7C                    *   @C015D:
00001D7C  BF00000000                    mov edi,NOT_ERROR
00001D81                                .for ( k = i : k < ModuleInfo.token_count : )
00001D81                    *   mov k, i
00001D81  8B4528            *    mov eax,  i
00001D84  8945FC            *    mov k, eax
00001D87                    *   @C0160:
00001D87                    *   cmp k , ModuleInfo.token_count
00001D87  8B0510020000      *    mov eax,  ModuleInfo.token_count
00001D8D  3945FC            *    cmp k , eax
00001D90  7D4D              *   jnl @C0162
00001D92                    *   invoke ExpandToken, line, addr k, tokenarray, ModuleInfo.token_count, addbrackets, equmode, buffer
00001D92  488B45F0          *    mov rax, buffer
00001D96  4889442430        *    mov [rsp+48], rax
00001D9B  8B4540            *    mov eax, equmode
00001D9E  89442428          *    mov [rsp+40], eax
00001DA2  8B4538            *    mov eax, addbrackets
00001DA5  89442420          *    mov [rsp+32], eax
00001DA9  448B0D10020000    *    mov r9d, ModuleInfo.token_count
00001DB0  4C8B4530          *    mov r8, tokenarray
00001DB4  488D55FC          *    lea rdx, k
00001DB8  488B4D20          *    mov rcx, line
00001DBC  E851FAFFFF        *    call ExpandToken
00001DC1                                    .break(1) .if eax == ERROR
00001DC1  83F8FF            *   cmp eax , ERROR
00001DC4  7451              *   jz  @C015F
00001DC6                                    .if eax == STRING_EXPANDED
00001DC6  83F801            *   cmp eax , STRING_EXPANDED
00001DC9  7502              *   jnz @C0163
00001DCB  8BF8                                  mov edi,eax
00001DCD                                    .endif
00001DCD                    *   @C0163:
00001DCD  6B45FC17                          imul eax,k,asm_tok
00001DD1  48034530                          add rax,tokenarray
00001DD5                                    .if ( [rax].asm_tok.token == T_COMMA )
00001DD5  80382C            *   cmp [rax].asm_tok.token , T_COMMA 
00001DD8  7503              *   jnz @C0164
00001DDA  FF45FC                                inc k
00001DDD                                    .endif
00001DDD                    *   @C0164:
00001DDD                                .endf
00001DDD                    *   @C0161:
00001DDD  EBA8              *   jmp @C0160
00001DDF                    *   @C0162:
00001DDF                                .break .if edi == NOT_ERROR
00001DDF  85FF              *   test edi , edi 
00001DE1  7434              *   jz  @C015F
00001DE3                                mov ModuleInfo.token_count,Tokenize( line, i, tokenarray, TOK_RESCAN )
00001DE3                    *   invoke Tokenize, line, i, tokenarray, TOK_RESCAN 
00001DE3  41B901000000      *    mov r9d, TOK_RESCAN 
00001DE9  4C8B4530          *    mov r8, tokenarray
00001DED  8B5528            *    mov edx, i
00001DF0  488B4D20          *    mov rcx, line
00001DF4  E800000000        *    call Tokenize
00001DF9  890510020000      *   mov ModuleInfo.token_count, eax
00001DFF                                .if esi == MAX_TEXTMACRO_NESTING
00001DFF  83FE14            *   cmp esi , MAX_TEXTMACRO_NESTING
00001E02  750C              *   jnz @C0165
00001E04                    *   invoke asmerr, 2123 
00001E04  B94B080000        *    mov ecx, 2123 
00001E09  E800000000        *    call asmerr
00001E0E                                   .break
00001E0E  EB07              *    jmp @C015F
00001E10                                .endif
00001E10                    *   @C0165:
00001E10                            .endf
00001E10                    *   @C015E:
00001E10  FFC6              *   inc esi
00001E12  E965FFFFFF        *   jmp @C015D
00001E17                    *   @C015F:
00001E17                            .return esi
00001E17  8BC6              *   mov eax,esi
00001E19  EBFE              *   jmp @C0166
                            *   org $ - 2
00001E19                    *   ret
00001E19                    *   @C0166:
00001E19  C9                *   leave
00001E1A  5F                *   pop rdi
00001E1B  5E                *   pop rsi
00001E1C  C3                *   retn 
00001E1D                        ExpandLineItems endp
00001E1D                        ExpandLiterals proc fastcall uses rbx i:int_t, tokenarray:token_t
00001E1D  48894C2408        *   mov [rsp+8], rcx
00001E22  4889542410        *   mov [rsp+16], rdx
00001E27  53                *   push rbx
00001E28  55                *   push rbp
00001E29  488BEC            *   mov rbp, rsp
00001E2C  4883EC28          *   sub rsp, 40
00001E30  33C0                      xor eax,eax
00001E32  488B5D20                  mov rbx,tokenarray
00001E36                            .for ( : ecx < ModuleInfo.token_count: ecx++ )
00001E36                    *   @C0167:
00001E36  3B0D10020000      *   cmp ecx , ModuleInfo.token_count
00001E3C  7D24              *   jnl @C0169
00001E3E  6BD117                        imul edx,ecx,asm_tok
00001E41                                .if ( [rbx+rdx].token == T_STRING && [rbx+rdx].stringlen &&( [rbx+rdx].string_delim == '<' || [rbx+rdx].string_delim == '{' ) )
00001E41  803C1309          *   cmp [rbx+rdx].token , T_STRING 
00001E45  7517              *   jnz @C016A
00001E47  837C130300        *   cmp [rbx+rdx].stringlen , 0
00001E4C  7410              *   jz  @C016A
00001E4E  807C13013C        *   cmp [rbx+rdx].string_delim , '<' 
00001E53  7407              *   jz  @C016B
00001E55                    *   @C016C:
00001E55  807C13017B        *   cmp [rbx+rdx].string_delim , '{' 
00001E5A  7502              *   jnz @C016A
00001E5C                    *   @C016B:
00001E5C  FFC0                              inc eax
00001E5E                                .endif
00001E5E                    *   @C016A:
00001E5E                            .endf
00001E5E                    *   @C0168:
00001E5E  FFC1              *   inc ecx
00001E60  EBD4              *   jmp @C0167
00001E62                    *   @C0169:
00001E62                            .if ( eax )
00001E62  85C0              *   test ( eax ), ( eax )
00001E64  7433              *   jz  @C016D
00001E66  6B4D1817                      imul ecx,i,asm_tok
00001E6A  4803D9                        add rbx,rcx
00001E6D                                .if ExpandText( [rbx].tokpos, tokenarray, FALSE ) == STRING_EXPANDED
00001E6D                    *   invoke ExpandText, [rbx].tokpos, tokenarray, FALSE 
00001E6D  4533C0            *    xor r8d, r8d
00001E70  488B5520          *    mov rdx, tokenarray
00001E74  488B4B0F          *    mov rcx, [rbx].tokpos
00001E78  E83BF2FFFF        *    call ExpandText
00001E7D  4883F801          *   cmp rax , STRING_EXPANDED
00001E81  7516              *   jnz @C016E
00001E83                    *   invoke Tokenize, [rbx].tokpos, i, tokenarray, TOK_RESCAN 
00001E83  41B901000000      *    mov r9d, TOK_RESCAN 
00001E89  4C8B4520          *    mov r8, tokenarray
00001E8D  8B5518            *    mov edx, i
00001E90  488B4B0F          *    mov rcx, [rbx].tokpos
00001E94  E800000000        *    call Tokenize
00001E99                                .endif
00001E99                    *   @C016E:
00001E99                            .endif
00001E99                    *   @C016D:
00001E99                            ret
00001E99  C9                *   leave
00001E9A  5B                *   pop rbx
00001E9B  C3                *   retn 
00001E9C                        ExpandLiterals endp
00001E9C                        ExpandProc proc fastcall private string:string_t, buffer:string_t
00001E9C  48894C2408        *   mov [rsp+8], rcx
00001EA1  4889542410        *   mov [rsp+16], rdx
00001EA6  55                *   push rbp
00001EA7  488BEC            *   mov rbp, rsp
00001EAA  4883EC20          *   sub rsp, 32
00000000                        .data
00001EAE                    *   _TEXT ends
00000017                    *   _DATA segment
                            *   assume cs:ERROR
00000017  696E766F6B652000       DS0003 sbyte "invoke ",0
00000000                        .code
0000001F                    *   _DATA ends
00001EAE                    *   _TEXT segment
                            *   assume cs:FLAT
00001EAE  488D3500000000            lea rsi,DS0003
00001EB5                    *   invoke SymFind, [rbx].string_ptr
00001EB5  488B4B07          *    mov rcx, [rbx].string_ptr
00001EB9  E800000000        *    call SymFind
00001EBE                            .if ( rax && [rax].asym.state == SYM_TYPE )
00001EBE  4885C0            *   test rax , rax 
00001EC1  740D              *   jz  @C016F
00001EC3  80781407          *   cmp [rax].asym.state , SYM_TYPE 
00001EC7  7507              *   jnz @C016F
00000000                        .data
00001EC9                    *   _TEXT ends
0000001F                    *   _DATA segment
                            *   assume cs:ERROR
0000001F  2E6E65772000           DS0004 sbyte ".new ",0
00000000                        .code
00000025                    *   _DATA ends
00001EC9                    *   _TEXT segment
                            *   assume cs:FLAT
00001EC9  488D3500000000                lea rsi,DS0004
00001ED0                            .endif
00001ED0                    *   @C016F:
00001ED0                    *   invoke tstrcpy, buffer, rsi 
00001ED0  488BD6            *    mov rdx, rsi 
00001ED3  488B4D18          *    mov rcx, buffer
00001ED7  E800000000        *    call tstrcpy
00001EDC                    *   invoke tstrcat, rax , [rbx].tokpos 
00001EDC  488B530F          *    mov rdx, [rbx].tokpos 
00001EE0  488BC8            *    mov rcx, rax 
00001EE3  E800000000        *    call tstrcat
00001EE8                            mov ModuleInfo.token_count,Tokenize( tstrcpy( string, buffer ), 0, rbx, TOK_DEFAULT )
00001EE8                    *   invoke tstrcpy, string, buffer 
00001EE8  488B5518          *    mov rdx, buffer 
00001EEC  488B4D10          *    mov rcx, string
00001EF0  E800000000        *    call tstrcpy
00001EF5                    *   invoke Tokenize, rax , 0, rbx, TOK_DEFAULT 
00001EF5  4533C9            *    xor r9d, r9d
00001EF8  4C8BC3            *    mov r8, rbx
00001EFB  33D2              *    xor edx, edx
00001EFD  488BC8            *    mov rcx, rax 
00001F00  E800000000        *    call Tokenize
00001F05  890510020000      *   mov ModuleInfo.token_count, eax
00001F0B                            ret
00001F0B  C9                *   leave
00001F0C  C3                *   retn 
00001F0D                        ExpandProc endp
00001F0D                        ExpandLine proc fastcall uses rsi rdi rbx string:string_t, tokenarray:token_t
00001F0D  48894C2408        *   mov [rsp+8], rcx
00001F12  4889542410        *   mov [rsp+16], rdx
00001F17  56                *   push rsi
00001F18  57                *   push rdi
00001F19  53                *   push rbx
00001F1A  55                *   push rbp
00001F1B  488BEC            *   mov rbp, rsp
00001F1E  4883EC68          *   sub rsp, 104
00001F22                            mov buffer,alloca(ModuleInfo.max_line_len)
00001F22                    *   invoke alloca, ModuleInfo.max_line_len
00001F22  8B0568010000      *   mov eax, ModuleInfo.max_line_len
00001F28  83C00F            *1  add     eax,16-1
00001F2B  83E0F0            *1  and     eax,-16
00001F2E  482BE0            *1  sub     rsp,rax
00001F31  488D442440        *1  lea     rax,[rsp+@ReservedStack]
00001F36  488945E0          *   mov buffer, rax
00001F3A                            .for ( lvl = 0: lvl < MAX_TEXTMACRO_NESTING: lvl++ )
00001F3A  C745F000000000    *   mov lvl, 0
00001F41                    *   @C0170:
00001F41  837DF014          *   cmp lvl , MAX_TEXTMACRO_NESTING
00001F45  0F8DD4050000      *   jnl @C0172
00001F4B  33F6                          xor esi,esi
00001F4D  8975F8                        mov bracket_flags,esi
00001F50  8975FC                        mov count,esi
00001F53  8975EC                        mov rc,esi
00001F56  488B5D30                      mov rbx,tokenarray
00001F5A                                .if ( ModuleInfo.token_count > 2 )
00001F5A  833D1002000002    *   cmp ModuleInfo.token_count , 2 
00001F61  7E49              *   jng @C0173
00001F63                                    .if ( [rbx+asm_tok].token == T_COLON || [rbx+asm_tok].token == T_DBL_COLON )
00001F63  807B173A          *   cmp [rbx+asm_tok].token , T_COLON 
00001F67  7406              *   jz  @C0175
00001F69                    *   @C0176:
00001F69  807B170D          *   cmp [rbx+asm_tok].token , T_DBL_COLON 
00001F6D  753D              *   jnz @C0174
00001F6F                    *   @C0175:
00001F6F                                        .if ( [rbx].token != T_ID ||[rbx+asm_tok].token == T_COLON ||[rbx+asm_tok*2].token != T_ID )
00001F6F  803B08            *   cmp [rbx].token , T_ID 
00001F72  750C              *   jnz @C0178
00001F74                    *   @C0179:
00001F74  807B173A          *   cmp [rbx+asm_tok].token , T_COLON 
00001F78  7406              *   jz  @C0178
00001F7A                    *   @C017A:
00001F7A  807B2E08          *   cmp [rbx+asm_tok*2].token , T_ID 
00001F7E  7407              *   jz  @C0177
00001F80                    *   @C0178:
00001F80                                            .return 0
00001F80  33C0              *   xor eax,eax
00001F82  E9AD050000        *   jmp @C017B
00001F87                                        .endif
00001F87                    *   @C0177:
00001F87                                        .if ( SymFind( [rbx+asm_tok*2].string_ptr ) )
00001F87                    *   invoke SymFind, [rbx+asm_tok*2].string_ptr 
00001F87  488B4B35          *    mov rcx, [rbx+asm_tok*2].string_ptr 
00001F8B  E800000000        *    call SymFind
00001F90  4885C0            *   test (  rax ), (  rax )
00001F93  740D              *   jz  @C017C
00001F95                                            .if ( [rax].asym.state == SYM_MACRO )
00001F95  80781409          *   cmp [rax].asym.state , SYM_MACRO 
00001F99  7507              *   jnz @C017D
00001F9B                                                .return 0
00001F9B  33C0              *   xor eax,eax
00001F9D  E992050000        *   jmp @C017B
00001FA2                                            .endif
00001FA2                    *   @C017D:
00001FA2                                        .endif
00001FA2                    *   @C017C:
00001FA2                                        .if ( [rbx+asm_tok*2].token == T_DIRECTIVE )
00001FA2  807B2E03          *   cmp [rbx+asm_tok*2].token , T_DIRECTIVE 
00001FA6  7504              *   jnz @C017E
00001FA8  4883C32E                                  add rbx,asm_tok*2
00001FAC                                        .endif
00001FAC                    *   @C017E:
00001FAC                                    .endif
00001FAC                    *   @C0174:
00001FAC                                .endif
00001FAC                    *   @C0173:
00001FAC  488B5530                      mov rdx,tokenarray
00001FB0                                .if ( [rbx].token == T_DIRECTIVE )
00001FB0  803B03            *   cmp [rbx].token , T_DIRECTIVE 
00001FB3  0F8599000000      *   jnz @C017F
00001FB9  4C8D1D00000000     1  	 lea  r11,SpecialTable
00001FC0  6B43030C           1  	 imul eax,[rbx].tokval,special_item
00001FC4                                    mov flags,[r11+rax].special_item.value
00001FC4  418B0403          *    mov eax, [r11+rax].special_item.value
00001FC8  8945F4            *    mov flags, eax
00001FCB                                    .if ( eax & DF_STRPARM )
00001FCB  A902000000        *   test eax , DF_STRPARM 
00001FD0  746D              *   je  @C0180
00001FD2  C745F8FFFFFFFF                        mov bracket_flags,-1
00001FD9                                        .if ( [rbx].dirtype == DRT_ERRDIR )
00001FD9  807B010A          *   cmp [rbx].dirtype , DRT_ERRDIR 
00001FDD  755E              *   jnz @C0181
00001FDF                                            .if ( [rbx].tokval == T_DOT_ERRDEF ||[rbx].tokval == T_DOT_ERRNDEF )
00001FDF  817B03CD010000    *   cmp [rbx].tokval , T_DOT_ERRDEF 
00001FE6  7409              *   jz  @C0183
00001FE8                    *   @C0184:
00001FE8  817B03CE010000    *   cmp [rbx].tokval , T_DOT_ERRNDEF 
00001FEF  754C              *   jnz @C0182
00001FF1                    *   @C0183:
00001FF1                                                .if esi
00001FF1  85F6              *   test esi, esi
00001FF3  7433              *   jz  @C0185
00001FF5                                                    mov rc,ExpandToken( string, &count, tokenarray, 1, FALSE, FALSE, buffer )
00001FF5                    *   invoke ExpandToken, string, addr count, tokenarray, 1, FALSE, FALSE, buffer 
00001FF5  488B45E0          *    mov rax, buffer 
00001FF9  4889442430        *    mov [rsp+48], rax
00001FFE  C744242800000000  *    mov dword ptr [rsp+40], FALSE
00002006  C744242000000000  *    mov dword ptr [rsp+32], FALSE
0000200E  41B901000000      *    mov r9d, 1
00002014  4C8B4530          *    mov r8, tokenarray
00002018  488D55FC          *    lea rdx, count
0000201C  488B4D28          *    mov rcx, string
00002020  E8EDF7FFFF        *    call ExpandToken
00002025  8945EC            *   mov rc, eax
00002028                                                .endif
00002028                    *   @C0185:
00002028                                                .while [rbx].token != T_FINAL && [rbx].token != T_COMMA
00002028  EB06              *   jmp @C0189
0000202A                    *   @C0186:
0000202A  FFC6                                              inc esi
0000202C  4883C317                                          add rbx,asm_tok
00002030                                                .endw
00002030                    *   @C0189:
00002030  803B00            *   cmp [rbx].token , T_FINAL 
00002033  7405              *   jz  @C0187
00002035                    *   @C0188:
00002035  803B2C            *   cmp [rbx].token , T_COMMA
00002038  75F0              *   jnz @C0186
0000203A                    *   @C0187:
0000203A  8975FC                                        mov count,esi
0000203D                                            .endif
0000203D                    *   @C0182:
0000203D                                        .endif
0000203D                    *   @C0181:
0000203D                                    .elseif ( eax & DF_NOEXPAND )
0000203D  EB0E              *   jmp @C018A
0000203F                    *   @C0180:
0000203F  A904000000        *   test eax , DF_NOEXPAND 
00002044  7407              *   je  @C018B
00002046                                        .return NOT_ERROR
00002046  33C0              *   xor eax,eax
00002048  E9E7040000        *   jmp @C017B
0000204D                                    .endif
0000204D                    *   @C018B:
0000204D                    *   @C018A:
0000204D                                .elseif ModuleInfo.token_count > 1 && [rdx+asm_tok].asm_tok.token == T_DIRECTIVE
0000204D  E982020000        *   jmp @C018C
00002052                    *   @C017F:
00002052  833D1002000001    *   cmp ModuleInfo.token_count , 1 
00002059  0F8E90010000      *   jng @C018D
0000205F  807A1703          *   cmp [rdx+asm_tok].asm_tok.token , T_DIRECTIVE
00002063  0F8586010000      *   jnz @C018D
00002069  8A4218                            mov al,[rdx+asm_tok].asm_tok.dirtype
0000206C                                    .switch al
0000206C                                    .case DRT_CATSTR
0000206C  E951010000        *    jmp @C018E
00002071                    *   @C018F:
00002071  C745F8FFFFFFFF                        mov bracket_flags,-1
00002078  C745FC02000000                        mov count,2
0000207F                                        .endc
0000207F  E966010000        *    jmp @C0190
00002084                                    .case DRT_SUBSTR
00002084                    *   @C0191:
00002084  C745F801000000                        mov bracket_flags,0x1
0000208B  C745FC02000000                        mov count,2
00002092                                        .endc
00002092  E953010000        *    jmp @C0190
00002097                                    .case DRT_SIZESTR
00002097                    *   @C0192:
00002097                                        mov rc,ExpandToken( string, &count, tokenarray, 1, FALSE, FALSE, buffer )
00002097                    *   invoke ExpandToken, string, addr count, tokenarray, 1, FALSE, FALSE, buffer 
00002097  488B45E0          *    mov rax, buffer 
0000209B  4889442430        *    mov [rsp+48], rax
000020A0  C744242800000000  *    mov dword ptr [rsp+40], FALSE
000020A8  C744242000000000  *    mov dword ptr [rsp+32], FALSE
000020B0  41B901000000      *    mov r9d, 1
000020B6  4C8B4530          *    mov r8, tokenarray
000020BA  488D55FC          *    lea rdx, count
000020BE  488B4D28          *    mov rcx, string
000020C2  E84BF7FFFF        *    call ExpandToken
000020C7  8945EC            *   mov rc, eax
000020CA  C745F801000000                        mov bracket_flags,0x1
000020D1  C745FC02000000                        mov count,2
000020D8                                        .endc
000020D8  E90D010000        *    jmp @C0190
000020DD                                    .case DRT_INSTR
000020DD                    *   @C0193:
000020DD                                        mov rc,ExpandToken( string, &count, tokenarray, 1, FALSE, FALSE, buffer )
000020DD                    *   invoke ExpandToken, string, addr count, tokenarray, 1, FALSE, FALSE, buffer 
000020DD  488B45E0          *    mov rax, buffer 
000020E1  4889442430        *    mov [rsp+48], rax
000020E6  C744242800000000  *    mov dword ptr [rsp+40], FALSE
000020EE  C744242000000000  *    mov dword ptr [rsp+32], FALSE
000020F6  41B901000000      *    mov r9d, 1
000020FC  4C8B4530          *    mov r8, tokenarray
00002100  488D55FC          *    lea rdx, count
00002104  488B4D28          *    mov rcx, string
00002108  E805F7FFFF        *    call ExpandToken
0000210D  8945EC            *   mov rc, eax
00002110                                        .for esi = 2, eax = 0, ecx = 0: esi < ModuleInfo.token_count: esi++
00002110  BE02000000        *   mov esi, 2
00002115  33C0              *   xor eax, eax
00002117  33C9              *   xor ecx, ecx
00002119                    *   @C0194:
00002119  3B3510020000      *   cmp esi , ModuleInfo.token_count
0000211F  7D28              *   jnl @C0196
00002121  6BDE17                                    imul ebx,esi,asm_tok
00002124  48035D30                                  add rbx,tokenarray
00002128                                            .if [rbx].token == T_OP_BRACKET
00002128  803B28            *   cmp [rbx].token , T_OP_BRACKET
0000212B  7504              *   jnz @C0197
0000212D  FFC0                                          inc eax
0000212F                                            .elseif [rbx].token == T_CL_BRACKET
0000212F  EB14              *   jmp @C0198
00002131                    *   @C0197:
00002131  803B29            *   cmp [rbx].token , T_CL_BRACKET
00002134  7504              *   jnz @C0199
00002136  FFC8                                          dec eax
00002138                                            .elseif [rbx].token == T_COMMA && eax == 0
00002138  EB0B              *   jmp @C0198
0000213A                    *   @C0199:
0000213A  803B2C            *   cmp [rbx].token , T_COMMA 
0000213D  7506              *   jnz @C019A
0000213F  85C0              *   test eax , eax 
00002141  7502              *   jnz @C019A
00002143  FFC1                                          inc ecx
00002145                                            .endif
00002145                    *   @C019A:
00002145                    *   @C0198:
00002145                                        .endf
00002145                    *   @C0195:
00002145  FFC6              *   inc esi
00002147  EBD0              *   jmp @C0194
00002149                    *   @C0196:
00002149  B803000000                            mov eax,3
0000214E                                        .if ecx > 1
0000214E  83F901            *   cmp ecx , 1
00002151  7605              *   jna @C019B
00002153  B806000000                                mov eax,6
00002158                                        .endif
00002158                    *   @C019B:
00002158  8945F8                                mov bracket_flags,eax
0000215B  C745FC02000000                        mov count,2
00002162                                        .endc
00002162  E983000000        *    jmp @C0190
00002167                                    .case DRT_MACRO
00002167                    *   @C019C:
00002167                    *   invoke SymFind, [rdx].asm_tok.string_ptr
00002167  488B4A07          *    mov rcx, [rdx].asm_tok.string_ptr
0000216B  E800000000        *    call SymFind
00002170                                        .if ( rax && [rax].asym.state != SYM_MACRO )
00002170  4885C0            *   test rax , rax 
00002173  7439              *   jz  @C019D
00002175  80781409          *   cmp [rax].asym.state , SYM_MACRO 
00002179  7433              *   jz  @C019D
0000217B                                            mov rc,ExpandToken( string, &count, tokenarray, 1, FALSE, FALSE, buffer )
0000217B                    *   invoke ExpandToken, string, addr count, tokenarray, 1, FALSE, FALSE, buffer 
0000217B  488B45E0          *    mov rax, buffer 
0000217F  4889442430        *    mov [rsp+48], rax
00002184  C744242800000000  *    mov dword ptr [rsp+40], FALSE
0000218C  C744242000000000  *    mov dword ptr [rsp+32], FALSE
00002194  41B901000000      *    mov r9d, 1
0000219A  4C8B4530          *    mov r8, tokenarray
0000219E  488D55FC          *    lea rdx, count
000021A2  488B4D28          *    mov rcx, string
000021A6  E867F6FFFF        *    call ExpandToken
000021AB  8945EC            *   mov rc, eax
000021AE                                        .endif
000021AE                    *   @C019D:
000021AE                                        mov count,ModuleInfo.token_count
000021AE  8B0510020000      *    mov eax, ModuleInfo.token_count
000021B4  8945FC            *    mov count, eax
000021B7                                        .endc
000021B7  EB31              *    jmp @C0190
000021B9                                    .case DRT_EQU
000021B9                    *   @C019E:
000021B9                                        .return NOT_ERROR
000021B9  33C0              *   xor eax,eax
000021BB  E974030000        *   jmp @C017B
000021C0                                    .endsw
000021C0  EB28              *    jmp @C0190
000021C2                    *   @C018E:
000021C2  3C05              *    cmp al, DRT_CATSTR
000021C4  0F84A7FEFFFF      *    je @C018F
000021CA  3C06              *    cmp al, DRT_SUBSTR
000021CC  0F84B2FEFFFF      *    je @C0191
000021D2  3C18              *    cmp al, DRT_SIZESTR
000021D4  0F84BDFEFFFF      *    je @C0192
000021DA  3C17              *    cmp al, DRT_INSTR
000021DC  0F84FBFEFFFF      *    je @C0193
000021E2  3C04              *    cmp al, DRT_MACRO
000021E4  7481              *    je @C019C
000021E6  3C2F              *    cmp al, DRT_EQU
000021E8  74CF              *    je @C019E
000021EA                    *   @C0190:
000021EA                                .else
000021EA  E9E5000000        *   jmp @C018C
000021EF                    *   @C018D:
000021EF                                    mov rc,ExpandToken( string, &count, tokenarray, 1, FALSE, FALSE, buffer )
000021EF                    *   invoke ExpandToken, string, addr count, tokenarray, 1, FALSE, FALSE, buffer 
000021EF  488B45E0          *    mov rax, buffer 
000021F3  4889442430        *    mov [rsp+48], rax
000021F8  C744242800000000  *    mov dword ptr [rsp+40], FALSE
00002200  C744242000000000  *    mov dword ptr [rsp+32], FALSE
00002208  41B901000000      *    mov r9d, 1
0000220E  4C8B4530          *    mov r8, tokenarray
00002212  488D55FC          *    lea rdx, count
00002216  488B4D28          *    mov rcx, string
0000221A  E8F3F5FFFF        *    call ExpandToken
0000221F  8945EC            *   mov rc, eax
00002222                                    .return .if eax == ERROR || eax == EMPTY
00002222  83F8FF            *   cmp eax , ERROR 
00002225  0F8409030000      *   jz  @C017B
0000222B  83F8FE            *   cmp eax , EMPTY
0000222E  0F8400030000      *   jz  @C017B
00002234                                    .if ( rc == STRING_EXPANDED )
00002234  837DEC01          *   cmp rc , STRING_EXPANDED 
00002238  751D              *   jnz @C019F
0000223A                                        mov ModuleInfo.token_count,Tokenize( string, 0, tokenarray, TOK_DEFAULT )
0000223A                    *   invoke Tokenize, string, 0, tokenarray, TOK_DEFAULT 
0000223A  4533C9            *    xor r9d, r9d
0000223D  4C8B4530          *    mov r8, tokenarray
00002241  33D2              *    xor edx, edx
00002243  488B4D28          *    mov rcx, string
00002247  E800000000        *    call Tokenize
0000224C  890510020000      *   mov ModuleInfo.token_count, eax
00002252                                       .continue
00002252  E9C0020000        *    jmp @C0171
00002257                                    .endif
00002257                    *   @C019F:
00002257  488B4530                          mov rax,tokenarray
0000225B                                    .if ( count == 1 && [rax].asm_tok.token == T_ID && [rax+asm_tok].asm_tok.token == T_ID )
0000225B  837DFC01          *   cmp count , 1 
0000225F  7573              *   jnz @C01A0
00002261  803808            *   cmp [rax].asm_tok.token , T_ID 
00002264  756E              *   jnz @C01A0
00002266  80781708          *   cmp [rax+asm_tok].asm_tok.token , T_ID 
0000226A  7568              *   jnz @C01A0
0000226C                                        mov rc,ExpandToken( string, &count, tokenarray, 2, FALSE, FALSE, buffer )
0000226C                    *   invoke ExpandToken, string, addr count, tokenarray, 2, FALSE, FALSE, buffer 
0000226C  488B45E0          *    mov rax, buffer 
00002270  4889442430        *    mov [rsp+48], rax
00002275  C744242800000000  *    mov dword ptr [rsp+40], FALSE
0000227D  C744242000000000  *    mov dword ptr [rsp+32], FALSE
00002285  41B902000000      *    mov r9d, 2
0000228B  4C8B4530          *    mov r8, tokenarray
0000228F  488D55FC          *    lea rdx, count
00002293  488B4D28          *    mov rcx, string
00002297  E876F5FFFF        *    call ExpandToken
0000229C  8945EC            *   mov rc, eax
0000229F                                        .return .if eax == ERROR || eax == EMPTY
0000229F  83F8FF            *   cmp eax , ERROR 
000022A2  0F848C020000      *   jz  @C017B
000022A8  83F8FE            *   cmp eax , EMPTY
000022AB  0F8483020000      *   jz  @C017B
000022B1                                        .if rc == STRING_EXPANDED
000022B1  837DEC01          *   cmp rc , STRING_EXPANDED
000022B5  751D              *   jnz @C01A1
000022B7                                            mov ModuleInfo.token_count,Tokenize( string, 0, tokenarray, TOK_DEFAULT )
000022B7                    *   invoke Tokenize, string, 0, tokenarray, TOK_DEFAULT 
000022B7  4533C9            *    xor r9d, r9d
000022BA  4C8B4530          *    mov r8, tokenarray
000022BE  33D2              *    xor edx, edx
000022C0  488B4D28          *    mov rcx, string
000022C4  E800000000        *    call Tokenize
000022C9  890510020000      *   mov ModuleInfo.token_count, eax
000022CF                                            .continue
000022CF  E943020000        *    jmp @C0171
000022D4                                        .endif
000022D4                    *   @C01A1:
000022D4                                    .endif
000022D4                    *   @C01A0:
000022D4                                .endif
000022D4                    *   @C018C:
000022D4                                .while ( count < ModuleInfo.token_count )
000022D4  EB67              *   jmp @C01A3
000022D6                    *   @C01A2:
000022D6  8B45F8                            mov eax,bracket_flags
000022D9  83E001                            and eax,1
000022DC  8945E8                            mov addbrackets,eax
000022DF                                    .if bracket_flags != -1
000022DF  837DF8FF          *   cmp bracket_flags , -1
000022E3  7403              *   jz  @C01A4
000022E5  D16DF8                                shr bracket_flags,1
000022E8                                    .endif
000022E8                    *   @C01A4:
000022E8                    *   invoke ExpandToken, string, addr count, tokenarray, ModuleInfo.token_count, addbrackets, FALSE, buffer 
000022E8  488B45E0          *    mov rax, buffer 
000022EC  4889442430        *    mov [rsp+48], rax
000022F1  C744242800000000  *    mov dword ptr [rsp+40], FALSE
000022F9  8B45E8            *    mov eax, addbrackets
000022FC  89442420          *    mov [rsp+32], eax
00002300  448B0D10020000    *    mov r9d, ModuleInfo.token_count
00002307  4C8B4530          *    mov r8, tokenarray
0000230B  488D55FC          *    lea rdx, count
0000230F  488B4D28          *    mov rcx, string
00002313  E8FAF4FFFF        *    call ExpandToken
00002318                                    .return .ifs ( eax < NOT_ERROR );; ERROR or EMPTY?
00002318  83F800            *   cmp eax , NOT_ERROR 
0000231B  0F8C13020000      *   jl  @C017B
00002321                                    .if eax == STRING_EXPANDED
00002321  83F801            *   cmp eax , STRING_EXPANDED
00002324  7507              *   jnz @C01A5
00002326  C745EC01000000                        mov rc,STRING_EXPANDED
0000232D                                    .endif
0000232D                    *   @C01A5:
0000232D  6B5DFC17                          imul ebx,count,asm_tok
00002331  48035D30                          add rbx,tokenarray
00002335                                    .if ( [rbx].token == T_COMMA )
00002335  803B2C            *   cmp [rbx].token , T_COMMA 
00002338  7503              *   jnz @C01A6
0000233A  FF45FC                                inc count
0000233D                                    .endif
0000233D                    *   @C01A6:
0000233D                                .endw
0000233D                    *   @C01A3:
0000233D                    *   cmp count , ModuleInfo.token_count 
0000233D  8B0510020000      *    mov eax,  ModuleInfo.token_count 
00002343  3945FC            *    cmp count , eax
00002346  7C8E              *   jl  @C01A2
00002348                                .if rc == STRING_EXPANDED
00002348  837DEC01          *   cmp rc , STRING_EXPANDED
0000234C  751B              *   jnz @C01A7
0000234E                                    mov ModuleInfo.token_count,Tokenize( string, 0, tokenarray, TOK_RESCAN or TOK_LINE )
0000234E                    *   invoke Tokenize, string, 0, tokenarray, TOK_RESCAN or TOK_LINE 
0000234E  41B905000000      *    mov r9d, TOK_RESCAN or TOK_LINE 
00002354  4C8B4530          *    mov r8, tokenarray
00002358  33D2              *    xor edx, edx
0000235A  488B4D28          *    mov rcx, string
0000235E  E800000000        *    call Tokenize
00002363  890510020000      *   mov ModuleInfo.token_count, eax
00002369                                .endif
00002369                    *   @C01A7:
00002369  488B5D30                      mov rbx,tokenarray
0000236D                                .if ( ModuleInfo.token_count > 2 && [rbx].flags & T_EXPAND )
0000236D  833D1002000002    *   cmp ModuleInfo.token_count , 2 
00002374  0F8E97010000      *   jng @C01A8
0000237A  F6430240          *   test [rbx].flags , T_EXPAND 
0000237E  0F848D010000      *   je  @C01A8
00002384                                    .if ( [rbx].flags & T_ISPROC )
00002384  F6430208          *   test [rbx].flags , T_ISPROC 
00002388  740D              *   je  @C01A9
0000238A                    *   invoke ExpandProc, string, buffer
0000238A  488B55E0          *    mov rdx, buffer
0000238E  488B4D28          *    mov rcx, string
00002392  E805FBFFFF        *    call ExpandProc
00002397                                    .endif
00002397                    *   @C01A9:
00002397                                    .for ( : [rbx].token != T_FINAL : rbx += asm_tok )
00002397                    *   @C01AA:
00002397  803B00            *   cmp [rbx].token , T_FINAL
0000239A  0F8471010000      *   jz  @C01AC
000023A0                                        .if ( [rbx+asm_tok].token == T_DBL_COLON )
000023A0  807B170D          *   cmp [rbx+asm_tok].token , T_DBL_COLON 
000023A4  0F855E010000      *   jnz @C01AD
000023AA  33FF                                      xor edi,edi
000023AC                                            .if ( [rbx+3*asm_tok].token == T_DIRECTIVE &&( [rbx+3*asm_tok].tokval == T_PROC || [rbx+3*asm_tok].tokval == T_PROTO ) )
000023AC  807B4503          *   cmp [rbx+3*asm_tok].token , T_DIRECTIVE 
000023B0  752C              *   jnz @C01AE
000023B2  817B4814020000    *   cmp [rbx+3*asm_tok].tokval , T_PROC 
000023B9  7409              *   jz  @C01AF
000023BB                    *   @C01B0:
000023BB  817B4813020000    *   cmp [rbx+3*asm_tok].tokval , T_PROTO 
000023C2  751A              *   jnz @C01AE
000023C4                    *   @C01AF:
000023C4  FFC7                                          inc edi
000023C6                                                .if ( SymFind([rbx].string_ptr) )
000023C6                    *   invoke SymFind, [rbx].string_ptr
000023C6  488B4B07          *    mov rcx, [rbx].string_ptr
000023CA  E800000000        *    call SymFind
000023CF  4885C0            *   test (  rax ), (  rax )
000023D2  7408              *   jz  @C01B1
000023D4                                                    .if ( [rax].asym.flag2 & S_CLASS )
000023D4  F6401901          *   test [rax].asym.flag2 , S_CLASS 
000023D8  7402              *   je  @C01B2
000023DA  FFC7                                                  inc edi
000023DC                                                    .endif
000023DC                    *   @C01B2:
000023DC                                                .endif
000023DC                    *   @C01B1:
000023DC                                            .else
000023DC  EB23              *   jmp @C01B3
000023DE                    *   @C01AE:
000023DE  8A03                                          mov al,[rbx].token
000023E0  8A632E                                        mov ah,[rbx+asm_tok*2].token
000023E3                                                .if ( ( al != T_REG && [rbx+3*asm_tok].token == T_OP_BRACKET ) ||( al < T_STRING && al > T_REG &&ah < T_STRING && ah > T_REG ) )
000023E3  3C02              *   cmp al , T_REG 
000023E5  7406              *   jz  @C01B6
000023E7  807B4528          *   cmp [rbx+3*asm_tok].token , T_OP_BRACKET 
000023EB  7412              *   jz  @C01B5
000023ED                    *   @C01B6:
000023ED  3C09              *   cmp al , T_STRING 
000023EF  7310              *   jnb @C01B4
000023F1  3C02              *   cmp al , T_REG 
000023F3  760C              *   jna @C01B4
000023F5  80FC09            *   cmp ah , T_STRING 
000023F8  7307              *   jnb @C01B4
000023FA  80FC02            *   cmp ah , T_REG 
000023FD  7602              *   jna @C01B4
000023FF                    *   @C01B5:
000023FF  FFC7                                              inc edi
00002401                                                .endif
00002401                    *   @C01B4:
00002401                                            .endif
00002401                    *   @C01B3:
00002401                                            .if ( edi == 1 )
00002401  83FF01            *   cmp edi , 1 
00002404  7529              *   jnz @C01B7
00002406  488B7B26                                      mov rdi,[rbx+asm_tok].tokpos
0000240A                                                .while ( byte ptr [rdi-1] <= ' ' )
0000240A  EB03              *   jmp @C01B9
0000240C                    *   @C01B8:
0000240C  48FFCF                                            dec rdi
0000240F                                                .endw
0000240F                    *   @C01B9:
0000240F  807FFF20          *   cmp byte ptr [rdi-1] , ' ' 
00002413  76F7              *   jna @C01B8
00002415  488B733D                                      mov rsi,[rbx+asm_tok*2].tokpos
00002419  B05F                                          mov al,'_'
0000241B  AA                                            stosb
0000241C                                                mov ecx,tstrlen(rsi)
0000241C                    *   invoke tstrlen, rsi
0000241C  488BCE            *    mov rcx, rsi
0000241F  E800000000        *    call tstrlen
00002424  8BC8              *   mov ecx, eax
00002426  FFC1                                          inc ecx
00002428  F3A4                                          rep movsb
0000242A                                            .elseif ( edi > 1 )
0000242A  E9B9000000        *   jmp @C01BA
0000242F                    *   @C01B7:
0000242F  83FF01            *   cmp edi , 1 
00002432  0F86B0000000      *   jna @C01BB
00002438  488B7DE0                                      mov rdi,buffer
0000243C  488B5530                                      mov rdx,tokenarray
00002440  488B720F                                      mov rsi,[rdx].asm_tok.tokpos
00002444  488B4B26                                      mov rcx,[rbx+asm_tok].tokpos
00002448  482BCE                                        sub rcx,rsi
0000244B  F3A4                                          rep movsb
0000244D  B05F                                          mov al,'_'
0000244F  AA                                            stosb
00002450  488B733D                                      mov rsi,[rbx+asm_tok*2].tokpos
00002454                                                .for ( edx = 3*asm_tok : [rbx+rdx].token != T_FINAL : rdx+=asm_tok )
00002454  BA45000000        *   mov edx, 3*asm_tok
00002459                    *   @C01BC:
00002459  803C1300          *   cmp [rbx+rdx].token , T_FINAL
0000245D  7412              *   jz  @C01BE
0000245F                                                    .break .if ( [rbx+rdx].token == T_COLON )
0000245F  803C133A          *   cmp [rbx+rdx].token , T_COLON 
00002463  740C              *   jz  @C01BE
00002465                                                    .break .if ( [rbx+rdx].token == T_STRING )
00002465  803C1309          *   cmp [rbx+rdx].token , T_STRING 
00002469  7406              *   jz  @C01BE
0000246B                                                .endf
0000246B                    *   @C01BD:
0000246B  4883C217          *   add rdx, asm_tok
0000246F  EBE8              *   jmp @C01BC
00002471                    *   @C01BE:
00002471                                                .if ( [rbx+rdx].token == T_COLON && [rbx+rdx-asm_tok].token == T_ID )
00002471  803C133A          *   cmp [rbx+rdx].token , T_COLON 
00002475  750B              *   jnz @C01BF
00002477  807C13E908        *   cmp [rbx+rdx-asm_tok].token , T_ID 
0000247C  7504              *   jnz @C01BF
0000247E  4883EA17                                          sub rdx,asm_tok
00002482                                                .endif
00002482                    *   @C01BF:
00002482  488B4C130F                                    mov rcx,[rbx+rdx].tokpos
00002487  482BCE                                        sub rcx,rsi
0000248A  F3A4                                          rep movsb
0000248C                                                .if ( byte ptr [rdi-1] == ' ' )
0000248C  807FFF20          *   cmp byte ptr [rdi-1] , ' ' 
00002490  7503              *   jnz @C01C0
00002492  48FFCF                                            dec rdi
00002495                                                .endif
00002495                    *   @C01C0:
00002495  B820746869                                    mov eax,'iht '
0000249A  AB                                            stosd
0000249B  B8733A7074                                    mov eax,'tp:s'
000024A0  AB                                            stosd
000024A1  66B87220                                      mov ax,' r'
000024A5  66AB                                          stosw
000024A7  488B4B07                                      mov rcx,[rbx].string_ptr
000024AB  8A01                                          mov al,[rcx]
000024AD                                                .while al
000024AD  EB06              *   jmp @C01C2
000024AF                    *   @C01C1:
000024AF  AA                                                stosb
000024B0  48FFC1                                            inc rcx
000024B3  8A01                                              mov al,[rcx]
000024B5                                                .endw
000024B5                    *   @C01C2:
000024B5  84C0              *   test al, al
000024B7  75F6              *   jnz @C01C1
000024B9                                                .if ( [rbx+rdx].token == T_COLON || [rbx+rdx+asm_tok].token == T_COLON )
000024B9  803C133A          *   cmp [rbx+rdx].token , T_COLON 
000024BD  7407              *   jz  @C01C4
000024BF                    *   @C01C5:
000024BF  807C13173A        *   cmp [rbx+rdx+asm_tok].token , T_COLON 
000024C4  7507              *   jnz @C01C3
000024C6                    *   @C01C4:
000024C6  B82C200000                                        mov eax,' ,'
000024CB  66AB                                              stosw
000024CD                                                .endif
000024CD                    *   @C01C3:
000024CD                                                mov ecx,tstrlen(rsi)
000024CD                    *   invoke tstrlen, rsi
000024CD  488BCE            *    mov rcx, rsi
000024D0  E800000000        *    call tstrlen
000024D5  8BC8              *   mov ecx, eax
000024D7  FFC1                                          inc ecx
000024D9  F3A4                                          rep movsb
000024DB                    *   invoke tstrcpy, string, buffer
000024DB  488B55E0          *    mov rdx, buffer
000024DF  488B4D28          *    mov rcx, string
000024E3  E800000000        *    call tstrcpy
000024E8                                            .endif
000024E8                    *   @C01BB:
000024E8                    *   @C01BA:
000024E8                                            .if ( edi )
000024E8  85FF              *   test ( edi ), ( edi )
000024EA  741C              *   jz  @C01C6
000024EC                                                mov ModuleInfo.token_count,Tokenize( string, 0, tokenarray, TOK_DEFAULT )
000024EC                    *   invoke Tokenize, string, 0, tokenarray, TOK_DEFAULT 
000024EC  4533C9            *    xor r9d, r9d
000024EF  4C8B4530          *    mov r8, tokenarray
000024F3  33D2              *    xor edx, edx
000024F5  488B4D28          *    mov rcx, string
000024F9  E800000000        *    call Tokenize
000024FE  890510020000      *   mov ModuleInfo.token_count, eax
00002504  4883EB17                                      sub rbx,asm_tok
00002508                                            .endif
00002508                    *   @C01C6:
00002508                                        .endif
00002508                    *   @C01AD:
00002508                                    .endf
00002508                    *   @C01AB:
00002508  4883C317          *   add rbx, asm_tok
0000250C  E986FEFFFF        *   jmp @C01AA
00002511                    *   @C01AC:
00002511                                .endif
00002511                    *   @C01A8:
00002511                                .break .if ( rc != STRING_EXPANDED )
00002511  837DEC01          *   cmp rc , STRING_EXPANDED 
00002515  7508              *   jnz @C0172
00002517                            .endf
00002517                    *   @C0171:
00002517  FF45F0            *   inc lvl
0000251A  E922FAFFFF        *   jmp @C0170
0000251F                    *   @C0172:
0000251F                            .return asmerr( 2123 ) .if ( lvl == MAX_TEXTMACRO_NESTING )
0000251F  837DF014          *   cmp lvl , MAX_TEXTMACRO_NESTING 
00002523  750C              *   jnz @C01C7
00002525                    *   invoke asmerr, 2123 
00002525  B94B080000        *    mov ecx, 2123 
0000252A  E800000000        *    call asmerr
0000252F  EB03              *   jmp @C017B
00002531                    *   @C01C7:
00002531                            .return rc
00002531  8B45EC            *   mov eax,rc
00002534  EBFE              *   jmp @C017B
                            *   org $ - 2
00002534                    *   ret
00002534                    *   @C017B:
00002534  C9                *   leave
00002535  5B                *   pop rbx
00002536  5F                *   pop rdi
00002537  5E                *   pop rsi
00002538  C3                *   retn 
00002539                        ExpandLine endp
                                    end
00002539                    *   _TEXT ends


Macros:

                N a m e                 Type

.l8  . . . . . . . . . . . . . .        Proc
.s8  . . . . . . . . . . . . . .        Proc
.z8  . . . . . . . . . . . . . .        Proc
@CStr  . . . . . . . . . . . . .        Func
@CatStr  . . . . . . . . . . . .        Func
@ComAlloc  . . . . . . . . . . .        Func
@Environ . . . . . . . . . . . .        Func
@InStr . . . . . . . . . . . . .        Func
@SizeStr . . . . . . . . . . . .        Func
@SubStr  . . . . . . . . . . . .        Func
CALLBACK . . . . . . . . . . . .        Func
CALLBACKC  . . . . . . . . . . .        Func
CCALLBACK  . . . . . . . . . . .        Func
DEFINE_LTYPE . . . . . . . . . .        Proc
DeleteType . . . . . . . . . . .        Proc
GetCpuSp . . . . . . . . . . . .        Func
GetMemtypeSp . . . . . . . . . .        Func
GetRegNo . . . . . . . . . . . .        Func
GetSflagsSp  . . . . . . . . . .        Func
GetValueSp . . . . . . . . . . .        Func
IS_ANY_BRANCH  . . . . . . . . .        Func
IS_BRANCH  . . . . . . . . . . .        Func
IS_CALL  . . . . . . . . . . . .        Func
IS_JCC . . . . . . . . . . . . .        Func
IS_JMP . . . . . . . . . . . . .        Func
IS_JMPCALL . . . . . . . . . . .        Func
IS_OPER_32 . . . . . . . . . . .        Func
IS_XCX_BRANCH  . . . . . . . . .        Func
IndexFromToken . . . . . . . . .        Func
IndexFromToken_imm . . . . . . .        Func
OSVER  . . . . . . . . . . . . .        Func
OpCls  . . . . . . . . . . . . .        Func
SPVER  . . . . . . . . . . . . .        Func
SUBVER . . . . . . . . . . . . .        Func
SymSearch  . . . . . . . . . . .        Func
UNREFERENCED_PARAMETER . . . . .        Func
_PTR_LD  . . . . . . . . . . . .        Func
asm_tok_tokptr . . . . . . . . .        Func
is_linequeue_populated . . . . .        Func
typeid . . . . . . . . . . . . .        Func


Structures and Unions:

                N a m e                 Size/Ofs   Type

EXTFLOAT . . . . . . . . . . . .              12
  l  . . . . . . . . . . . . . .               0   uint64_t
  h  . . . . . . . . . . . . . .               8   uint64_t
  e  . . . . . . . . . . . . . .              10   short_t
FLTINFO  . . . . . . . . . . . .              30
  ndigits  . . . . . . . . . . .               0   int_t
  scale  . . . . . . . . . . . .               4   int_t
  flags  . . . . . . . . . . . .               8   int_t
  expchar  . . . . . . . . . . .               C   int_t
  expwidth . . . . . . . . . . .              10   int_t
  sign . . . . . . . . . . . . .              14   int_t
  dec_place  . . . . . . . . . .              18   int_t
  n1 . . . . . . . . . . . . . .              1C   int_t
  nz1  . . . . . . . . . . . . .              20   int_t
  n2 . . . . . . . . . . . . . .              24   int_t
  nz2  . . . . . . . . . . . . .              28   int_t
  bufsize  . . . . . . . . . . .              2C   int_t
HEAP . . . . . . . . . . . . . .              20 (8)
  size . . . . . . . . . . . . .               0   size_t
  type . . . . . . . . . . . . .               8   uchar_t
  prev . . . . . . . . . . . . .              10   ptr_t
  next . . . . . . . . . . . . .              18   ptr_t
STRFLT . . . . . . . . . . . . .              22
  mantissa . . . . . . . . . . .               0   EXTFLOAT
  flags  . . . . . . . . . . . .              12   int_t
  exponent . . . . . . . . . . .              16   int_t
  string . . . . . . . . . . . .              1A   string_t
U128 . . . . . . . . . . . . . .              10
 . . . . . . . . . . . . . . . .              10
    i8 . . . . . . . . . . . . .               0   Byte[16]
    i16  . . . . . . . . . . . .               0   Word[8]
    i32  . . . . . . . . . . . .               0   DWord[4]
    i64  . . . . . . . . . . . .               0   QWord[2]
    u8 . . . . . . . . . . . . .               0   Byte[16]
    u16  . . . . . . . . . . . .               0   Word[8]
    u32  . . . . . . . . . . . .               0   DWord[4]
    u64  . . . . . . . . . . . .               0   QWord[2]
    u128 . . . . . . . . . . . .               0   XmmWord
_CRT_DOUBLE  . . . . . . . . . .               8
  x  . . . . . . . . . . . . . .               0   QWord
_CRT_FLOAT . . . . . . . . . . .               4
  f  . . . . . . . . . . . . . .               0   DWord
_LDBL12  . . . . . . . . . . . .               C (4)
  ld12 . . . . . . . . . . . . .               0   Byte[12]
_LDOUBLE . . . . . . . . . . . .               A (4)
  ld . . . . . . . . . . . . . .               0   Byte[10]
_LONGDOUBLE  . . . . . . . . . .               A
  x  . . . . . . . . . . . . . .               0   TByte
_div_t . . . . . . . . . . . . .               8
  quot . . . . . . . . . . . . .               0   int_t
  rem  . . . . . . . . . . . . .               4   int_t
_iobuf . . . . . . . . . . . . .              30 (8)
  _ptr . . . . . . . . . . . . .               0   LPTSTR
  _cnt . . . . . . . . . . . . .               8   SINT
  _base  . . . . . . . . . . . .              10   LPSTR
  _flag  . . . . . . . . . . . .              18   SINT
  _file  . . . . . . . . . . . .              1C   SINT
  _charbuf . . . . . . . . . . .              20   SINT
  _bufsiz  . . . . . . . . . . .              24   SINT
  _tmpfname  . . . . . . . . . .              28   LPTSTR
_ldiv_t  . . . . . . . . . . . .               8
  quot . . . . . . . . . . . . .               0   long_t
  rem  . . . . . . . . . . . . .               4   long_t
_lldiv_t . . . . . . . . . . . .              10
  quot . . . . . . . . . . . . .               0   int64_t
  rem  . . . . . . . . . . . . .               8   int64_t
_locale_tstruct  . . . . . . . .              10 (8)
  locinfo  . . . . . . . . . . .               0   pthreadlocinfo
  mbcinfo  . . . . . . . . . . .               8   pthreadmbcinfo
asm_tok  . . . . . . . . . . . .              17
  token  . . . . . . . . . . . .               0   uchar_t
 . . . . . . . . . . . . . . . .               1
    dirtype  . . . . . . . . . .               1   uchar_t
    bytval . . . . . . . . . . .               1   uchar_t
    precedence . . . . . . . . .               1   uchar_t
    string_delim . . . . . . . .               1   char_t
    floattype  . . . . . . . . .               1   char_t
    numbase  . . . . . . . . . .               1   char_t
    specval  . . . . . . . . . .               1   char_t
  flags  . . . . . . . . . . . .               2   uchar_t
 . . . . . . . . . . . . . . . .               4
    tokval . . . . . . . . . . .               3   uint_t
    stringlen  . . . . . . . . .               3   uint_t
    idarg  . . . . . . . . . . .               3   uint_t
    itemlen  . . . . . . . . . .               3   uint_t
    lastidx  . . . . . . . . . .               3   uint_t
  string_ptr . . . . . . . . . .               7   string_t
  tokpos . . . . . . . . . . . .               F   string_t
asm_tokVtbl  . . . . . . . . . .               8
  tokptr . . . . . . . . . . . .               0   P$0001
asym . . . . . . . . . . . . . .              5C
  nextitem . . . . . . . . . . .               0   ptr?asym
  name . . . . . . . . . . . . .               8   string_t
  name_size  . . . . . . . . . .              10   int_t
  state  . . . . . . . . . . . .              14   uchar_t
  mem_type . . . . . . . . . . .              15   uchar_t
  langtype . . . . . . . . . . .              16   uchar_t
  flags  . . . . . . . . . . . .              17   uchar_t
  flag1  . . . . . . . . . . . .              18   uchar_t
  flag2  . . . . . . . . . . . .              19   uchar_t
  segoffsize . . . . . . . . . .              1A   uchar_t
  is_far . . . . . . . . . . . .              1B   uchar_t
  type . . . . . . . . . . . . .              1C   ptr?asym
 . . . . . . . . . . . . . . . .               8
    offs . . . . . . . . . . . .              24   int_t
    value  . . . . . . . . . . .              24   int_t
    uvalue . . . . . . . . . . .              24   uint_t
    string_ptr . . . . . . . . .              24   string_t
    substitute . . . . . . . . .              24   ptr?asym
    func_ptr . . . . . . . . . .              24   P$0002
    classlnameidx  . . . . . . .              24   int_t
 . . . . . . . . . . . . . . . .               8
    segm . . . . . . . . . . . .              2C   ptr?asym
    class  . . . . . . . . . . .              2C   ptr?asym
    vtable . . . . . . . . . . .              2C   ptr?asym
    vmacro . . . . . . . . . . .              2C   ptr?asym
 . . . . . . . . . . . . . . . .               4
    first_size . . . . . . . . .              34   uint_t
 . . . . . . . . . . . . . . . .               4
      Ofssize  . . . . . . . . .              34   uchar_t
      is_ptr . . . . . . . . . .              35   uchar_t
 . . . . . . . . . . . . . . . .               1
        ptr_memtype  . . . . . .              36   uchar_t
        asmpass  . . . . . . . .              36   uchar_t
      sflags . . . . . . . . . .              37   uchar_t
    mac_flag . . . . . . . . . .              34   uchar_t
 . . . . . . . . . . . . . . . .               8
    first_length . . . . . . . .              38   uint_t
    max_mbr_size . . . . . . . .              38   uint_t
    target_type  . . . . . . . .              38   ptr?asym
  regist . . . . . . . . . . . .              40   ushort_t[2]
 . . . . . . . . . . . . . . . .               8
    total_size . . . . . . . . .              44   uint_t
    value3264  . . . . . . . . .              44   int_t
    dll  . . . . . . . . . . . .              44   ptr?dll_desc
    max_offset . . . . . . . . .              44   int_t
 . . . . . . . . . . . . . . . .               8
    total_length . . . . . . . .              4C   uint_t
    altname  . . . . . . . . . .              4C   ptr?asym
    debuginfo  . . . . . . . . .              4C   ptr?debug_info
    sfunc_ptr  . . . . . . . . .              4C   P$0003
 . . . . . . . . . . . . . . . .               4
      cvtyperef  . . . . . . . .              4C   ushort_t
      typekind . . . . . . . . .              4E   ushort_t
 . . . . . . . . . . . . . . . .               8
    bp_fixup . . . . . . . . . .              54   ptr?fixup
    ext_idx  . . . . . . . . . .              54   uint_t
 . . . . . . . . . . . . . . . .               4
      ext_idx1 . . . . . . . . .              54   ushort_t
      ext_idx2 . . . . . . . . .              56   ushort_t
code_info  . . . . . . . . . . .              5B
  inst . . . . . . . . . . . . .               0   int_t
  RegOverride  . . . . . . . . .               4   int_t
  rex  . . . . . . . . . . . . .               8   Byte
  adrsiz . . . . . . . . . . . .               9   Byte
  opsiz  . . . . . . . . . . . .               A   Byte
  evex . . . . . . . . . . . . .               B   Byte
  evexP3 . . . . . . . . . . . .               C   Byte
  vflags . . . . . . . . . . . .               D   Byte
  token  . . . . . . . . . . . .               E   Word
  opnd . . . . . . . . . . . . .              10   opnd_item[3]
  pinstr . . . . . . . . . . . .              4C   instr_t
  mem_type . . . . . . . . . . .              54   Byte
  rm_byte  . . . . . . . . . . .              55   Byte
  sib  . . . . . . . . . . . . .              56   Byte
  Ofssize  . . . . . . . . . . .              57   Byte
  opc_or . . . . . . . . . . . .              58   Byte
  vexregop . . . . . . . . . . .              59   Byte
  flags  . . . . . . . . . . . .              5A   Byte
com_item . . . . . . . . . . . .              24
  cmd  . . . . . . . . . . . . .               0   DWord
  class  . . . . . . . . . . . .               4   string_t
  langtype . . . . . . . . . . .               C   DWord
  publsym  . . . . . . . . . . .              10   ptr?asym
  method . . . . . . . . . . . .              18   DWord
  sym  . . . . . . . . . . . . .              1C   ptr?asym
debug_info . . . . . . . . . . .              18
  start_line . . . . . . . . . .               0   DWord
  end_line . . . . . . . . . . .               4   DWord
  ln_fileofs . . . . . . . . . .               8   DWord
  line_numbers . . . . . . . . .               C   Word
  file . . . . . . . . . . . . .               E   Word
  next_proc  . . . . . . . . . .              10   DWord
  next_file  . . . . . . . . . .              14   DWord
dll_desc . . . . . . . . . . . .               D
  next . . . . . . . . . . . . .               0   ptr?dll_desc
  cnt  . . . . . . . . . . . . .               8   int_t
  name . . . . . . . . . . . . .               C   char_t
dsym . . . . . . . . . . . . . .              74
   . . . . . . . . . . . . . . .               0   asym
 . . . . . . . . . . . . . . . .               8
    seginfo  . . . . . . . . . .              5C   ptr?seg_item
    grpinfo  . . . . . . . . . .              5C   ptr?grp_info
    procinfo . . . . . . . . . .              5C   ptr?proc_info
    structinfo . . . . . . . . .              5C   ptr?struct_info
    macroinfo  . . . . . . . . .              5C   ptr?macro_info
    nextll . . . . . . . . . . .              5C   ptr?dsym
  next . . . . . . . . . . . . .              64   ptr?dsym
 . . . . . . . . . . . . . . . .               8
    prev . . . . . . . . . . . .              6C   ptr?dsym
    nextproc . . . . . . . . . .              6C   ptr?dsym
    nextlocal  . . . . . . . . .              6C   ptr?dsym
    nextparam  . . . . . . . . .              6C   ptr?dsym
expr . . . . . . . . . . . . . .              64
 . . . . . . . . . . . . . . . .              10
 . . . . . . . . . . . . . . . .               8
      value  . . . . . . . . . .               0   int_t
      hvalue . . . . . . . . . .               4   int_t
 . . . . . . . . . . . . . . . .              10
 . . . . . . . . . . . . . . . .               8
        llvalue  . . . . . . . .               0   uint64_t
 . . . . . . . . . . . . . . . .               8
          l64_l  . . . . . . . .               0   uint_t
          l64_h  . . . . . . . .               4   uint_t
 . . . . . . . . . . . . . . . .               8
        hlvalue  . . . . . . . .               8   uint64_t
 . . . . . . . . . . . . . . . .               8
          h64_l  . . . . . . . .               8   uint_t
          h64_h  . . . . . . . .               C   uint_t
    uvalue . . . . . . . . . . .               0   uint_t
    value64  . . . . . . . . . .               0   int64_t
    dvalue . . . . . . . . . . .               0   QWord
    fvalue . . . . . . . . . . .               0   DWord
    st_idx . . . . . . . . . . .               0   int_t
    chararray  . . . . . . . . .               0   uchar_t[16]
 . . . . . . . . . . . . . . . .               8
    quoted_string  . . . . . . .              10   token_t
    float_tok  . . . . . . . . .              10   token_t
  base_reg . . . . . . . . . . .              18   token_t
  idx_reg  . . . . . . . . . . .              20   token_t
 . . . . . . . . . . . . . . . .               8
    label_tok  . . . . . . . . .              28   token_t
    type_tok . . . . . . . . . .              28   token_t
  override . . . . . . . . . . .              30   token_t
  inst . . . . . . . . . . . . .              38   int_t
  kind . . . . . . . . . . . . .              3C   int_t
  mem_type . . . . . . . . . . .              40   uchar_t
  scale  . . . . . . . . . . . .              41   uchar_t
  Ofssize  . . . . . . . . . . .              42   uchar_t
  flags  . . . . . . . . . . . .              43   uchar_t
  op . . . . . . . . . . . . . .              44   ptr?opinfo
  sym  . . . . . . . . . . . . .              4C   asym_t
  mbr  . . . . . . . . . . . . .              54   asym_t
  type . . . . . . . . . . . . .              5C   asym_t
file_seq . . . . . . . . . . . .               A
  next . . . . . . . . . . . . .               0   fileseq_t
  file . . . . . . . . . . . . .               8   ushort_t
fixup  . . . . . . . . . . . . .              34
  nextbp . . . . . . . . . . . .               0   ptr?fixup
  nextrlc  . . . . . . . . . . .               8   ptr?fixup
  offs . . . . . . . . . . . . .              10   DWord
  locofs . . . . . . . . . . . .              14   DWord
  type . . . . . . . . . . . . .              18   Byte
  options  . . . . . . . . . . .              19   Byte
 . . . . . . . . . . . . . . . .               2
    flags  . . . . . . . . . . .              1A   Word
 . . . . . . . . . . . . . . . .               2
      addbytes . . . . . . . . .              1A   Byte
      fx_flag  . . . . . . . . .              1B   Byte
 . . . . . . . . . . . . . . . .               8
 . . . . . . . . . . . . . . . .               3
      frame_type . . . . . . . .              1C   char_t
      frame_datum  . . . . . . .              1D   ushort_t
    segment_var  . . . . . . . .              1C   ptr?asym
  def_seg  . . . . . . . . . . .              24   ptr?dsym
  sym  . . . . . . . . . . . . .              2C   ptr?asym
format_options . . . . . . . . .              10
  init . . . . . . . . . . . . .               0   P$0005
  invalid_fixup_type . . . . . .               8   Word
  formatname . . . . . . . . . .               A   char_t[6]
global_options . . . . . . . . .              C0
  quiet  . . . . . . . . . . . .               0   Byte
  line_numbers . . . . . . . . .               1   Byte
  debug_symbols  . . . . . . . .               2   Byte
  debug_ext  . . . . . . . . . .               3   Byte
  floating_point . . . . . . . .               4   DWord
  error_limit  . . . . . . . . .               8   DWord
  no_error_disp  . . . . . . . .               C   Byte
  warning_level  . . . . . . . .               D   Byte
  warning_error  . . . . . . . .               E   Byte
  process_subdir . . . . . . . .               F   Byte
  names  . . . . . . . . . . . .              10   string_t[9]
  queues . . . . . . . . . . . .              58   ptr_t[3]
  no_comment_in_code_rec . . . .              70   Byte
  no_opt_farcall . . . . . . . .              71   Byte
  no_file_entry  . . . . . . . .              72   Byte
  no_static_procs  . . . . . . .              73   Byte
  no_section_aux_entry . . . . .              74   Byte
  no_cdecl_decoration  . . . . .              75   Byte
  stdcall_decoration . . . . . .              76   Byte
  no_export_decoration . . . . .              77   Byte
  entry_decorated  . . . . . . .              78   Byte
  write_listing  . . . . . . . .              79   Byte
  write_impdef . . . . . . . . .              7A   Byte
  case_sensitive . . . . . . . .              7B   Byte
  convert_uppercase  . . . . . .              7C   Byte
  preprocessor_stdout  . . . . .              7D   Byte
  masm51_compat  . . . . . . . .              7E   Byte
  strict_masm_compat . . . . . .              7F   Byte
  masm_compat_gencode  . . . . .              80   Byte
  masm8_proc_visibility  . . . .              81   Byte
  listif . . . . . . . . . . . .              82   Byte
  list_generated_code  . . . . .              83   Byte
  list_macro . . . . . . . . . .              84   DWord
  no_symbol_listing  . . . . . .              88   Byte
  first_pass_listing . . . . . .              89   Byte
  all_symbols_public . . . . . .              8A   Byte
  safeseh  . . . . . . . . . . .              8B   Byte
  output_format  . . . . . . . .              8C   DWord
  sub_format . . . . . . . . . .              90   DWord
  langtype . . . . . . . . . . .              94   DWord
  _model . . . . . . . . . . . .              98   DWord
  cpu  . . . . . . . . . . . . .              9C   DWord
  fctype . . . . . . . . . . . .              A0   DWord
  codepage . . . . . . . . . . .              A4   DWord
  ignore_include . . . . . . . .              A8   Byte
  fieldalign . . . . . . . . . .              A9   Byte
  syntax_check_only  . . . . . .              AA   Byte
  xflag  . . . . . . . . . . . .              AB   Byte
  loopalign  . . . . . . . . . .              AC   Byte
  casealign  . . . . . . . . . .              AD   Byte
  epilogueflags  . . . . . . . .              AE   Byte
  segmentalign . . . . . . . . .              AF   Byte
  pe_subsystem . . . . . . . . .              B0   Byte
  win64_flags  . . . . . . . . .              B1   Byte
  chkstack . . . . . . . . . . .              B2   Byte
  nolib  . . . . . . . . . . . .              B3   Byte
  masm_keywords  . . . . . . . .              B4   Byte
  arch . . . . . . . . . . . . .              B5   Byte
  frame_auto . . . . . . . . . .              B6   Byte
  floatformat  . . . . . . . . .              B7   Byte
  floatdigits  . . . . . . . . .              B8   DWord
  flt_size . . . . . . . . . . .              BC   Byte
  pic  . . . . . . . . . . . . .              BD   Byte
  endbr  . . . . . . . . . . . .              BE   Byte
  dotname  . . . . . . . . . . .              BF   Byte
grp_info . . . . . . . . . . . .              14
  seglist  . . . . . . . . . . .               0   ptr?seg_item
  grp_idx  . . . . . . . . . . .               8   int_t
  lname_idx  . . . . . . . . . .               C   int_t
  numseg . . . . . . . . . . . .              10   uint_t
input_status . . . . . . . . . .              1D
  token_stringbuf  . . . . . . .               0   string_t
  currsource . . . . . . . . . .               8   string_t
  CurrComment  . . . . . . . . .              10   string_t
  token_count  . . . . . . . . .              18   int_t
  line_flags . . . . . . . . . .              1C   char_t
instr_item . . . . . . . . . . .               8
  opclsidx . . . . . . . . . . .               0   Byte
  byte1_info . . . . . . . . . .               1   Byte
  flags  . . . . . . . . . . . .               2   Byte
  evex . . . . . . . . . . . . .               3   Byte
  cpu  . . . . . . . . . . . . .               4   Word
  opcode . . . . . . . . . . . .               6   Byte
  rm_byte  . . . . . . . . . . .               7   Byte
line_status  . . . . . . . . . .              31
  input  . . . . . . . . . . . .               0   string_t
  output . . . . . . . . . . . .               8   string_t
  start  . . . . . . . . . . . .              10   string_t
  index  . . . . . . . . . . . .              18   uint_t
  flags  . . . . . . . . . . . .              1C   char_t
  flags2 . . . . . . . . . . . .              1D   char_t
  flags3 . . . . . . . . . . . .              1E   char_t
  brachets . . . . . . . . . . .              1F   char_t
  tokenarray . . . . . . . . . .              20   token_t
  outbuf . . . . . . . . . . . .              28   string_t
  cstring  . . . . . . . . . . .              30   char_t
locrefcount  . . . . . . . . . .              20 (8)
  locale . . . . . . . . . . . .               0   LPSTR
  wlocale  . . . . . . . . . . .               8   LPWSTR
  refcount . . . . . . . . . . .              10   LPINT
  wrefcount  . . . . . . . . . .              18   LPINT
macro_info . . . . . . . . . . .              18
  parmcnt  . . . . . . . . . . .               0   ushort_t
 . . . . . . . . . . . . . . . .               2
    localcnt . . . . . . . . . .               2   ushort_t
    autoexp  . . . . . . . . . .               2   ushort_t
  parmlist . . . . . . . . . . .               4   ptr?mparm_list
  lines  . . . . . . . . . . . .               C   ptr?srcline
  srcfile  . . . . . . . . . . .              14   uint_t
macro_instance . . . . . . . . .              28
  currline . . . . . . . . . . .               0   srcline_t
  startline  . . . . . . . . . .               8   srcline_t
  localstart . . . . . . . . . .              10   uint_t
  parm_array . . . . . . . . . .              14   array_t
  _macro . . . . . . . . . . . .              1C   asym_t
  parmcnt  . . . . . . . . . . .              24   uint_t
module_info  . . . . . . . . . .             340
   . . . . . . . . . . . . . . .               0   module_vars
  proc_prologue  . . . . . . . .             16C   string_t
  proc_epilogue  . . . . . . . .             174   string_t
  CurrDll  . . . . . . . . . . .             17C   ptr?dll_desc
  fmtopt . . . . . . . . . . . .             184   ptr?format_options
  hll_label  . . . . . . . . . .             18C   DWord
  distance . . . . . . . . . . .             190   Byte
  _model . . . . . . . . . . . .             191   Byte
  langtype . . . . . . . . . . .             192   Byte
  ostype . . . . . . . . . . . .             193   Byte
  sub_format . . . . . . . . . .             194   Byte
  fctype . . . . . . . . . . . .             195   Byte
  segorder . . . . . . . . . . .             196   Byte
  offsettype . . . . . . . . . .             197   Byte
  cpu  . . . . . . . . . . . . .             198   DWord
  curr_cpu . . . . . . . . . . .             19C   DWord
  radix  . . . . . . . . . . . .             1A0   Byte
  fieldalign . . . . . . . . . .             1A1   Byte
  line_flags . . . . . . . . . .             1A2   Byte
  procalign  . . . . . . . . . .             1A3   Byte
  list_macro . . . . . . . . . .             1A4   DWord
  Ofssize  . . . . . . . . . . .             1A8   Byte
  defOfssize . . . . . . . . . .             1A9   Byte
  wordsize . . . . . . . . . . .             1AA   Byte
  inside_comment . . . . . . . .             1AB   Byte
  case_sensitive . . . . . . . .             1AC   Byte
  convert_uppercase  . . . . . .             1AD   Byte
  procs_private  . . . . . . . .             1AE   Byte
  procs_export . . . . . . . . .             1AF   Byte
  dotname  . . . . . . . . . . .             1B0   Byte
  ljmp . . . . . . . . . . . . .             1B1   Byte
  m510 . . . . . . . . . . . . .             1B2   Byte
  scoped . . . . . . . . . . . .             1B3   Byte
  oldstructs . . . . . . . . . .             1B4   Byte
  emulator . . . . . . . . . . .             1B5   Byte
  setif2 . . . . . . . . . . . .             1B6   Byte
  list . . . . . . . . . . . . .             1B7   Byte
  cref . . . . . . . . . . . . .             1B8   Byte
  listif . . . . . . . . . . . .             1B9   Byte
  list_generated_code  . . . . .             1BA   Byte
  StartupDirectiveFound  . . . .             1BB   Byte
  EndDirFound  . . . . . . . . .             1BC   Byte
  frame_auto . . . . . . . . . .             1BD   Byte
  NoSignExtend . . . . . . . . .             1BE   Byte
  simseg_init  . . . . . . . . .             1BF   Byte
 . . . . . . . . . . . . . . . .               8
 . . . . . . . . . . . . . . . .               2
      elf_osabi  . . . . . . . .             1C0   Byte
      win64_flags  . . . . . . .             1C1   Byte
 . . . . . . . . . . . . . . . .               8
      mz_ofs_fixups  . . . . . .             1C0   Word
      mz_alignment . . . . . . .             1C2   Word
      mz_heapmin . . . . . . . .             1C4   Word
      mz_heapmax . . . . . . . .             1C6   Word
  simseg_defd  . . . . . . . . .             1C8   Byte
  PhaseError . . . . . . . . . .             1C9   Byte
  CommentDataInCode  . . . . . .             1CA   Byte
  prologuemode . . . . . . . . .             1CB   Byte
  epiloguemode . . . . . . . . .             1CC   Byte
  invoke_exprparm  . . . . . . .             1CD   Byte
  cv_opt . . . . . . . . . . . .             1CE   Byte
  strict_masm_compat . . . . . .             1CF   Byte
  srcfile  . . . . . . . . . . .             1D0   uint_t
  currseg  . . . . . . . . . . .             1D4   ptr?dsym
  flat_grp . . . . . . . . . . .             1DC   ptr?dsym
  pCodeBuff  . . . . . . . . . .             1E4   ptr?byte
  GeneratedCode  . . . . . . . .             1EC   uint_t
  currsource . . . . . . . . . .             1F0   string_t
  CurrComment  . . . . . . . . .             1F8   string_t
  tokenarray . . . . . . . . . .             200   ptr?asm_tok
  stringbufferend  . . . . . . .             208   string_t
  token_count  . . . . . . . . .             210   int_t
  basereg  . . . . . . . . . . .             214   uint_t[3]
  name . . . . . . . . . . . . .             220   Byte[260]
  xflag  . . . . . . . . . . . .             324   Byte
  loopalign  . . . . . . . . . .             325   Byte
  casealign  . . . . . . . . . .             326   Byte
  epilogueflags  . . . . . . . .             327   Byte
  assert_proc  . . . . . . . . .             328   string_t
  codepage . . . . . . . . . . .             330   uint_t
  class_label  . . . . . . . . .             334   uint_t
  floatdigits  . . . . . . . . .             338   int_t
  floatformat  . . . . . . . . .             33C   Byte
  flt_size . . . . . . . . . . .             33D   Byte
  pic  . . . . . . . . . . . . .             33E   Byte
  endbr  . . . . . . . . . . . .             33F   Byte
module_vars  . . . . . . . . . .             16C
  error_count  . . . . . . . . .               0   uint_t
  warning_count  . . . . . . . .               4   uint_t
  num_segs . . . . . . . . . . .               8   uint_t
  PubQueue . . . . . . . . . . .               C   qdesc
  LnameQueue . . . . . . . . . .              1C   qdesc
  SafeSEHQueue . . . . . . . . .              2C   qdesc
  LibQueue . . . . . . . . . . .              3C   qdesc
  LinkQueue  . . . . . . . . . .              4C   qdesc
  DllQueue . . . . . . . . . . .              5C   ptr?dll_desc
  imp_prefix . . . . . . . . . .              64   string_t
  curr_file  . . . . . . . . . .              6C   LPFILE[4]
  curr_fname . . . . . . . . . .              8C   string_t[4]
  FNames . . . . . . . . . . . .              AC   array_t
  cnt_fnames . . . . . . . . . .              B4   uint_t
  IncludePath  . . . . . . . . .              B8   string_t
  line_queue . . . . . . . . . .              C0   qdesc
  src_stack  . . . . . . . . . .              D0   ptr?src_item
 . . . . . . . . . . . . . . . .               8
    start_fixup  . . . . . . . .              D8   ptr?fixup
    start_label  . . . . . . . .              D8   ptr?asym
  start_displ  . . . . . . . . .              E0   uint_t
  StrStack . . . . . . . . . . .              E4   ptr?str_item
  HllStack . . . . . . . . . . .              EC   ptr?hll_item
  HllFree  . . . . . . . . . . .              F4   ptr?hll_item
  ComStack . . . . . . . . . . .              FC   ptr?com_item
  RetStack . . . . . . . . . . .             104   ptr?hll_item
  FltStack . . . . . . . . . . .             10C   ptr?flt_item
  NspStack . . . . . . . . . . .             114   ptr?nsp_item
  ContextStack . . . . . . . . .             11C   ptr?byte
  ContextFree  . . . . . . . . .             124   ptr?byte
  SavedContexts  . . . . . . . .             12C   ptr?byte
  cntSavedContexts . . . . . . .             134   int_t
  anonymous_label  . . . . . . .             138   uint_t
  StackBase  . . . . . . . . . .             13C   ptr?asym
  ProcStatus . . . . . . . . . .             144   ptr?asym
  WriteModule  . . . . . . . . .             14C   P$0006
  EndDirHook . . . . . . . . . .             154   P$0007
  Pass1Checks  . . . . . . . . .             15C   P$0008
  pe_flags . . . . . . . . . . .             164   uint_t
  max_line_len . . . . . . . . .             168   uint_t
mparm_list . . . . . . . . . . .               9
  deflt  . . . . . . . . . . . .               0   string_t
  required . . . . . . . . . . .               8   uchar_t
nsp_item . . . . . . . . . . . .              10
  next . . . . . . . . . . . . .               0   ptr?nsp_item
  name . . . . . . . . . . . . .               8   ptr?sbyte
opnd_class . . . . . . . . . . .               9
  opnd_type  . . . . . . . . . .               0   DWord[2]
  opnd_type_3rd  . . . . . . . .               8   Byte
opnd_item  . . . . . . . . . . .              14
  type . . . . . . . . . . . . .               0   uint_t
  InsFixup . . . . . . . . . . .               4   fixup_t
 . . . . . . . . . . . . . . . .               8
 . . . . . . . . . . . . . . . .               8
      data32l  . . . . . . . . .               C   int_t
      data32h  . . . . . . . . .              10   int_t
    data64 . . . . . . . . . . .               C   uint64_t
proc_info  . . . . . . . . . . .              44
  regslist . . . . . . . . . . .               0   ptr?word
  paralist . . . . . . . . . . .               8   ptr?dsym
  locallist  . . . . . . . . . .              10   ptr?dsym
  labellist  . . . . . . . . . .              18   ptr?dsym
  parasize . . . . . . . . . . .              20   uint_t
  localsize  . . . . . . . . . .              24   uint_t
  prologuearg  . . . . . . . . .              28   string_t
  exc_handler  . . . . . . . . .              30   ptr?asym
  ReservedStack  . . . . . . . .              38   int_t
  prolog_list_pos  . . . . . . .              3C   uint_t
  flags  . . . . . . . . . . . .              40   uchar_t
  size_prolog  . . . . . . . . .              41   uchar_t
  basereg  . . . . . . . . . . .              42   ushort_t
qdesc  . . . . . . . . . . . . .              10
  head . . . . . . . . . . . . .               0   ptr?
  tail . . . . . . . . . . . . .               8   ptr?
qditem . . . . . . . . . . . . .               C
  next . . . . . . . . . . . . .               0   ptr?qditem
  size . . . . . . . . . . . . .               8   uint_t
qitem  . . . . . . . . . . . . .               9
  next . . . . . . . . . . . . .               0   ptr?qitem
  value  . . . . . . . . . . . .               8   Byte
qnode  . . . . . . . . . . . . .              10
  next . . . . . . . . . . . . .               0   ptr?
 . . . . . . . . . . . . . . . .               8
    elmt . . . . . . . . . . . .               8   ptr?
    sym  . . . . . . . . . . . .               8   ptr?asym
qualified_type . . . . . . . . .              11
  size . . . . . . . . . . . . .               0   int_t
  symtype  . . . . . . . . . . .               4   ptr?asym
  mem_type . . . . . . . . . . .               C   Byte
  is_ptr . . . . . . . . . . . .               D   Byte
  is_far . . . . . . . . . . . .               E   Byte
  Ofssize  . . . . . . . . . . .               F   Byte
  ptr_memtype  . . . . . . . . .              10   Byte
seg_info . . . . . . . . . . . .              6C
  sgroup . . . . . . . . . . . .               0   ptr?asym
  start_loc  . . . . . . . . . .               8   uint_t
 . . . . . . . . . . . . . . . .               4
    current_loc  . . . . . . . .               C   uint_t
    reloc_offset . . . . . . . .               C   uint_t
    start_offset . . . . . . . .               C   uint_t
  CodeBuffer . . . . . . . . . .              10   string_t
  bytes_written  . . . . . . . .              18   uint_t
 . . . . . . . . . . . . . . . .               8
    label_list . . . . . . . . .              1C   asym_t
    flushfunc  . . . . . . . . .              1C   P$0004
  head . . . . . . . . . . . . .              24   ptr?fixup
  tail . . . . . . . . . . . . .              2C   ptr?fixup
 . . . . . . . . . . . . . . . .               8
    LinnumQueue  . . . . . . . .              34   ptr_t
    fileoffset . . . . . . . . .              34   uint_t
    num_linnums  . . . . . . . .              34   uint_t
  num_relocs . . . . . . . . . .              3C   uint_t
  seg_idx  . . . . . . . . . . .              40   uint_t
  segtype  . . . . . . . . . . .              44   uint_t
  lname_idx  . . . . . . . . . .              48   int_t
  clsym  . . . . . . . . . . . .              4C   ptr?asym
 . . . . . . . . . . . . . . . .               4
    abs_frame  . . . . . . . . .              54   uint_t
    comdat_number  . . . . . . .              54   uint_t
    comdat_idx . . . . . . . . .              54   uint_t
 . . . . . . . . . . . . . . . .               8
    abs_offset . . . . . . . . .              58   uint_t
    aliasname  . . . . . . . . .              58   string_t
  Ofssize  . . . . . . . . . . .              60   uchar_t
  characteristics  . . . . . . .              61   uchar_t
  alignment  . . . . . . . . . .              62   uchar_t
  readonly . . . . . . . . . . .              63   uchar_t
  info . . . . . . . . . . . . .              64   uchar_t
  force32  . . . . . . . . . . .              65   uchar_t
  data_in_code . . . . . . . . .              66   uchar_t
  internal . . . . . . . . . . .              67   uchar_t
  written  . . . . . . . . . . .              68   uchar_t
  linnum_init  . . . . . . . . .              69   uchar_t
  combine  . . . . . . . . . . .              6A   uchar_t
  comdatselection  . . . . . . .              6B   uchar_t
seg_item . . . . . . . . . . . .              10
  next . . . . . . . . . . . . .               0   ptr?seg_item
  iseg . . . . . . . . . . . . .               8   ptr?dsym
sfield . . . . . . . . . . . . .              65
   . . . . . . . . . . . . . . .               0   asym
  next . . . . . . . . . . . . .              5C   ptr?sfield
  ivalue . . . . . . . . . . . .              64   char_t
special_item . . . . . . . . . .               C
  value  . . . . . . . . . . . .               0   DWord
  sflags . . . . . . . . . . . .               4   DWord
  cpu  . . . . . . . . . . . . .               8   Word
  bytval . . . . . . . . . . . .               A   Byte
  type . . . . . . . . . . . . .               B   Byte
src_item . . . . . . . . . . . .              18
  next . . . . . . . . . . . . .               0   ptr?src_item
  type . . . . . . . . . . . . .               8   Word
  srcfile  . . . . . . . . . . .               A   Word
 . . . . . . . . . . . . . . . .               8
    content  . . . . . . . . . .               C   ptr_t
    file . . . . . . . . . . . .               C   ptr_t
    mi . . . . . . . . . . . . .               C   ptr_t
  line_num . . . . . . . . . . .              14   uint_t
srcline  . . . . . . . . . . . .               A
  next . . . . . . . . . . . . .               0   ptr?srcline
  ph_count . . . . . . . . . . .               8   uchar_t
  line . . . . . . . . . . . . .               9   char_t[1]
struct_info  . . . . . . . . . .              12
  head . . . . . . . . . . . . .               0   ptr?sfield
  tail . . . . . . . . . . . . .               8   ptr?sfield
  alignment  . . . . . . . . . .              10   uchar_t
  flags  . . . . . . . . . . . .              11   uchar_t
symbol_queue . . . . . . . . . .              10
  head . . . . . . . . . . . . .               0   ptr?dsym
  tail . . . . . . . . . . . . .               8   ptr?dsym
threadlocinfo  . . . . . . . . .             158 (8)
  refcount . . . . . . . . . . .               0   SINT
  lc_codepage  . . . . . . . . .               4   UINT
  lc_collate_cp  . . . . . . . .               8   UINT
  lc_time_cp . . . . . . . . . .               C   UINT
  lc_category  . . . . . . . . .              10   locrefcount[6]
  lc_clike . . . . . . . . . . .              D0   SINT
  mb_cur_max . . . . . . . . . .              D4   SINT
  lconv_intl_refcount  . . . . .              D8   LPINT
  lconv_num_refcount . . . . . .              E0   LPINT
  lconv_mon_refcount . . . . . .              E8   LPINT
  lconvp . . . . . . . . . . . .              F0   PVOID
  ctype1_refcount  . . . . . . .              F8   LPINT
  ctype1 . . . . . . . . . . . .             100   LPSHORT
  pctype . . . . . . . . . . . .             108   LPSHORT
  pclmap . . . . . . . . . . . .             110   LPSTR
  pcumap . . . . . . . . . . . .             118   LPSTR
  lc_time_curr . . . . . . . . .             120   PVOID
  locale_name  . . . . . . . . .             128   LPWSTR[6]
threadmbcinfo  . . . . . . . . .             228 (8)
  refcount . . . . . . . . . . .               0   int_t
  mbcodepage . . . . . . . . . .               4   int_t
  ismbcodepage . . . . . . . . .               8   int_t
  mbulinfo . . . . . . . . . . .               C   Word[6]
  mbctype  . . . . . . . . . . .              18   Byte[257]
  mbcasemap  . . . . . . . . . .             119   Byte[256]
  mblocalename . . . . . . . . .             220   wstring_t


Types:

                N a m e                 Size    Attr

?LPQSORTCMD  . . . . . . . . . .           8  Proc L Near64 FASTCALL
?_PtFuncCompare  . . . . . . . .           8  Proc L Near64 FASTCALL
?_PtFuncCompare_s  . . . . . . .           8  Proc L Near64 FASTCALL
?_invalid_parameter_handler  . .           8  Proc L Near64 FASTCALL
?_onexit_t . . . . . . . . . . .           8  Proc L Near64 FASTCALL
?_purecall_handler . . . . . . .           8  Proc L Near64 FASTCALL
FILE . . . . . . . . . . . . . .          48  _iobuf
HANDLE . . . . . . . . . . . . .           8  Near Ptr 
LPBYTE . . . . . . . . . . . . .           8  Near Ptr Byte
LPDWORD  . . . . . . . . . . . .           8  Near Ptr DWord
LPFILE . . . . . . . . . . . . .           8  Near Ptr _iobuf
LPINT  . . . . . . . . . . . . .           8  Near Ptr DWord
LPQSORTCMD . . . . . . . . . . .           8  Near Ptr 
LPQWORD  . . . . . . . . . . . .           8  Near Ptr QWord
LPSHORT  . . . . . . . . . . . .           8  Near Ptr Word
LPSTR  . . . . . . . . . . . . .           8  Near Ptr Byte
LPTSTR . . . . . . . . . . . . .           8  Near Ptr Byte
LPWORD . . . . . . . . . . . . .           8  Near Ptr Word
LPWSTR . . . . . . . . . . . . .           8  Near Ptr Word
P$0001 . . . . . . . . . . . . .           8  Near Ptr 
P$0002 . . . . . . . . . . . . .           8  Near Ptr 
P$0003 . . . . . . . . . . . . .           8  Near Ptr 
P$0004 . . . . . . . . . . . . .           8  Near Ptr 
P$0005 . . . . . . . . . . . . .           8  Near Ptr 
P$0006 . . . . . . . . . . . . .           8  Near Ptr 
P$0007 . . . . . . . . . . . . .           8  Near Ptr 
P$0008 . . . . . . . . . . . . .           8  Near Ptr 
PQSORTCMD  . . . . . . . . . . .           8  Near Ptr 
PQSORTCMDT . . . . . . . . . . .           8  Proc L Near64 FASTCALL
PTBYTE . . . . . . . . . . . . .           8  Near Ptr Byte
PTCHAR . . . . . . . . . . . . .           8  Near Ptr Byte
PVOID  . . . . . . . . . . . . .           8  Near Ptr 
SINT . . . . . . . . . . . . . .           4  DWord
SIZE_T . . . . . . . . . . . . .           8  QWord
StrCmpFunc . . . . . . . . . . .           8  Near Ptr 
StrCmpFunc_t . . . . . . . . . .           8  Proc L Near64 FASTCALL
T$0001 . . . . . . . . . . . . .           8  Proc L Near64 WATCALL
T$0002 . . . . . . . . . . . . .           8  Proc L Near64 FASTCALL
T$0003 . . . . . . . . . . . . .           8  Proc L Near64 FASTCALL
T$0004 . . . . . . . . . . . . .           8  Proc L Near64 FASTCALL
T$0005 . . . . . . . . . . . . .           8  Proc L Near64 FASTCALL
T$0006 . . . . . . . . . . . . .           8  Proc L Near64 FASTCALL
T$0007 . . . . . . . . . . . . .           8  Proc L Near64 FASTCALL
T$0008 . . . . . . . . . . . . .           8  Proc L Near64 FASTCALL
TCHAR  . . . . . . . . . . . . .           1  Byte
UINT . . . . . . . . . . . . . .           4  DWord
ULONG  . . . . . . . . . . . . .           4  DWord
_PtFuncCompare . . . . . . . . .           8  Near Ptr 
_PtFuncCompare_s . . . . . . . .           8  Near Ptr 
_invalid_parameter_handler . . .           8  Near Ptr 
_locale_t  . . . . . . . . . . .           8  Near Ptr _locale_tstruct
_onexit_t  . . . . . . . . . . .           8  Near Ptr 
_purecall_handler  . . . . . . .           8  Near Ptr 
allowed_prefix . . . . . . . . .           4  DWord
array_t  . . . . . . . . . . . .           8  Near Ptr Near Ptr Byte
assume_segreg  . . . . . . . . .           4  DWord
asym_t . . . . . . . . . . . . .           8  Near Ptr asym
bool . . . . . . . . . . . . . .           4  DWord
char_t . . . . . . . . . . . . .           1  Byte
cond_class . . . . . . . . . . .           4  DWord
cpu_architecture . . . . . . . .           4  DWord
cpu_info . . . . . . . . . . . .           4  DWord
cpu_type . . . . . . . . . . . .           4  DWord
cvex_values  . . . . . . . . . .           4  DWord
cvoption_flags . . . . . . . . .           4  DWord
debug_t  . . . . . . . . . . . .           8  Near Ptr debug_info
directive_flags  . . . . . . . .           4  DWord
directive_type . . . . . . . . .           4  DWord
dist_type  . . . . . . . . . . .           4  DWord
dlldesc_t  . . . . . . . . . . .           8  Near Ptr dll_desc
double_t . . . . . . . . . . . .           8  QWord
dsym_t . . . . . . . . . . . . .           8  Near Ptr dsym
errno_t  . . . . . . . . . . . .           4  DWord
expr_flags . . . . . . . . . . .           4  DWord
expr_t . . . . . . . . . . . . .           8  Near Ptr expr
exprtype . . . . . . . . . . . .           4  DWord
file_extensions  . . . . . . . .           4  DWord
fileseq_t  . . . . . . . . . . .           8  Near Ptr file_seq
fixup_options  . . . . . . . . .           4  DWord
fixup_t  . . . . . . . . . . . .           8  Near Ptr fixup
fixup_types  . . . . . . . . . .           4  DWord
float_t  . . . . . . . . . . . .           4  DWord
fpo  . . . . . . . . . . . . . .           4  DWord
group_t  . . . . . . . . . . . .           8  Near Ptr grp_info
half_t . . . . . . . . . . . . .           2  Word
heap_t . . . . . . . . . . . . .           8  Near Ptr HEAP
if_state . . . . . . . . . . . .           4  DWord
input_t  . . . . . . . . . . . .           8  Near Ptr input_status
instr_t  . . . . . . . . . . . .           8  Near Ptr instr_item
instr_token  . . . . . . . . . .           4  DWord
int128_t . . . . . . . . . . . .          16  XmmWord
int16_t  . . . . . . . . . . . .           2  Word
int32_t  . . . . . . . . . . . .           4  DWord
int64_t  . . . . . . . . . . . .           8  QWord
int8_t . . . . . . . . . . . . .           1  Byte
int_16 . . . . . . . . . . . . .           2  Word
int_32 . . . . . . . . . . . . .           4  DWord
int_64 . . . . . . . . . . . . .           8  QWord
int_8  . . . . . . . . . . . . .           1  Byte
int_t  . . . . . . . . . . . . .           4  DWord
intptr_t . . . . . . . . . . . .           8  QWord
lang_type  . . . . . . . . . . .           4  DWord
ldouble_t  . . . . . . . . . . .          10  TByte
line_output_flags  . . . . . . .           4  DWord
listmacro  . . . . . . . . . . .           4  DWord
long_t . . . . . . . . . . . . .           4  DWord
lsttype  . . . . . . . . . . . .           4  DWord
masm_cpu . . . . . . . . . . . .           4  DWord
model_type . . . . . . . . . . .           4  DWord
mparm_t  . . . . . . . . . . . .           8  Near Ptr mparm_list
offset_type  . . . . . . . . . .           4  DWord
oformat  . . . . . . . . . . . .           4  DWord
onexit_t . . . . . . . . . . . .           8  Near Ptr 
op1_flags  . . . . . . . . . . .           4  DWord
oparg_types  . . . . . . . . . .           4  DWord
opt_names  . . . . . . . . . . .           4  DWord
opt_queues . . . . . . . . . . .           4  DWord
os_type  . . . . . . . . . . . .           4  DWord
proc_t . . . . . . . . . . . . .           8  Near Ptr proc_info
prologue_epilogue_mode . . . . .           4  DWord
pthreadlocinfo . . . . . . . . .           8  Near Ptr threadlocinfo
pthreadmbcinfo . . . . . . . . .           8  Near Ptr threadmbcinfo
ptr? . . . . . . . . . . . . . .           8  Near Ptr 
ptr?asm_tok  . . . . . . . . . .           8  Near Ptr asm_tok
ptr?asym . . . . . . . . . . . .           8  Near Ptr asym
ptr?byte . . . . . . . . . . . .           8  Near Ptr Byte
ptr?com_item . . . . . . . . . .           8  Near Ptr com_item
ptr?debug_info . . . . . . . . .           8  Near Ptr debug_info
ptr?dll_desc . . . . . . . . . .           8  Near Ptr dll_desc
ptr?dsym . . . . . . . . . . . .           8  Near Ptr dsym
ptr?fixup  . . . . . . . . . . .           8  Near Ptr fixup
ptr?flt_item . . . . . . . . . .           8  Near Ptr flt_item
ptr?format_options . . . . . . .           8  Near Ptr format_options
ptr?grp_info . . . . . . . . . .           8  Near Ptr grp_info
ptr?hll_item . . . . . . . . . .           8  Near Ptr hll_item
ptr?macro_info . . . . . . . . .           8  Near Ptr macro_info
ptr?mparm_list . . . . . . . . .           8  Near Ptr mparm_list
ptr?nsp_item . . . . . . . . . .           8  Near Ptr nsp_item
ptr?opinfo . . . . . . . . . . .           8  Near Ptr opinfo
ptr?proc_info  . . . . . . . . .           8  Near Ptr proc_info
ptr?qditem . . . . . . . . . . .           8  Near Ptr qditem
ptr?qitem  . . . . . . . . . . .           8  Near Ptr qitem
ptr?sbyte  . . . . . . . . . . .           8  Near Ptr Byte
ptr?seg_item . . . . . . . . . .           8  Near Ptr seg_item
ptr?sfield . . . . . . . . . . .           8  Near Ptr sfield
ptr?src_item . . . . . . . . . .           8  Near Ptr src_item
ptr?srcline  . . . . . . . . . .           8  Near Ptr srcline
ptr?str_item . . . . . . . . . .           8  Near Ptr str_item
ptr?struct_info  . . . . . . . .           8  Near Ptr struct_info
ptr?word . . . . . . . . . . . .           8  Near Ptr Word
ptr_t  . . . . . . . . . . . . .           8  Near Ptr 
qdesc_t  . . . . . . . . . . . .           8  Near Ptr qdesc
qfloat_t . . . . . . . . . . . .          16  XmmWord
qnode_t  . . . . . . . . . . . .           8  Near Ptr qnode
queue_type . . . . . . . . . . .           4  DWord
rex_bits . . . . . . . . . . . .           4  DWord
rm_info  . . . . . . . . . . . .           4  DWord
rounding_mode  . . . . . . . . .           4  DWord
seg_order  . . . . . . . . . . .           4  DWord
seg_type . . . . . . . . . . . .           4  DWord
segitem_t  . . . . . . . . . . .           8  Near Ptr seg_item
segment_t  . . . . . . . . . . .           8  Near Ptr seg_info
segofssize . . . . . . . . . . .           4  DWord
sformat  . . . . . . . . . . . .           4  DWord
short_t  . . . . . . . . . . . .           2  Word
size_t . . . . . . . . . . . . .           8  QWord
special_token  . . . . . . . . .           4  DWord
special_type . . . . . . . . . .           4  DWord
srcitem_t  . . . . . . . . . . .           8  Near Ptr src_item
srcline_t  . . . . . . . . . . .           8  Near Ptr srcline
stdcall_decoration . . . . . . .           4  DWord
string_t . . . . . . . . . . . .           8  Near Ptr Byte
sym_state  . . . . . . . . . . .           4  DWord
token_t  . . . . . . . . . . . .           8  Near Ptr asm_tok
uchar_t  . . . . . . . . . . . .           1  Byte
uint128_t  . . . . . . . . . . .          16  XmmWord
uint16_t . . . . . . . . . . . .           2  Word
uint32_t . . . . . . . . . . . .           4  DWord
uint64_t . . . . . . . . . . . .           8  QWord
uint8_t  . . . . . . . . . . . .           1  Byte
uint_16  . . . . . . . . . . . .           2  Word
uint_32  . . . . . . . . . . . .           4  DWord
uint_64  . . . . . . . . . . . .           8  QWord
uint_8 . . . . . . . . . . . . .           1  Byte
uint_t . . . . . . . . . . . . .           4  DWord
uintptr_t  . . . . . . . . . . .           8  QWord
ulong_t  . . . . . . . . . . . .           4  DWord
ushort_t . . . . . . . . . . . .           2  Word
ustring_t  . . . . . . . . . . .           8  Near Ptr Byte
warray_t . . . . . . . . . . . .           8  Near Ptr Near Ptr Word
wchar_t  . . . . . . . . . . . .           2  Word
wctype_t . . . . . . . . . . . .           2  Word
win64_flag_values  . . . . . . .           4  DWord
wint_t . . . . . . . . . . . . .           2  Word
wstring_t  . . . . . . . . . . .           8  Near Ptr Word


Segments and Groups:

                N a m e                 Size     Length   Align   Combine Class

FLAT . . . . . . . . . . . . . .        GROUP
_DATA  . . . . . . . . . . . . .        64 Bit   00000025 Para    Public  'DATA'
_TEXT  . . . . . . . . . . . . .        64 Bit   00002539 Para    Public  'CODE'


Procedures, parameters and locals:

                N a m e                 Type     Value    Segment  Length

AddLineQueue . . . . . . . . . .        P Near64 00000000 No Seg   *X *External FASTCALL
AddLineQueueX  . . . . . . . . .        P Near64 00000000 No Seg   *X *External FASTCALL
AddLinnumDataRef . . . . . . . .        P Near64 00000000 No Seg   *X *External FASTCALL
AddPredefinedText  . . . . . . .        P Near64 00000000 No Seg   *X *External FASTCALL
AddStringToIncludePath . . . . .        P Near64 00000000 No Seg   *X *External FASTCALL
AddTokens  . . . . . . . . . . .        P Near   00000FFF _TEXT    *X Private  FASTCALL
  tokenarray . . . . . . . . . .        Near              rbp + 0018
  start  . . . . . . . . . . . .        DWord             rbp + 0020
  count  . . . . . . . . . . . .        DWord             rbp + 0028
  _end . . . . . . . . . . . . .        DWord             rbp + 0030
  @C00C9 . . . . . . . . . . . .        L Near   0000107C _TEXT
  @C00C8 . . . . . . . . . . . .        L Near   000010B5 _TEXT
  @C00C3 . . . . . . . . . . . .        L Near   0000106F _TEXT
  @C00C7 . . . . . . . . . . . .        L Near   000010B5 _TEXT
  @C00C6 . . . . . . . . . . . .        L Near   0000106D _TEXT
  @C00C5 . . . . . . . . . . . .        L Near   00001064 _TEXT
  @C00C4 . . . . . . . . . . . .        L Near   00001033 _TEXT
  @C00CB . . . . . . . . . . . .        L Near   000010B5 _TEXT
  @C00CA . . . . . . . . . . . .        L Near   000010AD _TEXT
AlignInStruct  . . . . . . . . .        P Near64 00000000 No Seg   *X *External FASTCALL
AsmcKeywords . . . . . . . . . .        P Near64 00000000 No Seg   *X *External FASTCALL
AssembleModule . . . . . . . . .        P Near64 00000000 No Seg   *X *External FASTCALL
BackPatch  . . . . . . . . . . .        P Near64 00000000 No Seg   *X *External FASTCALL
ClearSrcStack  . . . . . . . . .        P Near64 00000000 No Seg   *X *External FASTCALL
CmdlineFini  . . . . . . . . . .        P Near64 00000000 No Seg   *X *External FASTCALL
CondCheckOpen  . . . . . . . . .        P Near64 00000000 No Seg   *X *External FASTCALL
CondInit . . . . . . . . . . . .        P Near64 00000000 No Seg   *X *External FASTCALL
CondPrepare  . . . . . . . . . .        P Near64 00000000 No Seg   *X *External FASTCALL
ConvertSectionName . . . . . . .        P Near64 00000000 No Seg   *X *External FASTCALL
CreateConstant . . . . . . . . .        P Near64 00000000 No Seg   *X *External FASTCALL
CreateFixup  . . . . . . . . . .        P Near64 00000000 No Seg   *X *External FASTCALL
CreateMacro  . . . . . . . . . .        P Near64 00000000 No Seg   *X *External FASTCALL
CreateStructField  . . . . . . .        P Near64 00000000 No Seg   *X *External FASTCALL
CreateType . . . . . . . . . . .        P Near64 00000000 No Seg   *X *External FASTCALL
CreateTypeSymbol . . . . . . . .        P Near64 00000000 No Seg   *X *External FASTCALL
CreateVariable . . . . . . . . .        P Near64 00000000 No Seg   *X *External FASTCALL
DelayExpand  . . . . . . . . . .        P Near64 00000000 No Seg   *X External  FASTCALL
DeleteLineQueue  . . . . . . . .        P Near64 00000000 No Seg   *X *External FASTCALL
EmitConstError . . . . . . . . .        P Near64 00000000 No Seg   *X *External FASTCALL
EndstructDirective . . . . . . .        P Near64 00000000 No Seg   *X *External FASTCALL
ErrnoStr . . . . . . . . . . . .        P Near64 00000000 No Seg   *X *External FASTCALL
EvalOperand  . . . . . . . . . .        P Near64 00000000 No Seg   *X External  FASTCALL
ExpandLine . . . . . . . . . . .        P Near   00001F0D _TEXT    *X Public   FASTCALL
  string . . . . . . . . . . . .        Near              rbp + 0028
  tokenarray . . . . . . . . . .        Near              rbp + 0030
  count  . . . . . . . . . . . .        DWord             rbp - 0004
  bracket_flags  . . . . . . . .        DWord             rbp - 0008
  flags  . . . . . . . . . . . .        DWord             rbp - 000C
  lvl  . . . . . . . . . . . . .        DWord             rbp - 0010
  rc . . . . . . . . . . . . . .        DWord             rbp - 0014
  addbrackets  . . . . . . . . .        DWord             rbp - 0018
  buffer . . . . . . . . . . . .        Near              rbp - 0020
  @C0198 . . . . . . . . . . . .        L Near   00002145 _TEXT
  @C0199 . . . . . . . . . . . .        L Near   0000213A _TEXT
  @C0194 . . . . . . . . . . . .        L Near   00002119 _TEXT
  @C0195 . . . . . . . . . . . .        L Near   00002145 _TEXT
  @C0196 . . . . . . . . . . . .        L Near   00002149 _TEXT
  @C0197 . . . . . . . . . . . .        L Near   00002131 _TEXT
  @C0190 . . . . . . . . . . . .        L Near   000021EA _TEXT
  @C0191 . . . . . . . . . . . .        L Near   00002084 _TEXT
  @C0192 . . . . . . . . . . . .        L Near   00002097 _TEXT
  @C0193 . . . . . . . . . . . .        L Near   000020DD _TEXT
  @C01C2 . . . . . . . . . . . .        L Near   000024B5 _TEXT
  @C01C3 . . . . . . . . . . . .        L Near   000024CD _TEXT
  @C01C0 . . . . . . . . . . . .        L Near   00002495 _TEXT
  @C01C1 . . . . . . . . . . . .        L Near   000024AF _TEXT
  @C01C6 . . . . . . . . . . . .        L Near   00002508 _TEXT
  @C01C7 . . . . . . . . . . . .        L Near   00002531 _TEXT
  @C01C4 . . . . . . . . . . . .        L Near   000024C6 _TEXT
  @C01C5 . . . . . . . . . . . .        L Near   000024BF _TEXT
  @C019D . . . . . . . . . . . .        L Near   000021AE _TEXT
  @C019E . . . . . . . . . . . .        L Near   000021B9 _TEXT
  @C019F . . . . . . . . . . . .        L Near   00002257 _TEXT
  @C019A . . . . . . . . . . . .        L Near   00002145 _TEXT
  @C019B . . . . . . . . . . . .        L Near   00002158 _TEXT
  @C019C . . . . . . . . . . . .        L Near   00002167 _TEXT
  @C01AD . . . . . . . . . . . .        L Near   00002508 _TEXT
  @C01AE  . . . . . . . . . . . . .        L Near   000023DE _TEXT
  @C01AF . . . . . . . . . . . .        L Near   000023C4 _TEXT
  @C01AA . . . . . . . . . . . .        L Near   00002397 _TEXT
  @C01AB . . . . . . . . . . . .        L Near   00002508 _TEXT
  @C01AC  . . . . . . . .        L Near   00002511 _TEXT
  @C0178 . . . . . . . . . . . .        L Near   00001F80 _TEXT
  @C0179 . . . . . . . . . . . .        L Near   00001F74 _TEXT
  @C0176 . . . . . . . . . . . .        L Near   00001F69 _TEXT
  @C0177 . . . . . . . . . . . .        L Near   00001F87 _TEXT
  @C0174 . . . . . . . . . . . .        L Near   00001FAC _TEXT
  @C0175 . . . . . . . . . . . .        L Near   00001F6F _TEXT
  @C0172 . . . . . . . . . . . .        L Near   0000251F _TEXT
  @C0173 . . . . . . . . . . . .        L Near   00001FAC _TEXT
  @C0170 . . . . . . . . . . . .        L Near   00001F41 _TEXT
  @C0171 . . . . . . . . . . . .        L Near   00002517 _TEXT
  @C01B9 . . . . . . . . . . . .        L Near   0000240F _TEXT
  @C01B8 . . . . . . . . . . . .        L Near   0000240C _TEXT
  @C01B5 . . . . . . . . . . . .        L Near   000023FF _TEXT
  @C018F . . . . . . . . . . . .        L Near   00002071 _TEXT
  @C01B4 . . . . . . . . . . . .        L Near   00002401 _TEXT
  @C018E . . . . . . . . . . . .        L Near   000021C2 _TEXT
  @C01B7 . . . . . . . . . . . .        L Near   0000242F _TEXT
  @C018D . . . . . . . . . . . .        L Near   000021EF _TEXT
  @C01B6 . . . . . . . . . . . .        L Near   000023ED _TEXT
  @C018C . . . . . . . . . . . .        L Near   000022D4 _TEXT
  @C01B1 . . . . . . . . . . . .        L Near   000023DC _TEXT
  @C018B . . . . . . . . . . . .        L Near   0000204D _TEXT
  @C01B0 . . . . . . . . . . . .        L Near   000023BB _TEXT
  @C018A . . . . . . . . . . . .        L Near   0000204D _TEXT
  @C01B3 . . . . . . . . . . . .        L Near   00002401 _TEXT
  @C01B2 . . . . . . . . . . . .        L Near   000023DC _TEXT
  @C017F . . . . . . . . . . . .        L Near   00002052 _TEXT
  @C017D . . . . . . . . . . . .        L Near   00001FA2 _TEXT
  @C017E . . . . . . . . . . . .        L Near   00001FAC _TEXT
  @C017B . . . . . . . . . . . .        L Near   00002534 _TEXT
  @C017C . . . . . . . . . . . .        L Near   00001FA2 _TEXT
  @C017A . . . . . . . . . . . .        L Near   00001F7A _TEXT
  @C01A4 . . . . . . . . . . . .        L Near   000022E8 _TEXT
  @C01A5 . . . . . . . . . . . .        L Near   0000232D _TEXT
  @C01A6 . . . . . . . . . . . .        L Near   0000233D _TEXT
  @C01A7 . . . . . . . . . . . .        L Near   00002369 _TEXT
  @C01A0 . . . . . . . . . . . .        L Near   000022D4 _TEXT
  @C01A1 . . . . . . . . . . . .        L Near   000022D4 _TEXT
  @C01A2 . . . . . . . . . . . .        L Near   000022D6 _TEXT
  @C01A3 . . . . . . . . . . . .        L Near   0000233D _TEXT
  @C01A8 . . . . . . . . . . . .        L Near   00002511 _TEXT
  @C01A9 . . . . . . . . . . . .        L Near   00002397 _TEXT
  @C0189 . . . . . . . . . . . .        L Near   00002030 _TEXT
  @C0188 . . . . . . . . . . . .        L Near   00002035 _TEXT
  @C0187 . . . . . . . . . . . .        L Near   0000203A _TEXT
  @C01BE . . . . . . . . . . . .        L Near   00002471 _TEXT
  @C0186 . . . . . . . . . . . .        L Near   0000202A _TEXT
  @C01BD . . . . . . . . . . . .        L Near   0000246B _TEXT
  @C0185 . . . . . . . . . . . .        L Near   00002028 _TEXT
  @C0184 . . . . . . . . . . . .        L Near   00001FE8 _TEXT
  @C01BF . . . . . . . . . . . .        L Near   00002482 _TEXT
  @C0183 . . . . . . . . . . . .        L Near   00001FF1 _TEXT
  @C01BA . . . . . . . . . . . .        L Near   000024E8 _TEXT
  @C0182 . . . . . . . . . . . .        L Near   0000203D _TEXT
  @C0181 . . . . . . . . . . . .        L Near   0000203D _TEXT
  @C01BC . . . . . . . . . . . .        L Near   00002459 _TEXT
  @C0180 . . . . . . . . . . . .        L Near   0000203F _TEXT
  @C01BB . . . . . . . . . . . .        L Near   000024E8 _TEXT
ExpandLineItems  . . . . . . . .        P Near   00001D44 _TEXT    *X Public   FASTCALL
  line . . . . . . . . . . . . .        Near              rbp + 0020
  i  . . . . . . . . . . . . . .        DWord             rbp + 0028
  tokenarray . . . . . . . . . .        Near              rbp + 0030
  addbrackets  . . . . . . . . .        DWord             rbp + 0038
  equmode  . . . . . . . . . . .        DWord             rbp + 0040
  k  . . . . . . . . . . . . . .        DWord             rbp - 0004
  buffer . . . . . . . . . . . .        Near              rbp - 0010
  @C0161 . . . . . . . . . . . .        L Near   00001DDD _TEXT
  @C0160 . . . . . . . . . . . .        L Near   00001D87 _TEXT
  @C0163 . . . . . . . . . . . .        L Near   00001DCD _TEXT
  @C0162 . . . . . . . . . . . .        L Near   00001DDF _TEXT
  @C0165  . . . . . . . . . . . . . .        L Near   00001E10 _TEXT
  @C0164 . . . . . . . . . . . .        L Near   00001DDD _TEXT
  @C0166 . . . . . . . . . . . .        L Near   00001E19 _TEXT
  @C015D . . . . . . . . . . . .        L Near   00001D7C _TEXT
  @C015E . . . . . . . . . . . .        L Near   00001E10 _TEXT
  @C015F . . . . . . . . . . . .        L Near   00001E17 _TEXT
ExpandLiterals . . . . . . . . .        P Near   00001E1D _TEXT    *X Public   FASTCALL
  i  . . . . . . . . . . . . . .        DWord             rbp + 0018
  tokenarray . . . . . . . . . .        Near              rbp + 0020
  @C016A . . . . . . . . . . . .        L Near   00001E5E _TEXT
  @C016C . . . . . . . . . . . .        L Near   00001E55 _TEXT
  @C016B . . . . . . . . . . . .        L Near   00001E5C _TEXT
  @C016E . . . . . . . . . . . .        L Near   00001E99 _TEXT
  @C016D . . . . . . . . . . . .        L Near   00001E99 _TEXT
  @C0167  . . . . . . . . . . . . . .        L Near   00001E36 _TEXT
  @C0169 . . . . . . . . . . . .        L Near   00001E62 _TEXT
  @C0168 . . . . . . . . . . . .        L Near   00001E5E _TEXT
ExpandProc . . . . . . . . . . .        P Near   00001E9C _TEXT    *X Private  FASTCALL
  string . . . . . . . . . . . .        Near              rbp + 0010
  buffer . . . . . . . . . . . .        Near              rbp + 0018
  @C016F . . . . . . . . . . . .        L Near   00001ED0 _TEXT
ExpandTMacro . . . . . . . . . .        P Near   000014BC _TEXT    *X Private  FASTCALL
  outbuf . . . . . . . . . . . .        Near              rbp + 0028
  tokenarray . . . . . . . . . .        Near              rbp + 0030
  equmode  . . . . . . . . . . .        DWord             rbp + 0038
  level  . . . . . . . . . . . .        DWord             rbp + 0040
  old_tokencount . . . . . . . .        DWord             rbp - 0004
  i  . . . . . . . . . . . . . .        DWord             rbp - 0008
  len  . . . . . . . . . . . . .        DWord             rbp - 000C
  is_exitm . . . . . . . . . . .        DWord             rbp - 0010
  sym  . . . . . . . . . . . . .        Near              rbp - 0018
  buffer . . . . . . . . . . . .        Near              rbp - 0020
  expanded . . . . . . . . . . .        Byte              rbp - 0021
  @C010F . . . . . . . . . . . .        L Near   000016B7 _TEXT
  @C010E . . . . . . . . . . . .        L Near   00001601 _TEXT
  @C010D . . . . . . . . . . . .        L Near   00001630 _TEXT
  @C010C . . . . . . . . . . . .        L Near   000016B7 _TEXT
  @C010B . . . . . . . . . . . .        L Near   000016BF _TEXT
  @C010A . . . . . . . . . . . .        L Near   000016B7 _TEXT
  @C0107 . . . . . . . . . . . .        L Near   0000151A _TEXT
  @C0106 . . . . . . . . . . . .        L Near   000016D4 _TEXT
  @C0105 . . . . . . . . . . . .        L Near   00001515 _TEXT
  @C0109 . . . . . . . . . . . .        L Near   00001543 _TEXT
  @C0108 . . . . . . . . . . . .        L Near   000016BF _TEXT
  @C0110 . . . . . . . . . . . .        L Near   000016B7 _TEXT
  @C0111 . . . . . . . . . . . .        L Near   00001691 _TEXT
ExpandText . . . . . . . . . . .        P Near   000010B8 _TEXT    *X Public   FASTCALL
  line . . . . . . . . . . . . .        Near              rbp + 0028
  tokenarray . . . . . . . . . .        Near              rbp + 0030
  substitute . . . . . . . . . .        DWord             rbp + 0038
  pIdent . . . . . . . . . . . .        Near              rbp - 0008
  lvl  . . . . . . . . . . . . .        DWord             rbp - 000C
  is_exitm . . . . . . . . . . .        DWord             rbp - 0010
  old_tokencount . . . . . . . .        DWord             rbp - 0014
  old_stringbufferend  . . . . .        Near              rbp - 0020
  rc . . . . . . . . . . . . . .        DWord             rbp - 0024
  sym  . . . . . . . . . . . . .        Near              rbp - 0030
  _sp  . . . . . . . . . . . . .        Near[20]          rbp - 00D0
  i  . . . . . . . . . . . . . .        DWord             rbp - 00D4
  cnt  . . . . . . . . . . . . .        DWord             rbp - 00D8
  quoted_string  . . . . . . . .        Byte              rbp - 00D9
  macro_proc . . . . . . . . . .        Byte              rbp - 00DA
  @C00D8 . . . . . . . . . . . .        L Near   0000124B _TEXT
  @C00D9 . . . . . . . . . . . .        L Near   000011CB _TEXT
  @C00D2 . . . . . . . . . . . .        L Near   0000115C _TEXT
  @C00D3 . . . . . . . . . . . .        L Near   00001150 _TEXT
  @C00D0 . . . . . . . . . . . .        L Near   00001425 _TEXT
  @C00D1 . . . . . . . . . . . .        L Near   000013FA _TEXT
  @C00D6 . . . . . . . . . . . .        L Near   00001173 _TEXT
  @C00D7 . . . . . . . . . . . .        L Near   000013F8 _TEXT
  @C00D4 . . . . . . . . . . . .        L Near   0000116F _TEXT
  @C00D5 . . . . . . . . . . . .        L Near   00001162 _TEXT
  @C0104 . . . . . . . . . . . .        L Near   000014A6 _TEXT
  @C0103 . . . . . . . . . . . .        L Near   0000148C _TEXT
  @C0102 . . . . . . . . . . . .        L Near   00001495 _TEXT
  @C0101 . . . . . . . . . . . .        L Near   000014B4 _TEXT
  @C0100 . . . . . . . . . . . .        L Near   00001486 _TEXT
  @C00CC . . . . . . . . . . . .        L Near   00001124 _TEXT
  @C00CF . . . . . . . . . . . .        L Near   0000113E _TEXT
  @C00CE . . . . . . . . . .        L Near   00001436 _TEXT
  @C00CD . . . . . . . . . . . .        L Near   0000142E _TEXT
  @C00DB . . . . . . . . . . . .        L Near   000011C2 _TEXT
  @C00DC . . . . . . . . . . . .        L Near   000011E5 _TEXT
  @C00DA . . . . . . . . . . . .        L Near   000011BC _TEXT
  @C00DF . . . . . . . . . . . .        L Near   000011F9 _TEXT
  @C00DD . . . . . . . . . . . .        L Near   000011DB _TEXT
  @C00DE . . . . . . . . . . . .        L Near   000011E3 _TEXT
  @C00FD . . . . . . . . . . . .        L Near   00001424 _TEXT
  @C00FE . . . . . . . . . . . .        L Near   0000145C _TEXT
  @C00FF . . . . . . . . . . . .        L Near   000014B4 _TEXT
  @C00E9 . . . . . . . . . . . .        L Near   000012C7 _TEXT
  @C00E8 . . . . . . . . . . . .        L Near   000012DE _TEXT
  @C00FA . . . . . . . . . . . .        L Near   00001400 _TEXT
  @C00FB . . . . . . . . . . . .        L Near   00001415 _TEXT
  @C00FC . . . . . . . . . . . .        L Near   00001424 _TEXT
  @C00E5 . . . . . . . . . . . .        L Near   000013D7 _TEXT
  @C00E4 . . . . . . . . . . . .        L Near   00001267 _TEXT
  @C00E7 . . . . . . . . . . . .        L Near   000012D6 _TEXT
  @C00E6 . . . . . . . .        L Near   000012B6 _TEXT
  @C00E1 . . . . . . . . . . . .        L Near   000013E6 _TEXT
  @C00E0 . . . . . . . . . . . .        L Near   000011F9 _TEXT
  @C00E3 . . . . . . . . . . . .        L Near   00001264 _TEXT
  @C00E2 . . . . . . . . . . . .        L Near   000013D9 _TEXT
  @C00F4 . . . . . . . . . . . .        L Near   000013E6 _TEXT
  @C00F5 . . . . . . . . . . . .        L Near   000013F8 _TEXT
  @C00F6 . . . . . . . . . . . .        L Near   0000142E _TEXT
  @C00F7 . . . . . . . . . . . .        L Near   00001425 _TEXT
  @C00F0 . . . . . . . . . . . .        L Near   00001326 _TEXT
  @C00F1 . . . . . . . . . . . .        L Near   00001326 _TEXT
  @C00F2 . . . . . . . . . . . .        L Near   000014B7 _TEXT
  @C00F3 . . . . . . . . . . . .        L Near   0000138A _TEXT
  @C00EE . . . . . . . . . . . .        L Near   00001316 _TEXT
  @C00ED . . . . . . . . . . . .        L Near   00001304 _TEXT
  @C00EF . . . . . . . . . . . .        L Near   00001314 _TEXT
  @C00EA . . . . . . . . . . . .        L Near   000012D6 _TEXT
  @C00F8 . . . . . . . . . . . .        L Near   00001424 _TEXT
  @C00F9 . . . . . . . . . . . .        L Near   00001404 _TEXT
  @C00EC . . . . . . . . . . . .        L Near   000012D6 _TEXT
  @C00EB . . . . . . . . . . . .        L Near   000012D6 _TEXT
ExpandToken  . . . . . . . . . .        P Near   00001812 _TEXT    *X Private  FASTCALL
  line . . . . . . . . . . . . .        Near              rbp + 0028
  pi . . . . . . . . . . . . . .        Near              rbp + 0030
  tokenarray . . . . . . . . . .        Near              rbp + 0038
  max  . . . . . . . . . . . . .        DWord             rbp + 0040
  bracket_flags  . . . . . . . .        DWord             rbp + 0048
  equmode  . . . . . . . . . . .        DWord             rbp + 0050
  buffer . . . . . . . . . . . .        Near              rbp + 0058
  pos  . . . . . . . . . . . . .        DWord             rbp - 0004
  i2 . . . . . . . . . . . . . .        DWord             rbp - 0008
  i  . . . . . . . . . . . . . .        DWord             rbp - 000C
  size . . . . . . . . . . . . .        DWord             rbp - 0010
  addbrackets  . . . . . . . . .        DWord             rbp - 0014
  evaluate . . . . . . . . . . .        Byte              rbp - 0015
  is_exitm . . . . . . . . . . .        DWord             rbp - 001C
  opndx  . . . . . . . . . . . .        expr              rbp - 0080
  rc . . . . . . . . . . . . . .        DWord             rbp - 0084
  old_tokencount . . . . . . . .        DWord             rbp - 0088
  @C0149 . . . . . . . . . . . .        L Near   00001B3C _TEXT
  @C0148 . . . . . . . . . . . .        L Near   00001BAC _TEXT
  @C0143 . . . . . . . . . . . .        L Near   00001A54 _TEXT
  @C0142 . . . . . . . . . . . .        L Near   00001A42 _TEXT
  @C0141 . . . . . . . . . . . .        L Near   00001A3C _TEXT
  @C0147 . . . . . . . . . . . .        L Near   00001BAC _TEXT
  @C0146 . . . . . . . . . . . .        L Near   00001AA7 _TEXT
  @C0145 . . . . . . . . . . . .        L Near   00001A7F _TEXT
  @C0144 . . . . . . . . . . . .        L Near   00001A72 _TEXT
  @C014C . . . . . . . . . . . .        L Near   00001B08 _TEXT
  @C014B . . . . . . . . . . . .        L Near   00001ADB _TEXT
  @C014A . . . . . . . . . . . .        L Near   00001AD4 _TEXT
  @C014F . . . . . . . . . . . .        L Near   00001B08 _TEXT
  @C014E . . . . . . . . . . . .        L Near   00001B00 _TEXT
  @C014D . . . . . . . . . . . .        L Near   00001AE8 _TEXT
  @C013B . . . . . . . . . . . .        L Near   000019DE _TEXT
  @C013C  . . . . . . . . . . .        L Near   00001AB3 _TEXT
  @C013A . . . . . . . .        L Near   0000198C _TEXT
  @C013F . . . . . . . . . . . .        L Near   00001A31 _TEXT
  @C013D . . . . . . . . . . . .        L Near   00001A4F _TEXT
  @C013E . . . . . . . . . . . .        L Near   00001A4D _TEXT
  @C0158 . . . . . . . . . . . .        L Near   00001BF2 _TEXT
  @C0159 . . . . . . . . . . . .        L Near   00001C87 _TEXT
  @C0129 . . . . . . . . . . . .        L Near   00001851 _TEXT
  @C0150 . . . . . . . . . . . .        L Near   00001AF9 _TEXT
  @C0151 . . . . . . . . . . . .        L Near   00001B00 _TEXT
  @C0152 . . . . . . . . . . . .        L Near   00001B00 _TEXT
  @C0153 . . . . . . . . . . . .        L Near   00001B3C _TEXT
  @C0154 . . . . . . . . . . . .        L Near   00001B3C _TEXT
  @C0155 . . . . . . . . . . . .        L Near   00001B67 _TEXT
  @C0156 . . . . . . . . . . . .        L Near   00001BA2 _TEXT
  @C0157 . . . . . . . . . . . .        L Near   00001D39 _TEXT
  @C0138 . . . . . . . . . . . .        L Near   00001931 _TEXT
  @C0139 . . . . . . . . . . . .        L Near   00001D3F _TEXT
  @C0132 . . . . . . . . . . . .        L Near   000018F6 _TEXT
  @C0133 . . . . . . . . . . . .        L Near   00001910 _TEXT
  @C0130 . . . . . . . . . . . .        L Near   00001A26 _TEXT
  @C0131 . . . . . . . . . . . .        L Near   00001925 _TEXT
  @C0136 . . . . . . . . . . . .        L Near   00001910 _TEXT
  @C0137 . . . . . . . . . . . .        L Near   00001910 _TEXT
  @C0134 . . . . . . . . . . . .        L Near   00001919 _TEXT
  @C0135 . . . . . . . . . . . .        L Near   00001907 _TEXT
  @C012E . . . . . . . . . . . .        L Near   00001BAC _TEXT
  @C012D . . . . . . . . . . . .        L Near   00001BAC _TEXT
  @C015A . . . . . . . . . . . .        L Near   00001C64 _TEXT
  @C015B . . . . . . . . . . . .        L Near   00001C7B _TEXT
  @C012F . . . . . . . . . . . .        L Near   00001AB8 _TEXT
  @C015C . . . . . . . . . . . .        L Near   00001C7B _TEXT
  @C012A . . . . . . . . . . . .        L Near   00001BAC _TEXT
  @C012C . . . . . . . . . . . .        L Near   0000189C _TEXT
  @C012B . . . . . . . . . . . .        L Near   00001BB4 _TEXT
ExprEvalInit . . . . . . . . . .        P Near64 00000000 No Seg   *X *External FASTCALL
FillDataBytes  . . . . . . . . .        P Near64 00000000 No Seg   *X *External FASTCALL
FreeFixup  . . . . . . . . . . .        P Near64 00000000 No Seg   *X *External FASTCALL
GetAlignedPointer  . . . . . . .        P Near64 00000000 No Seg   *X *External WATCALL
GetExtPart . . . . . . . . . . .        P Near64 00000000 No Seg   *X *External FASTCALL
GetFName . . . . . . . . . . . .        P Near64 00000000 No Seg   *X *External FASTCALL
GetFNamePart . . . . . . . . . .        P Near64 00000000 No Seg   *X *External FASTCALL
GetIfNestLevel . . . . . . . . .        P Near64 00000000 No Seg   *X External  FASTCALL
GetLangType  . . . . . . . . . .        P Near64 00000000 No Seg   *X *External FASTCALL
GetLineNumber  . . . . . . . . .        P Near64 00000000 No Seg   *X *External FASTCALL
GetLiteralValue  . . . . . . . .        P Near64 00000000 No Seg   *X *External FASTCALL
GetProcessHeap . . . . . . . . .        P Near64 00000000 No Seg   *X *External FASTCALL
GetQualifiedType . . . . . . . .        P Near64 00000000 No Seg   *X *External FASTCALL
GetTextLine  . . . . . . . . . .        P Near64 00000000 No Seg   *X External  FASTCALL
GetToken . . . . . . . . . . . .        P Near64 00000000 No Seg   *X *External FASTCALL
GetType  . . . . . . . . . . . .        P Near64 00000000 No Seg   *X *External FASTCALL
GlobalAlloc  . . . . . . . . . .        P Near64 00000000 No Seg   *X *External FASTCALL
GlobalFree . . . . . . . . . . .        P Near64 00000000 No Seg   *X *External FASTCALL
GlobalLock . . . . . . . . . . .        P Near64 00000000 No Seg   *X *External FASTCALL
GlobalUnlock . . . . . . . . . .        P Near64 00000000 No Seg   *X *External FASTCALL
HeapAlloc  . . . . . . . . . . .        P Near64 00000000 No Seg   *X *External FASTCALL
HeapFree . . . . . . . . . . . .        P Near64 00000000 No Seg   *X *External FASTCALL
IS_SIGNED  . . . . . . . . . . .        P Near64 00000000 No Seg   *X *External WATCALL
IndexFromToken_dword . . . . . .        P Near64 00000000 No Seg   *X *External WATCALL
InputExtend  . . . . . . . . . .        P Near64 00000000 No Seg   *X *External FASTCALL
InputFini  . . . . . . . . . . .        P Near64 00000000 No Seg   *X *External FASTCALL
InputInit  . . . . . . . . . . .        P Near64 00000000 No Seg   *X *External FASTCALL
InputPassInit  . . . . . . . . .        P Near64 00000000 No Seg   *X *External FASTCALL
InsertLineQueue  . . . . . . . .        P Near64 00000000 No Seg   *X *External FASTCALL
LclAlloc . . . . . . . . . . . .        P Near64 00000000 No Seg   *X *External FASTCALL
LclDup . . . . . . . . . . . . .        P Near64 00000000 No Seg   *X *External FASTCALL
LstInit  . . . . . . . . . . . .        P Near64 00000000 No Seg   *X *External FASTCALL
LstNL  . . . . . . . . . . . . .        P Near64 00000000 No Seg   *X *External FASTCALL
LstPrintf  . . . . . . . . . . .        P Near64 00000000 No Seg   *X *External FASTCALL
LstSetPosition . . . . . . . . .        P Near64 00000000 No Seg   *X *External FASTCALL
LstWrite . . . . . . . . . . . .        P Near64 00000000 No Seg   *X *External FASTCALL
LstWriteCRef . . . . . . . . . .        P Near64 00000000 No Seg   *X *External FASTCALL
LstWriteSrcLine  . . . . . . . .        P Near64 00000000 No Seg   *X External  FASTCALL
MacroInit  . . . . . . . . . . .        P Near64 00000000 No Seg   *X *External FASTCALL
MacroLineQueue . . . . . . . . .        P Near64 00000000 No Seg   *X *External FASTCALL
MemAlloc . . . . . . . . . . . .        P Near64 00000000 No Seg   *X *External FASTCALL
MemDup . . . . . . . . . . . . .        P Near64 00000000 No Seg   *X *External FASTCALL
MemFini  . . . . . . . . . . . .        P Near64 00000000 No Seg   *X *External FASTCALL
MemFree  . . . . . . . . . . . .        P Near64 00000000 No Seg   *X *External FASTCALL
MemInit  . . . . . . . . . . . .        P Near64 00000000 No Seg   *X *External FASTCALL
MemtypeFromSize  . . . . . . . .        P Near64 00000000 No Seg   *X *External FASTCALL
NameSpace  . . . . . . . . . . .        P Near64 00000000 No Seg   *X *External WATCALL
NameSpaceDirective . . . . . . .        P Near64 00000000 No Seg   *X *External FASTCALL
OperandSize  . . . . . . . . . .        P Near64 00000000 No Seg   *X *External FASTCALL
OutputByte . . . . . . . . . . .        P Near64 00000000 No Seg   *X *External FASTCALL
OutputBytes  . . . . . . . . . .        P Near64 00000000 No Seg   *X *External FASTCALL
ParseCmdline . . . . . . . . . .        P Near64 00000000 No Seg   *X *External FASTCALL
ParseLine  . . . . . . . . . . .        P Near64 00000000 No Seg   *X External  FASTCALL
PopInputStatus . . . . . . . . .        P Near64 00000000 No Seg   *X External  FASTCALL
PreprocessLine . . . . . . . . .        P Near64 00000000 No Seg   *X External  FASTCALL
PrintNote  . . . . . . . . . . .        P Near64 00000000 No Seg   *X *External FASTCALL
ProcessFile  . . . . . . . . . .        P Near64 00000000 No Seg   *X *External FASTCALL
PushInputStatus  . . . . . . . .        P Near64 00000000 No Seg   *X External  FASTCALL
PushMacro  . . . . . . . . . . .        P Near64 00000000 No Seg   *X External  FASTCALL
QAddItem . . . . . . . . . . . .        P Near64 00000000 No Seg   *X *External FASTCALL
QEnqueue . . . . . . . . . . . .        P Near64 00000000 No Seg   *X *External FASTCALL
RebuildLine  . . . . . . . . . .        P Near   000016D9 _TEXT    *X Private  FASTCALL
  newstring  . . . . . . . . . .        Near              rbp + 0028
  i  . . . . . . . . . . . . . .        DWord             rbp + 0030
  tokenarray . . . . . . . . . .        Near              rbp + 0038
  oldlen . . . . . . . . . . . .        DWord             rbp + 0040
  pos_line . . . . . . . . . . .        DWord             rbp + 0048
  addbrackets  . . . . . . . . .        DWord             rbp + 0050
  dest . . . . . . . . . . . . .        Near              rbp - 0008
  src  . . . . . . . . . . . . .        Near              rbp - 0010
  newlen . . . . . . . . . . . .        DWord             rbp - 0014
  rest . . . . . . . . . . . . .        DWord             rbp - 0018
  buffer . . . . . . . . . . . .        Near              rbp - 0020
  @C011D . . . . . . . . . . . .        L Near   000017D2 _TEXT
  @C011E . . . . . . . . . . . .        L Near   000017A7 _TEXT
  @C011F . . . . . . . . . . . .        L Near   000017C5 _TEXT
  @C011A . . . . . . . . . . . .        L Near   00001797 _TEXT
  @C0128 . . . . . . . . . . . .        L Near   0000180B _TEXT
  @C011B . . . . . . . . . . . .        L Near   00001797 _TEXT
  @C011C . . . . . . . . . . . .        L Near   0000180D _TEXT
  @C0125 . . . . . . . . . . . .        L Near   000017DB _TEXT
  @C0124 . . . . . . . . . . . .        L Near   000017B6 _TEXT
  @C0127 . . . . . . . . . . . .        L Near   00001803 _TEXT
  @C0126 . . . . . . . . . . . .        L Near   000017F3 _TEXT
  @C0121 . . . . . . . . . . . .        L Near   000017C0 _TEXT
  @C0120 . . . . . . . . . . . .        L Near   000017CA _TEXT
  @C0123 . . . . . . . . . . . .        L Near   000017B2 _TEXT
  @C0122 . . . . . . . . . . . .        L Near   000017BA _TEXT
  @C0114 . . . . . . . . . . . .        L Near   00001768 _TEXT
  @C0115 . . . . . . . . . . . .        L Near   0000176F _TEXT
  @C0116 . . . . . . . . . . . .        L Near   00001768 _TEXT
  @C0117 . . . . . . . . . . . .        L Near   00001765 _TEXT
  @C0112 . . . . . . . . . . . .        L Near   0000176F _TEXT
  @C0113 . . . . . . . . . . . .        L Near   00001755 _TEXT
  @C0118 . . . . . . . . . . . .        L Near   0000175D _TEXT
  @C0119 . . . . . . . . . . . .        L Near   00001761 _TEXT
ReleaseMacroData . . . . . . . .        P Near64 00000000 No Seg   *X *External FASTCALL
RetLineQueue . . . . . . . . . .        P Near64 00000000 No Seg   *X *External FASTCALL
RunLineQueue . . . . . . . . . .        P Near64 00000000 No Seg   *X *External FASTCALL
RunMacro . . . . . . . . . . . .        P Near   000000CC _TEXT    *X Public   FASTCALL
  mac  . . . . . . . . . . . . .        Near              rbp + 0028
  idx  . . . . . . . . . . . . .        DWord             rbp + 0030
  tokenarray . . . . . . . . . .        Near              rbp + 0038
  _out . . . . . . . . . . . . .        Near              rbp + 0040
  mflags . . . . . . . . . . . .        DWord             rbp + 0048
  is_exitm . . . . . . . . . . .        Near              rbp + 0050
  currparm . . . . . . . . . . .        Near              rbp - 0008
  savedStringBuffer  . . . . . .        Near              rbp - 0010
  i  . . . . . . . . . . . . . .        DWord             rbp - 0014
  _retm  . . . . . . . . . . . .        DWord             rbp - 0018
  parmidx  . . . . . . . . . . .        DWord             rbp - 001C
  skipcomma  . . . . . . . . . .        DWord             rbp - 0020
  varargcnt  . . . . . . . . . .        DWord             rbp - 0024
  bracket_level  . . . . . . . .        DWord             rbp - 0028
  parm_end_delim . . . . . . . .        DWord             rbp - 002C
  p  . . . . . . . . . . . . . .        Near              rbp - 0038
  parmstrings  . . . . . . . . .        Near              rbp - 0040
  info . . . . . . . . . . . . .        Near              rbp - 0048
  lnode  . . . . . . . . . . . .        Near              rbp - 0050
  sym  . . . . . . . . . . . . .        Near              rbp - 0058
  opndx  . . . . . . . . . . . .        expr              rbp - 00C0
  mi . . . . . . . . . . . . . .        macro_instance    rbp - 00E8
  oldstat  . . . . . . . . . . .        input_status      rbp - 0108
  oldifnesting . . . . . . . . .        DWord             rbp - 010C
  cntgoto  . . . . . . . . . . .        DWord             rbp - 0110
  inside_literal . . . . . . . .        DWord             rbp - 0114
  inside_angle_brackets  . . . .        DWord             rbp - 0118
  old_tokencount . . . . . . . .        DWord             rbp - 011C
  max  . . . . . . . . . . . . .        DWord             rbp - 0120
  cnt  . . . . . . . . . . . . .        DWord             rbp - 0124
  cnt_opnum  . . . . . . . . . .        DWord             rbp - 0128
  is_exitm2  . . . . . . . . . .        DWord             rbp - 012C
  len  . . . . . . . . . . . . .        DWord             rbp - 0130
  cvt  . . . . . . . . . . . . .        FLTINFO           rbp - 0160
  @C0028 . . . . . . . . . . . .        L Near   00000305 _TEXT
  @C00AA . . . . . . . . . . . .        L Near   00000E1A _TEXT
  @C0029 . . . . . . . . . . . .        L Near   0000031C _TEXT
  @C00AC . . . . . . . . . . . .        L Near   00000E31 _TEXT
  @C00AB . . . . . . . . . . . .        L Near   00000E51 _TEXT
  @C0059 . . . . . . . . . . . .        L Near   0000076B _TEXT
  @C00AE . . . . . . . . . . . .        L Near   00000E20 _TEXT
  @C0058 . . . . . . . . . . . .        L Near   00000639 _TEXT
  @C00AD . . . . . . . . . . . .        L Near   00000E24 _TEXT
  @C00AF . . . . . . . . . . . .        L Near   00000E46 _TEXT
  @C0055 . . . . . . . . . . . .        L Near   000005F9 _TEXT
  @C0020 . . . . . . . . . . . .        L Near   00000BB7 _TEXT
  @C0021 . . . . . . . . . . .        L Near   000002C0 _TEXT
  @C0054 . . . . . . . . . . .        L Near   000005F9 _TEXT
  @C00C2 . . . . . . . . . . .        L Near   00000FF7 _TEXT
  @C0022 . . . . . . . . . . . .        L Near   00000321 _TEXT
  @C0057 . . . . . . . . . . . .        L Near   000005D5 _TEXT
  @C00C1 . . . . . . . . . . . .        L Near   00000FC7 _TEXT
  @C0023 . . . . . . . . . . . .        L Near   000002E5 _TEXT
  @C0056 . . . . . . . . . . . .        L Near   000005DB _TEXT
  @C00C0 . . . . . . . . . . . .        L Near   00000F9E _TEXT
  @C0024 . . . . . . . . . . . .        L Near   000002CE _TEXT
  @C0051 . . . . . . . . . . . .        L Near   00000545 _TEXT
  @C0025 . . . . . . . .        L Near   000002D5 _TEXT
  @C0050 . . . . . . . .        L Near   00000504 _TEXT
  @C0053 . . . . . . . . . . . .        L Near   000005C3 _TEXT
  @C0027 . . . . . . . . . . . .        L Near   000002E0 _TEXT
  @C0052 . . . . . . . . . . . .        L Near   0000079E _TEXT
  @C0077 . . . . . . . . . . . .        L Near   00000A71 _TEXT
  @C0076 . . . . . . . . . . . .        L Near   00000A87 _TEXT
  @C0075 . . . . . . . . . . . .        L Near   00000A50 _TEXT
  @C0074  . . . . . .        L Near   00000A52 _TEXT
  @C0073 . . . . . . . . . . . .        L Near   00000A52 _TEXT
  @C0072 . . . . . . . . . . . .        L Near   00000A52 _TEXT
  @C0071 . . . . . . . . . . . .        L Near   000009C0 _TEXT
  @C0070 . . . . . . . . . . . .        L Near   00000989 _TEXT
  @C0079 . . . . . . . . . . . .        L Near   00000A77 _TEXT
  @C0078 . . . . . . . . . . . .        L Near   00000A69 _TEXT
  @C000F . . . . . . . . . . . .        L Near   00000175 _TEXT
  @C009A . . . . . . . . . . . .        L Near   00000D6E _TEXT
  @C009C . . . . . . . . . . . .        L Near   00000D69 _TEXT
  @C000D . . . . . . . . . . . .        L Near   00000FFA _TEXT
  @C000E . . . . . . . . . . . .        L Near   00000128 _TEXT
  @C009B . . . . . . . . . . . .        L Near   00000D55 _TEXT
  @C009E . . . . . . . . . . . .        L Near   00000FA9 _TEXT
  @C000C . . . . . . . . . . . .        L Near   00000109 _TEXT
  @C009D . . . . . . . . . . . .        L Near   00000D69 _TEXT
  @C009F . . . . . . . . . . . .        L Near   00000E94 _TEXT
  @C00A1 . . . . . . . . . . . .        L Near   00000D80 _TEXT
  @C00A0 . . . . . . . . . . . .        L Near   00000D8D _TEXT
  @C00A3  . . . . . . . . . . . .        L Near   00000E51 _TEXT
  @C00A2 . . . . . . . . . . . .        L Near   00000DA4 _TEXT
  @C00A5 . . . . . . . . . . . .        L Near   00000DBA _TEXT
  @C00A4 . . . . . . . . . . . .        L Near   00000DC8 _TEXT
  @C00A7  . . . . . . . . . . . . .        L Near   00000E51 _TEXT
  @C00A6 . . . . . . . . . . . .        L Near   00000DB4 _TEXT
  @C005E . . . . . . . . . . . .        L Near   000006F4 _TEXT
  @C00A9 . . . . . . . . . . . .        L Near   00000E51 _TEXT
  @C005D . . . . . . . . . . . .        L Near   000006A9 _TEXT
  @C002A . . . . . . . . . . . .        L Near   00000BAF _TEXT
  @C00A8 . . . . . . . . . . . .        L Near   00000DE1 _TEXT
  @C002B . . . . . . . . . . . .        L Near   0000034C _TEXT
  @C005F . . . . . . . . . . . .        L Near   00000727 _TEXT
  @C002C . . . . . . . . . . . .        L Near   00000AB9 _TEXT
  @C005A . . . . . . . . . . . .        L Near   0000076B _TEXT
  @C002D . . . . . . . . . . . .        L Near   00000AC1 _TEXT
  @C002E . . . . . . . . . . . .        L Near   0000036B _TEXT
  @C002F . . . . . . . . . . . .        L Near   0000035E _TEXT
  @C005C . . . . . . . . . . . .        L Near   0000076B _TEXT
  @C005B . . . . . . . . . . . .        L Near   0000067A _TEXT
  @C0099 . . . . . . . . . . . .        L Near   00000FC7 _TEXT
  @C0098 . . . . . . . . . . . .        L Near   00000D24 _TEXT
  @C0091 . . . . . . . . . . . .        L Near   00000C47 _TEXT
  @C0090 . . . . . . . . . . . . .        L Near   00000C1E _TEXT
  @C0093  . . . . . . . . . . . . .        L Near   00000C47 _TEXT
  @C0092 . . . . . . . . . . . .        L Near   00000C47 _TEXT
  @C0095 . . . . . . . . . . . .        L Near   00000FF7 _TEXT
  @C0094 . . . . . . . . . . . .        L Near   00000C81 _TEXT
  @C0097 . . . . . . . . . . . .        L Near   00000CF1 _TEXT
  @C0096  . . . . . . . . . . . . . .        L Near   00000CD8 _TEXT
  @C007F . . . . . . . . . . . .        L Near   00000AAA _TEXT
  @C007E . . . . . . . . . . . .        L Near   00000AAD _TEXT
  @C007D . . . . . . . . . . . .        L Near   00000AAB _TEXT
  @C007C . . . . . . . . . . . .        L Near   00000A9D _TEXT
  @C007B . . . . . . . . . . . .        L Near   00000AB3 _TEXT
  @C007A  . . . . . . . . . . . . . .        L Near   00000A7A _TEXT
  @C001A . . . . . . . . . . . .        L Near   000001F3 _TEXT
  @C00B8 . . . . . . . . . . . .        L Near   00000F57 _TEXT
  @C00B9 . . . . . . . . . . . .        L Near   00000F4C _TEXT
  @C001C  . . . . . . . . . . . . .        L Near   0000024C _TEXT
  @C0048  . . . . . . . . . . . . .        L Near   000004A1 _TEXT
  @C001B  . . . . . . . . .        L Near   00000264 _TEXT
  @C0049  . . . . . . . . .        L Near   000004B5 _TEXT
  @C001E . . . . . . . . . . . .        L Near   00000292 _TEXT
  @C001D . . . . . . . . . . . .        L Near   00000261 _TEXT
  @C001F . . . . . . . . . . . .        L Near   00000BAF _TEXT
  @C0042  . . . . . . . .        L Near   00000480 _TEXT
  @C00B0  . . . . . . . .        L Near   00000E49 _TEXT
  @C0043 . . . . . . . . . . . .        L Near   00000489 _TEXT
  @C00B1 . . . . . . . . . . . .        L Near   00000E77 _TEXT
  @C0040 . . . . . . . . . . . .        L Near   0000048C _TEXT
  @C00B2 . . . . . . . . . . . .        L Near   00000FDC _TEXT
  @C0041 . . . . . . . .        L Near   00000467 _TEXT
  @C00B3 . . . . . . . .        L Near   00000FA9 _TEXT
  @C0046 . . . . . . . . . . . .        L Near   00000480 _TEXT
  @C00B4 . . . . . . . . . . . .        L Near   00000FA9 _TEXT
  @C0047 . . . . . . . . . . . .        L Near   000004B5 _TEXT
  @C00B5 . . . . . . . . . . . .        L Near   00000F90 _TEXT
  @C0044 . . . . . . . . . . . .        L Near   00000479 _TEXT
  @C00B6 . . . . . . . . . . . .        L Near   00000EC8 _TEXT
  @C0045 . . . . . . . . . . . .        L Near   00000480 _TEXT
  @C00B7 . . . . . . . . . . . .        L Near   00000F4C _TEXT
  @C008F . . . . . . . . . . . .        L Near   00000C04 _TEXT
  @C008D . . . . . . . . . . . .        L Near   00000BD8 _TEXT
  @C008E . . . . . . . . . . . .        L Near   00000BE1 _TEXT
  @C008B . . . . . . . . . . . .        L Near   00000C1E _TEXT
  @C008C . . . . . . . . . . . .        L Near   00000BC8 _TEXT
  @C008A . . . . . . . . . . . .        L Near   00000C27 _TEXT
  @C003C . . . . . . . . . . . .        L Near   000004DD _TEXT
  @C003B . . . . . . . . . . . .        L Near   000004D5 _TEXT
  @C003A  . . . . . . . . . . . .        L Near   0000041C _TEXT
  @C003F . . . . . . . . . . . .        L Near   0000044C _TEXT
  @C003E . . . . . . . . . . . .        L Near   00000454 _TEXT
  @C003D . . . . . . . . . . . .        L Near   0000048E _TEXT
  @C0064 . . . . . . . . . . . .        L Near   0000080B _TEXT
  @C0065  . . . . . . . . . .        L Near   00000A52 _TEXT
  @C0066 . . . . . . . . . . . .        L Near   00000836 _TEXT
  @C0067 . . . . . . . . . . . .        L Near   00000828 _TEXT
  @C0060 . . . . . . . . . . . .        L Near   00000713 _TEXT
  @C0061 . . . . . . . . . . . .        L Near   0000075C _TEXT
  @C0062 . . . . . . . . . . . .        L Near   0000076B _TEXT
  @C0063 . . . . . . . . . . . .        L Near   0000078E _TEXT
  @C0068 . . . . . . . . . . . .        L Near   00000836 _TEXT
  @C0069 . . . . . . . . . . . .        L Near   00000836 _TEXT
  @C0011 . . . . . . . . . . . .        L Near   000001BA _TEXT
  @C0010 . . . . . . . . . . . .        L Near   0000016E _TEXT
  @C0013 . . . . . . . . . . . .        L Near   00000181 _TEXT
  @C0012 . . . . . . . . . . . .        L Near   000001A9 _TEXT
  @C0015 . . . . . . . . . . . .        L Near   000001A7 _TEXT
  @C0014 . . . . . . . . . . . .        L Near   0000019E _TEXT
  @C0017 . . . . . . . . . . . .        L Near   0000019E _TEXT
  @C0016  . . . . . . . . . . .        L Near   00000196 _TEXT
  @C0019 . . . . . . . . . . . .        L Near   000001B2 _TEXT
  @C004B . . . . . . . . . . . .        L Near   000004C0 _TEXT
  @C0018 . . . . . . . . . . . .        L Near   0000019E _TEXT
  @C004C . . . . . . . . . . . .        L Near   000004BA _TEXT
  @C00BA . . . . . . . . . . . .        L Near   00000F10 _TEXT
  @C00BB . . . . . . . . . . . .        L Near   00000F15 _TEXT
  @C004A . . . . . . . . . . . .        L Near   000004B5 _TEXT
  @C00BC . . . . . . . . . . . .        L Near   00000F18 _TEXT
  @C004F . . . . . . . . . . . .        L Near   00000502 _TEXT
  @C00BD . . . . . . . . . . . .        L Near   00000F4C _TEXT
  @C00BE . . . . . . . . . . . .        L Near   00000F6C _TEXT
  @C004D . . . . . . . . . . . .        L Near   000004D5 _TEXT
  @C00BF . . . . . . . . . . . .        L Near   00000F8E _TEXT
  @C004E . . . . . . . . . . . .        L Near   000004ED _TEXT
  @C006D . . . . . . . . . . . .        L Near   00000A52 _TEXT
  @C006E . . . . . . . . . . . .        L Near   00000A52 _TEXT
  @C006F . . . . . . . . . . . .        L Near   000009D1 _TEXT
  @C006A . . . . . . . . . . . .        L Near   000008FB _TEXT
  @C006B . . . . . . . . . . . .        L Near   00000878 _TEXT
  @C006C . . . . . . . . . . . .        L Near   0000087A _TEXT
  @C0086 . . . . . . . . . . . .        L Near   00000B45 _TEXT
  @C0087 . . . . . . . . .        L Near   00000B5F _TEXT
  @C0039 . . . . . . . . . . . .        L Near   000003F6 _TEXT
  @C0084 . . . . . . . . . . . .        L Near   00000B62 _TEXT
  @C0038 . . . . . . . . . . . .        L Near   00000408 _TEXT
  @C0085 . . . . . . . . . . . .        L Near   00000B4C _TEXT
  @C0082 . . . . . . . . . . . .        L Near   00000B2C _TEXT
  @C0083 . . . . . . . . . . . .        L Near   00000B69 _TEXT
  @C0080 . . . . . . . . . . . .        L Near   00000B6E _TEXT
  @C0081 . . . . . . . . . . . .        L Near   00000B0F _TEXT
  @C0033 . . . . . . . . . . . .        L Near   000007B0 _TEXT
  @C0032 . . . . . . . . . . . .        L Near   000003A0 _TEXT
  @C0031 . . . . . . . . . . . .        L Near   00000395 _TEXT
  @C0030 . . . . . . . . . . . .        L Near   000003A5 _TEXT
  @C0037 . . . . . . . . . . . .        L Near   00000412 _TEXT
  @C0036 . . . . . . . . . . . .        L Near   00000412 _TEXT
  @C0035 . . . . . . . . . . . .        L Near   000003BE _TEXT
  @C0088 . . . . . . . . . . . .        L Near   00000BAF _TEXT
  @C0034 . . . . . . . . . . . .        L Near   000003B7 _TEXT
  @C0089 . . . . . . . . . . . .        L Near   00000B9A _TEXT
SearchFile . . . . . . . . . . .        P Near64 00000000 No Seg   *X *External FASTCALL
SearchNameInStruct . . . . . . .        P Near64 00000000 No Seg   *X *External FASTCALL
SetCPU . . . . . . . . . . . . .        P Near64 00000000 No Seg   *X *External FASTCALL
SetFixupFrame  . . . . . . . . .        P Near64 00000000 No Seg   *X *External FASTCALL
SetIfNestLevel . . . . . . . . .        P Near64 00000000 No Seg   *X External  FASTCALL
SetLineNumber  . . . . . . . . .        P Near64 00000000 No Seg   *X External  FASTCALL
SetMasm510 . . . . . . . . . . .        P Near64 00000000 No Seg   *X *External FASTCALL
SetStructCurrentOffset . . . . .        P Near64 00000000 No Seg   *X *External FASTCALL
SetTextMacro . . . . . . . . . .        P Near64 00000000 No Seg   *X *External FASTCALL
SizeFromMemtype  . . . . . . . .        P Near64 00000000 No Seg   *X *External FASTCALL
SizeFromRegister . . . . . . . .        P Near64 00000000 No Seg   *X *External FASTCALL
SkipCurrentQueue . . . . . . . .        P Near64 00000000 No Seg   *X *External FASTCALL
SkipMacro  . . . . . . . . . . .        P Near   00000083 _TEXT    *X Private  FASTCALL
  tokenarray . . . . . . . . . .        Near              rbp + 0010
  buffer . . . . . . . . . . . .        Near              rbp - 0008
  @C000B . . . . . . . . . . . .        L Near   000000BC _TEXT
  @C000A . . . . . . . . . . . .        L Near   000000AA _TEXT
StoreMacro . . . . . . . . . . .        P Near64 00000000 No Seg   *X *External FASTCALL
StringInit . . . . . . . . . . .        P Near64 00000000 No Seg   *X *External FASTCALL
SymAddGlobal . . . . . . . . . .        P Near64 00000000 No Seg   *X *External FASTCALL
SymAddLocal  . . . . . . . . . .        P Near64 00000000 No Seg   *X *External FASTCALL
SymAlloc . . . . . . . . . . . .        P Near64 00000000 No Seg   *X *External FASTCALL
SymClearLocal  . . . . . . . . .        P Near64 00000000 No Seg   *X *External FASTCALL
SymCreate  . . . . . . . . . . .        P Near64 00000000 No Seg   *X *External FASTCALL
SymEnum  . . . . . . . . . . . .        P Near64 00000000 No Seg   *X *External FASTCALL
SymFind  . . . . . . . . . . . .        P Near64 00000000 No Seg   *X External  FASTCALL
SymFree  . . . . . . . . . . . .        P Near64 00000000 No Seg   *X *External FASTCALL
SymGetAll  . . . . . . . . . . .        P Near64 00000000 No Seg   *X *External FASTCALL
SymGetCount  . . . . . . . . . .        P Near64 00000000 No Seg   *X *External FASTCALL
SymGetLocal  . . . . . . . . . .        P Near64 00000000 No Seg   *X *External FASTCALL
SymInit  . . . . . . . . . . . .        P Near64 00000000 No Seg   *X *External FASTCALL
SymLCreate . . . . . . . . . . .        P Near64 00000000 No Seg   *X *External FASTCALL
SymLookup  . . . . . . . . . . .        P Near64 00000000 No Seg   *X *External FASTCALL
SymLookupLocal . . . . . . . . .        P Near64 00000000 No Seg   *X *External FASTCALL
SymMakeAllSymbolsPublic  . . . .        P Near64 00000000 No Seg   *X *External FASTCALL
SymPassInit  . . . . . . . . . .        P Near64 00000000 No Seg   *X *External FASTCALL
SymSetCmpFunc  . . . . . . . . .        P Near64 00000000 No Seg   *X *External FASTCALL
SymSetLocal  . . . . . . . . . .        P Near64 00000000 No Seg   *X *External FASTCALL
TextItemError  . . . . . . . . .        P Near64 00000000 No Seg   *X External  FASTCALL
Tokenize . . . . . . . . . . . .        P Near64 00000000 No Seg   *X External  FASTCALL
TypesInit  . . . . . . . . . . .        P Near64 00000000 No Seg   *X *External FASTCALL
UpdateStructSize . . . . . . . .        P Near64 00000000 No Seg   *X *External FASTCALL
WriteCodeLabel . . . . . . . . .        P Near64 00000000 No Seg   *X External  FASTCALL
WriteError . . . . . . . . . . .        P Near64 00000000 No Seg   *X *External FASTCALL
WritePreprocessedLine  . . . . .        P Near64 00000000 No Seg   *X External  FASTCALL
___mb_cur_max_func . . . . . . .        P Near64 00000000 No Seg   *X *External FASTCALL
___mb_cur_max_l_func . . . . . .        P Near64 00000000 No Seg   *X *External FASTCALL
__acrt_iob_func  . . . . . . . .        P Near64 00000000 No Seg   *X *External FASTCALL
__addo . . . . . . . . . . . . .        P Near64 00000000 No Seg   *X *External FASTCALL
__addq . . . . . . . . . . . . .        P Near64 00000000 No Seg   *X *External FASTCALL
__cmpq . . . . . . . . . . . . .        P Near64 00000000 No Seg   *X *External FASTCALL
__cvta_q . . . . . . . . . . . .        P Near64 00000000 No Seg   *X *External FASTCALL
__cvth_q . . . . . . . . . . . .        P Near64 00000000 No Seg   *X *External FASTCALL
__cvti32_q . . . . . . . . . . .        P Near64 00000000 No Seg   *X *External FASTCALL
__cvti64_q . . . . . . . . . . .        P Near64 00000000 No Seg   *X *External FASTCALL
__cvtld_q  . . . . . . . . . . .        P Near64 00000000 No Seg   *X *External FASTCALL
__cvtq_h . . . . . . . . . . . .        P Near64 00000000 No Seg   *X *External FASTCALL
__cvtq_i32 . . . . . . . . . . .        P Near64 00000000 No Seg   *X *External FASTCALL
__cvtq_i64 . . . . . . . . . . .        P Near64 00000000 No Seg   *X *External FASTCALL
__cvtq_ld  . . . . . . . . . . .        P Near64 00000000 No Seg   *X *External FASTCALL
__cvtq_sd  . . . . . . . . . . .        P Near64 00000000 No Seg   *X *External FASTCALL
__cvtq_ss  . . . . . . . . . . .        P Near64 00000000 No Seg   *X *External FASTCALL
__cvtsd_q  . . . . . . . . . . .        P Near64 00000000 No Seg   *X *External FASTCALL
__cvtss_q  . . . . . . . . . . .        P Near64 00000000 No Seg   *X *External FASTCALL
__div64  . . . . . . . . . . . .        P Near64 00000000 No Seg   *X *External WATCALL
__divo . . . . . . . . . . . . .        P Near64 00000000 No Seg   *X *External FASTCALL
__divq . . . . . . . . . . . . .        P Near64 00000000 No Seg   *X *External FASTCALL
__doserrno . . . . . . . . . . .        P Near64 00000000 No Seg   *X *External FASTCALL
__getmainargs  . . . . . . . . .        P Near64 00000000 No Seg   *X *External FASTCALL
__iob_func . . . . . . . . . . .        P Near64 00000000 No Seg   *X *External FASTCALL
__mul64  . . . . . . . . . . . .        P Near64 00000000 No Seg   *X *External WATCALL
__mulo . . . . . . . . . . . . .        P Near64 00000000 No Seg   *X *External FASTCALL
__mulq . . . . . . . . . . . . .        P Near64 00000000 No Seg   *X *External FASTCALL
__rem64  . . . . . . . . . . . .        P Near64 00000000 No Seg   *X *External WATCALL
__saro . . . . . . . . . . . . .        P Near64 00000000 No Seg   *X *External FASTCALL
__shlo . . . . . . . . . . . . .        P Near64 00000000 No Seg   *X *External FASTCALL
__shro . . . . . . . . . . . . .        P Near64 00000000 No Seg   *X *External FASTCALL
__sqrtq  . . . . . . . . . . . .        P Near64 00000000 No Seg   *X *External FASTCALL
__subo . . . . . . . . . . . . .        P Near64 00000000 No Seg   *X *External FASTCALL
__subq . . . . . . . . . . . . .        P Near64 00000000 No Seg   *X *External FASTCALL
__sys_errlist  . . . . . . . . .        P Near64 00000000 No Seg   *X *External FASTCALL
__sys_nerr . . . . . . . . . . .        P Near64 00000000 No Seg   *X *External FASTCALL
__wgetmainargs . . . . . . . . .        P Near64 00000000 No Seg   *X *External FASTCALL
_abs64 . . . . . . . . . . . . .        P Near64 00000000 No Seg   *X *External FASTCALL
_aligned_free  . . . . . . . . .        P Near64 00000000 No Seg   *X *External FASTCALL
_aligned_malloc  . . . . . . . .        P Near64 00000000 No Seg   *X *External FASTCALL
_aligned_msize . . . . . . . . .        P Near64 00000000 No Seg   *X *External FASTCALL
_aligned_offset_malloc . . . . .        P Near64 00000000 No Seg   *X *External FASTCALL
_aligned_offset_realloc  . . . .        P Near64 00000000 No Seg   *X *External FASTCALL
_aligned_offset_recalloc . . . .        P Near64 00000000 No Seg   *X *External FASTCALL
_aligned_realloc . . . . . . . .        P Near64 00000000 No Seg   *X *External FASTCALL
_aligned_recalloc  . . . . . . .        P Near64 00000000 No Seg   *X *External FASTCALL
_atodbl  . . . . . . . . . . . .        P Near64 00000000 No Seg   *X *External FASTCALL
_atodbl_l  . . . . . . . . . . .        P Near64 00000000 No Seg   *X *External FASTCALL
_atof_l  . . . . . . . . . . . .        P Near64 00000000 No Seg   *X *External FASTCALL
_atoflt  . . . . . . . . . . . .        P Near64 00000000 No Seg   *X *External FASTCALL
_atoflt_l  . . . . . . . . . . .        P Near64 00000000 No Seg   *X *External FASTCALL
_atoi128 . . . . . . . . . . . .        P Near64 00000000 No Seg   *X *External FASTCALL
_atoi64  . . . . . . . . . . . .        P Near64 00000000 No Seg   *X *External FASTCALL
_atoi64_l  . . . . . . . . . . .        P Near64 00000000 No Seg   *X *External FASTCALL
_atoi_l  . . . . . . . . . . . .        P Near64 00000000 No Seg   *X *External FASTCALL
_atol_l  . . . . . . . . . . . .        P Near64 00000000 No Seg   *X *External FASTCALL
_atoldbl . . . . . . . . . . . .        P Near64 00000000 No Seg   *X *External FASTCALL
_atoldbl_l . . . . . . . . . . .        P Near64 00000000 No Seg   *X *External FASTCALL
_atoll_l . . . . . . . . . . . .        P Near64 00000000 No Seg   *X *External FASTCALL
_atoow . . . . . . . . . . . . .        P Near64 00000000 No Seg   *X *External FASTCALL
_atoqw . . . . . . . . . . . . .        P Near64 00000000 No Seg   *X *External FASTCALL
_beep  . . . . . . . . . . . . .        P Near64 00000000 No Seg   *X *External FASTCALL
_calloca . . . . . . . . . . . .        P Near64 00000000 No Seg   *X *External WATCALL
_cfltcvt . . . . . . . . . . . .        P Near64 00000000 No Seg   *X *External FASTCALL
_cldcvt  . . . . . . . . . . . .        P Near64 00000000 No Seg   *X *External FASTCALL
_cqcvt . . . . . . . . . . . . .        P Near64 00000000 No Seg   *X *External FASTCALL
_cropzeros . . . . . . . . . . .        P Near64 00000000 No Seg   *X *External FASTCALL
_destoflt  . . . . . . . . . . .        P Near64 00000000 No Seg   *X *External FASTCALL
_dosmaperr . . . . . . . . . . .        P Near64 00000000 No Seg   *X *External FASTCALL
_dupenv_s  . . . . . . . . . . .        P Near64 00000000 No Seg   *X *External FASTCALL
_ecvt  . . . . . . . . . . . . .        P Near64 00000000 No Seg   *X *External FASTCALL
_ecvt_s  . . . . . . . . . . . .        P Near64 00000000 No Seg   *X *External FASTCALL
_errno . . . . . . . . . . . . .        P Near64 00000000 No Seg   *X *External FASTCALL
_exit  . . . . . . . . . . . . .        P Near64 00000000 No Seg   *X *External FASTCALL
_fcvt  . . . . . . . . . . . . .        P Near64 00000000 No Seg   *X *External FASTCALL
_fcvt_s  . . . . . . . . . . . .        P Near64 00000000 No Seg   *X *External FASTCALL
_fgetwchar . . . . . . . . . . .        P Near64 00000000 No Seg   *X *External FASTCALL
_filbuf  . . . . . . . . . . . .        P Near64 00000000 No Seg   *X *External FASTCALL
_fileno  . . . . . . . . . . . .        P Near64 00000000 No Seg   *X *External FASTCALL
_filwbuf . . . . . . . . . . . .        P Near64 00000000 No Seg   *X *External FASTCALL
_flsbuf  . . . . . . . . . . . .        P Near64 00000000 No Seg   *X *External FASTCALL
_flswbuf . . . . . . . . . . . .        P Near64 00000000 No Seg   *X *External FASTCALL
_fltadd  . . . . . . . . . . . .        P Near64 00000000 No Seg   *X *External FASTCALL
_fltdiv  . . . . . . . . . . . .        P Near64 00000000 No Seg   *X *External FASTCALL
_fltgetrounding  . . . . . . . .        P Near64 00000000 No Seg   *X *External FASTCALL
_fltmul  . . . . . . . . . . . .        P Near64 00000000 No Seg   *X *External FASTCALL
_fltpackfp . . . . . . . . . . .        P Near64 00000000 No Seg   *X *External FASTCALL
_fltround  . . . . . . . . . . .        P Near64 00000000 No Seg   *X *External FASTCALL
_fltscale  . . . . . . . . . . .        P Near64 00000000 No Seg   *X *External FASTCALL
_fltsetflags . . . . . . . . . .        P Near64 00000000 No Seg   *X *External FASTCALL
_fltsetrounding  . . . . . . . .        P Near64 00000000 No Seg   *X *External FASTCALL
_fltsub  . . . . . . . . . . . .        P Near64 00000000 No Seg   *X *External FASTCALL
_flttoi  . . . . . . . . . . . .        P Near64 00000000 No Seg   *X *External FASTCALL
_flttoi64  . . . . . . . . . . .        P Near64 00000000 No Seg   *X *External FASTCALL
_flttostr  . . . . . . . . . . .        P Near64 00000000 No Seg   *X External  FASTCALL
_fltunpack . . . . . . . . . . .        P Near64 00000000 No Seg   *X *External FASTCALL
_flushall  . . . . . . . . . . .        P Near64 00000000 No Seg   *X *External FASTCALL
_forcdecpt . . . . . . . . . . .        P Near64 00000000 No Seg   *X *External FASTCALL
_fptostr . . . . . . . . . . . .        P Near64 00000000 No Seg   *X *External FASTCALL
_fputchar  . . . . . . . . . . .        P Near64 00000000 No Seg   *X *External FASTCALL
_fputwchar . . . . . . . . . . .        P Near64 00000000 No Seg   *X *External FASTCALL
_freea . . . . . . . . . . . . .        P Near64 00000000 No Seg   *X *External FASTCALL
_freebuf . . . . . . . . . . . .        P Near64 00000000 No Seg   *X *External FASTCALL
_ftbuf . . . . . . . . . . . . .        P Near64 00000000 No Seg   *X *External FASTCALL
_fullpath  . . . . . . . . . . .        P Near64 00000000 No Seg   *X *External FASTCALL
_gcvt  . . . . . . . . . . . . .        P Near64 00000000 No Seg   *X *External FASTCALL
_gcvt_s  . . . . . . . . . . . .        P Near64 00000000 No Seg   *X *External FASTCALL
_get_doserrno  . . . . . . . . .        P Near64 00000000 No Seg   *X *External FASTCALL
_get_errno . . . . . . . . . . .        P Near64 00000000 No Seg   *X *External FASTCALL
_get_fmode . . . . . . . . . . .        P Near64 00000000 No Seg   *X *External FASTCALL
_get_invalid_parameter_handler .        P Near64 00000000 No Seg   *X *External FASTCALL
_get_pgmptr  . . . . . . . . . .        P Near64 00000000 No Seg   *X *External FASTCALL
_get_purecall_handler  . . . . .        P Near64 00000000 No Seg   *X *External FASTCALL
_get_wpgmptr . . . . . . . . . .        P Near64 00000000 No Seg   *X *External FASTCALL
_getbuf  . . . . . . . . . . . .        P Near64 00000000 No Seg   *X *External FASTCALL
_getst . . . . . . . . . . . . .        P Near64 00000000 No Seg   *X *External FASTCALL
_getws . . . . . . . . . . . . .        P Near64 00000000 No Seg   *X *External FASTCALL
_i64toa  . . . . . . . . . . . .        P Near64 00000000 No Seg   *X *External FASTCALL
_i64toa_s  . . . . . . . . . . .        P Near64 00000000 No Seg   *X *External FASTCALL
_i64toflt  . . . . . . . . . . .        P Near64 00000000 No Seg   *X *External FASTCALL
_i64tow  . . . . . . . . . . . .        P Near64 00000000 No Seg   *X *External FASTCALL
_i64tow_s  . . . . . . . . . . .        P Near64 00000000 No Seg   *X *External FASTCALL
_itoa  . . . . . . . . . . . . .        P Near64 00000000 No Seg   *X *External FASTCALL
_itoa_s  . . . . . . . . . . . .        P Near64 00000000 No Seg   *X *External FASTCALL
_itoflt  . . . . . . . . . . . .        P Near64 00000000 No Seg   *X *External FASTCALL
_itow  . . . . . . . . . . . . .        P Near64 00000000 No Seg   *X *External FASTCALL
_itow_s  . . . . . . . . . . . .        P Near64 00000000 No Seg   *X *External FASTCALL
_ltoa  . . . . . . . . . . . . .        P Near64 00000000 No Seg   *X *External FASTCALL
_ltoa_s  . . . . . . . . . . . .        P Near64 00000000 No Seg   *X *External FASTCALL
_ltow  . . . . . . . . . . . . .        P Near64 00000000 No Seg   *X *External FASTCALL
_ltow_s  . . . . . . . . . . . .        P Near64 00000000 No Seg   *X *External FASTCALL
_makepath  . . . . . . . . . . .        P Near64 00000000 No Seg   *X *External FASTCALL
_makepath_s  . . . . . . . . . .        P Near64 00000000 No Seg   *X *External FASTCALL
_mbccpy_s  . . . . . . . . . . .        P Near64 00000000 No Seg   *X *External FASTCALL
_mblen_l . . . . . . . . . . . .        P Near64 00000000 No Seg   *X *External FASTCALL
_mbspbrk . . . . . . . . . . . .        P Near64 00000000 No Seg   *X *External FASTCALL
_mbstowcs_s_l  . . . . . . . . .        P Near64 00000000 No Seg   *X *External FASTCALL
_mbstrlen  . . . . . . . . . . .        P Near64 00000000 No Seg   *X *External FASTCALL
_mbstrlen_l  . . . . . . . . . .        P Near64 00000000 No Seg   *X *External FASTCALL
_mbstrnlen . . . . . . . . . . .        P Near64 00000000 No Seg   *X *External FASTCALL
_mbstrnlen_l . . . . . . . . . .        P Near64 00000000 No Seg   *X *External FASTCALL
_mbtowc_l  . . . . . . . . . . .        P Near64 00000000 No Seg   *X *External FASTCALL
_memicmp . . . . . . . . . . . .        P Near64 00000000 No Seg   *X *External FASTCALL
_msize . . . . . . . . . . . . .        P Near64 00000000 No Seg   *X *External FASTCALL
_onexit  . . . . . . . . . . . .        P Near64 00000000 No Seg   *X *External FASTCALL
_openfile  . . . . . . . . . . .        P Near64 00000000 No Seg   *X *External FASTCALL
_output  . . . . . . . . . . . .        P Near64 00000000 No Seg   *X *External FASTCALL
_putenv  . . . . . . . . . . . .        P Near64 00000000 No Seg   *X *External FASTCALL
_putenv_s  . . . . . . . . . . .        P Near64 00000000 No Seg   *X *External FASTCALL
_putws . . . . . . . . . . . . .        P Near64 00000000 No Seg   *X *External FASTCALL
_recalloc  . . . . . . . . . . .        P Near64 00000000 No Seg   *X *External FASTCALL
_resetstkoflw  . . . . . . . . .        P Near64 00000000 No Seg   *X *External FASTCALL
_searchenv_s . . . . . . . . . .        P Near64 00000000 No Seg   *X *External FASTCALL
_set_abort_behavior  . . . . . .        P Near64 00000000 No Seg   *X *External FASTCALL
_set_doserrno  . . . . . . . . .        P Near64 00000000 No Seg   *X *External FASTCALL
_set_errno . . . . . . . . . . .        P Near64 00000000 No Seg   *X *External FASTCALL
_set_error_mode  . . . . . . . .        P Near64 00000000 No Seg   *X *External FASTCALL
_set_fmode . . . . . . . . . . .        P Near64 00000000 No Seg   *X *External FASTCALL
_set_invalid_parameter_handler .        P Near64 00000000 No Seg   *X *External FASTCALL
_set_purecall_handler  . . . . .        P Near64 00000000 No Seg   *X *External FASTCALL
_seterrormode  . . . . . . . . .        P Near64 00000000 No Seg   *X *External FASTCALL
_sleep . . . . . . . . . . . . .        P Near64 00000000 No Seg   *X *External FASTCALL
_snwprintf . . . . . . . . . . .        P Near64 00000000 No Seg   *X *External FASTCALL
_splitpath . . . . . . . . . . .        P Near64 00000000 No Seg   *X *External FASTCALL
_splitpath_s . . . . . . . . . .        P Near64 00000000 No Seg   *X *External FASTCALL
_stbuf . . . . . . . . . . . . .        P Near64 00000000 No Seg   *X *External FASTCALL
_strdup  . . . . . . . . . . . .        P Near64 00000000 No Seg   *X *External FASTCALL
_stricmp . . . . . . . . . . . .        P Near64 00000000 No Seg   *X *External FASTCALL
_strlwr  . . . . . . . . . . . .        P Near64 00000000 No Seg   *X *External FASTCALL
_strlwr_s  . . . . . . . . . . .        P Near64 00000000 No Seg   *X *External FASTCALL
_strnicmp  . . . . . . . . . . .        P Near64 00000000 No Seg   *X *External FASTCALL
_strnset . . . . . . . . . . . .        P Near64 00000000 No Seg   *X *External FASTCALL
_strnset_s . . . . . . . . . . .        P Near64 00000000 No Seg   *X *External FASTCALL
_strrev  . . . . . . . . . . . .        P Near64 00000000 No Seg   *X *External FASTCALL
_strset  . . . . . . . . . . . .        P Near64 00000000 No Seg   *X *External FASTCALL
_strset_s  . . . . . . . . . . .        P Near64 00000000 No Seg   *X *External FASTCALL
_strtod_l  . . . . . . . . . . .        P Near64 00000000 No Seg   *X *External FASTCALL
_strtof_l  . . . . . . . . . . .        P Near64 00000000 No Seg   *X *External FASTCALL
_strtoflt  . . . . . . . . . . .        P Near64 00000000 No Seg   *X *External FASTCALL
_strtoi64  . . . . . . . . . . .        P Near64 00000000 No Seg   *X *External FASTCALL
_strtoi64_l  . . . . . . . . . .        P Near64 00000000 No Seg   *X *External FASTCALL
_strtol_l  . . . . . . . . . . .        P Near64 00000000 No Seg   *X *External FASTCALL
_strtold . . . . . . . . . . . .        P Near64 00000000 No Seg   *X *External FASTCALL
_strtold_l . . . . . . . . . . .        P Near64 00000000 No Seg   *X *External FASTCALL
_strtoll_l . . . . . . . . . . .        P Near64 00000000 No Seg   *X *External FASTCALL
_strtoq  . . . . . . . . . . . .        P Near64 00000000 No Seg   *X *External FASTCALL
_strtoui64 . . . . . . . . . . .        P Near64 00000000 No Seg   *X *External FASTCALL
_strtoui64_l . . . . . . . . . .        P Near64 00000000 No Seg   *X *External FASTCALL
_strtoul_l . . . . . . . . . . .        P Near64 00000000 No Seg   *X *External FASTCALL
_strtoull_l  . . . . . . . . . .        P Near64 00000000 No Seg   *X *External FASTCALL
_strupr  . . . . . . . . . . . .        P Near64 00000000 No Seg   *X *External FASTCALL
_strupr_s  . . . . . . . . . . .        P Near64 00000000 No Seg   *X *External FASTCALL
_swab  . . . . . . . . . . . . .        P Near64 00000000 No Seg   *X *External FASTCALL
_ui64toa . . . . . . . . . . . .        P Near64 00000000 No Seg   *X *External FASTCALL
_ui64toa_s . . . . . . . . . . .        P Near64 00000000 No Seg   *X *External FASTCALL
_ui64tow . . . . . . . . . . . .        P Near64 00000000 No Seg   *X *External FASTCALL
_ui64tow_s . . . . . . . . . . .        P Near64 00000000 No Seg   *X *External FASTCALL
_ultoa . . . . . . . . . . . . .        P Near64 00000000 No Seg   *X *External FASTCALL
_ultoa_s . . . . . . . . . . . .        P Near64 00000000 No Seg   *X *External FASTCALL
_ultow . . . . . . . . . . . . .        P Near64 00000000 No Seg   *X *External FASTCALL
_ultow_s . . . . . . . . . . . .        P Near64 00000000 No Seg   *X *External FASTCALL
_vsnprintf . . . . . . . . . . .        P Near64 00000000 No Seg   *X *External FASTCALL
_vsnwprintf  . . . . . . . . . .        P Near64 00000000 No Seg   *X *External FASTCALL
_wcsdup  . . . . . . . . . . . .        P Near64 00000000 No Seg   *X *External FASTCALL
_wcsicmp . . . . . . . . . . . .        P Near64 00000000 No Seg   *X *External FASTCALL
_wcsicoll  . . . . . . . . . . .        P Near64 00000000 No Seg   *X *External FASTCALL
_wcslwr  . . . . . . . . . . . .        P Near64 00000000 No Seg   *X *External FASTCALL
_wcslwr_s  . . . . . . . . . . .        P Near64 00000000 No Seg   *X *External FASTCALL
_wcsncoll  . . . . . . . . . . .        P Near64 00000000 No Seg   *X *External FASTCALL
_wcsnicmp  . . . . . . . . . . .        P Near64 00000000 No Seg   *X *External FASTCALL
_wcsnicoll . . . . . . . . . . .        P Near64 00000000 No Seg   *X *External FASTCALL
_wcsnset . . . . . . . . . . . .        P Near64 00000000 No Seg   *X *External FASTCALL
_wcsnset_s . . . . . . . . . . .        P Near64 00000000 No Seg   *X *External FASTCALL
_wcsrev  . . . . . . . . . . . .        P Near64 00000000 No Seg   *X *External FASTCALL
_wcsset  . . . . . . . . . . . .        P Near64 00000000 No Seg   *X *External FASTCALL
_wcsset_s  . . . . . . . . . . .        P Near64 00000000 No Seg   *X *External FASTCALL
_wcstod_l  . . . . . . . . . . .        P Near64 00000000 No Seg   *X *External FASTCALL
_wcstof_l  . . . . . . . . . . .        P Near64 00000000 No Seg   *X *External FASTCALL
_wcstoi64  . . . . . . . . . . .        P Near64 00000000 No Seg   *X *External FASTCALL
_wcstoi64_l  . . . . . . . . . .        P Near64 00000000 No Seg   *X *External FASTCALL
_wcstol_l  . . . . . . . . . . .        P Near64 00000000 No Seg   *X *External FASTCALL
_wcstold_l . . . . . . . . . . .        P Near64 00000000 No Seg   *X *External FASTCALL
_wcstoll_l . . . . . . . . . . .        P Near64 00000000 No Seg   *X *External FASTCALL
_wcstombs_s_l  . . . . . . . . .        P Near64 00000000 No Seg   *X *External FASTCALL
_wcstoui64 . . . . . . . . . . .        P Near64 00000000 No Seg   *X *External FASTCALL
_wcstoui64_l . . . . . . . . . .        P Near64 00000000 No Seg   *X *External FASTCALL
_wcstoul_l . . . . . . . . . . .        P Near64 00000000 No Seg   *X *External FASTCALL
_wcstoull_l  . . . . . . . . . .        P Near64 00000000 No Seg   *X *External FASTCALL
_wcsupr  . . . . . . . . . . . .        P Near64 00000000 No Seg   *X *External FASTCALL
_wcsupr_s  . . . . . . . . . . .        P Near64 00000000 No Seg   *X *External FASTCALL
_wctomb_l  . . . . . . . . . . .        P Near64 00000000 No Seg   *X *External FASTCALL
_wctomb_s_l  . . . . . . . . . .        P Near64 00000000 No Seg   *X *External FASTCALL
_wdupenv_s . . . . . . . . . . .        P Near64 00000000 No Seg   *X *External FASTCALL
_wfdopen . . . . . . . . . . . .        P Near64 00000000 No Seg   *X *External FASTCALL
_wfopen  . . . . . . . . . . . .        P Near64 00000000 No Seg   *X *External FASTCALL
_wfreopen  . . . . . . . . . . .        P Near64 00000000 No Seg   *X *External FASTCALL
_wfsopenproto  . . . . . . . . .        P Near64 00000000 No Seg   *X *External FASTCALL
_wfullpath . . . . . . . . . . .        P Near64 00000000 No Seg   *X *External FASTCALL
_wgetenv . . . . . . . . . . . .        P Near64 00000000 No Seg   *X *External FASTCALL
_wgetenv_s . . . . . . . . . . .        P Near64 00000000 No Seg   *X *External FASTCALL
_wmakepath_s . . . . . . . . . .        P Near64 00000000 No Seg   *X *External FASTCALL
_woutput . . . . . . . . . . . .        P Near64 00000000 No Seg   *X *External FASTCALL
_wperror . . . . . . . . . . . .        P Near64 00000000 No Seg   *X *External FASTCALL
_wpopen  . . . . . . . . . . . .        P Near64 00000000 No Seg   *X *External FASTCALL
_wputenv . . . . . . . . . . . .        P Near64 00000000 No Seg   *X *External FASTCALL
_wputenv_s . . . . . . . . . . .        P Near64 00000000 No Seg   *X *External FASTCALL
_wremove . . . . . . . . . . . .        P Near64 00000000 No Seg   *X *External FASTCALL
_wsearchenv_s  . . . . . . . . .        P Near64 00000000 No Seg   *X *External FASTCALL
_wsplitpath  . . . . . . . . . .        P Near64 00000000 No Seg   *X *External FASTCALL
_wsplitpath_s  . . . . . . . . .        P Near64 00000000 No Seg   *X *External FASTCALL
_wsystem . . . . . . . . . . . .        P Near64 00000000 No Seg   *X *External FASTCALL
_wtempnam  . . . . . . . . . . .        P Near64 00000000 No Seg   *X *External FASTCALL
_wtmpnam . . . . . . . . . . . .        P Near64 00000000 No Seg   *X *External FASTCALL
_wtof  . . . . . . . . . . . . .        P Near64 00000000 No Seg   *X *External FASTCALL
_wtof_l  . . . . . . . . . . . .        P Near64 00000000 No Seg   *X *External FASTCALL
_wtoi  . . . . . . . . . . . . .        P Near64 00000000 No Seg   *X *External FASTCALL
_wtoi64  . . . . . . . . . . . .        P Near64 00000000 No Seg   *X *External FASTCALL
_wtoi64_l  . . . . . . . . . . .        P Near64 00000000 No Seg   *X *External FASTCALL
_wtoi_l  . . . . . . . . . . . .        P Near64 00000000 No Seg   *X *External FASTCALL
_wtol  . . . . . . . . . . . . .        P Near64 00000000 No Seg   *X *External FASTCALL
_wtol_l  . . . . . . . . . . . .        P Near64 00000000 No Seg   *X *External FASTCALL
_wtoll . . . . . . . . . . . . .        P Near64 00000000 No Seg   *X *External FASTCALL
_wtoll_l . . . . . . . . . . . .        P Near64 00000000 No Seg   *X *External FASTCALL
_xtoa  . . . . . . . . . . . . .        P Near64 00000000 No Seg   *X *External FASTCALL
_xtoa_s  . . . . . . . . . . . .        P Near64 00000000 No Seg   *X *External FASTCALL
_xtow  . . . . . . . . . . . . .        P Near64 00000000 No Seg   *X *External FASTCALL
_xtow_s  . . . . . . . . . . . .        P Near64 00000000 No Seg   *X *External FASTCALL
abort  . . . . . . . . . . . . .        P Near64 00000000 No Seg   *X *External FASTCALL
abs  . . . . . . . . . . . . . .        P Near64 00000000 No Seg   *X *External FASTCALL
alloca . . . . . . . . . . . . .        P Near64 00000000 No Seg   *X *External WATCALL
asmerr . . . . . . . . . . . . .        P Near64 00000000 No Seg   *X External  FASTCALL
atexit . . . . . . . . . . . . .        P Near64 00000000 No Seg   *X *External FASTCALL
atof . . . . . . . . . . . . . .        P Near64 00000000 No Seg   *X *External FASTCALL
atofloat . . . . . . . . . . . .        P Near64 00000000 No Seg   *X *External FASTCALL
atoi . . . . . . . . . . . . . .        P Near64 00000000 No Seg   *X *External FASTCALL
atol . . . . . . . . . . . . . .        P Near64 00000000 No Seg   *X *External FASTCALL
atoll  . . . . . . . . . . . . .        P Near64 00000000 No Seg   *X *External FASTCALL
bsearch  . . . . . . . . . . . .        P Near64 00000000 No Seg   *X *External FASTCALL
bsearch_s  . . . . . . . . . . .        P Near64 00000000 No Seg   *X *External FASTCALL
calloc . . . . . . . . . . . . .        P Near64 00000000 No Seg   *X *External FASTCALL
close_files  . . . . . . . . . .        P Near64 00000000 No Seg   *X *External FASTCALL
define_name  . . . . . . . . . .        P Near64 00000000 No Seg   *X *External FASTCALL
ecvt . . . . . . . . . . . . . .        P Near64 00000000 No Seg   *X *External FASTCALL
exit . . . . . . . . . . . . . .        P Near64 00000000 No Seg   *X *External FASTCALL
fclose . . . . . . . . . . . . .        P Near64 00000000 No Seg   *X *External FASTCALL
fcvt . . . . . . . . . . . . . .        P Near64 00000000 No Seg   *X *External FASTCALL
feof . . . . . . . . . . . . . .        P Near64 00000000 No Seg   *X *External FASTCALL
fflush . . . . . . . . . . . . .        P Near64 00000000 No Seg   *X *External FASTCALL
fgetc  . . . . . . . . . . . . .        P Near64 00000000 No Seg   *X *External FASTCALL
fgets  . . . . . . . . . . . . .        P Near64 00000000 No Seg   *X *External FASTCALL
fgetwc . . . . . . . . . . . . .        P Near64 00000000 No Seg   *X *External FASTCALL
fgetws . . . . . . . . . . . . .        P Near64 00000000 No Seg   *X *External FASTCALL
fill_placeholders  . . . . . . .        P Near64 00000000 No Seg   *X External  FASTCALL
fopen  . . . . . . . . . . . . .        P Near64 00000000 No Seg   *X *External FASTCALL
fopen_s  . . . . . . . . . . . .        P Near64 00000000 No Seg   *X *External FASTCALL
fprintf  . . . . . . . . . . . .        P Near64 00000000 No Seg   *X *External FASTCALL
fputc  . . . . . . . . . . . . .        P Near64 00000000 No Seg   *X *External FASTCALL
fputs  . . . . . . . . . . . . .        P Near64 00000000 No Seg   *X *External FASTCALL
fputwc . . . . . . . . . . . . .        P Near64 00000000 No Seg   *X *External FASTCALL
fputws . . . . . . . . . . . . .        P Near64 00000000 No Seg   *X *External FASTCALL
fread  . . . . . . . . . . . . .        P Near64 00000000 No Seg   *X *External FASTCALL
free . . . . . . . . . . . . . .        P Near64 00000000 No Seg   *X *External FASTCALL
fseek  . . . . . . . . . . . . .        P Near64 00000000 No Seg   *X *External FASTCALL
ftell  . . . . . . . . . . . . .        P Near64 00000000 No Seg   *X *External FASTCALL
ftobufin . . . . . . . . . . . .        P Near64 00000000 No Seg   *X *External FASTCALL
fwprintf . . . . . . . . . . . .        P Near64 00000000 No Seg   *X *External FASTCALL
fwrite . . . . . . . . . . . . .        P Near64 00000000 No Seg   *X *External FASTCALL
fwscanf  . . . . . . . . . . . .        P Near64 00000000 No Seg   *X *External FASTCALL
gcvt . . . . . . . . . . . . . .        P Near64 00000000 No Seg   *X *External FASTCALL
get_curr_srcfile . . . . . . . .        P Near64 00000000 No Seg   *X *External FASTCALL
getc . . . . . . . . . . . . . .        P Near64 00000000 No Seg   *X *External FASTCALL
getchar  . . . . . . . . . . . .        P Near64 00000000 No Seg   *X *External FASTCALL
getenv . . . . . . . . . . . . .        P Near64 00000000 No Seg   *X *External FASTCALL
getenv_s . . . . . . . . . . . .        P Near64 00000000 No Seg   *X *External FASTCALL
getwc  . . . . . . . . . . . . .        P Near64 00000000 No Seg   *X *External FASTCALL
getwchar . . . . . . . . . . . .        P Near64 00000000 No Seg   *X *External FASTCALL
isclabel . . . . . . . . . . . .        P Near64 00000000 No Seg   *X *External WATCALL
isclabel0  . . . . . . . . . . .        P Near64 00000000 No Seg   *X *External WATCALL
isdotlabel . . . . . . . . . . .        P Near64 00000000 No Seg   *X *External WATCALL
islabel  . . . . . . . . . . . .        P Near64 00000000 No Seg   *X *External WATCALL
islabel0 . . . . . . . . . . . .        P Near64 00000000 No Seg   *X *External WATCALL
islalnum . . . . . . . . . . . .        P Near64 00000000 No Seg   *X *External WATCALL
islalpha . . . . . . . . . . . .        P Near64 00000000 No Seg   *X *External WATCALL
islascii . . . . . . . . . . . .        P Near64 00000000 No Seg   *X *External WATCALL
islcntrl . . . . . . . . . . . .        P Near64 00000000 No Seg   *X *External WATCALL
isldigit . . . . . . . . . . . .        P Near64 00000000 No Seg   *X *External WATCALL
islgraph . . . . . . . . . . . .        P Near64 00000000 No Seg   *X *External WATCALL
isllower . . . . . . . . . . . .        P Near64 00000000 No Seg   *X *External WATCALL
islprint . . . . . . . . . . . .        P Near64 00000000 No Seg   *X *External WATCALL
islpunct . . . . . . . . . . . .        P Near64 00000000 No Seg   *X *External WATCALL
islspace . . . . . . . . . . . .        P Near64 00000000 No Seg   *X *External WATCALL
islupper . . . . . . . . . . . .        P Near64 00000000 No Seg   *X *External WATCALL
islxdigit  . . . . . . . . . . .        P Near64 00000000 No Seg   *X *External WATCALL
itoa . . . . . . . . . . . . . .        P Near64 00000000 No Seg   *X *External FASTCALL
labs . . . . . . . . . . . . . .        P Near64 00000000 No Seg   *X *External FASTCALL
ldiv . . . . . . . . . . . . . .        P Near64 00000000 No Seg   *X *External FASTCALL
llabs  . . . . . . . . . . . . .        P Near64 00000000 No Seg   *X *External FASTCALL
lldiv  . . . . . . . . . . . . .        P Near64 00000000 No Seg   *X *External FASTCALL
lnexttokc  . . . . . . . . . . .        P Near64 00000000 No Seg   *X *External FASTCALL
lprevtokc  . . . . . . . . . . .        P Near64 00000000 No Seg   *X *External FASTCALL
ltoa . . . . . . . . . . . . . .        P Near64 00000000 No Seg   *X *External FASTCALL
ltokstart  . . . . . . . . . . .        P Near64 00000000 No Seg   *X *External FASTCALL
ltokstartc . . . . . . . . . . .        P Near64 00000000 No Seg   *X *External FASTCALL
malloc . . . . . . . . . . . . .        P Near64 00000000 No Seg   *X *External FASTCALL
mblen  . . . . . . . . . . . . .        P Near64 00000000 No Seg   *X *External FASTCALL
mbstowcs . . . . . . . . . . . .        P Near64 00000000 No Seg   *X *External FASTCALL
mbstowcs_s . . . . . . . . . . .        P Near64 00000000 No Seg   *X *External FASTCALL
mbtowc . . . . . . . . . . . . .        P Near64 00000000 No Seg   *X *External FASTCALL
memchr . . . . . . . . . . . . .        P Near64 00000000 No Seg   *X *External FASTCALL
memcmp . . . . . . . . . . . . .        P Near64 00000000 No Seg   *X *External FASTCALL
memcpy . . . . . . . . . . . . .        P Near64 00000000 No Seg   *X *External FASTCALL
memcpy_s . . . . . . . . . . . .        P Near64 00000000 No Seg   *X *External FASTCALL
memmove  . . . . . . . . . . . .        P Near64 00000000 No Seg   *X *External FASTCALL
memset . . . . . . . . . . . . .        P Near64 00000000 No Seg   *X *External FASTCALL
myltoa . . . . . . . . . . . . .        P Near   00000000 _TEXT    *X Public   FASTCALL
  value  . . . . . . . . . . . .        QWord             rbp + 0028
  buffer . . . . . . . . . . . .        Near              rbp + 0030
  radix  . . . . . . . . . . . .        DWord             rbp + 0038
  sign . . . . . . . . . . . . .        DWord             rbp + 0040
  addzero  . . . . . . . . . . .        DWord             rbp + 0048
  tmpbuf . . . . . . . . . . . .        Byte[64]          rbp - 0040
  @C0008 . . . . . . . . . . . .        L Near   00000050 _TEXT
  @C0009 . . . . . . . . . . . .        L Near   0000006B _TEXT
  @C0006 . . . . . . . . . . . .        L Near   00000052 _TEXT
  @C0007 . . . . . . . . . . . .        L Near   00000057 _TEXT
  @C0004 . . . . . . . . . . . .        L Near   0000007E _TEXT
  @C0005 . . . . . . . . . . . .        L Near   0000003B _TEXT
  @C0002 . . . . . . . . . . . .        L Near   00000037 _TEXT
  @C0003 . . . . . . . . . . . .        L Near   00000037 _TEXT
  @C0001 . . . . . . . . . . . .        L Near   00000026 _TEXT
onexit . . . . . . . . . . . . .        P Near64 00000000 No Seg   *X *External FASTCALL
parsevex . . . . . . . . . . . .        P Near64 00000000 No Seg   *X *External FASTCALL
perror . . . . . . . . . . . . .        P Near64 00000000 No Seg   *X *External FASTCALL
printf . . . . . . . . . . . . .        P Near64 00000000 No Seg   *X *External FASTCALL
putenv . . . . . . . . . . . . .        P Near64 00000000 No Seg   *X *External FASTCALL
puts . . . . . . . . . . . . . .        P Near64 00000000 No Seg   *X *External FASTCALL
putwc  . . . . . . . . . . . . .        P Near64 00000000 No Seg   *X *External FASTCALL
putwchar . . . . . . . . . . . .        P Near64 00000000 No Seg   *X *External FASTCALL
qsort  . . . . . . . . . . . . .        P Near64 00000000 No Seg   *X *External FASTCALL
qsort_s  . . . . . . . . . . . .        P Near64 00000000 No Seg   *X *External FASTCALL
quad_resize  . . . . . . . . . .        P Near64 00000000 No Seg   *X *External FASTCALL
rand . . . . . . . . . . . . . .        P Near64 00000000 No Seg   *X *External FASTCALL
realloc  . . . . . . . . . . . .        P Near64 00000000 No Seg   *X *External FASTCALL
rewind . . . . . . . . . . . . .        P Near64 00000000 No Seg   *X *External FASTCALL
scanf  . . . . . . . . . . . . .        P Near64 00000000 No Seg   *X *External FASTCALL
set_curr_srcfile . . . . . . . .        P Near64 00000000 No Seg   *X *External FASTCALL
set_frame  . . . . . . . . . . .        P Near64 00000000 No Seg   *X *External FASTCALL
set_frame2 . . . . . . . . . . .        P Near64 00000000 No Seg   *X *External FASTCALL
setargv  . . . . . . . . . . . .        P Near64 00000000 No Seg   *X *External FASTCALL
setbuf . . . . . . . . . . . . .        P Near64 00000000 No Seg   *X *External FASTCALL
setvbuf  . . . . . . . . . . . .        P Near64 00000000 No Seg   *X *External FASTCALL
setwargv . . . . . . . . . . . .        P Near64 00000000 No Seg   *X *External FASTCALL
sprintf  . . . . . . . . . . . .        P Near64 00000000 No Seg   *X *External FASTCALL
srand  . . . . . . . . . . . . .        P Near64 00000000 No Seg   *X *External FASTCALL
store_fixup  . . . . . . . . . .        P Near64 00000000 No Seg   *X *External FASTCALL
strcat . . . . . . . . . . . . .        P Near64 00000000 No Seg   *X *External FASTCALL
strcat_s . . . . . . . . . . . .        P Near64 00000000 No Seg   *X *External FASTCALL
strchr . . . . . . . . . . . . .        P Near64 00000000 No Seg   *X *External FASTCALL
strcmp . . . . . . . . . . . . .        P Near64 00000000 No Seg   *X *External FASTCALL
strcpy . . . . . . . . . . . . .        P Near64 00000000 No Seg   *X *External FASTCALL
strcpy_s . . . . . . . . . . . .        P Near64 00000000 No Seg   *X *External FASTCALL
strlen . . . . . . . . . . . . .        P Near64 00000000 No Seg   *X *External FASTCALL
strncat_s  . . . . . . . . . . .        P Near64 00000000 No Seg   *X *External FASTCALL
strncmp  . . . . . . . . . . . .        P Near64 00000000 No Seg   *X *External FASTCALL
strncpy  . . . . . . . . . . . .        P Near64 00000000 No Seg   *X *External FASTCALL
strncpy_s  . . . . . . . . . . .        P Near64 00000000 No Seg   *X *External FASTCALL
strrchr  . . . . . . . . . . . .        P Near64 00000000 No Seg   *X *External FASTCALL
strstr . . . . . . . . . . . . .        P Near64 00000000 No Seg   *X *External FASTCALL
strtod . . . . . . . . . . . . .        P Near64 00000000 No Seg   *X *External FASTCALL
strtof . . . . . . . . . . . . .        P Near64 00000000 No Seg   *X *External FASTCALL
strtok . . . . . . . . . . . . .        P Near64 00000000 No Seg   *X *External FASTCALL
strtok_s . . . . . . . . . . . .        P Near64 00000000 No Seg   *X *External FASTCALL
strtol . . . . . . . . . . . . .        P Near64 00000000 No Seg   *X *External FASTCALL
strtold  . . . . . . . . . . . .        P Near64 00000000 No Seg   *X *External FASTCALL
strtoll  . . . . . . . . . . . .        P Near64 00000000 No Seg   *X *External FASTCALL
strtoqd  . . . . . . . . . . . .        P Near64 00000000 No Seg   *X *External FASTCALL
strtoul  . . . . . . . . . . . .        P Near64 00000000 No Seg   *X *External FASTCALL
strtoull . . . . . . . . . . . .        P Near64 00000000 No Seg   *X *External FASTCALL
swab . . . . . . . . . . . . . .        P Near64 00000000 No Seg   *X *External FASTCALL
swprintf . . . . . . . . . . . .        P Near64 00000000 No Seg   *X *External FASTCALL
swprintf_s . . . . . . . . . . .        P Near64 00000000 No Seg   *X *External FASTCALL
swscanf  . . . . . . . . . . . .        P Near64 00000000 No Seg   *X *External FASTCALL
swscanf_s  . . . . . . . . . . .        P Near64 00000000 No Seg   *X *External FASTCALL
sym_add_table  . . . . . . . . .        P Near64 00000000 No Seg   *X *External FASTCALL
sym_ext2int  . . . . . . . . . .        P Near64 00000000 No Seg   *X *External FASTCALL
sym_remove_table . . . . . . . .        P Near64 00000000 No Seg   *X *External FASTCALL
system . . . . . . . . . . . . .        P Near64 00000000 No Seg   *X *External FASTCALL
tgetenv  . . . . . . . . . . . .        P Near64 00000000 No Seg   *X *External FASTCALL
tmemcmp  . . . . . . . . . . . .        P Near64 00000000 No Seg   *X *External FASTCALL
tmemcpy  . . . . . . . . . . . .        P Near64 00000000 No Seg   *X *External FASTCALL
tmemicmp . . . . . . . . . . . .        P Near64 00000000 No Seg   *X External  FASTCALL
tmemmove . . . . . . . . . . . .        P Near64 00000000 No Seg   *X *External FASTCALL
tmemset  . . . . . . . . . . . .        P Near64 00000000 No Seg   *X *External FASTCALL
tprintf  . . . . . . . . . . . .        P Near64 00000000 No Seg   *X *External FASTCALL
tqsort . . . . . . . . . . . . .        P Near64 00000000 No Seg   *X *External FASTCALL
tsprintf . . . . . . . . . . . .        P Near64 00000000 No Seg   *X External  FASTCALL
tstrcat  . . . . . . . . . . . .        P Near64 00000000 No Seg   *X External  FASTCALL
tstrchr  . . . . . . . . . . . .        P Near64 00000000 No Seg   *X *External FASTCALL
tstrcmp  . . . . . . . . . . . .        P Near64 00000000 No Seg   *X *External FASTCALL
tstrcpy  . . . . . . . . . . . .        P Near64 00000000 No Seg   *X External  FASTCALL
tstricmp . . . . . . . . . . . .        P Near64 00000000 No Seg   *X *External FASTCALL
tstrlen  . . . . . . . . . . . .        P Near64 00000000 No Seg   *X External  FASTCALL
tstrncpy . . . . . . . . . . . .        P Near64 00000000 No Seg   *X *External FASTCALL
tstrrchr . . . . . . . . . . . .        P Near64 00000000 No Seg   *X *External FASTCALL
tstrstart  . . . . . . . . . . .        P Near64 00000000 No Seg   *X *External FASTCALL
tstrstr  . . . . . . . . . . . .        P Near64 00000000 No Seg   *X *External FASTCALL
tstrupr  . . . . . . . . . . . .        P Near64 00000000 No Seg   *X *External FASTCALL
tvfprintf  . . . . . . . . . . .        P Near64 00000000 No Seg   *X *External FASTCALL
tvsprintf  . . . . . . . . . . .        P Near64 00000000 No Seg   *X *External FASTCALL
ultoa  . . . . . . . . . . . . .        P Near64 00000000 No Seg   *X *External FASTCALL
ungetc . . . . . . . . . . . . .        P Near64 00000000 No Seg   *X *External FASTCALL
ungetwc  . . . . . . . . . . . .        P Near64 00000000 No Seg   *X *External FASTCALL
vfprintf . . . . . . . . . . . .        P Near64 00000000 No Seg   *X *External FASTCALL
vfwprintf  . . . . . . . . . . .        P Near64 00000000 No Seg   *X *External FASTCALL
vsprintf . . . . . . . . . . . .        P Near64 00000000 No Seg   *X *External FASTCALL
vswprintf  . . . . . . . . . . .        P Near64 00000000 No Seg   *X *External FASTCALL
vwprintf . . . . . . . . . . . .        P Near64 00000000 No Seg   *X *External FASTCALL
wcscat . . . . . . . . . . . . .        P Near64 00000000 No Seg   *X *External FASTCALL
wcscat_s . . . . . . . . . . . .        P Near64 00000000 No Seg   *X *External FASTCALL
wcschr . . . . . . . . . . . . .        P Near64 00000000 No Seg   *X *External FASTCALL
wcscmp . . . . . . . . . . . . .        P Near64 00000000 No Seg   *X *External FASTCALL
wcscoll  . . . . . . . . . . . .        P Near64 00000000 No Seg   *X *External FASTCALL
wcscpy . . . . . . . . . . . . .        P Near64 00000000 No Seg   *X *External FASTCALL
wcscpy_s . . . . . . . . . . . .        P Near64 00000000 No Seg   *X *External FASTCALL
wcscspn  . . . . . . . . . . . .        P Near64 00000000 No Seg   *X *External FASTCALL
wcslen . . . . . . . . . . . . .        P Near64 00000000 No Seg   *X *External FASTCALL
wcsncat  . . . . . . . . . . . .        P Near64 00000000 No Seg   *X *External FASTCALL
wcsncat_s  . . . . . . . . . . .        P Near64 00000000 No Seg   *X *External FASTCALL
wcsncmp  . . . . . . . . . . . .        P Near64 00000000 No Seg   *X *External FASTCALL
wcsncpy  . . . . . . . . . . . .        P Near64 00000000 No Seg   *X *External FASTCALL
wcsncpy_s  . . . . . . . . . . .        P Near64 00000000 No Seg   *X *External FASTCALL
wcsnlen  . . . . . . . . . . . .        P Near64 00000000 No Seg   *X *External FASTCALL
wcspbrk  . . . . . . . . . . . .        P Near64 00000000 No Seg   *X *External FASTCALL
wcsrchr  . . . . . . . . . . . .        P Near64 00000000 No Seg   *X *External FASTCALL
wcsspn . . . . . . . . . . . . .        P Near64 00000000 No Seg   *X *External FASTCALL
wcsstr . . . . . . . . . . . . .        P Near64 00000000 No Seg   *X *External FASTCALL
wcstod . . . . . . . . . . . . .        P Near64 00000000 No Seg   *X *External FASTCALL
wcstof . . . . . . . . . . . . .        P Near64 00000000 No Seg   *X *External FASTCALL
wcstok . . . . . . . . . . . . .        P Near64 00000000 No Seg   *X *External FASTCALL
wcstok_s . . . . . . . . . . . .        P Near64 00000000 No Seg   *X *External FASTCALL
wcstol . . . . . . . . . . . . .        P Near64 00000000 No Seg   *X *External FASTCALL
wcstold  . . . . . . . . . . . .        P Near64 00000000 No Seg   *X *External FASTCALL
wcstoll  . . . . . . . . . . . .        P Near64 00000000 No Seg   *X *External FASTCALL
wcstombs_s . . . . . . . . . . .        P Near64 00000000 No Seg   *X *External FASTCALL
wcstoul  . . . . . . . . . . . .        P Near64 00000000 No Seg   *X *External FASTCALL
wcstoull . . . . . . . . . . . .        P Near64 00000000 No Seg   *X *External FASTCALL
wcsxfrm  . . . . . . . . . . . .        P Near64 00000000 No Seg   *X *External FASTCALL
wctomb . . . . . . . . . . . . .        P Near64 00000000 No Seg   *X *External FASTCALL
wctomb_s . . . . . . . . . . . .        P Near64 00000000 No Seg   *X *External FASTCALL
wprintf  . . . . . . . . . . . .        P Near64 00000000 No Seg   *X *External FASTCALL
write_logo . . . . . . . . . . .        P Near64 00000000 No Seg   *X *External FASTCALL
write_options  . . . . . . . . .        P Near64 00000000 No Seg   *X *External FASTCALL
write_usage  . . . . . . . . . .        P Near64 00000000 No Seg   *X *External FASTCALL
wscanf . . . . . . . . . . . . .        P Near64 00000000 No Seg   *X *External FASTCALL


Symbols:

                N a m e                 Type       Value     Attr

.lodsd . . . . . . . . . . . . .        Text   lodsq
.movsd . . . . . . . . . . . . .        Text   movsq
.stosd . . . . . . . . . . . . .        Text   stosq
AP_FWAIT . . . . . . . . . . . .        Number             4h 
AP_LOCK  . . . . . . . . . . . .        Number             1h 
AP_NO_FWAIT  . . . . . . . . . .        Number             5h 
AP_REP . . . . . . . . . . . . .        Number             2h 
AP_REPxx . . . . . . . . . . . .        Number             3h 
ARCH_AVX . . . . . . . . . . . .        Number             3h 
ARCH_AVX2  . . . . . . . . . . .        Number             4h 
ARCH_AVX512  . . . . . . . . . .        Number             5h 
ARCH_IX86_FP . . . . . . . . . .        Number             0h 
ARCH_SSE . . . . . . . . . . . .        Number             1h 
ARCH_SSE2  . . . . . . . . . . .        Number             2h 
ASM  . . . . . . . . . . . . . .        Number             0h 
ASMC_MAJOR_VER . . . . . . . . .        Number             2h 
ASMC_MINOR_VER . . . . . . . . .        Number            22h 
ASMC_SUBMINOR_VER  . . . . . . .        Number            1Bh 
ASMC_VERSION . . . . . . . . . .        Number            EAh 
ASMC_VERSSTR . . . . . . . . . .        Text   "2.34.27"
ASSUME_CS  . . . . . . . . . . .        Number             1h 
ASSUME_DS  . . . . . . . . . . .        Number             3h 
ASSUME_ES  . . . . . . . . . . .        Number             0h 
ASSUME_FS  . . . . . . . . . . .        Number             4h 
ASSUME_GS  . . . . . . . . . . .        Number             5h 
ASSUME_NOTHING . . . . . . . . .        Number      FFFFFFFEh 
ASSUME_SS  . . . . . . . . . . .        Number             2h 
AT_ALL . . . . . . . . . . . . .        Number           1FFh 
AT_BF  . . . . . . . . . . . . .        Number            40h 
AT_CONST . . . . . . . . . . . .        Number            21h 
AT_FIELD . . . . . . . . . . . .        Number            10h 
AT_FLOAT . . . . . . . . . . . .        Number           100h 
AT_IND . . . . . . . . . . . . .        Number             4h 
AT_LABEL . . . . . . . . . . . .        Number             2h 
AT_LF  . . . . . . . . . . . . .        Number            12h 
AT_LFN . . . . . . . . . . . . .        Number            32h 
AT_LIF . . . . . . . . . . . . .        Number            16h 
AT_NUM . . . . . . . . . . . . .        Number            20h 
AT_REG . . . . . . . . . . . . .        Number             8h 
AT_TBF . . . . . . . . . . . . .        Number            41h 
AT_TL  . . . . . . . . . . . . .        Number             3h 
AT_TLF . . . . . . . . . . . . .        Number            13h 
AT_TLFN  . . . . . . . . . . . .        Number            33h 
AT_TLN . . . . . . . . . . . . .        Number            23h 
AT_TLR . . . . . . . . . . . . .        Number             Bh 
AT_TYPE  . . . . . . . . . . . .        Number             1h 
AT_UNDEF . . . . . . . . . . . .        Number            80h 
AliasTable . . . . . . . . . . .        Text   SymTables[TAB_ALIAS*symbol_queue].head
BIN_DISALLOWED . . . . . . . . .        Number             0h 
BLOCK_ACTIVE . . . . . . . . . .        Number             0h 
BLOCK_DONE . . . . . . . . . . .        Number             2h 
BLOCK_INACTIVE . . . . . . . . .        Number             1h 
CC_BLKARG  . . . . . . . . . . .        Number             3h 
CC_LITARG  . . . . . . . . . . .        Number             2h 
CC_NULL  . . . . . . . . . . . .        Number             0h 
CC_NUMARG  . . . . . . . . . . .        Number             1h 
CC_PASS1 . . . . . . . . . . . .        Number             5h 
CC_PASS2 . . . . . . . . . . . .        Number             6h 
CC_SYMARG  . . . . . . . . . . .        Number             4h 
CHAR_BIT . . . . . . . . . . . .        Number             8h 
CHAR_MAX . . . . . . . . . . . .        Number            7Fh 
CHAR_MIN . . . . . . . . . . . .        Number     -00000080h 
CHEXPREFIX . . . . . . . . . . .        Number             0h 
CI_BASE_RIP  . . . . . . . . . .        Number            80h 
CI_CONST_SIZE_FIXED  . . . . . .        Number             8h 
CI_ISDIRECT  . . . . . . . . . .        Number             2h 
CI_ISFAR . . . . . . . . . . . .        Number             4h 
CI_ISWIDE  . . . . . . . . . . .        Number             1h 
CI_UNDEF_SYM . . . . . . . . . .        Number            40h 
CI_X86HI_USED  . . . . . . . . .        Number            10h 
CI_x64LO_USED  . . . . . . . . .        Number            20h 
COFF32_DISALLOWED  . . . . . . .        Number           E12h 
COFF64_DISALLOWED  . . . . . . .        Number           E12h 
CPU_186  . . . . . . . . . . . .        Number             1h 
CPU_286  . . . . . . . . . . . .        Number             2h 
CPU_386  . . . . . . . . . . . .        Number             3h 
CPU_486  . . . . . . . . . . . .        Number             4h 
CPU_586  . . . . . . . . . . . .        Number             5h 
CPU_64 . . . . . . . . . . . . .        Number             Ah 
CPU_686  . . . . . . . . . . . .        Number             6h 
CPU_86 . . . . . . . . . . . . .        Number             0h 
CPU_MMX  . . . . . . . . . . . .        Number             7h 
CPU_SSE  . . . . . . . . . . . .        Number             8h 
CPU_SSE2 . . . . . . . . . . . .        Number             9h 
CSF_GRPCHK . . . . . . . . . . .        Number             1h 
CSI_BSS  . . . . . . . . . . . .        Number             3h 
CSI_CONST  . . . . . . . . . . .        Number             2h 
CSI_DATA . . . . . . . . . . . .        Number             1h 
CSI_TEXT . . . . . . . . . . . .        Number             0h 
CVEX_MAX . . . . . . . . . . . .        Number             3h 
CVEX_MIN . . . . . . . . . . . .        Number             0h 
CVEX_NORMAL  . . . . . . . . . .        Number             2h 
CVEX_REDUCED . . . . . . . . . .        Number             1h 
CVO_STATICTLS  . . . . . . . . .        Number             1h 
CurrFName  . . . . . . . . . . .        Text   ModuleInfo.curr_fname
CurrFile . . . . . . . . . . . .        Text   ModuleInfo.curr_file
CurrIfState  . . . . . . . . . .        DWord              0h *External FASTCALL
CurrSeg  . . . . . . . . . . . .        Text   ModuleInfo.currseg
CurrSource . . . . . . . . . . .        Text   ModuleInfo.currsource
CurrStruct . . . . . . . . . . .        Near               0h *External FASTCALL
CurrWordSize . . . . . . . . . .        Text   ModuleInfo.wordsize
DBG_UNREFERENCED_LOCAL_VARIABLE         Text   UNREFERENCED_PARAMETER
DBG_UNREFERENCED_PARAMETER . . .        Text   UNREFERENCED_PARAMETER
DF_CEXPR . . . . . . . . . . . .        Number             1h 
DF_CGEN  . . . . . . . . . . . .        Number           100h 
DF_LABEL . . . . . . . . . . . .        Number             8h 
DF_NOCONCAT  . . . . . . . . . .        Number            20h 
DF_NOEXPAND  . . . . . . . . . .        Number             4h 
DF_NOSTRUC . . . . . . . . . . .        Number            10h 
DF_PROC  . . . . . . . . . . . .        Number            40h 
DF_STORE . . . . . . . . . . . .        Number            80h 
DF_STRPARM . . . . . . . . . . .        Number             2h 
DRT_ALIAS  . . . . . . . . . . .        Number            2Dh 
DRT_ALIGN  . . . . . . . . . . .        Number            27h 
DRT_ASSERT . . . . . . . . . . .        Number            38h 
DRT_ASSUME . . . . . . . . . . .        Number            2Bh 
DRT_CATSTR . . . . . . . . . . .        Number             5h 
DRT_CLASS  . . . . . . . . . . .        Number            3Ah 
DRT_COMM . . . . . . . . . . . .        Number            1Dh 
DRT_CONDDIR  . . . . . . . . . .        Number             0h 
DRT_CONTEXT  . . . . . . . . . .        Number            35h 
DRT_CPU  . . . . . . . . . . . .        Number             Bh 
DRT_DATADIR  . . . . . . . . . .        Number             8h 
DRT_DOT_NAME . . . . . . . . . .        Number            33h 
DRT_ECHO . . . . . . . . . . . .        Number            2Eh 
DRT_END  . . . . . . . . . . . .        Number             9h 
DRT_ENDP . . . . . . . . . . . .        Number            23h 
DRT_ENDS . . . . . . . . . . . .        Number            29h 
DRT_ENUM . . . . . . . . . . . .        Number            3Eh 
DRT_EQU  . . . . . . . . . . . .        Number            2Fh 
DRT_EQUALSGN . . . . . . . . . .        Number            30h 
DRT_ERRDIR . . . . . . . . . . .        Number             Ah 
DRT_EXCFRAME . . . . . . . . . .        Number            19h 
DRT_EXTERN . . . . . . . . . . .        Number            1Eh 
DRT_EXTERNDEF  . . . . . . . . .        Number            1Fh 
DRT_GROUP  . . . . . . . . . . .        Number            2Ah 
DRT_HLLEND . . . . . . . . . . .        Number            12h 
DRT_HLLEXIT  . . . . . . . . . .        Number            11h 
DRT_HLLFOR . . . . . . . . . . .        Number            36h 
DRT_HLLSTART . . . . . . . . . .        Number            10h 
DRT_INCBIN . . . . . . . . . . .        Number            31h 
DRT_INCLIB . . . . . . . . . . .        Number            32h 
DRT_INCLUDE  . . . . . . . . . .        Number             3h 
DRT_INSTR  . . . . . . . . . . .        Number            17h 
DRT_INVOKE . . . . . . . . . . .        Number            25h 
DRT_LABEL  . . . . . . . . . . .        Number            2Ch 
DRT_LISTING  . . . . . . . . . .        Number             Ch 
DRT_LISTMAC  . . . . . . . . . .        Number             Dh 
DRT_LOCAL  . . . . . . . . . . .        Number            24h 
DRT_LOOPDIR  . . . . . . . . . .        Number             1h 
DRT_MACINT . . . . . . . . . . .        Number             7h 
DRT_MACRO  . . . . . . . . . . .        Number             4h 
DRT_MODEL  . . . . . . . . . . .        Number            14h 
DRT_NAMESPACE  . . . . . . . . .        Number            3Fh 
DRT_NEW  . . . . . . . . . . . .        Number            3Ch 
DRT_OPTION . . . . . . . . . . .        Number            34h 
DRT_ORG  . . . . . . . . . . . .        Number            26h 
DRT_PRAGMA . . . . . . . . . . .        Number            3Bh 
DRT_PROC . . . . . . . . . . . .        Number            22h 
DRT_PROTO  . . . . . . . . . . .        Number            20h 
DRT_PUBLIC . . . . . . . . . . .        Number            21h 
DRT_PURGE  . . . . . . . . . . .        Number             2h 
DRT_RADIX  . . . . . . . . . . .        Number            15h 
DRT_RECORD . . . . . . . . . . .        Number            1Ch 
DRT_RETURN . . . . . . . . . . .        Number            3Dh 
DRT_SAFESEH  . . . . . . . . . .        Number            16h 
DRT_SEGMENT  . . . . . . . . . .        Number            28h 
DRT_SEGORDER . . . . . . . . . .        Number             Eh 
DRT_SIMSEG . . . . . . . . . . .        Number             Fh 
DRT_SIZESTR  . . . . . . . . . .        Number            18h 
DRT_STARTEXIT  . . . . . . . . .        Number            13h 
DRT_STRUCT . . . . . . . . . . .        Number            1Ah 
DRT_SUBSTR . . . . . . . . . . .        Number             6h 
DRT_SWITCH . . . . . . . . . . .        Number            37h 
DRT_TYPEDEF  . . . . . . . . . .        Number            1Bh 
DRT_UNDEF  . . . . . . . . . . .        Number            39h 
DS0000 . . . . . . . . . . . . .        Byte               8h _DATA FASTCALL
DS0001 . . . . . . . . . . . . .        Byte[3]            9h _DATA FASTCALL
DS0002 . . . . . . . . . . . . .        Byte[11]           Ch _DATA FASTCALL
DS0003 . . . . . . . . . . . . .        Byte[8]           17h _DATA FASTCALL
DS0004 . . . . . . . . . . . . .        Byte[6]           1Fh _DATA FASTCALL
D_EXPBIAS  . . . . . . . . . . .        Number           3FFh 
D_EXPBITS  . . . . . . . . . . .        Number             Bh 
D_EXPMASK  . . . . . . . . . . .        Number           7FFh 
D_EXPMAX . . . . . . . . . . . .        Number           400h 
D_SIGBITS  . . . . . . . . . . .        Number            35h 
DefaultDir . . . . . . . . . . .        Near               0h *External FASTCALL
ELF32_DISALLOWED . . . . . . . .        Number           F00h 
ELF64_DISALLOWED . . . . . . . .        Number           F00h 
EMPTY  . . . . . . . . . . . . .        Number     -00000002h 
EOF  . . . . . . . . . . . . . .        Number     -00000001h 
ERR  . . . . . . . . . . . . . .        Number             3h 
ERROR  . . . . . . . . . . . . .        Number     -00000001h 
EXPF_IN_SQBR . . . . . . . . . .        Number             8h 
EXPF_NOERRMSG  . . . . . . . . .        Number             1h 
EXPF_NOUNDEF . . . . . . . . . .        Number             2h 
EXPF_ONEOPND . . . . . . . . . .        Number             4h 
EXPR_ADDR  . . . . . . . . . . .        Number             1h 
EXPR_CONST . . . . . . . . . . .        Number             0h 
EXPR_EMPTY . . . . . . . . . . .        Number      FFFFFFFEh 
EXPR_ERROR . . . . . . . . . . .        Number      FFFFFFFFh 
EXPR_FLOAT . . . . . . . . . . .        Number             3h 
EXPR_REG . . . . . . . . . . . .        Number             2h 
E_ASSUMECHECK  . . . . . . . . .        Number            40h 
E_EXPLICIT . . . . . . . . . . .        Number             2h 
E_INDIRECT . . . . . . . . . . .        Number             1h 
E_IS_ABS . . . . . . . . . . . .        Number             4h 
E_IS_DOT . . . . . . . . . . . .        Number            80h 
E_IS_OPEATTR . . . . . . . . . .        Number            10h 
E_IS_TYPE  . . . . . . . . . . .        Number             8h 
E_NEGATIVE . . . . . . . . . . .        Number            20h 
ExtTable . . . . . . . . . . . .        Text   SymTables[TAB_EXT*symbol_queue].head
FALSE  . . . . . . . . . . . . .        Number             0h 
FCT_ELF64  . . . . . . . . . . .        Number             3h 
FCT_MSC  . . . . . . . . . . . .        Number             0h 
FCT_VEC32  . . . . . . . . . . .        Number             4h 
FCT_VEC64  . . . . . . . . . . .        Number             5h 
FCT_WATCOMC  . . . . . . . . . .        Number             1h 
FCT_WIN64  . . . . . . . . . . .        Number             2h 
FILENAME_MAX . . . . . . . . . .        Number           104h 
FIX_HIBYTE . . . . . . . . . . .        Number             Bh 
FIX_LAST . . . . . . . . . . . .        Number             Eh 
FIX_OFF16  . . . . . . . . . . .        Number             5h 
FIX_OFF32  . . . . . . . . . . .        Number             6h 
FIX_OFF32_IMGREL . . . . . . . .        Number             Ch 
FIX_OFF32_SECREL . . . . . . . .        Number             Dh 
FIX_OFF64  . . . . . . . . . . .        Number             7h 
FIX_OFF8 . . . . . . . . . . . .        Number             4h 
FIX_PTR16  . . . . . . . . . . .        Number             9h 
FIX_PTR32  . . . . . . . . . . .        Number             Ah 
FIX_RELOFF16 . . . . . . . . . .        Number             2h 
FIX_RELOFF32 . . . . . . . . . .        Number             3h 
FIX_RELOFF8  . . . . . . . . . .        Number             1h 
FIX_SEG  . . . . . . . . . . . .        Number             8h 
FIX_VOID . . . . . . . . . . . .        Number             0h 
FPO_EMULATION  . . . . . . . . .        Number             1h 
FPO_NO_EMULATION . . . . . . . .        Number             0h 
FX_LOADER_RESOLVED . . . . . . .        Number             1h 
FX_ORGOCCURED  . . . . . . . . .        Number             2h 
F_EXPBIAS  . . . . . . . . . . .        Number            7Fh 
F_EXPBITS  . . . . . . . . . . .        Number             8h 
F_EXPMASK  . . . . . . . . . . .        Number            FFh 
F_EXPMAX . . . . . . . . . . . .        Number            80h 
F_SIGBITS  . . . . . . . . . . .        Number            18h 
GMEM_DDESHARE  . . . . . . . . .        Number          2000h 
GMEM_MOVEABLE  . . . . . . . . .        Number             2h 
HEAP_ZERO_MEMORY . . . . . . . .        Number             8h 
H_EXPBIAS  . . . . . . . . . . .        Number             Fh 
H_EXPBITS  . . . . . . . . . . .        Number             5h 
H_EXPMASK  . . . . . . . . . . .        Number            1Fh 
H_EXPMAX . . . . . . . . . . . .        Number            10h 
H_SIGBITS  . . . . . . . . . . .        Number             Bh 
I32_SPEC . . . . . . . . . . . .        Text   ""
I64_SPEC . . . . . . . . . . . .        Text   "I64"
II_ALLOWED_PREFIX  . . . . . . .        Number             7h 
II_FIRST . . . . . . . . . . . .        Number             8h 
II_OPND_DIR  . . . . . . . . . .        Number            80h 
II_RM_INFO . . . . . . . . . . .        Number            70h 
INFINITY . . . . . . . . . . . .        Text   7FFF0000000000000000000000000000r
INS_FIRST_1  . . . . . . . . . .        Number           22Ah 
INT_MAX  . . . . . . . . . . . .        Number      7FFFFFFFh 
INT_MIN  . . . . . . . . . . . .        Number     -80000000h 
InstrTable . . . . . . . . . . .        instr_item         0h *External FASTCALL
LANG_BASIC . . . . . . . . . . .        Number             6h 
LANG_C . . . . . . . . . . . . .        Number             1h 
LANG_FASTCALL  . . . . . . . . .        Number             7h 
LANG_FORTRAN . . . . . . . . . .        Number             5h 
LANG_NONE  . . . . . . . . . . .        Number             0h 
LANG_PASCAL  . . . . . . . . . .        Number             4h 
LANG_STDCALL . . . . . . . . . .        Number             3h 
LANG_SYSCALL . . . . . . . . . .        Number             2h 
LANG_VECTORCALL  . . . . . . . .        Number             8h 
LANG_WATCALL . . . . . . . . . .        Number             9h 
LD_EXPBIAS . . . . . . . . . . .        Number          3FFFh 
LD_EXPBITS . . . . . . . . . . .        Number             Fh 
LD_EXPMASK . . . . . . . . . . .        Number          7FFFh 
LD_EXPMAX  . . . . . . . . . . .        Number          4000h 
LD_SIGBITS . . . . . . . . . . .        Number            40h 
LLONG_MAX  . . . . . . . . . . .        Number      FFFFFFFFh 
LLONG_MIN  . . . . . . . . . . .        Number      0h 
LM_LISTMACRO . . . . . . . . . .        Number             1h 
LM_LISTMACROALL  . . . . . . . .        Number             2h 
LM_NOLISTMACRO . . . . . . . . .        Number             0h 
LNAME_NULL . . . . . . . . . . .        Number             0h 
LOF_LISTED . . . . . . . . . . .        Number             1h 
LOF_SKIPPOS  . . . . . . . . . .        Number             2h 
LONGDOUBLE_IS_DOUBLE . . . . . .        Number             0h 
LONG_IS_INT  . . . . . . . . . .        Number             1h 
LONG_MAX . . . . . . . . . . . .        Number      7FFFFFFFh 
LONG_MIN . . . . . . . . . . . .        Number     -80000000h 
LST  . . . . . . . . . . . . . .        Number             2h 
LSTTYPE_CODE . . . . . . . . . .        Number             1h 
LSTTYPE_DATA . . . . . . . . . .        Number             0h 
LSTTYPE_DIRECTIVE  . . . . . . .        Number             4h 
LSTTYPE_EQUATE . . . . . . . . .        Number             2h 
LSTTYPE_LABEL  . . . . . . . . .        Number             7h 
LSTTYPE_MACRO  . . . . . . . . .        Number             5h 
LSTTYPE_MACROLINE  . . . . . . .        Number             8h 
LSTTYPE_STRUCT . . . . . . . . .        Number             6h 
LSTTYPE_TMACRO . . . . . . . . .        Number             3h 
LastCodeBufSize  . . . . . . . .        DWord              0h *External FASTCALL
LinnumQueue  . . . . . . . . . .        qdesc              0h *External FASTCALL
MAX_ID_LEN . . . . . . . . . . .        Number            F7h 
MAX_IF_NESTING . . . . . . . . .        Number            1Eh 
MAX_LINE_LEN . . . . . . . . . .        Number           800h 
MAX_LNAME  . . . . . . . . . . .        Number            FFh 
MAX_MACRO_NESTING  . . . . . . .        Number            64h 
MAX_OPND . . . . . . . . . . . .        Number             3h 
MAX_SEGALIGNMENT . . . . . . . .        Number            FFh 
MAX_SEGMENT_ALIGN  . . . . . . .        Number          1000h 
MAX_SEG_NESTING  . . . . . . . .        Number            14h 
MAX_STRING_LEN . . . . . . . . .        Number           7E0h 
MAX_STRUCT_ALIGN . . . . . . . .        Number            20h 
MAX_STRUCT_NESTING . . . . . . .        Number            20h 
MAX_TEXTMACRO_NESTING  . . . . .        Number            14h 
MAX_TOKEN  . . . . . . . . . . .        Number           200h 
MB_CUR_MAX . . . . . . . . . . .        Text   ___mb_cur_max_func()
MB_LEN_MAX . . . . . . . . . . .        Number             2h 
MF_IGNARGS . . . . . . . . . . .        Number             4h 
MF_LABEL . . . . . . . . . . . .        Number             1h 
MF_NOSAVE  . . . . . . . . . . .        Number             2h 
MINFINITY  . . . . . . . . . . .        Text   0FFFF0000000000000000000000000000r
MODEL_COMPACT  . . . . . . . . .        Number             3h 
MODEL_FLAT . . . . . . . . . . .        Number             7h 
MODEL_HUGE . . . . . . . . . . .        Number             6h 
MODEL_LARGE  . . . . . . . . . .        Number             5h 
MODEL_MEDIUM . . . . . . . . . .        Number             4h 
MODEL_NONE . . . . . . . . . . .        Number             0h 
MODEL_SMALL  . . . . . . . . . .        Number             2h 
MODEL_TINY . . . . . . . . . . .        Number             1h 
MT_ABS . . . . . . . . . . . . .        Number            C2h 
MT_ADDRESS . . . . . . . . . . .        Number            80h 
MT_BITS  . . . . . . . . . . . .        Number            C1h 
MT_BYTE  . . . . . . . . . . . .        Number             0h 
MT_DWORD . . . . . . . . . . . .        Number             3h 
MT_EMPTY . . . . . . . . . . . .        Number            C0h 
MT_FAR . . . . . . . . . . . . .        Number            82h 
MT_FLOAT . . . . . . . . . . . .        Number            20h 
MT_FWORD . . . . . . . . . . . .        Number             5h 
MT_NEAR  . . . . . . . . . . . .        Number            81h 
MT_OWORD . . . . . . . . . . . .        Number             Fh 
MT_PROC  . . . . . . . . . . . .        Number            80h 
MT_PTR . . . . . . . . . . . . .        Number            C3h 
MT_QWORD . . . . . . . . . . . .        Number             7h 
MT_REAL10  . . . . . . . . . . .        Number            29h 
MT_REAL16  . . . . . . . . . . .        Number            2Fh 
MT_REAL2 . . . . . . . . . . . .        Number            21h 
MT_REAL4 . . . . . . . . . . . .        Number            23h 
MT_REAL8 . . . . . . . . . . . .        Number            27h 
MT_SBYTE . . . . . . . . . . . .        Number            40h 
MT_SDWORD  . . . . . . . . . . .        Number            43h 
MT_SIGNED  . . . . . . . . . . .        Number            40h 
MT_SIZE_MASK . . . . . . . . . .        Number            1Fh 
MT_SPECIAL . . . . . . . . . . .        Number            80h 
MT_SPECIAL_MASK  . . . . . . . .        Number            C0h 
MT_SQWORD  . . . . . . . . . . .        Number            47h 
MT_SWORD . . . . . . . . . . . .        Number            41h 
MT_TBYTE . . . . . . . . . . . .        Number             9h 
MT_TYPE  . . . . . . . . . . . .        Number            C4h 
MT_WORD  . . . . . . . . . . . .        Number             1h 
MT_YMMWORD . . . . . . . . . . .        Number            1Fh 
MT_YWORD . . . . . . . . . . . .        Number            1Fh 
MT_ZMMWORD . . . . . . . . . . .        Number            3Fh 
MT_ZWORD . . . . . . . . . . . .        Number            3Fh 
M_186  . . . . . . . . . . . . .        Number             2h 
M_1_PI . . . . . . . . . . . . .        Text   0.31830988618379067153776752674502872406891929148091
M_1_SQRTPI . . . . . . . . . . .        Text   0.56418958354775628694807945156077258584405062932900
M_286  . . . . . . . . . . . . .        Number             4h 
M_287  . . . . . . . . . . . . .        Number           400h 
M_2_PI . . . . . . . . . . . . .        Text   0.63661977236758134307553505349005744813783858296183
M_2_SQRTPI . . . . . . . . . . .        Text   1.12837916709551257389615890312154517168810125865800
M_386  . . . . . . . . . . . . .        Number             8h 
M_387  . . . . . . . . . . . . .        Number           800h 
M_3PI_4  . . . . . . . . . . . .        Text   2.35619449019234492884698253745962716314787704953133
M_486  . . . . . . . . . . . . .        Number            10h 
M_586  . . . . . . . . . . . . .        Number            20h 
M_686  . . . . . . . . . . . . .        Number            40h 
M_8086 . . . . . . . . . . . . .        Number             1h 
M_8087 . . . . . . . . . . . . .        Number           100h 
M_ACC2 . . . . . . . . . . . . .        Text   2.640647263387478295711248440058223113730493441
M_ACC3 . . . . . . . . . . . . .        Text   4.287372893578830648645201991089526317058943389
M_ACC4 . . . . . . . . . . . . .        Text   5.534907817649887676220380749279383354399213359
M_C2 . . . . . . . . . . . . . .        Text   0.660161815846869573927812110014555778432623360
M_C3 . . . . . . . . . . . . . .        Text   0.635166354604271207206696591272522417342065687
M_C4 . . . . . . . . . . . . . .        Text   0.307494878758327093123354486071076853022178520
M_CPUMSK . . . . . . . . . . . .        Number            7Fh 
M_E  . . . . . . . . . . . . . .        Text   2.71828182845904523536028747135266249775724709369996
M_HL2  . . . . . . . . . . . . .        Text   1.320323631693739147855624220029111556865246721
M_HL3  . . . . . . . . . . . . .        Text   2.858248595719220432430134660726350878039295593
M_HL4  . . . . . . . . . . . . .        Text   4.151180863237415757165285561959537515799410019
M_INVLN2 . . . . . . . . . . . .        Text   1.44269504088896340735992468100189213742664595415299
M_ISFUNC . . . . . . . . . . . .        Number             2h 
M_ISVARARG . . . . . . . . . . .        Number             1h 
M_IVLN10 . . . . . . . . . . . .        Text   0.43429448190325182765112891891660508229439700580367
M_LABEL  . . . . . . . . . . . .        Number             4h 
M_LI2  . . . . . . . . . . . . .        Text   1.045163780117492784844588889194613136522615578
M_LN10 . . . . . . . . . . . . .        Text   2.30258509299404568401799145468436420760110148862877
M_LN2  . . . . . . . . . . . . .        Text   0.69314718055994530941723212145817656807550013436026
M_LN2_CUBED  . . . . . . . . . .        Text   0.33302465198892947971885358261173054415612648534861
M_LN2_SQUARED  . . . . . . . . .        Text   0.48045301391820142466710252632666497173055295159455
M_LOG10E . . . . . . . . . . . .        Text   0.43429448190325182765112891891660508229439700580367
M_LOG2 . . . . . . . . . . . . .        Text   0.30102999566398119521373889472449302676818988146211
M_LOG2E  . . . . . . . . . . . .        Text   1.44269504088896340735992468100189213742664595415299
M_LOG2_E . . . . . . . . . . . .        Text   0.69314718055994530941723212145817656807550013436026
M_LOGE . . . . . . . . . . . . .        Text   0.43429448190325182765112891891660508229439700580367
M_MULTILINE  . . . . . . . . . .        Number             8h 
M_PI . . . . . . . . . . . . . .        Text   3.14159265358979323846264338327950288419716939937511
M_PI_2 . . . . . . . . . . . . .        Text   1.57079632679489661923132169163975144209858469968755
M_PI_4 . . . . . . . . . . . . .        Text   0.78539816339744830961566084581987572104929234984378
M_PROT . . . . . . . . . . . . .        Number            80h 
M_PURGED . . . . . . . . . . . .        Number            10h 
M_SQRT1_2  . . . . . . . . . . .        Text   0.70710678118654752440084436210484903928483593768847
M_SQRT2  . . . . . . . . . . . .        Text   1.41421356237309504880168872420969807856967187537695
M_SQRT3  . . . . . . . . . . . .        Text   1.73205080756887729352744634150587236694280525381038
M_SQRTPI . . . . . . . . . . . .        Text   1.77245385090551602729816748334114518279754945612239
M_TWOPI  . . . . . . . . . . . .        Text   6.28318530717958647692528676655900576839433879875021
MacroLevel . . . . . . . . . . .        DWord              4h _DATA Public FASTCALL
MacroLocals  . . . . . . . . . .        int_t              0h _DATA Public FASTCALL
ModelToken . . . . . . . . . . .        Near               0h *External FASTCALL
ModuleInfo . . . . . . . . . . .        module_info         0h External FASTCALL
NAN  . . . . . . . . . . . . . .        Text   0FFFF8000000000000000000000000000r
NOTE_INCLUDED_BY . . . . . . . .        Number             0h 
NOTE_ITERATION_MACRO_CALLED_FROM         Number             2h 
NOTE_MACRO_CALLED_FROM . . . . .        Number             1h 
NOTE_MAIN_LINE_CODE  . . . . . .        Number             3h 
NOT_ERROR  . . . . . . . . . . .        Number             0h 
NO_OPPRFX  . . . . . . . . . . .        Number          FD00h 
NTDDI_LONGHORN . . . . . . . . .        Number       6000000h 
NTDDI_VERSION  . . . . . . . . .        Number       6010000h 
NTDDI_VISTA  . . . . . . . . . .        Number       6000000h 
NTDDI_VISTASP1 . . . . . . . . .        Number       6000100h 
NTDDI_VISTASP2 . . . . . . . . .        Number       6000200h 
NTDDI_VISTASP3 . . . . . . . . .        Number       6000300h 
NTDDI_VISTASP4 . . . . . . . . .        Number       6000400h 
NTDDI_WIN10  . . . . . . . . . .        Number       A000000h 
NTDDI_WIN10_19H1 . . . . . . . .        Number       A000007h 
NTDDI_WIN10_MN . . . . . . . . .        Number       A000009h 
NTDDI_WIN10_RS1  . . . . . . . .        Number       A000002h 
NTDDI_WIN10_RS2  . . . . . . . .        Number       A000003h 
NTDDI_WIN10_RS3  . . . . . . . .        Number       A000004h 
NTDDI_WIN10_RS4  . . . . . . . .        Number       A000005h 
NTDDI_WIN10_RS5  . . . . . . . .        Number       A000006h 
NTDDI_WIN10_TH2  . . . . . . . .        Number       A000001h 
NTDDI_WIN10_VB . . . . . . . . .        Number       A000008h 
NTDDI_WIN2003  . . . . . . . . .        Number       5000000h 
NTDDI_WIN2K  . . . . . . . . . .        Number       5000000h 
NTDDI_WIN2KSP1 . . . . . . . . .        Number       5000100h 
NTDDI_WIN2KSP2 . . . . . . . . .        Number       5000200h 
NTDDI_WIN2KSP3 . . . . . . . . .        Number       5000300h 
NTDDI_WIN2KSP4 . . . . . . . . .        Number       5000400h 
NTDDI_WIN6 . . . . . . . . . . .        Number       6000000h 
NTDDI_WIN6SP1  . . . . . . . . .        Number       6000100h 
NTDDI_WIN6SP2  . . . . . . . . .        Number       6000200h 
NTDDI_WIN6SP3  . . . . . . . . .        Number       6000300h 
NTDDI_WIN6SP4  . . . . . . . . .        Number       6000400h 
NTDDI_WIN7 . . . . . . . . . . .        Number       6010000h 
NTDDI_WIN7SP1  . . . . . . . . .        Number       6010100h 
NTDDI_WIN8 . . . . . . . . . . .        Number       6020000h 
NTDDI_WINBLUE  . . . . . . . . .        Number       6030000h 
NTDDI_WINTHRESHOLD . . . . . . .        Number       A000000h 
NTDDI_WINXP  . . . . . . . . . .        Number       5010000h 
NTDDI_WINXPSP1 . . . . . . . . .        Number       5010100h 
NTDDI_WINXPSP2 . . . . . . . . .        Number       5010200h 
NTDDI_WINXPSP3 . . . . . . . . .        Number       5010300h 
NTDDI_WINXPSP4 . . . . . . . . .        Number       5010400h 
NTDDI_WS03 . . . . . . . . . . .        Number       5020000h 
NTDDI_WS03SP1  . . . . . . . . .        Number       5020100h 
NTDDI_WS03SP2  . . . . . . . . .        Number       5020200h 
NTDDI_WS03SP3  . . . . . . . . .        Number       5020300h 
NTDDI_WS03SP4  . . . . . . . . .        Number       5020400h 
NTDDI_WS08 . . . . . . . . . . .        Number       6000100h 
NTDDI_WS08SP2  . . . . . . . . .        Number       6000200h 
NTDDI_WS08SP3  . . . . . . . . .        Number       6000300h 
NTDDI_WS08SP4  . . . . . . . . .        Number       6000400h 
NULL . . . . . . . . . . . . . .        Number             0h 
NULLC  . . . . . . . . . . . . .        Number             0h 
NUM_FILE_TYPES . . . . . . . . .        Number             4h 
OBJ  . . . . . . . . . . . . . .        Number             1h 
OFORMAT_BIN  . . . . . . . . . .        Number             0h 
OFORMAT_COFF . . . . . . . . . .        Number             2h 
OFORMAT_ELF  . . . . . . . . . .        Number             3h 
OFORMAT_OMF  . . . . . . . . . .        Number             1h 
OLDKEYWORDS  . . . . . . . . . .        Number             0h 
OMF_DISALLOWED . . . . . . . . .        Number             0h 
OP3_CL . . . . . . . . . . . . .        Number             1h 
OP3_HID  . . . . . . . . . . . .        Number             5h 
OP3_I  . . . . . . . . . . . . .        Number             4h 
OP3_I8_U . . . . . . . . . . . .        Number             2h 
OP3_K  . . . . . . . . . . . . .        Number             3h 
OP3_NONE . . . . . . . . . . . .        Number             0h 
OP3_RGT16  . . . . . . . . . . .        Number             3h 
OP3_R_MS . . . . . . . . . . . .        Number             3h 
OP3_XMM  . . . . . . . . . . . .        Number             3h 
OP3_XMM0 . . . . . . . . . . . .        Number             3h 
OP3_YMM  . . . . . . . . . . . .        Number             3h 
OP3_ZMM  . . . . . . . . . . . .        Number             3h 
OPERANDS_H . . . . . . . . . . .        Number             0h 
OPND1  . . . . . . . . . . . . .        Number             0h 
OPND2  . . . . . . . . . . . . .        Number             1h 
OPND3  . . . . . . . . . . . . .        Number             2h 
OPNI2  . . . . . . . . . . . . .        Number            14h 
OPNI3  . . . . . . . . . . . . .        Number            28h 
OPSYS_DOS  . . . . . . . . . . .        Number             0h 
OPSYS_OS2  . . . . . . . . . . .        Number             1h 
OPTJ_CALL  . . . . . . . . . . .        Number             4h 
OPTJ_EXPLICIT  . . . . . . . . .        Number             1h 
OPTJ_EXTEND  . . . . . . . . . .        Number             2h 
OPTJ_JXX . . . . . . . . . . . .        Number             3h 
OPTJ_NONE  . . . . . . . . . . .        Number             0h 
OPTJ_PUSH  . . . . . . . . . . .        Number             5h 
OPTN_ASM_FN  . . . . . . . . . .        Number             0h 
OPTN_CODE_CLASS  . . . . . . . .        Number             8h 
OPTN_DATA_SEG  . . . . . . . . .        Number             7h 
OPTN_ERR_FN  . . . . . . . . . .        Number             3h 
OPTN_LAST  . . . . . . . . . . .        Number             9h 
OPTN_LNKDEF_FN . . . . . . . . .        Number             4h 
OPTN_LST_FN  . . . . . . . . . .        Number             2h 
OPTN_MODULE_NAME . . . . . . . .        Number             5h 
OPTN_OBJ_FN  . . . . . . . . . .        Number             1h 
OPTN_TEXT_SEG  . . . . . . . . .        Number             6h 
OPTQ_FINCLUDE  . . . . . . . . .        Number             0h 
OPTQ_INCPATH . . . . . . . . . .        Number             2h 
OPTQ_LAST  . . . . . . . . . . .        Number             3h 
OPTQ_MACRO . . . . . . . . . . .        Number             1h 
OPT_ASSERT . . . . . . . . . . .        Number            40h 
OPT_CSTACK . . . . . . . . . . .        Number             1h 
OPT_LSTRING  . . . . . . . . . .        Number             4h 
OPT_NOTABLE  . . . . . . . . . .        Number            10h 
OPT_PASCAL . . . . . . . . . . .        Number             8h 
OPT_PUSHF  . . . . . . . . . . .        Number            80h 
OPT_REGAX  . . . . . . . . . . .        Number            20h 
OPT_WSTRING  . . . . . . . . . .        Number             2h 
OP_A . . . . . . . . . . . . . .        Number            80h 
OP_AL  . . . . . . . . . . . . .        Number            81h 
OP_AX  . . . . . . . . . . . . .        Number            82h 
OP_CL  . . . . . . . . . . . . .        Number        800001h 
OP_CL_ONLY . . . . . . . . . . .        Number        800000h 
OP_DX  . . . . . . . . . . . . .        Number       1000002h 
OP_DX_ONLY . . . . . . . . . . .        Number       1000000h 
OP_EAX . . . . . . . . . . . . .        Number            84h 
OP_I . . . . . . . . . . . . . .        Number         70000h 
OP_I16 . . . . . . . . . . . . .        Number         20000h 
OP_I32 . . . . . . . . . . . . .        Number         40000h 
OP_I48 . . . . . . . . . . . . .        Number      40000000h 
OP_I64 . . . . . . . . . . . . .        Number         80000h 
OP_I8  . . . . . . . . . . . . .        Number         10000h 
OP_I8_U  . . . . . . . . . . . .        Number        870000h 
OP_IGE16 . . . . . . . . . . . .        Number         60000h 
OP_IGE8  . . . . . . . . . . . .        Number         70000h 
OP_I_1 . . . . . . . . . . . . .        Number        210000h 
OP_I_3 . . . . . . . . . . . . .        Number        410000h 
OP_I_ANY . . . . . . . . . . . .        Number      400F0000h 
OP_K . . . . . . . . . . . . . .        Number        100000h 
OP_M . . . . . . . . . . . . . .        Number        401F00h 
OP_M08 . . . . . . . . . . . . .        Number           100h 
OP_M128  . . . . . . . . . . . .        Number          1000h 
OP_M16 . . . . . . . . . . . . .        Number           200h 
OP_M256  . . . . . . . . . . . .        Number          2000h 
OP_M32 . . . . . . . . . . . . .        Number           400h 
OP_M48 . . . . . . . . . . . . .        Number        200000h 
OP_M512  . . . . . . . . . . . .        Number          4000h 
OP_M64 . . . . . . . . . . . . .        Number           800h 
OP_M80 . . . . . . . . . . . . .        Number        400000h 
OP_MFPTR . . . . . . . . . . . .        Number        600400h 
OP_MGT16 . . . . . . . . . . . .        Number           C00h 
OP_MGT8  . . . . . . . . . . . .        Number           E00h 
OP_MMX . . . . . . . . . . . . .        Number          8000h 
OP_MS  . . . . . . . . . . . . .        Number           F00h 
OP_M_ANY . . . . . . . . . . . .        Number        607F00h 
OP_NONE  . . . . . . . . . . . .        Number             0h 
OP_R . . . . . . . . . . . . . .        Number             Fh 
OP_R16 . . . . . . . . . . . . .        Number             2h 
OP_R32 . . . . . . . . . . . . .        Number             4h 
OP_R64 . . . . . . . . . . . . .        Number             8h 
OP_R8  . . . . . . . . . . . . .        Number             1h 
OP_RAX . . . . . . . . . . . . .        Number            88h 
OP_RGT16 . . . . . . . . . . . .        Number             Ch 
OP_RGT8  . . . . . . . . . . . .        Number             Eh 
OP_RIP . . . . . . . . . . . . .        Number       2000010h 
OP_RSPEC . . . . . . . . . . . .        Number       2000000h 
OP_SR  . . . . . . . . . . . . .        Number       C000000h 
OP_SR386 . . . . . . . . . . . .        Number       8000000h 
OP_SR86  . . . . . . . . . . . .        Number       4000000h 
OP_ST  . . . . . . . . . . . . .        Number      10000000h 
OP_STI . . . . . . . . . . . . .        Number      30000000h 
OP_ST_REG  . . . . . . . . . . .        Number      20000000h 
OP_XMM . . . . . . . . . . . . .        Number            10h 
OP_YMM . . . . . . . . . . . . .        Number            20h 
OP_ZMM . . . . . . . . . . . . .        Number            40h 
OSVERSION_MASK . . . . . . . . .        Number      FFFF0000h 
OT_FLAT  . . . . . . . . . . . .        Number             1h 
OT_GROUP . . . . . . . . . . . .        Number             0h 
OT_SEGMENT . . . . . . . . . . .        Number             2h 
Options  . . . . . . . . . . . .        global_options         0h External FASTCALL
PASS_1 . . . . . . . . . . . . .        Number             0h 
PASS_2 . . . . . . . . . . . . .        Number             1h 
PEM_DEFAULT  . . . . . . . . . .        Number             0h 
PEM_MACRO  . . . . . . . . . . .        Number             1h 
PEM_NONE . . . . . . . . . . . .        Number             2h 
PLACEHOLDER_CHAR . . . . . . . .        Number             Ah 
PROC_FORCEFRAME  . . . . . . . .        Number             8h 
PROC_FPO . . . . . . . . . . . .        Number            80h 
PROC_HAS_VARARG  . . . . . . . .        Number             1h 
PROC_ISEXPORT  . . . . . . . . .        Number             4h 
PROC_ISFRAME . . . . . . . . . .        Number            40h 
PROC_LOADDS  . . . . . . . . . .        Number            10h 
PROC_PE_TYPE . . . . . . . . . .        Number             2h 
PROC_STACKPARAM  . . . . . . . .        Number            20h 
PSAPI_VERSION  . . . . . . . . .        Number             0h 
PTR_IS_INT . . . . . . . . . . .        Number             0h 
PTR_IS_LONG  . . . . . . . . . .        Number             0h 
P_186  . . . . . . . . . . . . .        Number            10h 
P_286  . . . . . . . . . . . . .        Number            20h 
P_286p . . . . . . . . . . . . .        Number            28h 
P_287  . . . . . . . . . . . . .        Number             3h 
P_386  . . . . . . . . . . . . .        Number            30h 
P_386p . . . . . . . . . . . . .        Number            38h 
P_387  . . . . . . . . . . . . .        Number             4h 
P_486  . . . . . . . . . . . . .        Number            40h 
P_486p . . . . . . . . . . . . .        Number            48h 
P_586  . . . . . . . . . . . . .        Number            50h 
P_586p . . . . . . . . . . . . .        Number            58h 
P_64 . . . . . . . . . . . . . .        Number            70h 
P_64p  . . . . . . . . . . . . .        Number            78h 
P_686  . . . . . . . . . . . . .        Number            60h 
P_686p . . . . . . . . . . . . .        Number            68h 
P_86 . . . . . . . . . . . . . .        Number             0h 
P_87 . . . . . . . . . . . . . .        Number             2h 
P_AVX  . . . . . . . . . . . . .        Number          8000h 
P_CPU_MASK . . . . . . . . . . .        Number            F0h 
P_EXT_ALL  . . . . . . . . . . .        Number          FF00h 
P_EXT_MASK . . . . . . . . . . .        Number          FF00h 
P_FPU_MASK . . . . . . . . . . .        Number             7h 
P_K3D  . . . . . . . . . . . . .        Number           200h 
P_MMX  . . . . . . . . . . . . .        Number           100h 
P_NO87 . . . . . . . . . . . . .        Number             1h 
P_PM . . . . . . . . . . . . . .        Number             8h 
P_SSE1 . . . . . . . . . . . . .        Number           400h 
P_SSE2 . . . . . . . . . . . . .        Number           800h 
P_SSE3 . . . . . . . . . . . . .        Number          1000h 
P_SSE4 . . . . . . . . . . . . .        Number          4000h 
P_SSEALL . . . . . . . . . . . .        Number          FC00h 
P_SSSE3  . . . . . . . . . . . .        Number          2000h 
Parse_Pass . . . . . . . . . . .        DWord              0h *External FASTCALL
ProcTable  . . . . . . . . . . .        Text   SymTables[TAB_PROC*symbol_queue].head
Q_DIGITS . . . . . . . . . . . .        Number            26h 
Q_EXPBIAS  . . . . . . . . . . .        Number          3FFFh 
Q_EXPBITS  . . . . . . . . . . .        Number             Fh 
Q_EXPMASK  . . . . . . . . . . .        Number          7FFFh 
Q_EXPMAX . . . . . . . . . . . .        Number          4000h 
Q_SIGBITS  . . . . . . . . . . .        Number            71h 
Q_SIGDIG . . . . . . . . . . . .        Number            31h 
QueueTestLines . . . . . . . . .        Text   AddLineQueue
RAND_MAX . . . . . . . . . . . .        Number          7FFFh 
REX_B  . . . . . . . . . . . . .        Number             1h 
REX_R  . . . . . . . . . . . . .        Number             4h 
REX_W  . . . . . . . . . . . . .        Number             8h 
REX_X  . . . . . . . . . . . . .        Number             2h 
RWT_BINARY_OP  . . . . . . . . .        Number             5h 
RWT_DIRECTIVE  . . . . . . . . .        Number             3h 
RWT_REG  . . . . . . . . . . . .        Number             2h 
RWT_RES_ID . . . . . . . . . . .        Number             7h 
RWT_STYPE  . . . . . . . . . . .        Number             6h 
RWT_UNARY_OP . . . . . . . . . .        Number             4h 
R_in_OP  . . . . . . . . . . . .        Number             3h 
SCHAR_MAX  . . . . . . . . . . .        Number            7Fh 
SCHAR_MIN  . . . . . . . . . . .        Number     -00000080h 
SEEK_CUR . . . . . . . . . . . .        Number             1h 
SEEK_END . . . . . . . . . . . .        Number             2h 
SEEK_SET . . . . . . . . . . . .        Number             0h 
SEGORDER_ALPHA . . . . . . . . .        Number             2h 
SEGORDER_DOSSEG  . . . . . . . .        Number             1h 
SEGORDER_SEQ . . . . . . . . . .        Number             0h 
SEGTYPE_ABS  . . . . . . . . . .        Number             5h 
SEGTYPE_BSS  . . . . . . . . . .        Number             3h 
SEGTYPE_CDATA  . . . . . . . . .        Number             7h 
SEGTYPE_CODE . . . . . . . . . .        Number             1h 
SEGTYPE_DATA . . . . . . . . . .        Number             2h 
SEGTYPE_ERROR  . . . . . . . . .        Number             Ah 
SEGTYPE_HDR  . . . . . . . . . .        Number             6h 
SEGTYPE_RELOC  . . . . . . . . .        Number             8h 
SEGTYPE_RSRC . . . . . . . . . .        Number             9h 
SEGTYPE_STACK  . . . . . . . . .        Number             4h 
SEGTYPE_UNDEF  . . . . . . . . .        Number             0h 
SFORMAT_64BIT  . . . . . . . . .        Number             3h 
SFORMAT_MZ . . . . . . . . . . .        Number             1h 
SFORMAT_NONE . . . . . . . . . .        Number             0h 
SFORMAT_PE . . . . . . . . . . .        Number             2h 
SFR_IREG . . . . . . . . . . . .        Number            80h 
SFR_SIZMSK . . . . . . . . . . .        Number            7Fh 
SFR_SSBASED  . . . . . . . . . .        Number           100h 
SHORT_IS_INT . . . . . . . . . .        Number             0h 
SHRT_MAX . . . . . . . . . . . .        Number          7FFFh 
SHRT_MIN . . . . . . . . . . . .        Number     -00008000h 
SIT_FILE . . . . . . . . . . . .        Number             0h 
SIT_MACRO  . . . . . . . . . . .        Number             1h 
SIZE_CODEPTR . . . . . . . . . .        Number            70h 
SIZE_DATAPTR . . . . . . . . . .        Number            68h 
SIZE_MAX . . . . . . . . . . . .        Number     -00000001h 
SI_ISINLINE  . . . . . . . . . .        Number             1h 
SI_ISOPEN  . . . . . . . . . . .        Number             2h 
SI_ORGINSIDE . . . . . . . . . .        Number             4h 
SPECIAL_LAST . . . . . . . . . .        Number           22Bh 
SPVERSION_MASK . . . . . . . . .        Number          FF00h 
STACK_FAR  . . . . . . . . . . .        Number             1h 
STACK_NEAR . . . . . . . . . . .        Number             0h 
STDCALL_FULL . . . . . . . . . .        Number             0h 
STDCALL_HALF . . . . . . . . . .        Number             2h 
STDCALL_NONE . . . . . . . . . .        Number             1h 
STRING_EXPANDED  . . . . . . . .        Number             1h 
SUBVERSION_MASK  . . . . . . . .        Number            FFh 
SYM_ALIAS  . . . . . . . . . . .        Number             8h 
SYM_CLASS_LNAME  . . . . . . . .        Number             Bh 
SYM_EXTERNAL . . . . . . . . . .        Number             2h 
SYM_GRP  . . . . . . . . . . . .        Number             4h 
SYM_INTERNAL . . . . . . . . . .        Number             1h 
SYM_MACRO  . . . . . . . . . . .        Number             9h 
SYM_SEG  . . . . . . . . . . . .        Number             3h 
SYM_STACK  . . . . . . . . . . .        Number             5h 
SYM_STRUCT_FIELD . . . . . . . .        Number             6h 
SYM_TMACRO . . . . . . . . . . .        Number             Ah 
SYM_TYPE . . . . . . . . . . . .        Number             7h 
SYM_UNDEFINED  . . . . . . . . .        Number             0h 
S_ARGUSED  . . . . . . . . . . .        Number            20h 
S_CLASS  . . . . . . . . . . . .        Number             1h 
S_FWDREF . . . . . . . . . . . .        Number            20h 
S_IAT_USED . . . . . . . . . . .        Number             8h 
S_INCLUDED . . . . . . . . . . .        Number            40h 
S_ISARRAY  . . . . . . . . . . .        Number             2h 
S_ISCOM  . . . . . . . . . . . .        Number             1h 
S_ISDATA . . . . . . . . . . . .        Number             4h 
S_ISDEFINED  . . . . . . . . . .        Number             2h 
S_ISEQUATE . . . . . . . . . . .        Number            10h 
S_ISINLINE . . . . . . . . . . .        Number            10h 
S_ISPROC . . . . . . . . . . . .        Number             8h 
S_ISPUBLIC . . . . . . . . . . .        Number            80h 
S_ISSAVED  . . . . . . . . . . .        Number            10h 
S_ISSTATIC . . . . . . . . . . .        Number            20h 
S_ISVARARG . . . . . . . . . . .        Number             4h 
S_ISVECTOR . . . . . . . . . . .        Number             8h 
S_ISVTABLE . . . . . . . . . . .        Number             4h 
S_LIST . . . . . . . . . . . . .        Number             1h 
S_LOCALGPR . . . . . . . . . . .        Number            40h 
S_METHOD . . . . . . . . . . . .        Number            80h 
S_OPERATOR . . . . . . . . . . .        Number            80h 
S_PREDEFINED . . . . . . . . . .        Number            20h 
S_SCOPED . . . . . . . . . . . .        Number             4h 
S_STKUSED  . . . . . . . . . . .        Number            10h 
S_USED . . . . . . . . . . . . .        Number             1h 
S_VARIABLE . . . . . . . . . . .        Number            40h 
S_VMACRO . . . . . . . . . . . .        Number             8h 
S_VPARRAY  . . . . . . . . . . .        Number            40h 
S_VTABLE . . . . . . . . . . . .        Number             2h 
S_WEAK . . . . . . . . . . . . .        Number             2h 
SegTable . . . . . . . . . . . .        Text   SymTables[TAB_SEG*symbol_queue].head
SpecialTable . . . . . . . . . .        special_item         0h External FASTCALL
StringBufferEnd  . . . . . . . .        Text   ModuleInfo.stringbufferend
SymCmpFunc . . . . . . . . . . .        Near               0h *External FASTCALL
SymTables  . . . . . . . . . . .        symbol_queue         0h *External FASTCALL
TAB_ALIAS  . . . . . . . . . . .        Number             5h 
TAB_EXT  . . . . . . . . . . . .        Number             1h 
TAB_GRP  . . . . . . . . . . . .        Number             3h 
TAB_LAST . . . . . . . . . . . .        Number             6h 
TAB_PROC . . . . . . . . . . . .        Number             4h 
TAB_SEG  . . . . . . . . . . . .        Number             2h 
TAB_UNDEF  . . . . . . . . . . .        Number             0h 
TEVALUE_UNSIGNED . . . . . . . .        Number             1h 
TF3_EXPANSION  . . . . . . . . .        Number             2h 
TF3_ISCONCAT . . . . . . . . . .        Number             1h 
TOK_DEFAULT  . . . . . . . . . .        Number             0h 
TOK_LINE . . . . . . . . . . . .        Number             4h 
TOK_NOCURLBRACES . . . . . . . .        Number             2h 
TOK_RESCAN . . . . . . . . . . .        Number             1h 
TRUE . . . . . . . . . . . . . .        Number             1h 
TYPE_NONE  . . . . . . . . . . .        Number             0h 
TYPE_RECORD  . . . . . . . . . .        Number             4h 
TYPE_STRUCT  . . . . . . . . . .        Number             1h 
TYPE_TYPEDEF . . . . . . . . . .        Number             3h 
TYPE_UNION . . . . . . . . . . .        Number             2h 
T_AAA  . . . . . . . . . . . . .        Number           289h 
T_AAD  . . . . . . . . . . . . .        Number           28Ah 
T_AAM  . . . . . . . . . . . . .        Number           28Bh 
T_AAS  . . . . . . . . . . . . .        Number           28Ch 
T_ADC  . . . . . . . . . . . . .        Number           25Fh 
T_ADCX . . . . . . . . . . . . .        Number           4C0h 
T_ADD  . . . . . . . . . . . . .        Number           25Dh 
T_ADDPD  . . . . . . . . . . . .        Number           3BAh 
T_ADDPS  . . . . . . . . . . . .        Number           3BBh 
T_ADDR . . . . . . . . . . . . .        Number           10Ch 
T_ADDSD  . . . . . . . . . . . .        Number           3BCh 
T_ADDSS  . . . . . . . . . . . .        Number           3BDh 
T_ADDSUBPD . . . . . . . . . . .        Number           49Ch 
T_ADDSUBPS . . . . . . . . . . .        Number           49Dh 
T_ADOX . . . . . . . . . . . . .        Number           50Fh 
T_AESDEC . . . . . . . . . . . .        Number           4BBh 
T_AESDECLAST . . . . . . . . . .        Number           4BAh 
T_AESENC . . . . . . . . . . . .        Number           4BCh 
T_AESENCLAST . . . . . . . . . .        Number           4BDh 
T_AESIMC . . . . . . . . . . . .        Number           4BEh 
T_AESKEYGENASSIST  . . . . . . .        Number           4BFh 
T_AH . . . . . . . . . . . . . .        Number             5h 
T_AL . . . . . . . . . . . . . .        Number             1h 
T_ALIAS  . . . . . . . . . . . .        Number           220h 
T_ALIGN  . . . . . . . . . . . .        Number           21Ah 
T_AND  . . . . . . . . . . . . .        Number           261h 
T_ANDN . . . . . . . . . . . . .        Number           63Eh 
T_ANDNPD . . . . . . . . . . . .        Number           3F9h 
T_ANDNPS . . . . . . . . . . . .        Number           3FAh 
T_ANDPD  . . . . . . . . . . . .        Number           3FBh 
T_ANDPS  . . . . . . . . . . . .        Number           3FCh 
T_ARPL . . . . . . . . . . . . .        Number           29Ch 
T_ASSUME . . . . . . . . . . . .        Number           21Fh 
T_AX . . . . . . . . . . . . . .        Number             9h 
T_BAD_NUM  . . . . . . . . . . .        Number             Ch 
T_BASIC  . . . . . . . . . . . .        Number           115h 
T_BEXTR  . . . . . . . . . . . .        Number           640h 
T_BH . . . . . . . . . . . . . .        Number             8h 
T_BINARY_OPERATOR  . . . . . . .        Number             5h 
T_BL . . . . . . . . . . . . . .        Number             4h 
T_BLENDPD  . . . . . . . . . . .        Number           4D4h 
T_BLENDPS  . . . . . . . . . . .        Number           4D5h 
T_BLENDVPD . . . . . . . . . . .        Number           4D6h 
T_BLENDVPS . . . . . . . . . . .        Number           4D7h 
T_BLSI . . . . . . . . . . . . .        Number           648h 
T_BLSMSK . . . . . . . . . . . .        Number           649h 
T_BLSR . . . . . . . . . . . . .        Number           64Ah 
T_BOUND_ . . . . . . . . . . . .        Number           2C4h 
T_BP . . . . . . . . . . . . . .        Number             Eh 
T_BPL  . . . . . . . . . . . . .        Number            58h 
T_BSF  . . . . . . . . . . . . .        Number           2C5h 
T_BSR  . . . . . . . . . . . . .        Number           2C6h 
T_BSWAP  . . . . . . . . . . . .        Number           2C7h 
T_BT . . . . . . . . . . . . . .        Number           2B0h 
T_BTC  . . . . . . . . . . . . .        Number           2B1h 
T_BTR  . . . . . . . . . . . . .        Number           2B2h 
T_BTS  . . . . . . . . . . . . .        Number           2B3h 
T_BX . . . . . . . . . . . . . .        Number             Ch 
T_BYTE . . . . . . . . . . . . .        Number            CDh 
T_BZHI . . . . . . . . . . . . .        Number           644h 
T_CALL . . . . . . . . . . . . .        Number           22Bh 
T_CATSTR . . . . . . . . . . . .        Number           1F8h 
T_CBW  . . . . . . . . . . . . .        Number           2C8h 
T_CCALL  . . . . . . . . . . . .        Number           110h 
T_CDQ  . . . . . . . . . . . . .        Number           2C9h 
T_CDQE . . . . . . . . . . . . .        Number           4C1h 
T_CH . . . . . . . . . . . . . .        Number             6h 
T_CL . . . . . . . . . . . . . .        Number             2h 
T_CLC  . . . . . . . . . . . . .        Number           2B5h 
T_CLD  . . . . . . . . . . . . .        Number           2B9h 
T_CLFLUSH  . . . . . . . . . . .        Number           3AFh 
T_CLI  . . . . . . . . . . . . .        Number           2B7h 
T_CLTS . . . . . . . . . . . . .        Number           2CCh 
T_CL_BRACKET . . . . . . . . . .        Number            29h 
T_CL_SQ_BRACKET  . . . . . . . .        Number            5Dh 
T_CMC  . . . . . . . . . . . . .        Number           2B4h 
T_CMOVA  . . . . . . . . . . . .        Number           320h 
T_CMOVAE . . . . . . . . . . . .        Number           321h 
T_CMOVB  . . . . . . . . . . . .        Number           322h 
T_CMOVBE . . . . . . . . . . . .        Number           323h 
T_CMOVC  . . . . . . . . . . . .        Number           324h 
T_CMOVE  . . . . . . . . . . . .        Number           325h 
T_CMOVG  . . . . . . . . . . . .        Number           326h 
T_CMOVGE . . . . . . . . . . . .        Number           327h 
T_CMOVL  . . . . . . . . . . . .        Number           328h 
T_CMOVLE . . . . . . . . . . . .        Number           329h 
T_CMOVNA . . . . . . . . . . . .        Number           32Ah 
T_CMOVNAE  . . . . . . . . . . .        Number           32Bh 
T_CMOVNB . . . . . . . . . . . .        Number           32Ch 
T_CMOVNBE  . . . . . . . . . . .        Number           32Dh 
T_CMOVNC . . . . . . . . . . . .        Number           32Eh 
T_CMOVNE . . . . . . . . . . . .        Number           32Fh 
T_CMOVNG . . . . . . . . . . . .        Number           330h 
T_CMOVNGE  . . . . . . . . . . .        Number           331h 
T_CMOVNL . . . . . . . . . . . .        Number           332h 
T_CMOVNLE  . . . . . . . . . . .        Number           333h 
T_CMOVNO . . . . . . . . . . . .        Number           334h 
T_CMOVNP . . . . . . . . . . . .        Number           335h 
T_CMOVNS . . . . . . . . . . . .        Number           336h 
T_CMOVNZ . . . . . . . . . . . .        Number           337h 
T_CMOVO  . . . . . . . . . . . .        Number           338h 
T_CMOVP  . . . . . . . . . . . .        Number           339h 
T_CMOVPE . . . . . . . . . . . .        Number           33Ah 
T_CMOVPO . . . . . . . . . . . .        Number           33Bh 
T_CMOVS  . . . . . . . . . . . .        Number           33Ch 
T_CMOVZ  . . . . . . . . . . . .        Number           33Dh 
T_CMP  . . . . . . . . . . . . .        Number           264h 
T_CMPEQPD  . . . . . . . . . . .        Number           3D9h 
T_CMPEQPS  . . . . . . . . . . .        Number           3E1h 
T_CMPEQSD  . . . . . . . . . . .        Number           3E9h 
T_CMPEQSS  . . . . . . . . . . .        Number           3F1h 
T_CMPLEPD  . . . . . . . . . . .        Number           3DBh 
T_CMPLEPS  . . . . . . . . . . .        Number           3E3h 
T_CMPLESD  . . . . . . . . . . .        Number           3EBh 
T_CMPLESS  . . . . . . . . . . .        Number           3F3h 
T_CMPLTPD  . . . . . . . . . . .        Number           3DAh 
T_CMPLTPS  . . . . . . . . . . .        Number           3E2h 
T_CMPLTSD  . . . . . . . . . . .        Number           3EAh 
T_CMPLTSS  . . . . . . . . . . .        Number           3F2h 
T_CMPNEQPD . . . . . . . . . . .        Number           3DDh 
T_CMPNEQPS . . . . . . . . . . .        Number           3E5h 
T_CMPNEQSD . . . . . . . . . . .        Number           3EDh 
T_CMPNEQSS . . . . . . . . . . .        Number           3F5h 
T_CMPNLEPD . . . . . . . . . . .        Number           3DFh 
T_CMPNLEPS . . . . . . . . . . .        Number           3E7h 
T_CMPNLESD . . . . . . . . . . .        Number           3EFh 
T_CMPNLESS . . . . . . . . . . .        Number           3F7h 
T_CMPNLTPD . . . . . . . . . . .        Number           3DEh 
T_CMPNLTPS . . . . . . . . . . .        Number           3E6h 
T_CMPNLTSD . . . . . . . . . . .        Number           3EEh 
T_CMPNLTSS . . . . . . . . . . .        Number           3F6h 
T_CMPORDPD . . . . . . . . . . .        Number           3E0h 
T_CMPORDPS . . . . . . . . . . .        Number           3E8h 
T_CMPORDSD . . . . . . . . . . .        Number           3F0h 
T_CMPORDSS . . . . . . . . . . .        Number           3F8h 
T_CMPPD  . . . . . . . . . . . .        Number           3D6h 
T_CMPPS  . . . . . . . . . . . .        Number           3D7h 
T_CMPS . . . . . . . . . . . . .        Number           26Dh 
T_CMPSB  . . . . . . . . . . . .        Number           26Eh 
T_CMPSD  . . . . . . . . . . . .        Number           270h 
T_CMPSQ  . . . . . . . . . . . .        Number           4C8h 
T_CMPSS  . . . . . . . . . . . .        Number           3D8h 
T_CMPSW  . . . . . . . . . . . .        Number           26Fh 
T_CMPUNORDPD . . . . . . . . . .        Number           3DCh 
T_CMPUNORDPS . . . . . . . . . .        Number           3E4h 
T_CMPUNORDSD . . . . . . . . . .        Number           3ECh 
T_CMPUNORDSS . . . . . . . . . .        Number           3F4h 
T_CMPXCHG  . . . . . . . . . . .        Number           2CDh 
T_CMPXCHG16B . . . . . . . . . .        Number           4C6h 
T_CMPXCHG8B  . . . . . . . . . .        Number           2CEh 
T_COLON  . . . . . . . . . . . .        Number            3Ah 
T_COMISD . . . . . . . . . . . .        Number           3FFh 
T_COMISS . . . . . . . . . . . .        Number           400h 
T_COMM . . . . . . . . . . . . .        Number           20Eh 
T_COMMA  . . . . . . . . . . . .        Number            2Ch 
T_COMMENT  . . . . . . . . . . .        Number           1CFh 
T_CPUID  . . . . . . . . . . . .        Number           2CFh 
T_CQO  . . . . . . . . . . . . .        Number           4C2h 
T_CR0  . . . . . . . . . . . . .        Number            48h 
T_CR2  . . . . . . . . . . . . .        Number            49h 
T_CR3  . . . . . . . . . . . . .        Number            4Ah 
T_CR4  . . . . . . . . . . . . .        Number            4Bh 
T_CR8  . . . . . . . . . . . . .        Number            CCh 
T_CRC32  . . . . . . . . . . . .        Number           502h 
T_CS . . . . . . . . . . . . . .        Number            1Ah 
T_CVTDQ2PD . . . . . . . . . . .        Number           413h 
T_CVTDQ2PS . . . . . . . . . . .        Number           40Fh 
T_CVTPD2DQ . . . . . . . . . . .        Number           412h 
T_CVTPD2PI . . . . . . . . . . .        Number           403h 
T_CVTPD2PS . . . . . . . . . . .        Number           415h 
T_CVTPI2PD . . . . . . . . . . .        Number           407h 
T_CVTPI2PS . . . . . . . . . . .        Number           408h 
T_CVTPS2DQ . . . . . . . . . . .        Number           410h 
T_CVTPS2PD . . . . . . . . . . .        Number           416h 
T_CVTPS2PI . . . . . . . . . . .        Number           404h 
T_CVTSD2SI . . . . . . . . . . .        Number           405h 
T_CVTSD2SS . . . . . . . . . . .        Number           417h 
T_CVTSI2SD . . . . . . . . . . .        Number           409h 
T_CVTSI2SS . . . . . . . . . . .        Number           40Ah 
T_CVTSS2SD . . . . . . . . . . .        Number           418h 
T_CVTSS2SI . . . . . . . . . . .        Number           406h 
T_CVTTPD2DQ  . . . . . . . . . .        Number           414h 
T_CVTTPD2PI  . . . . . . . . . .        Number           40Bh 
T_CVTTPS2DQ  . . . . . . . . . .        Number           411h 
T_CVTTPS2PI  . . . . . . . . . .        Number           40Ch 
T_CVTTSD2SI  . . . . . . . . . .        Number           40Dh 
T_CVTTSS2SI  . . . . . . . . . .        Number           40Eh 
T_CWD  . . . . . . . . . . . . .        Number           2CAh 
T_CWDE . . . . . . . . . . . . .        Number           2CBh 
T_CX . . . . . . . . . . . . . .        Number             Ah 
T_DAA  . . . . . . . . . . . . .        Number           28Dh 
T_DAS  . . . . . . . . . . . . .        Number           28Eh 
T_DB . . . . . . . . . . . . . .        Number           1FCh 
T_DBL_COLON  . . . . . . . . . .        Number             Dh 
T_DD . . . . . . . . . . . . . .        Number           1FEh 
T_DEC  . . . . . . . . . . . . .        Number           2BCh 
T_DEFINE . . . . . . . . . . . .        Number           224h 
T_DEFINED  . . . . . . . . . . .        Number           10Ah 
T_DELAYED  . . . . . . . . . . .        Number             2h 
T_DF . . . . . . . . . . . . . .        Number           1FFh 
T_DH . . . . . . . . . . . . . .        Number             7h 
T_DI . . . . . . . . . . . . . .        Number            10h 
T_DIL  . . . . . . . . . . . . .        Number            5Ah 
T_DIRECTIVE  . . . . . . . . . .        Number             3h 
T_DIV  . . . . . . . . . . . . .        Number           2A5h 
T_DIVPD  . . . . . . . . . . . .        Number           3BEh 
T_DIVPS  . . . . . . . . . . . .        Number           3BFh 
T_DIVSD  . . . . . . . . . . . .        Number           3C0h 
T_DIVSS  . . . . . . . . . . . .        Number           3C1h 
T_DL . . . . . . . . . . . . . .        Number             3h 
T_DOSSEG . . . . . . . . . . . .        Number           149h 
T_DOT  . . . . . . . . . . . . .        Number            2Eh 
T_DOT_186  . . . . . . . . . . .        Number           11Ah 
T_DOT_286  . . . . . . . . . . .        Number           11Bh 
T_DOT_286C . . . . . . . . . . .        Number           11Ch 
T_DOT_286P . . . . . . . . . . .        Number           11Dh 
T_DOT_287  . . . . . . . . . . .        Number           12Dh 
T_DOT_386  . . . . . . . . . . .        Number           11Eh 
T_DOT_386C . . . . . . . . . . .        Number           11Fh 
T_DOT_386P . . . . . . . . . . .        Number           120h 
T_DOT_387  . . . . . . . . . . .        Number           12Eh 
T_DOT_486  . . . . . . . . . . .        Number           121h 
T_DOT_486P . . . . . . . . . . .        Number           122h 
T_DOT_586  . . . . . . . . . . .        Number           123h 
T_DOT_586P . . . . . . . . . . .        Number           124h 
T_DOT_686  . . . . . . . . . . .        Number           125h 
T_DOT_686P . . . . . . . . . . .        Number           126h 
T_DOT_8086 . . . . . . . . . . .        Number           119h 
T_DOT_8087 . . . . . . . . . . .        Number           12Ch 
T_DOT_ALLOCSTACK . . . . . . . .        Number           202h 
T_DOT_ALPHA  . . . . . . . . . .        Number           146h 
T_DOT_ASSERT . . . . . . . . . .        Number           1A0h 
T_DOT_ASSERTB  . . . . . . . . .        Number           1A1h 
T_DOT_ASSERTD  . . . . . . . . .        Number           1A3h 
T_DOT_ASSERTW  . . . . . . . . .        Number           1A2h 
T_DOT_BREAK  . . . . . . . . . .        Number           154h 
T_DOT_CASE . . . . . . . . . . .        Number           1B6h 
T_DOT_CLASS  . . . . . . . . . .        Number           1A8h 
T_DOT_CODE . . . . . . . . . . .        Number           14Ah 
T_DOT_COMDEF . . . . . . . . . .        Number           1A9h 
T_DOT_CONST  . . . . . . . . . .        Number           150h 
T_DOT_CONTINUE . . . . . . . . .        Number           155h 
T_DOT_CREF . . . . . . . . . . .        Number           130h 
T_DOT_DATA . . . . . . . . . . .        Number           14Ch 
T_DOT_DATA_UN  . . . . . . . . .        Number           14Dh 
T_DOT_DEFAULT  . . . . . . . . .        Number           1B9h 
T_DOT_DOSSEG . . . . . . . . . .        Number           147h 
T_DOT_ELSE . . . . . . . . . . .        Number           156h 
T_DOT_ELSEIF . . . . . . . . . .        Number           157h 
T_DOT_ELSEIFD  . . . . . . . . .        Number           174h 
T_DOT_ELSEIFS  . . . . . . . . .        Number           173h 
T_DOT_ELSEIFSD . . . . . . . . .        Number           175h 
T_DOT_ENDC . . . . . . . . . . .        Number           1B7h 
T_DOT_ENDF . . . . . . . . . . .        Number           1A6h 
T_DOT_ENDIF  . . . . . . . . . .        Number           158h 
T_DOT_ENDN . . . . . . . . . . .        Number           1B4h 
T_DOT_ENDPROLOG  . . . . . . . .        Number           203h 
T_DOT_ENDS . . . . . . . . . . .        Number           1AEh 
T_DOT_ENDSW  . . . . . . . . . .        Number           1BAh 
T_DOT_ENDW . . . . . . . . . . .        Number           159h 
T_DOT_ENUM . . . . . . . . . . .        Number           1B1h 
T_DOT_ENUMT  . . . . . . . . . .        Number           1B2h 
T_DOT_ERR  . . . . . . . . . . .        Number           1C2h 
T_DOT_ERR1 . . . . . . . . . . .        Number           1C3h 
T_DOT_ERR2 . . . . . . . . . . .        Number           1C4h 
T_DOT_ERRB . . . . . . . . . . .        Number           1CBh 
T_DOT_ERRDEF . . . . . . . . . .        Number           1CDh 
T_DOT_ERRDIF . . . . . . . . . .        Number           1C7h 
T_DOT_ERRDIFI  . . . . . . . . .        Number           1C8h 
T_DOT_ERRE . . . . . . . . . . .        Number           1C5h 
T_DOT_ERRIDN . . . . . . . . . .        Number           1C9h 
T_DOT_ERRIDNI  . . . . . . . . .        Number           1CAh 
T_DOT_ERRNB  . . . . . . . . . .        Number           1CCh 
T_DOT_ERRNDEF  . . . . . . . . .        Number           1CEh 
T_DOT_ERRNZ  . . . . . . . . . .        Number           1C6h 
T_DOT_EXIT . . . . . . . . . . .        Number           1BDh 
T_DOT_FARDATA  . . . . . . . . .        Number           14Eh 
T_DOT_FARDATA_UN . . . . . . . .        Number           14Fh 
T_DOT_FOR  . . . . . . . . . . .        Number           1A4h 
T_DOT_FORS . . . . . . . . . . .        Number           1A5h 
T_DOT_GOTOSW . . . . . . . . . .        Number           1B8h 
T_DOT_HIGH . . . . . . . . . . .        Number            EAh 
T_DOT_IF . . . . . . . . . . . .        Number           151h 
T_DOT_IFA  . . . . . . . . . . .        Number           15Ch 
T_DOT_IFB  . . . . . . . . . . .        Number           16Bh 
T_DOT_IFC  . . . . . . . . . . .        Number           16Ch 
T_DOT_IFD  . . . . . . . . . . .        Number           16Fh 
T_DOT_IFG  . . . . . . . . . . .        Number           15Dh 
T_DOT_IFL  . . . . . . . . . . .        Number           15Eh 
T_DOT_IFNA . . . . . . . . . . .        Number           162h 
T_DOT_IFNB . . . . . . . . . . .        Number           163h 
T_DOT_IFNC . . . . . . . . . . .        Number           164h 
T_DOT_IFNG . . . . . . . . . . .        Number           165h 
T_DOT_IFNL . . . . . . . . . . .        Number           166h 
T_DOT_IFNO . . . . . . . . . . .        Number           167h 
T_DOT_IFNP . . . . . . . . . . .        Number           168h 
T_DOT_IFNS . . . . . . . . . . .        Number           169h 
T_DOT_IFNZ . . . . . . . . . . .        Number           16Ah 
T_DOT_IFO  . . . . . . . . . . .        Number           15Fh 
T_DOT_IFP  . . . . . . . . . . .        Number           160h 
T_DOT_IFS  . . . . . . . . . . .        Number           16Dh 
T_DOT_IFSB . . . . . . . . . . .        Number           170h 
T_DOT_IFSD . . . . . . . . . . .        Number           172h 
T_DOT_IFSW . . . . . . . . . . .        Number           171h 
T_DOT_IFW  . . . . . . . . . . .        Number           16Eh 
T_DOT_IFZ  . . . . . . . . . . .        Number           161h 
T_DOT_INLINE . . . . . . . . . .        Number           1ACh 
T_DOT_K3D  . . . . . . . . . . .        Number           127h 
T_DOT_LALL . . . . . . . . . . .        Number           144h 
T_DOT_LENGTH . . . . . . . . . .        Number            EEh 
T_DOT_LFCOND . . . . . . . . . .        Number           131h 
T_DOT_LIST . . . . . . . . . . .        Number           132h 
T_DOT_LISTALL  . . . . . . . . .        Number           133h 
T_DOT_LISTIF . . . . . . . . . .        Number           134h 
T_DOT_LISTMACRO  . . . . . . . .        Number           140h 
T_DOT_LISTMACROALL . . . . . . .        Number           141h 
T_DOT_LOW  . . . . . . . . . . .        Number            F0h 
T_DOT_MASK . . . . . . . . . . .        Number            F4h 
T_DOT_MMX  . . . . . . . . . . .        Number           128h 
T_DOT_MODEL  . . . . . . . . . .        Number           1BFh 
T_DOT_NAME . . . . . . . . . . .        Number           227h 
T_DOT_NAMESPACE  . . . . . . . .        Number           1B3h 
T_DOT_NEW  . . . . . . . . . . .        Number           1B0h 
T_DOT_NO87 . . . . . . . . . . .        Number           12Fh 
T_DOT_NOCREF . . . . . . . . . .        Number           135h 
T_DOT_NOLIST . . . . . . . . . .        Number           136h 
T_DOT_NOLISTIF . . . . . . . . .        Number           137h 
T_DOT_NOLISTMACRO  . . . . . . .        Number           142h 
T_DOT_OPERATOR . . . . . . . . .        Number           1ABh 
T_DOT_PAGE . . . . . . . . . . .        Number           13Ch 
T_DOT_PRAGMA . . . . . . . . . .        Number           1BCh 
T_DOT_PUSHFRAME  . . . . . . . .        Number           204h 
T_DOT_PUSHREG  . . . . . . . . .        Number           205h 
T_DOT_RADIX  . . . . . . . . . .        Number           1C0h 
T_DOT_REPEAT . . . . . . . . . .        Number           152h 
T_DOT_RETURN . . . . . . . . . .        Number           1BBh 
T_DOT_SAFESEH  . . . . . . . . .        Number           1C1h 
T_DOT_SALL . . . . . . . . . . .        Number           145h 
T_DOT_SAVEREG  . . . . . . . . .        Number           206h 
T_DOT_SAVEXMM128 . . . . . . . .        Number           207h 
T_DOT_SEQ  . . . . . . . . . . .        Number           148h 
T_DOT_SETFRAME . . . . . . . . .        Number           208h 
T_DOT_SFCOND . . . . . . . . . .        Number           138h 
T_DOT_SIZE . . . . . . . . . . .        Number            FAh 
T_DOT_STACK  . . . . . . . . . .        Number           14Bh 
T_DOT_STARTUP  . . . . . . . . .        Number           1BEh 
T_DOT_STATIC . . . . . . . . . .        Number           1ADh 
T_DOT_SUBTITLE . . . . . . . . .        Number           13Dh 
T_DOT_SUBTTL . . . . . . . . . .        Number           13Eh 
T_DOT_SWITCH . . . . . . . . . .        Number           1B5h 
T_DOT_TEMPLATE . . . . . . . . .        Number           1AAh 
T_DOT_TFCOND . . . . . . . . . .        Number           139h 
T_DOT_THIS . . . . . . . . . . .        Number            FCh 
T_DOT_TITLE  . . . . . . . . . .        Number           13Fh 
T_DOT_TYPE . . . . . . . . . . .        Number            E9h 
T_DOT_UNTIL  . . . . . . . . . .        Number           15Ah 
T_DOT_UNTILA . . . . . . . . . .        Number           18Bh 
T_DOT_UNTILB . . . . . . . . . .        Number           199h 
T_DOT_UNTILCXZ . . . . . . . . .        Number           15Bh 
T_DOT_UNTILD . . . . . . . . . .        Number           19Ch 
T_DOT_UNTILG . . . . . . . . . .        Number           18Ch 
T_DOT_UNTILL . . . . . . . . . .        Number           18Dh 
T_DOT_UNTILNA  . . . . . . . . .        Number           191h 
T_DOT_UNTILNB  . . . . . . . . .        Number           192h 
T_DOT_UNTILNG  . . . . . . . . .        Number           193h 
T_DOT_UNTILNL  . . . . . . . . .        Number           194h 
T_DOT_UNTILNO  . . . . . . . . .        Number           195h 
T_DOT_UNTILNP  . . . . . . . . .        Number           196h 
T_DOT_UNTILNS  . . . . . . . . .        Number           197h 
T_DOT_UNTILNZ  . . . . . . . . .        Number           198h 
T_DOT_UNTILO . . . . . . . . . .        Number           18Eh 
T_DOT_UNTILP . . . . . . . . . .        Number           18Fh 
T_DOT_UNTILS . . . . . . . . . .        Number           19Ah 
T_DOT_UNTILSB  . . . . . . . . .        Number           19Dh 
T_DOT_UNTILSD  . . . . . . . . .        Number           19Fh 
T_DOT_UNTILSW  . . . . . . . . .        Number           19Eh 
T_DOT_UNTILW . . . . . . . . . .        Number           19Bh 
T_DOT_UNTILZ . . . . . . . . . .        Number           190h 
T_DOT_WHILE  . . . . . . . . . .        Number           153h 
T_DOT_WHILEA . . . . . . . . . .        Number           176h 
T_DOT_WHILEB . . . . . . . . . .        Number           184h 
T_DOT_WHILED . . . . . . . . . .        Number           187h 
T_DOT_WHILEG . . . . . . . . . .        Number           177h 
T_DOT_WHILEL . . . . . . . . . .        Number           178h 
T_DOT_WHILENA  . . . . . . . . .        Number           17Ch 
T_DOT_WHILENB  . . . . . . . . .        Number           17Dh 
T_DOT_WHILENG  . . . . . . . . .        Number           17Eh 
T_DOT_WHILENL  . . . . . . . . .        Number           17Fh 
T_DOT_WHILENO  . . . . . . . . .        Number           180h 
T_DOT_WHILENP  . . . . . . . . .        Number           181h 
T_DOT_WHILENS  . . . . . . . . .        Number           182h 
T_DOT_WHILENZ  . . . . . . . . .        Number           183h 
T_DOT_WHILEO . . . . . . . . . .        Number           179h 
T_DOT_WHILEP . . . . . . . . . .        Number           17Ah 
T_DOT_WHILES . . . . . . . . . .        Number           185h 
T_DOT_WHILESB  . . . . . . . . .        Number           188h 
T_DOT_WHILESD  . . . . . . . . .        Number           18Ah 
T_DOT_WHILESW  . . . . . . . . .        Number           189h 
T_DOT_WHILEW . . . . . . . . . .        Number           186h 
T_DOT_WHILEZ . . . . . . . . . .        Number           17Bh 
T_DOT_WIDTH  . . . . . . . . . .        Number            FEh 
T_DOT_X64  . . . . . . . . . . .        Number           12Ah 
T_DOT_X64P . . . . . . . . . . .        Number           12Bh 
T_DOT_XALL . . . . . . . . . . .        Number           143h 
T_DOT_XCREF  . . . . . . . . . .        Number           13Ah 
T_DOT_XLIST  . . . . . . . . . .        Number           13Bh 
T_DOT_XMM  . . . . . . . . . . .        Number           129h 
T_DPPD . . . . . . . . . . . . .        Number           4D8h 
T_DPPS . . . . . . . . . . . . .        Number           4D9h 
T_DQ . . . . . . . . . . . . . .        Number           200h 
T_DR0  . . . . . . . . . . . . .        Number            4Ch 
T_DR1  . . . . . . . . . . . . .        Number            4Dh 
T_DR2  . . . . . . . . . . . . .        Number            4Eh 
T_DR3  . . . . . . . . . . . . .        Number            4Fh 
T_DR6  . . . . . . . . . . . . .        Number            50h 
T_DR7  . . . . . . . . . . . . .        Number            51h 
T_DS . . . . . . . . . . . . . .        Number            1Ch 
T_DT . . . . . . . . . . . . . .        Number           201h 
T_DUP  . . . . . . . . . . . . .        Number           10Bh 
T_DW . . . . . . . . . . . . . .        Number           1FDh 
T_DWORD  . . . . . . . . . . . .        Number            D2h 
T_DX . . . . . . . . . . . . . .        Number             Bh 
T_EAX  . . . . . . . . . . . . .        Number            11h 
T_EBP  . . . . . . . . . . . . .        Number            16h 
T_EBX  . . . . . . . . . . . . .        Number            14h 
T_ECHO . . . . . . . . . . . . .        Number           221h 
T_ECX  . . . . . . . . . . . . .        Number            12h 
T_EDI  . . . . . . . . . . . . .        Number            18h 
T_EDX  . . . . . . . . . . . . .        Number            13h 
T_ELSE . . . . . . . . . . . . .        Number           1DCh 
T_ELSEIF . . . . . . . . . . . .        Number           1DDh 
T_ELSEIF1  . . . . . . . . . . .        Number           1DFh 
T_ELSEIF2  . . . . . . . . . . .        Number           1E0h 
T_ELSEIFB  . . . . . . . . . . .        Number           1E5h 
T_ELSEIFDEF  . . . . . . . . . .        Number           1E7h 
T_ELSEIFDIF  . . . . . . . . . .        Number           1E1h 
T_ELSEIFDIFI . . . . . . . . . .        Number           1E2h 
T_ELSEIFE  . . . . . . . . . . .        Number           1DEh 
T_ELSEIFIDN  . . . . . . . . . .        Number           1E3h 
T_ELSEIFIDNI . . . . . . . . . .        Number           1E4h 
T_ELSEIFNB . . . . . . . . . . .        Number           1E6h 
T_ELSEIFNDEF . . . . . . . . . .        Number           1E8h 
T_EMMS . . . . . . . . . . . . .        Number           3AEh 
T_END  . . . . . . . . . . . . .        Number           222h 
T_ENDBR32  . . . . . . . . . . .        Number           4D3h 
T_ENDBR64  . . . . . . . . . . .        Number           4D2h 
T_ENDIF  . . . . . . . . . . . .        Number           1E9h 
T_ENDM . . . . . . . . . . . . .        Number           1F3h 
T_ENDP . . . . . . . . . . . . .        Number           215h 
T_ENDS . . . . . . . . . . . . .        Number           21Dh 
T_ENTER  . . . . . . . . . . . .        Number           2D0h 
T_EQ . . . . . . . . . . . . . .        Number           102h 
T_EQU  . . . . . . . . . . . . .        Number           223h 
T_ES . . . . . . . . . . . . . .        Number            19h 
T_ESI  . . . . . . . . . . . . .        Number            17h 
T_ESP  . . . . . . . . . . . . .        Number            15h 
T_EVEN . . . . . . . . . . . . .        Number           21Bh 
T_EVEX_OPT . . . . . . . . . . .        Number            10h 
T_EXITM  . . . . . . . . . . . .        Number           1F2h 
T_EXPAND . . . . . . . . . . . .        Number            40h 
T_EXPR . . . . . . . . . . . . .        Number            20h 
T_EXTERN . . . . . . . . . . . .        Number           20Fh 
T_EXTERNDEF  . . . . . . . . . .        Number           211h 
T_EXTRACTPS  . . . . . . . . . .        Number           4DAh 
T_EXTRN  . . . . . . . . . . . .        Number           210h 
T_F2XM1  . . . . . . . . . . . .        Number           38Eh 
T_FABS . . . . . . . . . . . . .        Number           38Fh 
T_FADD . . . . . . . . . . . . .        Number           350h 
T_FADDP  . . . . . . . . . . . .        Number           351h 
T_FAR  . . . . . . . . . . . . .        Number            E2h 
T_FAR16  . . . . . . . . . . . .        Number            E5h 
T_FAR32  . . . . . . . . . . . .        Number            E6h 
T_FASTCALL . . . . . . . . . . .        Number           116h 
T_FBLD . . . . . . . . . . . . .        Number           390h 
T_FBSTP  . . . . . . . . . . . .        Number           391h 
T_FCHS . . . . . . . . . . . . .        Number           392h 
T_FCLEX  . . . . . . . . . . . .        Number           38Ch 
T_FCMOVB . . . . . . . . . . . .        Number           33Eh 
T_FCMOVBE  . . . . . . . . . . .        Number           33Fh 
T_FCMOVE . . . . . . . . . . . .        Number           340h 
T_FCMOVNB  . . . . . . . . . . .        Number           341h 
T_FCMOVNBE . . . . . . . . . . .        Number           342h 
T_FCMOVNE  . . . . . . . . . . .        Number           343h 
T_FCMOVNU  . . . . . . . . . . .        Number           344h 
T_FCMOVU . . . . . . . . . . . .        Number           345h 
T_FCOM . . . . . . . . . . . . .        Number           346h 
T_FCOMI  . . . . . . . . . . . .        Number           34Ch 
T_FCOMIP . . . . . . . . . . . .        Number           34Dh 
T_FCOMP  . . . . . . . . . . . .        Number           347h 
T_FCOMPP . . . . . . . . . . . .        Number           348h 
T_FCOS . . . . . . . . . . . . .        Number           381h 
T_FDECSTP  . . . . . . . . . . .        Number           39Ah 
T_FDISI  . . . . . . . . . . . .        Number           388h 
T_FDIV . . . . . . . . . . . . .        Number           354h 
T_FDIVP  . . . . . . . . . . . .        Number           355h 
T_FDIVR  . . . . . . . . . . . .        Number           356h 
T_FDIVRP . . . . . . . . . . . .        Number           357h 
T_FEMMS  . . . . . . . . . . . .        Number           481h 
T_FENI . . . . . . . . . . . . .        Number           38Ah 
T_FFREE  . . . . . . . . . . . .        Number           39Ch 
T_FFREEP . . . . . . . . . . . .        Number           39Dh 
T_FIADD  . . . . . . . . . . . .        Number           35Ch 
T_FICOM  . . . . . . . . . . . .        Number           35Dh 
T_FICOMP . . . . . . . . . . . .        Number           35Eh 
T_FIDIV  . . . . . . . . . . . .        Number           35Fh 
T_FIDIVR . . . . . . . . . . . .        Number           360h 
T_FILD . . . . . . . . . . . . .        Number           364h 
T_FIMUL  . . . . . . . . . . . .        Number           361h 
T_FINAL  . . . . . . . . . . . .        Number             0h 
T_FINCSTP  . . . . . . . . . . .        Number           39Bh 
T_FINIT  . . . . . . . . . . . .        Number           386h 
T_FIST . . . . . . . . . . . . .        Number           366h 
T_FISTP  . . . . . . . . . . . .        Number           365h 
T_FISTTP . . . . . . . . . . . .        Number           49Eh 
T_FISUB  . . . . . . . . . . . .        Number           362h 
T_FISUBR . . . . . . . . . . . .        Number           363h 
T_FLAT . . . . . . . . . . . . .        Number           10Dh 
T_FLD  . . . . . . . . . . . . .        Number           367h 
T_FLD1 . . . . . . . . . . . . .        Number           393h 
T_FLDCW  . . . . . . . . . . . .        Number           37Ch 
T_FLDENV . . . . . . . . . . . .        Number           36Ah 
T_FLDENVD  . . . . . . . . . . .        Number           36Bh 
T_FLDENVW  . . . . . . . . . . .        Number           36Ch 
T_FLDL2E . . . . . . . . . . . .        Number           394h 
T_FLDL2T . . . . . . . . . . . .        Number           395h 
T_FLDLG2 . . . . . . . . . . . .        Number           396h 
T_FLDLN2 . . . . . . . . . . . .        Number           397h 
T_FLDPI  . . . . . . . . . . . .        Number           398h 
T_FLDZ . . . . . . . . . . . . .        Number           399h 
T_FLOAT  . . . . . . . . . . . .        Number             Bh 
T_FMUL . . . . . . . . . . . . .        Number           352h 
T_FMULP  . . . . . . . . . . . .        Number           353h 
T_FNCLEX . . . . . . . . . . . .        Number           38Dh 
T_FNDISI . . . . . . . . . . . .        Number           389h 
T_FNENI  . . . . . . . . . . . .        Number           38Bh 
T_FNINIT . . . . . . . . . . . .        Number           387h 
T_FNOP . . . . . . . . . . . . .        Number           39Eh 
T_FNSAVE . . . . . . . . . . . .        Number           36Dh 
T_FNSAVED  . . . . . . . . . . .        Number           36Eh 
T_FNSAVEW  . . . . . . . . . . .        Number           36Fh 
T_FNSTCW . . . . . . . . . . . .        Number           37Dh 
T_FNSTENV  . . . . . . . . . . .        Number           370h 
T_FNSTENVD . . . . . . . . . . .        Number           371h 
T_FNSTENVW . . . . . . . . . . .        Number           372h 
T_FNSTSW . . . . . . . . . . . .        Number           37Eh 
T_FOR  . . . . . . . . . . . . .        Number           1EAh 
T_FORC . . . . . . . . . . . . .        Number           1EBh 
T_FORTRAN  . . . . . . . . . . .        Number           114h 
T_FPATAN . . . . . . . . . . . .        Number           382h 
T_FPREM  . . . . . . . . . . . .        Number           39Fh 
T_FPREM1 . . . . . . . . . . . .        Number           3A0h 
T_FPTAN  . . . . . . . . . . . .        Number           383h 
T_FRAME  . . . . . . . . . . . .        Number           10Fh 
T_FRNDINT  . . . . . . . . . . .        Number           3A1h 
T_FRSTOR . . . . . . . . . . . .        Number           373h 
T_FRSTORD  . . . . . . . . . . .        Number           374h 
T_FRSTORW  . . . . . . . . . . .        Number           375h 
T_FS . . . . . . . . . . . . . .        Number            1Dh 
T_FSAVE  . . . . . . . . . . . .        Number           376h 
T_FSAVED . . . . . . . . . . . .        Number           377h 
T_FSAVEW . . . . . . . . . . . .        Number           378h 
T_FSCALE . . . . . . . . . . . .        Number           3A2h 
T_FSETPM . . . . . . . . . . . .        Number           3A3h 
T_FSIN . . . . . . . . . . . . .        Number           384h 
T_FSINCOS  . . . . . . . . . . .        Number           385h 
T_FSQRT  . . . . . . . . . . . .        Number           3A4h 
T_FST  . . . . . . . . . . . . .        Number           369h 
T_FSTCW  . . . . . . . . . . . .        Number           37Fh 
T_FSTENV . . . . . . . . . . . .        Number           379h 
T_FSTENVD  . . . . . . . . . . .        Number           37Ah 
T_FSTENVW  . . . . . . . . . . .        Number           37Bh 
T_FSTP . . . . . . . . . . . . .        Number           368h 
T_FSTSW  . . . . . . . . . . . .        Number           380h 
T_FSUB . . . . . . . . . . . . .        Number           358h 
T_FSUBP  . . . . . . . . . . . .        Number           359h 
T_FSUBR  . . . . . . . . . . . .        Number           35Ah 
T_FSUBRP . . . . . . . . . . . .        Number           35Bh 
T_FTST . . . . . . . . . . . . .        Number           3A5h 
T_FUCOM  . . . . . . . . . . . .        Number           349h 
T_FUCOMI . . . . . . . . . . . .        Number           34Eh 
T_FUCOMIP  . . . . . . . . . . .        Number           34Fh 
T_FUCOMP . . . . . . . . . . . .        Number           34Ah 
T_FUCOMPP  . . . . . . . . . . .        Number           34Bh 
T_FWAIT  . . . . . . . . . . . .        Number           3A6h 
T_FWORD  . . . . . . . . . . . .        Number            D5h 
T_FXAM . . . . . . . . . . . . .        Number           3A7h 
T_FXCH . . . . . . . . . . . . .        Number           3A8h 
T_FXRSTOR  . . . . . . . . . . .        Number           3A9h 
T_FXSAVE . . . . . . . . . . . .        Number           3AAh 
T_FXTRACT  . . . . . . . . . . .        Number           3ABh 
T_FYL2X  . . . . . . . . . . . .        Number           3ACh 
T_FYL2XP1  . . . . . . . . . . .        Number           3ADh 
T_GE . . . . . . . . . . . . . .        Number           104h 
T_GOTO . . . . . . . . . . . . .        Number           1F4h 
T_GROUP  . . . . . . . . . . . .        Number           21Eh 
T_GS . . . . . . . . . . . . . .        Number            1Eh 
T_GT . . . . . . . . . . . . . .        Number           105h 
T_HADDPD . . . . . . . . . . . .        Number           49Fh 
T_HADDPS . . . . . . . . . . . .        Number           4A0h 
T_HIGH32 . . . . . . . . . . . .        Number            EBh 
T_HIGH64 . . . . . . . . . . . .        Number            FFh 
T_HIGHWORD . . . . . . . . . . .        Number            ECh 
T_HLLCODE  . . . . . . . . . . .        Number             1h 
T_HLT  . . . . . . . . . . . . .        Number           2D1h 
T_HSUBPD . . . . . . . . . . . .        Number           4A1h 
T_HSUBPS . . . . . . . . . . . .        Number           4A2h 
T_ID . . . . . . . . . . . . . .        Number             8h 
T_IDIV . . . . . . . . . . . . .        Number           2A6h 
T_IF . . . . . . . . . . . . . .        Number           1D0h 
T_IF1  . . . . . . . . . . . . .        Number           1D2h 
T_IF2  . . . . . . . . . . . . .        Number           1D3h 
T_IFB  . . . . . . . . . . . . .        Number           1D8h 
T_IFDEF  . . . . . . . . . . . .        Number           1DAh 
T_IFDIF  . . . . . . . . . . . .        Number           1D4h 
T_IFDIFI . . . . . . . . . . . .        Number           1D5h 
T_IFE  . . . . . . . . . . . . .        Number           1D1h 
T_IFIDN  . . . . . . . . . . . .        Number           1D6h 
T_IFIDNI . . . . . . . . . . . .        Number           1D7h 
T_IFNB . . . . . . . . . . . . .        Number           1D9h 
T_IFNDEF . . . . . . . . . . . .        Number           1DBh 
T_IMAGEREL . . . . . . . . . . .        Number            EDh 
T_IMUL . . . . . . . . . . . . .        Number           2D2h 
T_IN . . . . . . . . . . . . . .        Number           2D3h 
T_INC  . . . . . . . . . . . . .        Number           2BBh 
T_INCBIN . . . . . . . . . . . .        Number           225h 
T_INCLUDE  . . . . . . . . . . .        Number           1F6h 
T_INCLUDELIB . . . . . . . . . .        Number           226h 
T_INS  . . . . . . . . . . . . .        Number           271h 
T_INSB . . . . . . . . . . . . .        Number           272h 
T_INSD . . . . . . . . . . . . .        Number           274h 
T_INSERTPS . . . . . . . . . . .        Number           4DBh 
T_INSTR  . . . . . . . . . . . .        Number           1FAh 
T_INSTRUCTION  . . . . . . . . .        Number             1h 
T_INSW . . . . . . . . . . . . .        Number           273h 
T_INT  . . . . . . . . . . . . .        Number           2D4h 
T_INTO . . . . . . . . . . . . .        Number           2D5h 
T_INVD . . . . . . . . . . . . .        Number           2D6h 
T_INVEPT . . . . . . . . . . . .        Number           523h 
T_INVLPG . . . . . . . . . . . .        Number           2D7h 
T_INVOKE . . . . . . . . . . . .        Number           218h 
T_INVPCID  . . . . . . . . . . .        Number           50Dh 
T_INVVPID  . . . . . . . . . . .        Number           524h 
T_IRET . . . . . . . . . . . . .        Number           2D8h 
T_IRETD  . . . . . . . . . . . .        Number           2D9h 
T_IRETDF . . . . . . . . . . . .        Number           2DBh 
T_IRETF  . . . . . . . . . . . .        Number           2DAh 
T_IRETQ  . . . . . . . . . . . .        Number           4C5h 
T_IRP  . . . . . . . . . . . . .        Number           1ECh 
T_IRPC . . . . . . . . . . . . .        Number           1EDh 
T_ISFUNC . . . . . . . . . . . .        Number             4h 
T_ISPROC . . . . . . . . . . . .        Number             8h 
T_JA . . . . . . . . . . . . . .        Number           22Dh 
T_JAE  . . . . . . . . . . . . .        Number           22Eh 
T_JB . . . . . . . . . . . . . .        Number           22Fh 
T_JBE  . . . . . . . . . . . . .        Number           230h 
T_JC . . . . . . . . . . . . . .        Number           231h 
T_JCXZ . . . . . . . . . . . . .        Number           24Bh 
T_JE . . . . . . . . . . . . . .        Number           232h 
T_JECXZ  . . . . . . . . . . . .        Number           24Ch 
T_JG . . . . . . . . . . . . . .        Number           233h 
T_JGE  . . . . . . . . . . . . .        Number           234h 
T_JL . . . . . . . . . . . . . .        Number           235h 
T_JLE  . . . . . . . . . . . . .        Number           236h 
T_JMP  . . . . . . . . . . . . .        Number           22Ch 
T_JNA  . . . . . . . . . . . . .        Number           237h 
T_JNAE . . . . . . . . . . . . .        Number           238h 
T_JNB  . . . . . . . . . . . . .        Number           239h 
T_JNBE . . . . . . . . . . . . .        Number           23Ah 
T_JNC  . . . . . . . . . . . . .        Number           23Bh 
T_JNE  . . . . . . . . . . . . .        Number           23Ch 
T_JNG  . . . . . . . . . . . . .        Number           23Dh 
T_JNGE . . . . . . . . . . . . .        Number           23Eh 
T_JNL  . . . . . . . . . . . . .        Number           23Fh 
T_JNLE . . . . . . . . . . . . .        Number           240h 
T_JNO  . . . . . . . . . . . . .        Number           241h 
T_JNP  . . . . . . . . . . . . .        Number           242h 
T_JNS  . . . . . . . . . . . . .        Number           243h 
T_JNZ  . . . . . . . . . . . . .        Number           244h 
T_JO . . . . . . . . . . . . . .        Number           245h 
T_JP . . . . . . . . . . . . . .        Number           246h 
T_JPE  . . . . . . . . . . . . .        Number           247h 
T_JPO  . . . . . . . . . . . . .        Number           248h 
T_JRCXZ  . . . . . . . . . . . .        Number           24Dh 
T_JS . . . . . . . . . . . . . .        Number           249h 
T_JZ . . . . . . . . . . . . . .        Number           24Ah 
T_K0 . . . . . . . . . . . . . .        Number            38h 
T_K1 . . . . . . . . . . . . . .        Number            39h 
T_K2 . . . . . . . . . . . . . .        Number            3Ah 
T_K3 . . . . . . . . . . . . . .        Number            3Bh 
T_K4 . . . . . . . . . . . . . .        Number            3Ch 
T_K5 . . . . . . . . . . . . . .        Number            3Dh 
T_K6 . . . . . . . . . . . . . .        Number            3Eh 
T_K7 . . . . . . . . . . . . . .        Number            3Fh 
T_KADDB  . . . . . . . . . . . .        Number           668h 
T_KADDD  . . . . . . . . . . . .        Number           676h 
T_KADDQ  . . . . . . . . . . . .        Number           677h 
T_KADDW  . . . . . . . . . . . .        Number           669h 
T_KANDB  . . . . . . . . . . . .        Number           66Ah 
T_KANDD  . . . . . . . . . . . .        Number           678h 
T_KANDNB . . . . . . . . . . . .        Number           66Ch 
T_KANDND . . . . . . . . . . . .        Number           67Ah 
T_KANDNQ . . . . . . . . . . . .        Number           67Bh 
T_KANDNW . . . . . . . . . . . .        Number           66Dh 
T_KANDQ  . . . . . . . . . . . .        Number           679h 
T_KANDW  . . . . . . . . . . . .        Number           66Bh 
T_KMOVB  . . . . . . . . . . . .        Number           693h 
T_KMOVD  . . . . . . . . . . . .        Number           694h 
T_KMOVQ  . . . . . . . . . . . .        Number           695h 
T_KMOVW  . . . . . . . . . . . .        Number           696h 
T_KNOTB  . . . . . . . . . . . .        Number           683h 
T_KNOTD  . . . . . . . . . . . .        Number           685h 
T_KNOTQ  . . . . . . . . . . . .        Number           686h 
T_KNOTW  . . . . . . . . . . . .        Number           684h 
T_KORB . . . . . . . . . . . . .        Number           66Eh 
T_KORD . . . . . . . . . . . . .        Number           67Ch 
T_KORQ . . . . . . . . . . . . .        Number           67Dh 
T_KORTESTB . . . . . . . . . . .        Number           687h 
T_KORTESTD . . . . . . . . . . .        Number           689h 
T_KORTESTQ . . . . . . . . . . .        Number           68Ah 
T_KORTESTW . . . . . . . . . . .        Number           688h 
T_KORW . . . . . . . . . . . . .        Number           66Fh 
T_KSHIFTLB . . . . . . . . . . .        Number           68Bh 
T_KSHIFTLD . . . . . . . . . . .        Number           68Dh 
T_KSHIFTLQ . . . . . . . . . . .        Number           68Eh 
T_KSHIFTLW . . . . . . . . . . .        Number           68Ch 
T_KSHIFTRB . . . . . . . . . . .        Number           68Fh 
T_KSHIFTRD . . . . . . . . . . .        Number           691h 
T_KSHIFTRQ . . . . . . . . . . .        Number           692h 
T_KSHIFTRW . . . . . . . . . . .        Number           690h 
T_KUNPCKBW . . . . . . . . . . .        Number           674h 
T_KUNPCKDQ . . . . . . . . . . .        Number           682h 
T_KUNPCKWD . . . . . . . . . . .        Number           675h 
T_KXNORB . . . . . . . . . . . .        Number           672h 
T_KXNORD . . . . . . . . . . . .        Number           680h 
T_KXNORQ . . . . . . . . . . . .        Number           681h 
T_KXNORW . . . . . . . . . . . .        Number           673h 
T_KXORB  . . . . . . . . . . . .        Number           670h 
T_KXORD  . . . . . . . . . . . .        Number           67Eh 
T_KXORQ  . . . . . . . . . . . .        Number           67Fh 
T_KXORW  . . . . . . . . . . . .        Number           671h 
T_LABEL  . . . . . . . . . . . .        Number           217h 
T_LAHF . . . . . . . . . . . . .        Number           2DCh 
T_LAR  . . . . . . . . . . . . .        Number           2DDh 
T_LDDQU  . . . . . . . . . . . .        Number           4A3h 
T_LDMXCSR  . . . . . . . . . . .        Number           3B0h 
T_LDS  . . . . . . . . . . . . .        Number           28Fh 
T_LE . . . . . . . . . . . . . .        Number           106h 
T_LEA  . . . . . . . . . . . . .        Number           2DFh 
T_LEAVE  . . . . . . . . . . . .        Number           2E0h 
T_LENGTHOF . . . . . . . . . . .        Number            EFh 
T_LES  . . . . . . . . . . . . .        Number           290h 
T_LFENCE . . . . . . . . . . . .        Number           3B2h 
T_LFS  . . . . . . . . . . . . .        Number           2E1h 
T_LGDT . . . . . . . . . . . . .        Number           2E4h 
T_LGS  . . . . . . . . . . . . .        Number           2E2h 
T_LIDT . . . . . . . . . . . . .        Number           2E5h 
T_LLDT . . . . . . . . . . . . .        Number           29Dh 
T_LMSW . . . . . . . . . . . . .        Number           29Eh 
T_LOCAL  . . . . . . . . . . . .        Number           216h 
T_LOCK . . . . . . . . . . . . .        Number           2AAh 
T_LODS . . . . . . . . . . . . .        Number           275h 
T_LODSB  . . . . . . . . . . . .        Number           276h 
T_LODSD  . . . . . . . . . . . .        Number           278h 
T_LODSQ  . . . . . . . . . . . .        Number           4C9h 
T_LODSW  . . . . . . . . . . . .        Number           277h 
T_LOOP . . . . . . . . . . . . .        Number           24Eh 
T_LOOPD  . . . . . . . . . . . .        Number           253h 
T_LOOPE  . . . . . . . . . . . .        Number           24Fh 
T_LOOPED . . . . . . . . . . . .        Number           254h 
T_LOOPEW . . . . . . . . . . . .        Number           259h 
T_LOOPNE . . . . . . . . . . . .        Number           251h 
T_LOOPNED  . . . . . . . . . . .        Number           256h 
T_LOOPNEW  . . . . . . . . . . .        Number           25Bh 
T_LOOPNZ . . . . . . . . . . . .        Number           252h 
T_LOOPNZD  . . . . . . . . . . .        Number           257h 
T_LOOPNZW  . . . . . . . . . . .        Number           25Ch 
T_LOOPW  . . . . . . . . . . . .        Number           258h 
T_LOOPZ  . . . . . . . . . . . .        Number           250h 
T_LOOPZD . . . . . . . . . . . .        Number           255h 
T_LOOPZW . . . . . . . . . . . .        Number           25Ah 
T_LOW32  . . . . . . . . . . . .        Number            F1h 
T_LOW64  . . . . . . . . . . . .        Number           100h 
T_LOWWORD  . . . . . . . . . . .        Number            F2h 
T_LROFFSET . . . . . . . . . . .        Number            F3h 
T_LSL  . . . . . . . . . . . . .        Number           2DEh 
T_LSS  . . . . . . . . . . . . .        Number           2E3h 
T_LT . . . . . . . . . . . . . .        Number           107h 
T_LTR  . . . . . . . . . . . . .        Number           29Fh 
T_LZCNT  . . . . . . . . . . . .        Number           50Bh 
T_MACRO  . . . . . . . . . . . .        Number           1F1h 
T_MASKMOVDQU . . . . . . . . . .        Number           419h 
T_MASKMOVQ . . . . . . . . . . .        Number           41Ah 
T_MAXPD  . . . . . . . . . . . .        Number           3C2h 
T_MAXPS  . . . . . . . . . . . .        Number           3C3h 
T_MAXSD  . . . . . . . . . . . .        Number           3C4h 
T_MAXSS  . . . . . . . . . . . .        Number           3C5h 
T_MFENCE . . . . . . . . . . . .        Number           3B3h 
T_MINPD  . . . . . . . . . . . .        Number           3C6h 
T_MINPS  . . . . . . . . . . . .        Number           3C7h 
T_MINSD  . . . . . . . . . . . .        Number           3C8h 
T_MINSS  . . . . . . . . . . . .        Number           3C9h 
T_MM0  . . . . . . . . . . . . .        Number            20h 
T_MM1  . . . . . . . . . . . . .        Number            21h 
T_MM2  . . . . . . . . . . . . .        Number            22h 
T_MM3  . . . . . . . . . . . . .        Number            23h 
T_MM4  . . . . . . . . . . . . .        Number            24h 
T_MM5  . . . . . . . . . . . . .        Number            25h 
T_MM6  . . . . . . . . . . . . .        Number            26h 
T_MM7  . . . . . . . . . . . . .        Number            27h 
T_MMWORD . . . . . . . . . . . .        Number            E7h 
T_MOD  . . . . . . . . . . . . .        Number           108h 
T_MONITOR  . . . . . . . . . . .        Number           4A4h 
T_MOV  . . . . . . . . . . . . .        Number           2C2h 
T_MOVAPD . . . . . . . . . . . .        Number           41Dh 
T_MOVAPS . . . . . . . . . . . .        Number           41Eh 
T_MOVBE  . . . . . . . . . . . .        Number           2C3h 
T_MOVD . . . . . . . . . . . . .        Number           41Bh 
T_MOVDDUP  . . . . . . . . . . .        Number           4A5h 
T_MOVDQ2Q  . . . . . . . . . . .        Number           429h 
T_MOVDQA . . . . . . . . . . . .        Number           41Fh 
T_MOVDQU . . . . . . . . . . . .        Number           420h 
T_MOVHLPS  . . . . . . . . . . .        Number           427h 
T_MOVHPD . . . . . . . . . . . .        Number           423h 
T_MOVHPS . . . . . . . . . . . .        Number           424h 
T_MOVLHPS  . . . . . . . . . . .        Number           428h 
T_MOVLPD . . . . . . . . . . . .        Number           425h 
T_MOVLPS . . . . . . . . . . . .        Number           426h 
T_MOVMSKPD . . . . . . . . . . .        Number           42Bh 
T_MOVMSKPS . . . . . . . . . . .        Number           42Ch 
T_MOVNTDQ  . . . . . . . . . . .        Number           42Dh 
T_MOVNTDQA . . . . . . . . . . .        Number           4DCh 
T_MOVNTI . . . . . . . . . . . .        Number           42Eh 
T_MOVNTPD  . . . . . . . . . . .        Number           42Fh 
T_MOVNTPS  . . . . . . . . . . .        Number           430h 
T_MOVNTQ . . . . . . . . . . . .        Number           431h 
T_MOVQ . . . . . . . . . . . . .        Number           41Ch 
T_MOVQ2DQ  . . . . . . . . . . .        Number           42Ah 
T_MOVS . . . . . . . . . . . . .        Number           279h 
T_MOVSB  . . . . . . . . . . . .        Number           27Ah 
T_MOVSD  . . . . . . . . . . . .        Number           27Ch 
T_MOVSHDUP . . . . . . . . . . .        Number           4A6h 
T_MOVSLDUP . . . . . . . . . . .        Number           4A7h 
T_MOVSQ  . . . . . . . . . . . .        Number           4CAh 
T_MOVSS  . . . . . . . . . . . .        Number           432h 
T_MOVSW  . . . . . . . . . . . .        Number           27Bh 
T_MOVSX  . . . . . . . . . . . .        Number           2E6h 
T_MOVSXD . . . . . . . . . . . .        Number           4C7h 
T_MOVUPD . . . . . . . . . . . .        Number           421h 
T_MOVUPS . . . . . . . . . . . .        Number           422h 
T_MOVZX  . . . . . . . . . . . .        Number           2E7h 
T_MPSADBW  . . . . . . . . . . .        Number           4DDh 
T_MUL  . . . . . . . . . . . . .        Number           2A7h 
T_MULPD  . . . . . . . . . . . .        Number           3CAh 
T_MULPS  . . . . . . . . . . . .        Number           3CBh 
T_MULSD  . . . . . . . . . . . .        Number           3CCh 
T_MULSS  . . . . . . . . . . . .        Number           3CDh 
T_MULX . . . . . . . . . . . . .        Number           63Fh 
T_MWAIT  . . . . . . . . . . . .        Number           4A8h 
T_NE . . . . . . . . . . . . . .        Number           103h 
T_NEAR . . . . . . . . . . . . .        Number            E1h 
T_NEAR16 . . . . . . . . . . . .        Number            E3h 
T_NEAR32 . . . . . . . . . . . .        Number            E4h 
T_NEG  . . . . . . . . . . . . .        Number           2A8h 
T_NOP  . . . . . . . . . . . . .        Number           2E8h 
T_NOT  . . . . . . . . . . . . .        Number           2A9h 
T_NULL . . . . . . . . . . . . .        Number             0h 
T_NUM  . . . . . . . . . . . . .        Number             Ah 
T_OFFSET . . . . . . . . . . . .        Number            F5h 
T_OPATTR . . . . . . . . . . . .        Number            F6h 
T_OPTION . . . . . . . . . . . .        Number           228h 
T_OP_BRACKET . . . . . . . . . .        Number            28h 
T_OP_SQ_BRACKET  . . . . . . . .        Number            5Bh 
T_OR . . . . . . . . . . . . . .        Number           25Eh 
T_ORG  . . . . . . . . . . . . .        Number           219h 
T_ORPD . . . . . . . . . . . . .        Number           3FDh 
T_ORPS . . . . . . . . . . . . .        Number           3FEh 
T_OUT  . . . . . . . . . . . . .        Number           2E9h 
T_OUTS . . . . . . . . . . . . .        Number           27Dh 
T_OUTSB  . . . . . . . . . . . .        Number           27Eh 
T_OUTSD  . . . . . . . . . . . .        Number           280h 
T_OUTSW  . . . . . . . . . . . .        Number           27Fh 
T_OWORD  . . . . . . . . . . . .        Number            DBh 
T_PABSB  . . . . . . . . . . . .        Number           4A9h 
T_PABSD  . . . . . . . . . . . .        Number           4AAh 
T_PABSW  . . . . . . . . . . . .        Number           4ABh 
T_PACKSSDW . . . . . . . . . . .        Number           433h 
T_PACKSSWB . . . . . . . . . . .        Number           434h 
T_PACKUSDW . . . . . . . . . . .        Number           4DEh 
T_PACKUSWB . . . . . . . . . . .        Number           435h 
T_PADDB  . . . . . . . . . . . .        Number           436h 
T_PADDD  . . . . . . . . . . . .        Number           438h 
T_PADDQ  . . . . . . . . . . . .        Number           439h 
T_PADDSB . . . . . . . . . . . .        Number           43Ah 
T_PADDSW . . . . . . . . . . . .        Number           43Bh 
T_PADDUSB  . . . . . . . . . . .        Number           43Ch 
T_PADDUSW  . . . . . . . . . . .        Number           43Dh 
T_PADDW  . . . . . . . . . . . .        Number           437h 
T_PALIGNR  . . . . . . . . . . .        Number           4ACh 
T_PAND . . . . . . . . . . . . .        Number           43Eh 
T_PANDN  . . . . . . . . . . . .        Number           43Fh 
T_PASCAL . . . . . . . . . . . .        Number           113h 
T_PAUSE  . . . . . . . . . . . .        Number           3B9h 
T_PAVGB  . . . . . . . . . . . .        Number           440h 
T_PAVGUSB  . . . . . . . . . . .        Number           484h 
T_PAVGW  . . . . . . . . . . . .        Number           441h 
T_PBLENDVB . . . . . . . . . . .        Number           4DFh 
T_PBLENDW  . . . . . . . . . . .        Number           4E0h 
T_PCLMULQDQ  . . . . . . . . . .        Number           4B9h 
T_PCMPEQB  . . . . . . . . . . .        Number           442h 
T_PCMPEQD  . . . . . . . . . . .        Number           444h 
T_PCMPEQQ  . . . . . . . . . . .        Number           4E1h 
T_PCMPEQW  . . . . . . . . . . .        Number           443h 
T_PCMPESTRI  . . . . . . . . . .        Number           504h 
T_PCMPESTRM  . . . . . . . . . .        Number           503h 
T_PCMPGTB  . . . . . . . . . . .        Number           445h 
T_PCMPGTD  . . . . . . . . . . .        Number           447h 
T_PCMPGTQ  . . . . . . . . . . .        Number           507h 
T_PCMPGTW  . . . . . . . . . . .        Number           446h 
T_PCMPISTRI  . . . . . . . . . .        Number           506h 
T_PCMPISTRM  . . . . . . . . . .        Number           505h 
T_PDEP . . . . . . . . . . . . .        Number           645h 
T_PERCENT  . . . . . . . . . . .        Number            25h 
T_PEXT . . . . . . . . . . . . .        Number           646h 
T_PEXTRB . . . . . . . . . . . .        Number           4E2h 
T_PEXTRD . . . . . . . . . . . .        Number           4E3h 
T_PEXTRQ . . . . . . . . . . . .        Number           4CDh 
T_PEXTRW . . . . . . . . . . . .        Number           448h 
T_PF2ID  . . . . . . . . . . . .        Number           485h 
T_PF2IW  . . . . . . . . . . . .        Number           486h 
T_PFACC  . . . . . . . . . . . .        Number           487h 
T_PFADD  . . . . . . . . . . . .        Number           488h 
T_PFCMPEQ  . . . . . . . . . . .        Number           489h 
T_PFCMPGE  . . . . . . . . . . .        Number           48Ah 
T_PFCMPGT  . . . . . . . . . . .        Number           48Bh 
T_PFMAX  . . . . . . . . . . . .        Number           48Ch 
T_PFMIN  . . . . . . . . . . . .        Number           48Dh 
T_PFMUL  . . . . . . . . . . . .        Number           48Eh 
T_PFNACC . . . . . . . . . . . .        Number           48Fh 
T_PFPNACC  . . . . . . . . . . .        Number           490h 
T_PFRCP  . . . . . . . . . . . .        Number           491h 
T_PFRCPIT1 . . . . . . . . . . .        Number           492h 
T_PFRCPIT2 . . . . . . . . . . .        Number           493h 
T_PFRSQIT1 . . . . . . . . . . .        Number           494h 
T_PFRSQRT  . . . . . . . . . . .        Number           495h 
T_PFSUB  . . . . . . . . . . . .        Number           496h 
T_PFSUBR . . . . . . . . . . . .        Number           497h 
T_PHADDD . . . . . . . . . . . .        Number           4ADh 
T_PHADDSW  . . . . . . . . . . .        Number           4AEh 
T_PHADDW . . . . . . . . . . . .        Number           4AFh 
T_PHMINPOSUW . . . . . . . . . .        Number           4E4h 
T_PHSUBD . . . . . . . . . . . .        Number           4B0h 
T_PHSUBSW  . . . . . . . . . . .        Number           4B1h 
T_PHSUBW . . . . . . . . . . . .        Number           4B2h 
T_PI2FD  . . . . . . . . . . . .        Number           498h 
T_PI2FW  . . . . . . . . . . . .        Number           499h 
T_PINSRB . . . . . . . . . . . .        Number           4E5h 
T_PINSRD . . . . . . . . . . . .        Number           4E6h 
T_PINSRQ . . . . . . . . . . . .        Number           4CEh 
T_PINSRW . . . . . . . . . . . .        Number           449h 
T_PMADDUBSW  . . . . . . . . . .        Number           4B3h 
T_PMADDWD  . . . . . . . . . . .        Number           44Ah 
T_PMAXSB . . . . . . . . . . . .        Number           4E7h 
T_PMAXSD . . . . . . . . . . . .        Number           4E8h 
T_PMAXSW . . . . . . . . . . . .        Number           44Bh 
T_PMAXUB . . . . . . . . . . . .        Number           44Ch 
T_PMAXUD . . . . . . . . . . . .        Number           4EAh 
T_PMAXUW . . . . . . . . . . . .        Number           4E9h 
T_PMINSB . . . . . . . . . . . .        Number           4EBh 
T_PMINSD . . . . . . . . . . . .        Number           4ECh 
T_PMINSW . . . . . . . . . . . .        Number           44Dh 
T_PMINUB . . . . . . . . . . . .        Number           44Eh 
T_PMINUD . . . . . . . . . . . .        Number           4EEh 
T_PMINUW . . . . . . . . . . . .        Number           4EDh 
T_PMOVMSKB . . . . . . . . . . .        Number           44Fh 
T_PMOVSXBD . . . . . . . . . . .        Number           4F0h 
T_PMOVSXBQ . . . . . . . . . . .        Number           4F1h 
T_PMOVSXBW . . . . . . . . . . .        Number           4EFh 
T_PMOVSXDQ . . . . . . . . . . .        Number           4F6h 
T_PMOVSXWD . . . . . . . . . . .        Number           4F4h 
T_PMOVSXWQ . . . . . . . . . . .        Number           4F5h 
T_PMOVZXBD . . . . . . . . . . .        Number           4F8h 
T_PMOVZXBQ . . . . . . . . . . .        Number           4F3h 
T_PMOVZXBW . . . . . . . . . . .        Number           4F7h 
T_PMOVZXDQ . . . . . . . . . . .        Number           4F2h 
T_PMOVZXWD . . . . . . . . . . .        Number           4F9h 
T_PMOVZXWQ . . . . . . . . . . .        Number           4FAh 
T_PMULDQ . . . . . . . . . . . .        Number           4FBh 
T_PMULHRSW . . . . . . . . . . .        Number           4B4h 
T_PMULHRW  . . . . . . . . . . .        Number           49Ah 
T_PMULHUW  . . . . . . . . . . .        Number           450h 
T_PMULHW . . . . . . . . . . . .        Number           451h 
T_PMULLD . . . . . . . . . . . .        Number           4FCh 
T_PMULLW . . . . . . . . . . . .        Number           452h 
T_PMULUDQ  . . . . . . . . . . .        Number           453h 
T_POP  . . . . . . . . . . . . .        Number           2BEh 
T_POPA . . . . . . . . . . . . .        Number           291h 
T_POPAD  . . . . . . . . . . . .        Number           292h 
T_POPAW  . . . . . . . . . . . .        Number           293h 
T_POPCNT . . . . . . . . . . . .        Number           508h 
T_POPCONTEXT . . . . . . . . . .        Number           229h 
T_POPF . . . . . . . . . . . . .        Number           2C1h 
T_POPFD  . . . . . . . . . . . .        Number           294h 
T_POPFQ  . . . . . . . . . . . .        Number           4C4h 
T_POR  . . . . . . . . . . . . .        Number           454h 
T_PREFETCH . . . . . . . . . . .        Number           482h 
T_PREFETCHNTA  . . . . . . . . .        Number           3B5h 
T_PREFETCHT0 . . . . . . . . . .        Number           3B6h 
T_PREFETCHT1 . . . . . . . . . .        Number           3B7h 
T_PREFETCHT2 . . . . . . . . . .        Number           3B8h 
T_PREFETCHW  . . . . . . . . . .        Number           483h 
T_PROC . . . . . . . . . . . . .        Number           214h 
T_PROTO  . . . . . . . . . . . .        Number           213h 
T_PSADBW . . . . . . . . . . . .        Number           455h 
T_PSHUFB . . . . . . . . . . . .        Number           4B5h 
T_PSHUFD . . . . . . . . . . . .        Number           456h 
T_PSHUFHW  . . . . . . . . . . .        Number           458h 
T_PSHUFLW  . . . . . . . . . . .        Number           459h 
T_PSHUFW . . . . . . . . . . . .        Number           457h 
T_PSIGNB . . . . . . . . . . . .        Number           4B6h 
T_PSIGND . . . . . . . . . . . .        Number           4B7h 
T_PSIGNW . . . . . . . . . . . .        Number           4B8h 
T_PSLLD  . . . . . . . . . . . .        Number           45Bh 
T_PSLLDQ . . . . . . . . . . . .        Number           462h 
T_PSLLQ  . . . . . . . . . . . .        Number           45Ch 
T_PSLLW  . . . . . . . . . . . .        Number           45Ah 
T_PSRAD  . . . . . . . . . . . .        Number           45Eh 
T_PSRAW  . . . . . . . . . . . .        Number           45Dh 
T_PSRLD  . . . . . . . . . . . .        Number           460h 
T_PSRLDQ . . . . . . . . . . . .        Number           463h 
T_PSRLQ  . . . . . . . . . . . .        Number           461h 
T_PSRLW  . . . . . . . . . . . .        Number           45Fh 
T_PSUBB  . . . . . . . . . . . .        Number           464h 
T_PSUBD  . . . . . . . . . . . .        Number           466h 
T_PSUBQ  . . . . . . . . . . . .        Number           467h 
T_PSUBSB . . . . . . . . . . . .        Number           468h 
T_PSUBSW . . . . . . . . . . . .        Number           469h 
T_PSUBUSB  . . . . . . . . . . .        Number           46Ah 
T_PSUBUSW  . . . . . . . . . . .        Number           46Bh 
T_PSUBW  . . . . . . . . . . . .        Number           465h 
T_PSWAPD . . . . . . . . . . . .        Number           49Bh 
T_PTEST  . . . . . . . . . . . .        Number           4FDh 
T_PTR  . . . . . . . . . . . . .        Number           109h 
T_PUBLIC . . . . . . . . . . . .        Number           212h 
T_PUNPCKHBW  . . . . . . . . . .        Number           46Dh 
T_PUNPCKHDQ  . . . . . . . . . .        Number           46Fh 
T_PUNPCKHQDQ . . . . . . . . . .        Number           473h 
T_PUNPCKHWD  . . . . . . . . . .        Number           46Eh 
T_PUNPCKLBW  . . . . . . . . . .        Number           470h 
T_PUNPCKLDQ  . . . . . . . . . .        Number           472h 
T_PUNPCKLQDQ . . . . . . . . . .        Number           474h 
T_PUNPCKLWD  . . . . . . . . . .        Number           471h 
T_PURGE  . . . . . . . . . . . .        Number           1F5h 
T_PUSH . . . . . . . . . . . . .        Number           2BDh 
T_PUSHA  . . . . . . . . . . . .        Number           295h 
T_PUSHAD . . . . . . . . . . . .        Number           296h 
T_PUSHAW . . . . . . . . . . . .        Number           297h 
T_PUSHCONTEXT  . . . . . . . . .        Number           22Ah 
T_PUSHD  . . . . . . . . . . . .        Number           299h 
T_PUSHF  . . . . . . . . . . . .        Number           2C0h 
T_PUSHFD . . . . . . . . . . . .        Number           298h 
T_PUSHFQ . . . . . . . . . . . .        Number           4C3h 
T_PUSHW  . . . . . . . . . . . .        Number           2BFh 
T_PXOR . . . . . . . . . . . . .        Number           46Ch 
T_QUESTION_MARK  . . . . . . . .        Number            3Fh 
T_QWORD  . . . . . . . . . . . .        Number            D6h 
T_R10  . . . . . . . . . . . . .        Number            7Dh 
T_R10B . . . . . . . . . . . . .        Number            5Dh 
T_R10D . . . . . . . . . . . . .        Number            6Dh 
T_R10W . . . . . . . . . . . . .        Number            65h 
T_R11  . . . . . . . . . . . . .        Number            7Eh 
T_R11B . . . . . . . . . . . . .        Number            5Eh 
T_R11D . . . . . . . . . . . . .        Number            6Eh 
T_R11W . . . . . . . . . . . . .        Number            66h 
T_R12  . . . . . . . . . . . . .        Number            7Fh 
T_R12B . . . . . . . . . . . . .        Number            5Fh 
T_R12D . . . . . . . . . . . . .        Number            6Fh 
T_R12W . . . . . . . . . . . . .        Number            67h 
T_R13  . . . . . . . . . . . . .        Number            80h 
T_R13B . . . . . . . . . . . . .        Number            60h 
T_R13D . . . . . . . . . . . . .        Number            70h 
T_R13W . . . . . . . . . . . . .        Number            68h 
T_R14  . . . . . . . . . . . . .        Number            81h 
T_R14B . . . . . . . . . . . . .        Number            61h 
T_R14D . . . . . . . . . . . . .        Number            71h 
T_R14W . . . . . . . . . . . . .        Number            69h 
T_R15  . . . . . . . . . . . . .        Number            82h 
T_R15B . . . . . . . . . . . . .        Number            62h 
T_R15D . . . . . . . . . . . . .        Number            72h 
T_R15W . . . . . . . . . . . . .        Number            6Ah 
T_R8 . . . . . . . . . . . . . .        Number            7Bh 
T_R8B  . . . . . . . . . . . . .        Number            5Bh 
T_R8D  . . . . . . . . . . . . .        Number            6Bh 
T_R8W  . . . . . . . . . . . . .        Number            63h 
T_R9 . . . . . . . . . . . . . .        Number            7Ch 
T_R9B  . . . . . . . . . . . . .        Number            5Ch 
T_R9D  . . . . . . . . . . . . .        Number            6Ch 
T_R9W  . . . . . . . . . . . . .        Number            64h 
T_RAX  . . . . . . . . . . . . .        Number            73h 
T_RBP  . . . . . . . . . . . . .        Number            78h 
T_RBX  . . . . . . . . . . . . .        Number            76h 
T_RCL  . . . . . . . . . . . . .        Number           265h 
T_RCPPS  . . . . . . . . . . . .        Number           475h 
T_RCPSS  . . . . . . . . . . . .        Number           476h 
T_RCR  . . . . . . . . . . . . .        Number           266h 
T_RCX  . . . . . . . . . . . . .        Number            74h 
T_RDFSBASE . . . . . . . . . . .        Number           510h 
T_RDGSBASE . . . . . . . . . . .        Number           511h 
T_RDI  . . . . . . . . . . . . .        Number            7Ah 
T_RDMSR  . . . . . . . . . . . .        Number           2EAh 
T_RDPID  . . . . . . . . . . . .        Number           50Eh 
T_RDPMC  . . . . . . . . . . . .        Number           2EBh 
T_RDRAND . . . . . . . . . . . .        Number           509h 
T_RDSEED . . . . . . . . . . . .        Number           50Ah 
T_RDTSC  . . . . . . . . . . . .        Number           2ECh 
T_RDTSCP . . . . . . . . . . . .        Number           2EDh 
T_RDX  . . . . . . . . . . . . .        Number            75h 
T_REAL10 . . . . . . . . . . . .        Number            DAh 
T_REAL16 . . . . . . . . . . . .        Number            DCh 
T_REAL2  . . . . . . . . . . . .        Number            D1h 
T_REAL4  . . . . . . . . . . . .        Number            D4h 
T_REAL8  . . . . . . . . . . . .        Number            D8h 
T_RECORD . . . . . . . . . . . .        Number           20Dh 
T_REG  . . . . . . . . . . . . .        Number             2h 
T_REP  . . . . . . . . . . . . .        Number           2ABh 
T_REPE . . . . . . . . . . . . .        Number           2ACh 
T_REPEAT . . . . . . . . . . . .        Number           1EEh 
T_REPNE  . . . . . . . . . . . .        Number           2ADh 
T_REPNZ  . . . . . . . . . . . .        Number           2AEh 
T_REPT . . . . . . . . . . . . .        Number           1EFh 
T_REPZ . . . . . . . . . . . . .        Number           2AFh 
T_RES_ID . . . . . . . . . . . .        Number             7h 
T_RET  . . . . . . . . . . . . .        Number           2EEh 
T_RETD . . . . . . . . . . . . .        Number           29Ah 
T_RETF . . . . . . . . . . . . .        Number           2F0h 
T_RETM . . . . . . . . . . . . .        Number           1AFh 
T_RETN . . . . . . . . . . . . .        Number           2EFh 
T_RETW . . . . . . . . . . . . .        Number           29Bh 
T_RIP  . . . . . . . . . . . . .        Number            83h 
T_ROL  . . . . . . . . . . . . .        Number           267h 
T_ROR  . . . . . . . . . . . . .        Number           268h 
T_RORX . . . . . . . . . . . . .        Number           647h 
T_ROUNDPD  . . . . . . . . . . .        Number           4FFh 
T_ROUNDPS  . . . . . . . . . . .        Number           4FEh 
T_ROUNDSD  . . . . . . . . . . .        Number           501h 
T_ROUNDSS  . . . . . . . . . . .        Number           500h 
T_RSI  . . . . . . . . . . . . .        Number            79h 
T_RSM  . . . . . . . . . . . . .        Number           2F1h 
T_RSP  . . . . . . . . . . . . .        Number            77h 
T_RSQRTPS  . . . . . . . . . . .        Number           477h 
T_RSQRTSS  . . . . . . . . . . .        Number           478h 
T_SAHF . . . . . . . . . . . . .        Number           2F2h 
T_SAL  . . . . . . . . . . . . .        Number           269h 
T_SAR  . . . . . . . . . . . . .        Number           26Ah 
T_SARX . . . . . . . . . . . . .        Number           641h 
T_SBB  . . . . . . . . . . . . .        Number           260h 
T_SBYTE  . . . . . . . . . . . .        Number            CEh 
T_SCAS . . . . . . . . . . . . .        Number           281h 
T_SCASB  . . . . . . . . . . . .        Number           282h 
T_SCASD  . . . . . . . . . . . .        Number           284h 
T_SCASQ  . . . . . . . . . . . .        Number           4CBh 
T_SCASW  . . . . . . . . . . . .        Number           283h 
T_SDWORD . . . . . . . . . . . .        Number            D3h 
T_SECTIONREL . . . . . . . . . .        Number            F7h 
T_SEG  . . . . . . . . . . . . .        Number            F8h 
T_SEGMENT  . . . . . . . . . . .        Number           21Ch 
T_SETA . . . . . . . . . . . . .        Number           302h 
T_SETAE  . . . . . . . . . . . .        Number           303h 
T_SETB . . . . . . . . . . . . .        Number           304h 
T_SETBE  . . . . . . . . . . . .        Number           305h 
T_SETC . . . . . . . . . . . . .        Number           306h 
T_SETE . . . . . . . . . . . . .        Number           307h 
T_SETG . . . . . . . . . . . . .        Number           308h 
T_SETGE  . . . . . . . . . . . .        Number           309h 
T_SETL . . . . . . . . . . . . .        Number           30Ah 
T_SETLE  . . . . . . . . . . . .        Number           30Bh 
T_SETNA  . . . . . . . . . . . .        Number           30Ch 
T_SETNAE . . . . . . . . . . . .        Number           30Dh 
T_SETNB  . . . . . . . . . . . .        Number           30Eh 
T_SETNBE . . . . . . . . . . . .        Number           30Fh 
T_SETNC  . . . . . . . . . . . .        Number           310h 
T_SETNE  . . . . . . . . . . . .        Number           311h 
T_SETNG  . . . . . . . . . . . .        Number           312h 
T_SETNGE . . . . . . . . . . . .        Number           313h 
T_SETNL  . . . . . . . . . . . .        Number           314h 
T_SETNLE . . . . . . . . . . . .        Number           315h 
T_SETNO  . . . . . . . . . . . .        Number           316h 
T_SETNP  . . . . . . . . . . . .        Number           317h 
T_SETNS  . . . . . . . . . . . .        Number           318h 
T_SETNZ  . . . . . . . . . . . .        Number           319h 
T_SETO . . . . . . . . . . . . .        Number           31Ah 
T_SETP . . . . . . . . . . . . .        Number           31Bh 
T_SETPE  . . . . . . . . . . . .        Number           31Ch 
T_SETPO  . . . . . . . . . . . .        Number           31Dh 
T_SETS . . . . . . . . . . . . .        Number           31Eh 
T_SETZ . . . . . . . . . . . . .        Number           31Fh 
T_SFENCE . . . . . . . . . . . .        Number           3B4h 
T_SGDT . . . . . . . . . . . . .        Number           2F3h 
T_SHL  . . . . . . . . . . . . .        Number           26Bh 
T_SHLD . . . . . . . . . . . . .        Number           2F5h 
T_SHLX . . . . . . . . . . . . .        Number           642h 
T_SHORT  . . . . . . . . . . . .        Number            F9h 
T_SHR  . . . . . . . . . . . . .        Number           26Ch 
T_SHRD . . . . . . . . . . . . .        Number           2F6h 
T_SHRX . . . . . . . . . . . . .        Number           643h 
T_SHUFPD . . . . . . . . . . . .        Number           479h 
T_SHUFPS . . . . . . . . . . . .        Number           47Ah 
T_SI . . . . . . . . . . . . . .        Number             Fh 
T_SIDT . . . . . . . . . . . . .        Number           2F4h 
T_SIL  . . . . . . . . . . . . .        Number            59h 
T_SIZEOF . . . . . . . . . . . .        Number            FBh 
T_SIZESTR  . . . . . . . . . . .        Number           1FBh 
T_SLDT . . . . . . . . . . . . .        Number           2A0h 
T_SMSW . . . . . . . . . . . . .        Number           2A1h 
T_SP . . . . . . . . . . . . . .        Number             Dh 
T_SPL  . . . . . . . . . . . . .        Number            57h 
T_SQRT . . . . . . . . . . . . .        Number           101h 
T_SQRTPD . . . . . . . . . . . .        Number           3CEh 
T_SQRTPS . . . . . . . . . . . .        Number           3CFh 
T_SQRTSD . . . . . . . . . . . .        Number           3D0h 
T_SQRTSS . . . . . . . . . . . .        Number           3D1h 
T_SQWORD . . . . . . . . . . . .        Number            D7h 
T_SS . . . . . . . . . . . . . .        Number            1Bh 
T_ST . . . . . . . . . . . . . .        Number            1Fh 
T_STC  . . . . . . . . . . . . .        Number           2B6h 
T_STD  . . . . . . . . . . . . .        Number           2BAh 
T_STDCALL  . . . . . . . . . . .        Number           112h 
T_STI  . . . . . . . . . . . . .        Number           2B8h 
T_STMXCSR  . . . . . . . . . . .        Number           3B1h 
T_STOS . . . . . . . . . . . . .        Number           285h 
T_STOSB  . . . . . . . . . . . .        Number           286h 
T_STOSD  . . . . . . . . . . . .        Number           288h 
T_STOSQ  . . . . . . . . . . . .        Number           4CCh 
T_STOSW  . . . . . . . . . . . .        Number           287h 
T_STR  . . . . . . . . . . . . .        Number           2A2h 
T_STRING . . . . . . . . . . . .        Number             9h 
T_STRUC  . . . . . . . . . . . .        Number           209h 
T_STRUCT . . . . . . . . . . . .        Number           20Ah 
T_STYPE  . . . . . . . . . . . .        Number             6h 
T_SUB  . . . . . . . . . . . . .        Number           262h 
T_SUBPD  . . . . . . . . . . . .        Number           3D2h 
T_SUBPS  . . . . . . . . . . . .        Number           3D3h 
T_SUBSD  . . . . . . . . . . . .        Number           3D4h 
T_SUBSS  . . . . . . . . . . . .        Number           3D5h 
T_SUBSTR . . . . . . . . . . . .        Number           1F9h 
T_SWAPGS . . . . . . . . . . . .        Number           4CFh 
T_SWORD  . . . . . . . . . . . .        Number            D0h 
T_SYSCALL  . . . . . . . . . . .        Number           111h 
T_SYSCALL_ . . . . . . . . . . .        Number           4D0h 
T_SYSENTER . . . . . . . . . . .        Number           2F7h 
T_SYSEXIT  . . . . . . . . . . .        Number           2F8h 
T_SYSRET . . . . . . . . . . . .        Number           4D1h 
T_TBYTE  . . . . . . . . . . . .        Number            D9h 
T_TEST . . . . . . . . . . . . .        Number           2F9h 
T_TEXTEQU  . . . . . . . . . . .        Number           1F7h 
T_TR3  . . . . . . . . . . . . .        Number            52h 
T_TR4  . . . . . . . . . . . . .        Number            53h 
T_TR5  . . . . . . . . . . . . .        Number            54h 
T_TR6  . . . . . . . . . . . . .        Number            55h 
T_TR7  . . . . . . . . . . . . .        Number            56h 
T_TYPEDEF  . . . . . . . . . . .        Number           20Ch 
T_TYPEOF . . . . . . . . . . . .        Number            FDh 
T_TZCNT  . . . . . . . . . . . .        Number           50Ch 
T_UCOMISD  . . . . . . . . . . .        Number           47Bh 
T_UCOMISS  . . . . . . . . . . .        Number           47Ch 
T_UD2  . . . . . . . . . . . . .        Number           2FAh 
T_UNARY_OPERATOR . . . . . . . .        Number             4h 
T_UNDEF  . . . . . . . . . . . .        Number           1A7h 
T_UNION  . . . . . . . . . . . .        Number           20Bh 
T_UNPCKHPD . . . . . . . . . . .        Number           47Dh 
T_UNPCKHPS . . . . . . . . . . .        Number           47Eh 
T_UNPCKLPD . . . . . . . . . . .        Number           47Fh 
T_UNPCKLPS . . . . . . . . . . .        Number           480h 
T_VADDPD . . . . . . . . . . . .        Number           53Fh 
T_VADDPS . . . . . . . . . . . .        Number           540h 
T_VADDSD . . . . . . . . . . . .        Number           541h 
T_VADDSS . . . . . . . . . . . .        Number           542h 
T_VADDSUBPD  . . . . . . . . . .        Number           571h 
T_VADDSUBPS  . . . . . . . . . .        Number           572h 
T_VAESDEC  . . . . . . . . . . .        Number           5C1h 
T_VAESDECLAST  . . . . . . . . .        Number           5C0h 
T_VAESENC  . . . . . . . . . . .        Number           5C2h 
T_VAESENCLAST  . . . . . . . . .        Number           5C3h 
T_VAESIMC  . . . . . . . . . . .        Number           5C4h 
T_VAESKEYGENASSIST . . . . . . .        Number           5C5h 
T_VALIGND  . . . . . . . . . . .        Number           706h 
T_VALIGNQ  . . . . . . . . . . .        Number           707h 
T_VANDNPD  . . . . . . . . . . .        Number           55Dh 
T_VANDNPS  . . . . . . . . . . .        Number           55Eh 
T_VANDPD . . . . . . . . . . . .        Number           55Bh 
T_VANDPS . . . . . . . . . . . .        Number           55Ch 
T_VARARG . . . . . . . . . . . .        Number           10Eh 
T_VBLENDMPD  . . . . . . . . . .        Number           708h 
T_VBLENDMPS  . . . . . . . . . .        Number           709h 
T_VBLENDPD . . . . . . . . . . .        Number           573h 
T_VBLENDPS . . . . . . . . . . .        Number           574h 
T_VBLENDVPD  . . . . . . . . . .        Number           528h 
T_VBLENDVPS  . . . . . . . . . .        Number           529h 
T_VBROADCASTF128 . . . . . . . .        Number           527h 
T_VBROADCASTF32X2  . . . . . . .        Number           6A0h 
T_VBROADCASTF32X4  . . . . . . .        Number           6A1h 
T_VBROADCASTF32X8  . . . . . . .        Number           6A2h 
T_VBROADCASTF64X2  . . . . . . .        Number           77Eh 
T_VBROADCASTF64X4  . . . . . . .        Number           6A3h 
T_VBROADCASTI128 . . . . . . . .        Number           638h 
T_VBROADCASTI32X4  . . . . . . .        Number           6A5h 
T_VBROADCASTI32X8  . . . . . . .        Number           6A6h 
T_VBROADCASTI32x2  . . . . . . .        Number           6A4h 
T_VBROADCASTI64X2  . . . . . . .        Number           77Fh 
T_VBROADCASTI64X4  . . . . . . .        Number           780h 
T_VBROADCASTSD . . . . . . . . .        Number           526h 
T_VBROADCASTSS . . . . . . . . .        Number           525h 
T_VCMPPD . . . . . . . . . . . .        Number           536h 
T_VCMPPS . . . . . . . . . . . .        Number           537h 
T_VCMPSD . . . . . . . . . . . .        Number           539h 
T_VCMPSS . . . . . . . . . . . .        Number           538h 
T_VCOMISD  . . . . . . . . . . .        Number           561h 
T_VCOMISS  . . . . . . . . . . .        Number           562h 
T_VCOMPRESSPD  . . . . . . . . .        Number           6A7h 
T_VCOMPRESSPS  . . . . . . . . .        Number           77Ch 
T_VCVTDQ2PD  . . . . . . . . . .        Number           53Ah 
T_VCVTDQ2PS  . . . . . . . . . .        Number           565h 
T_VCVTPD2DQ  . . . . . . . . . .        Number           53Bh 
T_VCVTPD2PS  . . . . . . . . . .        Number           53Dh 
T_VCVTPD2QQ  . . . . . . . . . .        Number           6A9h 
T_VCVTPD2UDQ . . . . . . . . . .        Number           6AAh 
T_VCVTPD2UQQ . . . . . . . . . .        Number           6ABh 
T_VCVTPH2PS  . . . . . . . . . .        Number           6ACh 
T_VCVTPS2DQ  . . . . . . . . . .        Number           566h 
T_VCVTPS2PD  . . . . . . . . . .        Number           568h 
T_VCVTPS2PH  . . . . . . . . . .        Number           6ADh 
T_VCVTPS2QQ  . . . . . . . . . .        Number           781h 
T_VCVTPS2UDQ . . . . . . . . . .        Number           782h 
T_VCVTPS2UQQ . . . . . . . . . .        Number           783h 
T_VCVTQQ2PD  . . . . . . . . . .        Number           6AEh 
T_VCVTQQ2PS  . . . . . . . . . .        Number           6AFh 
T_VCVTSD2SI  . . . . . . . . . .        Number           569h 
T_VCVTSD2SS  . . . . . . . . . .        Number           56Bh 
T_VCVTSD2USI . . . . . . . . . .        Number           767h 
T_VCVTSI2SD  . . . . . . . . . .        Number           56Ch 
T_VCVTSI2SS  . . . . . . . . . .        Number           56Dh 
T_VCVTSS2SD  . . . . . . . . . .        Number           56Eh 
T_VCVTSS2SI  . . . . . . . . . .        Number           56Fh 
T_VCVTSS2USI . . . . . . . . . .        Number           768h 
T_VCVTTPD2DQ . . . . . . . . . .        Number           53Ch 
T_VCVTTPD2QQ . . . . . . . . . .        Number           6B0h 
T_VCVTTPD2UDQ  . . . . . . . . .        Number           6B1h 
T_VCVTTPD2UQQ  . . . . . . . . .        Number           6B2h 
T_VCVTTPS2DQ . . . . . . . . . .        Number           567h 
T_VCVTTPS2QQ . . . . . . . . . .        Number           784h 
T_VCVTTPS2UDQ  . . . . . . . . .        Number           785h 
T_VCVTTPS2UQQ  . . . . . . . . .        Number           786h 
T_VCVTTSD2SI . . . . . . . . . .        Number           56Ah 
T_VCVTTSD2USI  . . . . . . . . .        Number           76Bh 
T_VCVTTSS2SI . . . . . . . . . .        Number           570h 
T_VCVTTSS2USI  . . . . . . . . .        Number           76Ch 
T_VCVTUDQ2PD . . . . . . . . . .        Number           6B3h 
T_VCVTUDQ2PS . . . . . . . . . .        Number           788h 
T_VCVTUQQ2PD . . . . . . . . . .        Number           787h 
T_VCVTUQQ2PS . . . . . . . . . .        Number           6B4h 
T_VCVTUSI2SD . . . . . . . . . .        Number           769h 
T_VCVTUSI2SS . . . . . . . . . .        Number           76Ah 
T_VDIVPD . . . . . . . . . . . .        Number           543h 
T_VDIVPS . . . . . . . . . . . .        Number           544h 
T_VDIVSD . . . . . . . . . . . .        Number           545h 
T_VDIVSS . . . . . . . . . . . .        Number           546h 
T_VDPPD  . . . . . . . . . . . .        Number           575h 
T_VDPPS  . . . . . . . . . . . .        Number           576h 
T_VECTORCALL . . . . . . . . . .        Number           117h 
T_VERR . . . . . . . . . . . . .        Number           2A3h 
T_VERW . . . . . . . . . . . . .        Number           2A4h 
T_VEXP2PD  . . . . . . . . . . .        Number           698h 
T_VEXP2PS  . . . . . . . . . . .        Number           697h 
T_VEXPANDPD  . . . . . . . . . .        Number           6B5h 
T_VEXPANDPS  . . . . . . . . . .        Number           789h 
T_VEXTRACTF128 . . . . . . . . .        Number           52Bh 
T_VEXTRACTF32X8  . . . . . . . .        Number           6B7h 
T_VEXTRACTF32x4  . . . . . . . .        Number           6B6h 
T_VEXTRACTF64X2  . . . . . . . .        Number           78Ah 
T_VEXTRACTF64x4  . . . . . . . .        Number           78Bh 
T_VEXTRACTI128 . . . . . . . . .        Number           639h 
T_VEXTRACTI32X8  . . . . . . . .        Number           6B9h 
T_VEXTRACTI32x4  . . . . . . . .        Number           6B8h 
T_VEXTRACTI64X2  . . . . . . . .        Number           78Ch 
T_VEXTRACTI64x4  . . . . . . . .        Number           78Dh 
T_VEXTRACTPS . . . . . . . . . .        Number           577h 
T_VFIXUPIMMPD  . . . . . . . . .        Number           771h 
T_VFIXUPIMMPS  . . . . . . . . .        Number           772h 
T_VFIXUPIMMSD  . . . . . . . . .        Number           773h 
T_VFIXUPIMMSS  . . . . . . . . .        Number           774h 
T_VFMADD132PD  . . . . . . . . .        Number           70Ah 
T_VFMADD132PS  . . . . . . . . .        Number           70Dh 
T_VFMADD132SD  . . . . . . . . .        Number           710h 
T_VFMADD132SS  . . . . . . . . .        Number           713h 
T_VFMADD213PD  . . . . . . . . .        Number           70Bh 
T_VFMADD213PS  . . . . . . . . .        Number           70Eh 
T_VFMADD213SD  . . . . . . . . .        Number           711h 
T_VFMADD213SS  . . . . . . . . .        Number           714h 
T_VFMADD231PD  . . . . . . . . .        Number           70Ch 
T_VFMADD231PS  . . . . . . . . .        Number           70Fh 
T_VFMADD231SD  . . . . . . . . .        Number           712h 
T_VFMADD231SS  . . . . . . . . .        Number           715h 
T_VFMADDSUB132PD . . . . . . . .        Number           722h 
T_VFMADDSUB132PS . . . . . . . .        Number           725h 
T_VFMADDSUB213PD . . . . . . . .        Number           723h 
T_VFMADDSUB213PS . . . . . . . .        Number           726h 
T_VFMADDSUB231PD . . . . . . . .        Number           724h 
T_VFMADDSUB231PS . . . . . . . .        Number           727h 
T_VFMSUB132PD  . . . . . . . . .        Number           716h 
T_VFMSUB132PS  . . . . . . . . .        Number           719h 
T_VFMSUB132SD  . . . . . . . . .        Number           71Ch 
T_VFMSUB132SS  . . . . . . . . .        Number           71Fh 
T_VFMSUB213PD  . . . . . . . . .        Number           717h 
T_VFMSUB213PS  . . . . . . . . .        Number           71Ah 
T_VFMSUB213SD  . . . . . . . . .        Number           71Dh 
T_VFMSUB213SS  . . . . . . . . .        Number           720h 
T_VFMSUB231PD  . . . . . . . . .        Number           718h 
T_VFMSUB231PS  . . . . . . . . .        Number           71Bh 
T_VFMSUB231SD  . . . . . . . . .        Number           71Eh 
T_VFMSUB231SS  . . . . . . . . .        Number           721h 
T_VFMSUBADD132PD . . . . . . . .        Number           728h 
T_VFMSUBADD132PS . . . . . . . .        Number           72Bh 
T_VFMSUBADD213PD . . . . . . . .        Number           729h 
T_VFMSUBADD213PS . . . . . . . .        Number           72Ch 
T_VFMSUBADD231PD . . . . . . . .        Number           72Ah 
T_VFMSUBADD231PS . . . . . . . .        Number           72Dh 
T_VFNMADD132PD . . . . . . . . .        Number           72Eh 
T_VFNMADD132PS . . . . . . . . .        Number           731h 
T_VFNMADD132SD . . . . . . . . .        Number           734h 
T_VFNMADD132SS . . . . . . . . .        Number           737h 
T_VFNMADD213PD . . . . . . . . .        Number           72Fh 
T_VFNMADD213PS . . . . . . . . .        Number           732h 
T_VFNMADD213SD . . . . . . . . .        Number           735h 
T_VFNMADD213SS . . . . . . . . .        Number           738h 
T_VFNMADD231PD . . . . . . . . .        Number           730h 
T_VFNMADD231PS . . . . . . . . .        Number           733h 
T_VFNMADD231SD . . . . . . . . .        Number           736h 
T_VFNMADD231SS . . . . . . . . .        Number           739h 
T_VFNMSUB132PD . . . . . . . . .        Number           73Ah 
T_VFNMSUB132PS . . . . . . . . .        Number           73Dh 
T_VFNMSUB132SD . . . . . . . . .        Number           740h 
T_VFNMSUB132SS . . . . . . . . .        Number           743h 
T_VFNMSUB213PD . . . . . . . . .        Number           73Bh 
T_VFNMSUB213PS . . . . . . . . .        Number           73Eh 
T_VFNMSUB213SD . . . . . . . . .        Number           741h 
T_VFNMSUB213SS . . . . . . . . .        Number           744h 
T_VFNMSUB231PD . . . . . . . . .        Number           73Ch 
T_VFNMSUB231PS . . . . . . . . .        Number           73Fh 
T_VFNMSUB231SD . . . . . . . . .        Number           742h 
T_VFNMSUB231SS . . . . . . . . .        Number           745h 
T_VFPCLASSPD . . . . . . . . . .        Number           6BAh 
T_VFPCLASSPS . . . . . . . . . .        Number           78Eh 
T_VGATHERDPD . . . . . . . . . .        Number           78Fh 
T_VGATHERDPS . . . . . . . . . .        Number           6BBh 
T_VGATHERPF0DPD  . . . . . . . .        Number           6C1h 
T_VGATHERPF0DPS  . . . . . . . .        Number           6BFh 
T_VGATHERPF0QPD  . . . . . . . .        Number           6C2h 
T_VGATHERPF0QPS  . . . . . . . .        Number           6C0h 
T_VGATHERPF1DPD  . . . . . . . .        Number           6C5h 
T_VGATHERPF1DPS  . . . . . . . .        Number           6C3h 
T_VGATHERPF1QPD  . . . . . . . .        Number           6C6h 
T_VGATHERPF1QPS  . . . . . . . .        Number           6C4h 
T_VGATHERQPD . . . . . . . . . .        Number           790h 
T_VGATHERQPS . . . . . . . . . .        Number           6BCh 
T_VGETEXPPD  . . . . . . . . . .        Number           6D3h 
T_VGETEXPPS  . . . . . . . . . .        Number           6D4h 
T_VGETEXPSD  . . . . . . . . . .        Number           6D5h 
T_VGETEXPSS  . . . . . . . . . .        Number           6D6h 
T_VGETMANTPD . . . . . . . . . .        Number           6DFh 
T_VGETMANTPS . . . . . . . . . .        Number           6E0h 
T_VGETMANTSD . . . . . . . . . .        Number           6E1h 
T_VGETMANTSS . . . . . . . . . .        Number           6E2h 
T_VHADDPD  . . . . . . . . . . .        Number           578h 
T_VHADDPS  . . . . . . . . . . .        Number           579h 
T_VHSUBPD  . . . . . . . . . . .        Number           57Ah 
T_VHSUBPS  . . . . . . . . . . .        Number           57Bh 
T_VINSERTF128  . . . . . . . . .        Number           52Ah 
T_VINSERTF32X4 . . . . . . . . .        Number           746h 
T_VINSERTF32x8 . . . . . . . . .        Number           748h 
T_VINSERTF64x2 . . . . . . . . .        Number           747h 
T_VINSERTF64x4 . . . . . . . . .        Number           749h 
T_VINSERTI128  . . . . . . . . .        Number           637h 
T_VINSERTI32x4 . . . . . . . . .        Number           74Ah 
T_VINSERTI32x8 . . . . . . . . .        Number           74Ch 
T_VINSERTI64x2 . . . . . . . . .        Number           74Bh 
T_VINSERTI64x4 . . . . . . . . .        Number           74Dh 
T_VINSERTPS  . . . . . . . . . .        Number           57Ch 
T_VLDDQU . . . . . . . . . . . .        Number           57Dh 
T_VLDMXCSR . . . . . . . . . . .        Number           57Eh 
T_VMASKMOVDQU  . . . . . . . . .        Number           580h 
T_VMASKMOVPD . . . . . . . . . .        Number           52Dh 
T_VMASKMOVPS . . . . . . . . . .        Number           52Ch 
T_VMAXPD . . . . . . . . . . . .        Number           547h 
T_VMAXPS . . . . . . . . . . . .        Number           548h 
T_VMAXSD . . . . . . . . . . . .        Number           549h 
T_VMAXSS . . . . . . . . . . . .        Number           54Ah 
T_VMCALL . . . . . . . . . . . .        Number           519h 
T_VMCLEAR  . . . . . . . . . . .        Number           51Fh 
T_VMINPD . . . . . . . . . . . .        Number           54Bh 
T_VMINPS . . . . . . . . . . . .        Number           54Ch 
T_VMINSD . . . . . . . . . . . .        Number           54Dh 
T_VMINSS . . . . . . . . . . . .        Number           54Eh 
T_VMLAUNCH . . . . . . . . . . .        Number           51Ah 
T_VMOVAPD  . . . . . . . . . . .        Number           581h 
T_VMOVAPS  . . . . . . . . . . .        Number           582h 
T_VMOVD  . . . . . . . . . . . .        Number           583h 
T_VMOVDDUP . . . . . . . . . . .        Number           53Eh 
T_VMOVDQA  . . . . . . . . . . .        Number           585h 
T_VMOVDQA32  . . . . . . . . . .        Number           69Dh 
T_VMOVDQA64  . . . . . . . . . .        Number           779h 
T_VMOVDQU  . . . . . . . . . . .        Number           586h 
T_VMOVDQU16  . . . . . . . . . .        Number           77Ah 
T_VMOVDQU32  . . . . . . . . . .        Number           69Fh 
T_VMOVDQU64  . . . . . . . . . .        Number           77Bh 
T_VMOVDQU8 . . . . . . . . . . .        Number           69Eh 
T_VMOVHLPS . . . . . . . . . . .        Number           587h 
T_VMOVHPD  . . . . . . . . . . .        Number           589h 
T_VMOVHPS  . . . . . . . . . . .        Number           58Ah 
T_VMOVLHPS . . . . . . . . . . .        Number           588h 
T_VMOVLPD  . . . . . . . . . . .        Number           58Bh 
T_VMOVLPS  . . . . . . . . . . .        Number           58Ch 
T_VMOVMSKPD  . . . . . . . . . .        Number           626h 
T_VMOVMSKPS  . . . . . . . . . .        Number           627h 
T_VMOVNTDQ . . . . . . . . . . .        Number           58Fh 
T_VMOVNTDQA  . . . . . . . . . .        Number           590h 
T_VMOVNTPD . . . . . . . . . . .        Number           591h 
T_VMOVNTPS . . . . . . . . . . .        Number           592h 
T_VMOVQ  . . . . . . . . . . . .        Number           584h 
T_VMOVSD . . . . . . . . . . . .        Number           58Dh 
T_VMOVSHDUP  . . . . . . . . . .        Number           593h 
T_VMOVSLDUP  . . . . . . . . . .        Number           594h 
T_VMOVSS . . . . . . . . . . . .        Number           58Eh 
T_VMOVUPD  . . . . . . . . . . .        Number           595h 
T_VMOVUPS  . . . . . . . . . . .        Number           596h 
T_VMPSADBW . . . . . . . . . . .        Number           597h 
T_VMPTRLD  . . . . . . . . . . .        Number           51Dh 
T_VMPTRST  . . . . . . . . . . .        Number           51Eh 
T_VMREAD . . . . . . . . . . . .        Number           521h 
T_VMRESUME . . . . . . . . . . .        Number           51Bh 
T_VMULPD . . . . . . . . . . . .        Number           54Fh 
T_VMULPS . . . . . . . . . . . .        Number           550h 
T_VMULSD . . . . . . . . . . . .        Number           551h 
T_VMULSS . . . . . . . . . . . .        Number           552h 
T_VMWRITE  . . . . . . . . . . .        Number           522h 
T_VMXOFF . . . . . . . . . . . .        Number           51Ch 
T_VMXON  . . . . . . . . . . . .        Number           520h 
T_VORPD  . . . . . . . . . . . .        Number           55Fh 
T_VORPS  . . . . . . . . . . . .        Number           560h 
T_VPABSB . . . . . . . . . . . .        Number           598h 
T_VPABSD . . . . . . . . . . . .        Number           59Ah 
T_VPABSQ . . . . . . . . . . . .        Number           74Eh 
T_VPABSW . . . . . . . . . . . .        Number           599h 
T_VPACKSSDW  . . . . . . . . . .        Number           59Ch 
T_VPACKSSWB  . . . . . . . . . .        Number           59Bh 
T_VPACKUSDW  . . . . . . . . . .        Number           59Eh 
T_VPACKUSWB  . . . . . . . . . .        Number           59Dh 
T_VPADDB . . . . . . . . . . . .        Number           59Fh 
T_VPADDD . . . . . . . . . . . .        Number           5A1h 
T_VPADDQ . . . . . . . . . . . .        Number           5A2h 
T_VPADDSB  . . . . . . . . . . .        Number           5A3h 
T_VPADDSW  . . . . . . . . . . .        Number           5A4h 
T_VPADDUSB . . . . . . . . . . .        Number           5A5h 
T_VPADDUSW . . . . . . . . . . .        Number           5A6h 
T_VPADDW . . . . . . . . . . . .        Number           5A0h 
T_VPALIGNR . . . . . . . . . . .        Number           5A7h 
T_VPAND  . . . . . . . . . . . .        Number           5A8h 
T_VPANDD . . . . . . . . . . . .        Number           64Fh 
T_VPANDN . . . . . . . . . . . .        Number           5A9h 
T_VPANDND  . . . . . . . . . . .        Number           651h 
T_VPANDNQ  . . . . . . . . . . .        Number           652h 
T_VPANDQ . . . . . . . . . . . .        Number           650h 
T_VPAVGB . . . . . . . . . . . .        Number           5AAh 
T_VPAVGW . . . . . . . . . . . .        Number           5ABh 
T_VPBLENDD . . . . . . . . . . .        Number           635h 
T_VPBLENDMD  . . . . . . . . . .        Number           755h 
T_VPBLENDMQ  . . . . . . . . . .        Number           756h 
T_VPBLENDVB  . . . . . . . . . .        Number           52Eh 
T_VPBLENDW . . . . . . . . . . .        Number           5ACh 
T_VPBROADCASTB . . . . . . . . .        Number           63Dh 
T_VPBROADCASTD . . . . . . . . .        Number           63Bh 
T_VPBROADCASTMB2Q  . . . . . . .        Number           667h 
T_VPBROADCASTMW2D  . . . . . . .        Number           666h 
T_VPBROADCASTQ . . . . . . . . .        Number           63Ah 
T_VPBROADCASTW . . . . . . . . .        Number           63Ch 
T_VPCLMULQDQ . . . . . . . . . .        Number           5BFh 
T_VPCMPB . . . . . . . . . . . .        Number           74Fh 
T_VPCMPD . . . . . . . . . . . .        Number           750h 
T_VPCMPEQB . . . . . . . . . . .        Number           5B1h 
T_VPCMPEQD . . . . . . . . . . .        Number           5B3h 
T_VPCMPEQQ . . . . . . . . . . .        Number           5B4h 
T_VPCMPEQW . . . . . . . . . . .        Number           5B2h 
T_VPCMPESTRI . . . . . . . . . .        Number           5ADh 
T_VPCMPESTRM . . . . . . . . . .        Number           5AEh 
T_VPCMPGTB . . . . . . . . . . .        Number           5B5h 
T_VPCMPGTD . . . . . . . . . . .        Number           5B7h 
T_VPCMPGTQ . . . . . . . . . . .        Number           5B8h 
T_VPCMPGTW . . . . . . . . . . .        Number           5B6h 
T_VPCMPISTRI . . . . . . . . . .        Number           5AFh 
T_VPCMPISTRM . . . . . . . . . .        Number           5B0h 
T_VPCMPQ . . . . . . . . . . . .        Number           751h 
T_VPCMPUB  . . . . . . . . . . .        Number           752h 
T_VPCMPUD  . . . . . . . . . . .        Number           753h 
T_VPCMPUQ  . . . . . . . . . . .        Number           754h 
T_VPCOMPRESSD  . . . . . . . . .        Number           6A8h 
T_VPCOMPRESSQ  . . . . . . . . .        Number           77Dh 
T_VPCONFLICTD  . . . . . . . . .        Number           65Eh 
T_VPCONFLICTQ  . . . . . . . . .        Number           65Fh 
T_VPERM2F128 . . . . . . . . . .        Number           531h 
T_VPERM2I128 . . . . . . . . . .        Number           636h 
T_VPERMB . . . . . . . . . . . .        Number           62Bh 
T_VPERMD . . . . . . . . . . . .        Number           62Ch 
T_VPERMI2D . . . . . . . . . . .        Number           775h 
T_VPERMI2PD  . . . . . . . . . .        Number           778h 
T_VPERMI2PS  . . . . . . . . . .        Number           777h 
T_VPERMI2Q . . . . . . . . . . .        Number           776h 
T_VPERMILPD  . . . . . . . . . .        Number           52Fh 
T_VPERMILPS  . . . . . . . . . .        Number           530h 
T_VPERMPD  . . . . . . . . . . .        Number           62Ah 
T_VPERMPS  . . . . . . . . . . .        Number           62Eh 
T_VPERMQ . . . . . . . . . . . .        Number           62Dh 
T_VPERMW . . . . . . . . . . . .        Number           64Bh 
T_VPEXPANDD  . . . . . . . . . .        Number           6E3h 
T_VPEXPANDQ  . . . . . . . . . .        Number           797h 
T_VPEXTRB  . . . . . . . . . . .        Number           5B9h 
T_VPEXTRD  . . . . . . . . . . .        Number           5BBh 
T_VPEXTRQ  . . . . . . . . . . .        Number           5C6h 
T_VPEXTRW  . . . . . . . . . . .        Number           5BAh 
T_VPGATHERDD . . . . . . . . . .        Number           6BDh 
T_VPGATHERDQ . . . . . . . . . .        Number           791h 
T_VPGATHERQD . . . . . . . . . .        Number           6BEh 
T_VPGATHERQQ . . . . . . . . . .        Number           792h 
T_VPHADDD  . . . . . . . . . . .        Number           5C9h 
T_VPHADDSW . . . . . . . . . . .        Number           5CAh 
T_VPHADDW  . . . . . . . . . . .        Number           5C8h 
T_VPHMINPOSUW  . . . . . . . . .        Number           5CBh 
T_VPHSUBD  . . . . . . . . . . .        Number           5CDh 
T_VPHSUBSW . . . . . . . . . . .        Number           5CEh 
T_VPHSUBW  . . . . . . . . . . .        Number           5CCh 
T_VPINSRB  . . . . . . . . . . .        Number           5BCh 
T_VPINSRD  . . . . . . . . . . .        Number           5BEh 
T_VPINSRQ  . . . . . . . . . . .        Number           5C7h 
T_VPINSRW  . . . . . . . . . . .        Number           5BDh 
T_VPLZCNTD . . . . . . . . . . .        Number           660h 
T_VPLZCNTQ . . . . . . . . . . .        Number           661h 
T_VPMADDUBSW . . . . . . . . . .        Number           5D0h 
T_VPMADDWD . . . . . . . . . . .        Number           5CFh 
T_VPMASKMOVD . . . . . . . . . .        Number           628h 
T_VPMASKMOVQ . . . . . . . . . .        Number           629h 
T_VPMAXSB  . . . . . . . . . . .        Number           5D1h 
T_VPMAXSD  . . . . . . . . . . .        Number           5D3h 
T_VPMAXSQ  . . . . . . . . . . .        Number           757h 
T_VPMAXSW  . . . . . . . . . . .        Number           5D2h 
T_VPMAXUB  . . . . . . . . . . .        Number           5D4h 
T_VPMAXUD  . . . . . . . . . . .        Number           5D6h 
T_VPMAXUQ  . . . . . . . . . . .        Number           758h 
T_VPMAXUW  . . . . . . . . . . .        Number           5D5h 
T_VPMINSB  . . . . . . . . . . .        Number           5D7h 
T_VPMINSD  . . . . . . . . . . .        Number           5D9h 
T_VPMINSQ  . . . . . . . . . . .        Number           759h 
T_VPMINSW  . . . . . . . . . . .        Number           5D8h 
T_VPMINUB  . . . . . . . . . . .        Number           5DAh 
T_VPMINUD  . . . . . . . . . . .        Number           5DCh 
T_VPMINUQ  . . . . . . . . . . .        Number           75Ah 
T_VPMINUW  . . . . . . . . . . .        Number           5DBh 
T_VPMOVB2M . . . . . . . . . . .        Number           6F0h 
T_VPMOVD2M . . . . . . . . . . .        Number           6F1h 
T_VPMOVDB  . . . . . . . . . . .        Number           6F4h 
T_VPMOVDW  . . . . . . . . . . .        Number           6F5h 
T_VPMOVM2B . . . . . . . . . . .        Number           6F2h 
T_VPMOVM2D . . . . . . . . . . .        Number           6F3h 
T_VPMOVM2Q . . . . . . . . . . .        Number           79Ah 
T_VPMOVM2W . . . . . . . . . . .        Number           79Bh 
T_VPMOVMSKB  . . . . . . . . . .        Number           5DDh 
T_VPMOVQ2M . . . . . . . . . . .        Number           799h 
T_VPMOVQB  . . . . . . . . . . .        Number           6F6h 
T_VPMOVQD  . . . . . . . . . . .        Number           6F7h 
T_VPMOVQW  . . . . . . . . . . .        Number           6F8h 
T_VPMOVSDB . . . . . . . . . . .        Number           6FAh 
T_VPMOVSDW . . . . . . . . . . .        Number           6FBh 
T_VPMOVSQB . . . . . . . . . . .        Number           6FCh 
T_VPMOVSQD . . . . . . . . . . .        Number           6FDh 
T_VPMOVSQW . . . . . . . . . . .        Number           6FEh 
T_VPMOVSWB . . . . . . . . . . .        Number           6FFh 
T_VPMOVSXBD  . . . . . . . . . .        Number           5DFh 
T_VPMOVSXBQ  . . . . . . . . . .        Number           5E0h 
T_VPMOVSXBW  . . . . . . . . . .        Number           5DEh 
T_VPMOVSXDQ  . . . . . . . . . .        Number           5E3h 
T_VPMOVSXWD  . . . . . . . . . .        Number           5E1h 
T_VPMOVSXWQ  . . . . . . . . . .        Number           5E2h 
T_VPMOVUSDB  . . . . . . . . . .        Number           700h 
T_VPMOVUSDW  . . . . . . . . . .        Number           701h 
T_VPMOVUSQB  . . . . . . . . . .        Number           702h 
T_VPMOVUSQD  . . . . . . . . . .        Number           703h 
T_VPMOVUSQW  . . . . . . . . . .        Number           704h 
T_VPMOVUSWB  . . . . . . . . . .        Number           705h 
T_VPMOVW2M . . . . . . . . . . .        Number           798h 
T_VPMOVWB  . . . . . . . . . . .        Number           6F9h 
T_VPMOVZXBD  . . . . . . . . . .        Number           5E5h 
T_VPMOVZXBQ  . . . . . . . . . .        Number           5E6h 
T_VPMOVZXBW  . . . . . . . . . .        Number           5E4h 
T_VPMOVZXDQ  . . . . . . . . . .        Number           5E9h 
T_VPMOVZXWD  . . . . . . . . . .        Number           5E7h 
T_VPMOVZXWQ  . . . . . . . . . .        Number           5E8h 
T_VPMULDQ  . . . . . . . . . . .        Number           5F0h 
T_VPMULHRSW  . . . . . . . . . .        Number           5EBh 
T_VPMULHUW . . . . . . . . . . .        Number           5EAh 
T_VPMULHW  . . . . . . . . . . .        Number           5ECh 
T_VPMULLD  . . . . . . . . . . .        Number           5EEh 
T_VPMULLW  . . . . . . . . . . .        Number           5EDh 
T_VPMULUDQ . . . . . . . . . . .        Number           5EFh 
T_VPOR . . . . . . . . . . . . .        Number           5F1h 
T_VPORD  . . . . . . . . . . . .        Number           75Bh 
T_VPORQ  . . . . . . . . . . . .        Number           75Ch 
T_VPROLD . . . . . . . . . . . .        Number           658h 
T_VPROLQ . . . . . . . . . . . .        Number           659h 
T_VPROLVD  . . . . . . . . . . .        Number           656h 
T_VPROLVQ  . . . . . . . . . . .        Number           657h 
T_VPRORD . . . . . . . . . . . .        Number           65Ch 
T_VPRORQ . . . . . . . . . . . .        Number           65Dh 
T_VPRORVD  . . . . . . . . . . .        Number           65Ah 
T_VPRORVQ  . . . . . . . . . . .        Number           65Bh 
T_VPSADBW  . . . . . . . . . . .        Number           5F2h 
T_VPSCATTERDD  . . . . . . . . .        Number           6C9h 
T_VPSCATTERDQ  . . . . . . . . .        Number           795h 
T_VPSCATTERQD  . . . . . . . . .        Number           6CAh 
T_VPSCATTERQQ  . . . . . . . . .        Number           796h 
T_VPSHUFB  . . . . . . . . . . .        Number           5F3h 
T_VPSHUFD  . . . . . . . . . . .        Number           5F4h 
T_VPSHUFHW . . . . . . . . . . .        Number           5F5h 
T_VPSHUFLW . . . . . . . . . . .        Number           5F6h 
T_VPSIGNB  . . . . . . . . . . .        Number           5F7h 
T_VPSIGND  . . . . . . . . . . .        Number           5F9h 
T_VPSIGNW  . . . . . . . . . . .        Number           5F8h 
T_VPSLLD . . . . . . . . . . . .        Number           5FDh 
T_VPSLLDQ  . . . . . . . . . . .        Number           5FAh 
T_VPSLLQ . . . . . . . . . . . .        Number           5FEh 
T_VPSLLVD  . . . . . . . . . . .        Number           630h 
T_VPSLLVQ  . . . . . . . . . . .        Number           631h 
T_VPSLLVW  . . . . . . . . . . .        Number           62Fh 
T_VPSLLW . . . . . . . . . . . .        Number           5FCh 
T_VPSRAD . . . . . . . . . . . .        Number           600h 
T_VPSRAQ . . . . . . . . . . . .        Number           655h 
T_VPSRAVD  . . . . . . . . . . .        Number           632h 
T_VPSRAVQ  . . . . . . . . . . .        Number           64Dh 
T_VPSRAVW  . . . . . . . . . . .        Number           64Ch 
T_VPSRAW . . . . . . . . . . . .        Number           5FFh 
T_VPSRLD . . . . . . . . . . . .        Number           602h 
T_VPSRLDQ  . . . . . . . . . . .        Number           5FBh 
T_VPSRLQ . . . . . . . . . . . .        Number           603h 
T_VPSRLVD  . . . . . . . . . . .        Number           633h 
T_VPSRLVQ  . . . . . . . . . . .        Number           634h 
T_VPSRLVW  . . . . . . . . . . .        Number           64Eh 
T_VPSRLW . . . . . . . . . . . .        Number           601h 
T_VPSUBB . . . . . . . . . . . .        Number           605h 
T_VPSUBD . . . . . . . . . . . .        Number           607h 
T_VPSUBQ . . . . . . . . . . . .        Number           608h 
T_VPSUBSB  . . . . . . . . . . .        Number           609h 
T_VPSUBSW  . . . . . . . . . . .        Number           60Ah 
T_VPSUBUSB . . . . . . . . . . .        Number           60Bh 
T_VPSUBUSW . . . . . . . . . . .        Number           60Ch 
T_VPSUBW . . . . . . . . . . . .        Number           606h 
T_VPTERNLOGD . . . . . . . . . .        Number           761h 
T_VPTERNLOGQ . . . . . . . . . .        Number           762h 
T_VPTEST . . . . . . . . . . . .        Number           604h 
T_VPTESTMB . . . . . . . . . . .        Number           75Dh 
T_VPTESTMD . . . . . . . . . . .        Number           75Fh 
T_VPTESTMQ . . . . . . . . . . .        Number           760h 
T_VPTESTMW . . . . . . . . . . .        Number           75Eh 
T_VPTESTNMB  . . . . . . . . . .        Number           662h 
T_VPTESTNMD  . . . . . . . . . .        Number           664h 
T_VPTESTNMQ  . . . . . . . . . .        Number           665h 
T_VPTESTNMW  . . . . . . . . . .        Number           663h 
T_VPUNPCKHBW . . . . . . . . . .        Number           60Dh 
T_VPUNPCKHDQ . . . . . . . . . .        Number           60Fh 
T_VPUNPCKHQDQ  . . . . . . . . .        Number           610h 
T_VPUNPCKHWD . . . . . . . . . .        Number           60Eh 
T_VPUNPCKLBW . . . . . . . . . .        Number           611h 
T_VPUNPCKLDQ . . . . . . . . . .        Number           613h 
T_VPUNPCKLQDQ  . . . . . . . . .        Number           614h 
T_VPUNPCKLWD . . . . . . . . . .        Number           612h 
T_VPXOR  . . . . . . . . . . . .        Number           615h 
T_VPXORD . . . . . . . . . . . .        Number           653h 
T_VPXORQ . . . . . . . . . . . .        Number           654h 
T_VRCP14PD . . . . . . . . . . .        Number           6E4h 
T_VRCP14PS . . . . . . . . . . .        Number           6E5h 
T_VRCP14SD . . . . . . . . . . .        Number           6E6h 
T_VRCP14SS . . . . . . . . . . .        Number           6E7h 
T_VRCP28PD . . . . . . . . . . .        Number           69Ah 
T_VRCP28PS . . . . . . . . . . .        Number           699h 
T_VRCP28SD . . . . . . . . . . .        Number           69Ch 
T_VRCP28SS . . . . . . . . . . .        Number           69Bh 
T_VRCPPS . . . . . . . . . . . .        Number           616h 
T_VRCPSS . . . . . . . . . . . .        Number           617h 
T_VREDUCEPD  . . . . . . . . . .        Number           6E8h 
T_VREDUCEPS  . . . . . . . . . .        Number           6E9h 
T_VREDUCESD  . . . . . . . . . .        Number           6EAh 
T_VREDUCESS  . . . . . . . . . .        Number           6EBh 
T_VRNDSCALEPD  . . . . . . . . .        Number           6ECh 
T_VRNDSCALEPS  . . . . . . . . .        Number           6EDh 
T_VRNDSCALESD  . . . . . . . . .        Number           6EEh 
T_VRNDSCALESS  . . . . . . . . .        Number           6EFh 
T_VROUNDPD . . . . . . . . . . .        Number           61Ah 
T_VROUNDPS . . . . . . . . . . .        Number           61Bh 
T_VROUNDSD . . . . . . . . . . .        Number           61Ch 
T_VROUNDSS . . . . . . . . . . .        Number           61Dh 
T_VRSQRT14PD . . . . . . . . . .        Number           6D7h 
T_VRSQRT14PS . . . . . . . . . .        Number           6D8h 
T_VRSQRT14SD . . . . . . . . . .        Number           6D9h 
T_VRSQRT14SS . . . . . . . . . .        Number           6DAh 
T_VRSQRT28PD . . . . . . . . . .        Number           6DBh 
T_VRSQRT28PS . . . . . . . . . .        Number           6DCh 
T_VRSQRT28SD . . . . . . . . . .        Number           6DDh 
T_VRSQRT28SS . . . . . . . . . .        Number           6DEh 
T_VRSQRTPS . . . . . . . . . . .        Number           618h 
T_VRSQRTSS . . . . . . . . . . .        Number           619h 
T_VSCALEFPD  . . . . . . . . . .        Number           76Dh 
T_VSCALEFPS  . . . . . . . . . .        Number           76Eh 
T_VSCALEFSD  . . . . . . . . . .        Number           76Fh 
T_VSCALEFSS  . . . . . . . . . .        Number           770h 
T_VSCATTERDPD  . . . . . . . . .        Number           793h 
T_VSCATTERDPS  . . . . . . . . .        Number           6C7h 
T_VSCATTERPF0DPD . . . . . . . .        Number           6CDh 
T_VSCATTERPF0DPS . . . . . . . .        Number           6CBh 
T_VSCATTERPF0QPD . . . . . . . .        Number           6CEh 
T_VSCATTERPF0QPS . . . . . . . .        Number           6CCh 
T_VSCATTERPF1DPD . . . . . . . .        Number           6D1h 
T_VSCATTERPF1DPS . . . . . . . .        Number           6CFh 
T_VSCATTERPF1QPD . . . . . . . .        Number           6D2h 
T_VSCATTERPF1QPS . . . . . . . .        Number           6D0h 
T_VSCATTERQPD  . . . . . . . . .        Number           794h 
T_VSCATTERQPS  . . . . . . . . .        Number           6C8h 
T_VSHUFF32X4 . . . . . . . . . .        Number           763h 
T_VSHUFF64X2 . . . . . . . . . .        Number           764h 
T_VSHUFI32X4 . . . . . . . . . .        Number           765h 
T_VSHUFI64X2 . . . . . . . . . .        Number           766h 
T_VSHUFPD  . . . . . . . . . . .        Number           61Eh 
T_VSHUFPS  . . . . . . . . . . .        Number           61Fh 
T_VSQRTPD  . . . . . . . . . . .        Number           553h 
T_VSQRTPS  . . . . . . . . . . .        Number           554h 
T_VSQRTSD  . . . . . . . . . . .        Number           555h 
T_VSQRTSS  . . . . . . . . . . .        Number           556h 
T_VSTMXCSR . . . . . . . . . . .        Number           57Fh 
T_VSUBPD . . . . . . . . . . . .        Number           557h 
T_VSUBPS . . . . . . . . . . . .        Number           558h 
T_VSUBSD . . . . . . . . . . . .        Number           559h 
T_VSUBSS . . . . . . . . . . . .        Number           55Ah 
T_VTESTPD  . . . . . . . . . . .        Number           533h 
T_VTESTPS  . . . . . . . . . . .        Number           532h 
T_VUCOMISD . . . . . . . . . . .        Number           620h 
T_VUCOMISS . . . . . . . . . . .        Number           621h 
T_VUNPCKHPD  . . . . . . . . . .        Number           622h 
T_VUNPCKHPS  . . . . . . . . . .        Number           623h 
T_VUNPCKLPD  . . . . . . . . . .        Number           624h 
T_VUNPCKLPS  . . . . . . . . . .        Number           625h 
T_VXORPD . . . . . . . . . . . .        Number           563h 
T_VXORPS . . . . . . . . . . . .        Number           564h 
T_VZEROALL . . . . . . . . . . .        Number           534h 
T_VZEROUPPER . . . . . . . . . .        Number           535h 
T_WAIT . . . . . . . . . . . . .        Number           2FBh 
T_WATCALL  . . . . . . . . . . .        Number           118h 
T_WBINVD . . . . . . . . . . . .        Number           2FCh 
T_WHILE  . . . . . . . . . . . .        Number           1F0h 
T_WORD . . . . . . . . . . . . .        Number            CFh 
T_WRFSBASE . . . . . . . . . . .        Number           512h 
T_WRGSBASE . . . . . . . . . . .        Number           513h 
T_WRMSR  . . . . . . . . . . . .        Number           2FDh 
T_XADD . . . . . . . . . . . . .        Number           2FEh 
T_XCHG . . . . . . . . . . . . .        Number           2FFh 
T_XGETBV . . . . . . . . . . . .        Number           517h 
T_XLAT . . . . . . . . . . . . .        Number           300h 
T_XLATB  . . . . . . . . . . . .        Number           301h 
T_XMM0 . . . . . . . . . . . . .        Number            28h 
T_XMM1 . . . . . . . . . . . . .        Number            29h 
T_XMM10  . . . . . . . . . . . .        Number            86h 
T_XMM11  . . . . . . . . . . . .        Number            87h 
T_XMM12  . . . . . . . . . . . .        Number            88h 
T_XMM13  . . . . . . . . . . . .        Number            89h 
T_XMM14  . . . . . . . . . . . .        Number            8Ah 
T_XMM15  . . . . . . . . . . . .        Number            8Bh 
T_XMM16  . . . . . . . . . . . .        Number            8Ch 
T_XMM17  . . . . . . . . . . . .        Number            8Dh 
T_XMM18  . . . . . . . . . . . .        Number            8Eh 
T_XMM19  . . . . . . . . . . . .        Number            8Fh 
T_XMM2 . . . . . . . . . . . . .        Number            2Ah 
T_XMM20  . . . . . . . . . . . .        Number            90h 
T_XMM21  . . . . . . . . . . . .        Number            91h 
T_XMM22  . . . . . . . . . . . .        Number            92h 
T_XMM23  . . . . . . . . . . . .        Number            93h 
T_XMM24  . . . . . . . . . . . .        Number            94h 
T_XMM25  . . . . . . . . . . . .        Number            95h 
T_XMM26  . . . . . . . . . . . .        Number            96h 
T_XMM27  . . . . . . . . . . . .        Number            97h 
T_XMM28  . . . . . . . . . . . .        Number            98h 
T_XMM29  . . . . . . . . . . . .        Number            99h 
T_XMM3 . . . . . . . . . . . . .        Number            2Bh 
T_XMM30  . . . . . . . . . . . .        Number            9Ah 
T_XMM31  . . . . . . . . . . . .        Number            9Bh 
T_XMM4 . . . . . . . . . . . . .        Number            2Ch 
T_XMM5 . . . . . . . . . . . . .        Number            2Dh 
T_XMM6 . . . . . . . . . . . . .        Number            2Eh 
T_XMM7 . . . . . . . . . . . . .        Number            2Fh 
T_XMM8 . . . . . . . . . . . . .        Number            84h 
T_XMM9 . . . . . . . . . . . . .        Number            85h 
T_XMMWORD  . . . . . . . . . . .        Number            E8h 
T_XOR  . . . . . . . . . . . . .        Number           263h 
T_XORPD  . . . . . . . . . . . .        Number           401h 
T_XORPS  . . . . . . . . . . . .        Number           402h 
T_XRSTOR . . . . . . . . . . . .        Number           514h 
T_XSAVE  . . . . . . . . . . . .        Number           515h 
T_XSAVEOPT . . . . . . . . . . .        Number           516h 
T_XSETBV . . . . . . . . . . . .        Number           518h 
T_YMM0 . . . . . . . . . . . . .        Number            30h 
T_YMM1 . . . . . . . . . . . . .        Number            31h 
T_YMM10  . . . . . . . . . . . .        Number            9Eh 
T_YMM11  . . . . . . . . . . . .        Number            9Fh 
T_YMM12  . . . . . . . . . . . .        Number            A0h 
T_YMM13  . . . . . . . . . . . .        Number            A1h 
T_YMM14  . . . . . . . . . . . .        Number            A2h 
T_YMM15  . . . . . . . . . . . .        Number            A3h 
T_YMM16  . . . . . . . . . . . .        Number            A4h 
T_YMM17  . . . . . . . . . . . .        Number            A5h 
T_YMM18  . . . . . . . . . . . .        Number            A6h 
T_YMM19  . . . . . . . . . . . .        Number            A7h 
T_YMM2 . . . . . . . . . . . . .        Number            32h 
T_YMM20  . . . . . . . . . . . .        Number            A8h 
T_YMM21  . . . . . . . . . . . .        Number            A9h 
T_YMM22  . . . . . . . . . . . .        Number            AAh 
T_YMM23  . . . . . . . . . . . .        Number            ABh 
T_YMM24  . . . . . . . . . . . .        Number            ACh 
T_YMM25  . . . . . . . . . . . .        Number            ADh 
T_YMM26  . . . . . . . . . . . .        Number            AEh 
T_YMM27  . . . . . . . . . . . .        Number            AFh 
T_YMM28  . . . . . . . . . . . .        Number            B0h 
T_YMM29  . . . . . . . . . . . .        Number            B1h 
T_YMM3 . . . . . . . . . . . . .        Number            33h 
T_YMM30  . . . . . . . . . . . .        Number            B2h 
T_YMM31  . . . . . . . . . . . .        Number            B3h 
T_YMM4 . . . . . . . . . . . . .        Number            34h 
T_YMM5 . . . . . . . . . . . . .        Number            35h 
T_YMM6 . . . . . . . . . . . . .        Number            36h 
T_YMM7 . . . . . . . . . . . . .        Number            37h 
T_YMM8 . . . . . . . . . . . . .        Number            9Ch 
T_YMM9 . . . . . . . . . . . . .        Number            9Dh 
T_YMMWORD  . . . . . . . . . . .        Number            DFh 
T_YWORD  . . . . . . . . . . . .        Number            DDh 
T_ZMM0 . . . . . . . . . . . . .        Number            40h 
T_ZMM1 . . . . . . . . . . . . .        Number            41h 
T_ZMM10  . . . . . . . . . . . .        Number            B6h 
T_ZMM11  . . . . . . . . . . . .        Number            B7h 
T_ZMM12  . . . . . . . . . . . .        Number            B8h 
T_ZMM13  . . . . . . . . . . . .        Number            B9h 
T_ZMM14  . . . . . . . . . . . .        Number            BAh 
T_ZMM15  . . . . . . . . . . . .        Number            BBh 
T_ZMM16  . . . . . . . . . . . .        Number            BCh 
T_ZMM17  . . . . . . . . . . . .        Number            BDh 
T_ZMM18  . . . . . . . . . . . .        Number            BEh 
T_ZMM19  . . . . . . . . . . . .        Number            BFh 
T_ZMM2 . . . . . . . . . . . . .        Number            42h 
T_ZMM20  . . . . . . . . . . . .        Number            C0h 
T_ZMM21  . . . . . . . . . . . .        Number            C1h 
T_ZMM22  . . . . . . . . . . . .        Number            C2h 
T_ZMM23  . . . . . . . . . . . .        Number            C3h 
T_ZMM24  . . . . . . . . . . . .        Number            C4h 
T_ZMM25  . . . . . . . . . . . .        Number            C5h 
T_ZMM26  . . . . . . . . . . . .        Number            C6h 
T_ZMM27  . . . . . . . . . . . .        Number            C7h 
T_ZMM28  . . . . . . . . . . . .        Number            C8h 
T_ZMM29  . . . . . . . . . . . .        Number            C9h 
T_ZMM3 . . . . . . . . . . . . .        Number            43h 
T_ZMM30  . . . . . . . . . . . .        Number            CAh 
T_ZMM31  . . . . . . . . . . . .        Number            CBh 
T_ZMM4 . . . . . . . . . . . . .        Number            44h 
T_ZMM5 . . . . . . . . . . . . .        Number            45h 
T_ZMM6 . . . . . . . . . . . . .        Number            46h 
T_ZMM7 . . . . . . . . . . . . .        Number            47h 
T_ZMM8 . . . . . . . . . . . . .        Number            B4h 
T_ZMM9 . . . . . . . . . . . . .        Number            B5h 
T_ZMMWORD  . . . . . . . . . . .        Number            E0h 
T_ZWORD  . . . . . . . . . . . .        Number            DEh 
Token_Count  . . . . . . . . . .        Text   ModuleInfo.token_count
UCHAR_MAX  . . . . . . . . . . .        Number            FFh 
UINT_MAX . . . . . . . . . . . .        Number      FFFFFFFFh 
ULLONG_MAX . . . . . . . . . . .        Number     -00000001h 
ULONG_MAX  . . . . . . . . . . .        Number      FFFFFFFFh 
USE16  . . . . . . . . . . . . .        Number             0h 
USE32  . . . . . . . . . . . . .        Number             1h 
USE64  . . . . . . . . . . . . .        Number             2h 
USE_COMALLOC . . . . . . . . . .        Number             0h 
USE_EMPTY  . . . . . . . . . . .        Number            FEh 
USE_INDIRECTION  . . . . . . . .        Number             0h 
USHRT_MAX  . . . . . . . . . . .        Number          FFFFh 
VEX_START  . . . . . . . . . . .        Number           525h 
VX1_B  . . . . . . . . . . . . .        Number            20h 
VX1_M1 . . . . . . . . . . . . .        Number             2h 
VX1_M2 . . . . . . . . . . . . .        Number             1h 
VX1_R  . . . . . . . . . . . . .        Number            80h 
VX1_R1 . . . . . . . . . . . . .        Number            10h 
VX1_X  . . . . . . . . . . . . .        Number            40h 
VX2_1  . . . . . . . . . . . . .        Number             4h 
VX2_P0 . . . . . . . . . . . . .        Number             1h 
VX2_P1 . . . . . . . . . . . . .        Number             2h 
VX2_V0 . . . . . . . . . . . . .        Number             8h 
VX2_V1 . . . . . . . . . . . . .        Number            10h 
VX2_V2 . . . . . . . . . . . . .        Number            20h 
VX2_V3 . . . . . . . . . . . . .        Number            40h 
VX2_W  . . . . . . . . . . . . .        Number            80h 
VX3_A0 . . . . . . . . . . . . .        Number             1h 
VX3_A1 . . . . . . . . . . . . .        Number             2h 
VX3_A2 . . . . . . . . . . . . .        Number             4h 
VX3_B  . . . . . . . . . . . . .        Number            10h 
VX3_L0 . . . . . . . . . . . . .        Number            20h 
VX3_L1 . . . . . . . . . . . . .        Number            40h 
VX3_V  . . . . . . . . . . . . .        Number             8h 
VX3_Z  . . . . . . . . . . . . .        Number            80h 
VX_NV0 . . . . . . . . . . . . .        Number             4h 
VX_OP1V  . . . . . . . . . . . .        Number             1h 
VX_OP2V  . . . . . . . . . . . .        Number             2h 
VX_OP3 . . . . . . . . . . . . .        Number             8h 
VX_OP3V  . . . . . . . . . . . .        Number             4h 
VX_RXB . . . . . . . . . . . . .        Number             Fh 
VX_SAE . . . . . . . . . . . . .        Number            20h 
VX_W1  . . . . . . . . . . . . .        Number             2h 
VX_XMMI  . . . . . . . . . . . .        Number             8h 
VX_ZMM . . . . . . . . . . . . .        Number            10h 
VX_ZMM24 . . . . . . . . . . . .        Number            80h 
VX_ZMM8  . . . . . . . . . . . .        Number            40h 
W64F_ALL . . . . . . . . . . . .        Number             7h 
W64F_AUTOSTACKSP . . . . . . . .        Number             2h 
W64F_SAVEREGPARAMS . . . . . . .        Number             1h 
W64F_STACKALIGN16  . . . . . . .        Number             4h 
WDK_NTDDI_VERSION  . . . . . . .        Number       A000008h 
WINAPI . . . . . . . . . . . . .        Text   fastcall
WINVER . . . . . . . . . . . . .        Number           601h 
_AMD64_  . . . . . . . . . . . .        Number             0h 
_CALLBACK_DEFINED  . . . . . . .        Number             0h 
_CALL_REPORTFAULT  . . . . . . .        Number             2h 
_CONTROL . . . . . . . . . . . .        Number            20h 
_CRT_ALGO_DEFINED  . . . . . . .        Number             0h 
_CRT_ALLOCATION_DEFINED  . . . .        Number             0h 
_CRT_DOUBLE_DEC  . . . . . . . .        Number             0h 
_CRT_ERRNO_DEFINED . . . . . . .        Number             0h 
_CRT_PERROR_DEFINED  . . . . . .        Number             0h 
_CRT_SYSTEM_DEFINED  . . . . . .        Number             0h 
_CRT_TERMINATE_DEFINED . . . . .        Number             0h 
_CRT_WPERROR_DEFINED . . . . . .        Number             0h 
_CRT_WSYSTEM_DEFINED . . . . . .        Number             0h 
_CVTBUFSIZE  . . . . . . . . . .        Number           15Dh 
_DIGIT . . . . . . . . . . . . .        Number             4h 
_DIV_T_DEFINED . . . . . . . . .        Number             0h 
_ERRNO_T_DEFINED . . . . . . . .        Number             0h 
_FILE_DEFINED  . . . . . . . . .        Number             0h 
_GRANULARITY . . . . . . . . . .        Number            10h 
_HEAP_ALIGNED  . . . . . . . . .        Number             3h 
_HEAP_COALESCE . . . . . . . . .        Number     -00000001h 
_HEAP_EMPTYLIST_SIZE . . . . . .        Number          1000h 
_HEAP_FREE . . . . . . . . . . .        Number             0h 
_HEAP_GLOBAL . . . . . . . . . .        Number             2h 
_HEAP_GROWMIN  . . . . . . . . .        Number          1000h 
_HEAP_GROWSIZE . . . . . . . . .        Number         40000h 
_HEAP_GROWSTART  . . . . . . . .        Number          1000h 
_HEAP_LOCAL  . . . . . . . . . .        Number             1h 
_HEAP_MAXREGSIZE_L . . . . . . .        Number       1000000h 
_HEAP_MAXREGSIZE_S . . . . . . .        Number       1000000h 
_HEAP_MAXREQ . . . . . . . . . .        Number     -00000020h 
_HEAP_REGIONMAX  . . . . . . . .        Number            40h 
_HEAP_REGIONSIZE_L . . . . . . .        Number        100000h 
_HEAP_REGIONSIZE_S . . . . . . .        Number          4000h 
_HEX . . . . . . . . . . . . . .        Number            80h 
_I16_MAX . . . . . . . . . . . .        Number          7FFFh 
_I16_MIN . . . . . . . . . . . .        Number     -00008000h 
_I32_MAX . . . . . . . . . . . .        Number      7FFFFFFFh 
_I32_MIN . . . . . . . . . . . .        Number     -80000000h 
_I64_MAX . . . . . . . . . . . .        Number      FFFFFFFFh 
_I64_MIN . . . . . . . . . . . .        Number      0h 
_I8_MAX  . . . . . . . . . . . .        Number            7Fh 
_I8_MIN  . . . . . . . . . . . .        Number     -00000080h 
_INC_MALLOC  . . . . . . . . . .        Number             0h 
_INC_SDKDDKVER . . . . . . . . .        Number             0h 
_INTEGRAL_MAX_BITS . . . . . . .        Number            40h 
_INTIOBUF  . . . . . . . . . . .        Number          1000h 
_INTPTR_T_DEFINED  . . . . . . .        Number             0h 
_IOCOMMIT  . . . . . . . . . . .        Number          4000h 
_IOCTRLZ . . . . . . . . . . . .        Number          2000h 
_IOEOF . . . . . . . . . . . . .        Number            10h 
_IOERR . . . . . . . . . . . . .        Number            20h 
_IOFBF . . . . . . . . . . . . .        Number             0h 
_IOFEOF  . . . . . . . . . . . .        Number           800h 
_IOFLRTN . . . . . . . . . . . .        Number          1000h 
_IOLBF . . . . . . . . . . . . .        Number            40h 
_IOMYBUF . . . . . . . . . . . .        Number             8h 
_IONBF . . . . . . . . . . . . .        Number             4h 
_IOREAD  . . . . . . . . . . . .        Number             1h 
_IORW  . . . . . . . . . . . . .        Number            80h 
_IOSETVBUF . . . . . . . . . . .        Number           400h 
_IOSTRG  . . . . . . . . . . . .        Number            40h 
_IOWRT . . . . . . . . . . . . .        Number             2h 
_IOYOURBUF . . . . . . . . . . .        Number           100h 
_LABEL . . . . . . . . . . . . .        Number            40h 
_LOWER . . . . . . . . . . . . .        Number             2h 
_MAXIOBUF  . . . . . . . . . . .        Number          4000h 
_MAX_DIR . . . . . . . . . . . .        Number           100h 
_MAX_DRIVE . . . . . . . . . . .        Number             3h 
_MAX_ENV . . . . . . . . . . . .        Number          7FFFh 
_MAX_EXT . . . . . . . . . . . .        Number           100h 
_MAX_FNAME . . . . . . . . . . .        Number           100h 
_MAX_PATH  . . . . . . . . . . .        Number           104h 
_MINIOBUF  . . . . . . . . . . .        Number           200h 
_MSC_FULL_VER  . . . . . . . . .        Number       A21FE80h 
_MSC_VER . . . . . . . . . . . .        Number           6A4h 
_M_AMD64 . . . . . . . . . . . .        Number            64h 
_M_X64 . . . . . . . . . . . . .        Number            64h 
_NSTREAM_  . . . . . . . . . . .        Number            14h 
_NT_TARGET_VERSION_WIN10_RS4 . .        Number           A05h 
_ONEXIT_T_DEFINED  . . . . . . .        Number             0h 
_OUT_TO_DEFAULT  . . . . . . . .        Number             0h 
_OUT_TO_MSGBOX . . . . . . . . .        Number             2h 
_OUT_TO_STDERR . . . . . . . . .        Number             1h 
_PAGESIZE_ . . . . . . . . . . .        Number          1000h 
_PUNCT . . . . . . . . . . . . .        Number            10h 
_REGS6432  . . . . . . . . . . .        Number             0h 
_REPORT_ERRMODE  . . . . . . . .        Number             3h 
_SEGSIZE_  . . . . . . . . . . .        Number         10000h 
_SPACE . . . . . . . . . . . . .        Number             8h 
_ST_CAPEXP . . . . . . . . . . .        Number         10000h 
_ST_CVT  . . . . . . . . . . . .        Number          8000h 
_ST_DIGITS . . . . . . . . . . .        Number           400h 
_ST_DOT  . . . . . . . . . . . .        Number           800h 
_ST_DOUBLE . . . . . . . . . . .        Number         80000h 
_ST_E  . . . . . . . . . . . . .        Number          1000h 
_ST_F  . . . . . . . . . . . . .        Number          2000h 
_ST_FLOAT  . . . . . . . . . . .        Number         40000h 
_ST_G  . . . . . . . . . . . . .        Number          4000h 
_ST_INVALID  . . . . . . . . . .        Number            80h 
_ST_ISHEX  . . . . . . . . . . .        Number            10h 
_ST_ISINF  . . . . . . . . . . .        Number            40h 
_ST_ISNAN  . . . . . . . . . . .        Number            20h 
_ST_ISZERO . . . . . . . . . . .        Number             8h 
_ST_LONGDOUBLE . . . . . . . . .        Number        100000h 
_ST_NEGEXP . . . . . . . . . . .        Number             4h 
_ST_NEGNUM . . . . . . . . . . .        Number             2h 
_ST_NO_TRUNC . . . . . . . . . .        Number         20000h 
_ST_OVERFLOW . . . . . . . . . .        Number           200h 
_ST_QUADFLOAT  . . . . . . . . .        Number        200000h 
_ST_SIGN . . . . . . . . . . . .        Number             1h 
_ST_UNDERFLOW  . . . . . . . . .        Number           100h 
_TCHAR_DEFINED . . . . . . . . .        Number             0h 
_THREADLOCALEINFO  . . . . . . .        Number             0h 
_THREADMBCINFO . . . . . . . . .        Number             0h 
_UI16_MAX  . . . . . . . . . . .        Number          FFFFh 
_UI32_MAX  . . . . . . . . . . .        Number      FFFFFFFFh 
_UI64_MAX  . . . . . . . . . . .        Number     -00000001h 
_UI8_MAX . . . . . . . . . . . .        Number            FFh 
_UINTPTR_T_DEFINED . . . . . . .        Number             0h 
_UPPER . . . . . . . . . . . . .        Number             1h 
_WCHAR_T_DEFINED . . . . . . . .        Number             0h 
_WCTYPE_T_DEFINED  . . . . . . .        Number             0h 
_WIN32 . . . . . . . . . . . . .        Number             0h 
_WIN32_IE  . . . . . . . . . . .        Number           800h 
_WIN32_IE_IE100  . . . . . . . .        Number           A00h 
_WIN32_IE_IE110  . . . . . . . .        Number           A00h 
_WIN32_IE_IE20 . . . . . . . . .        Number           200h 
_WIN32_IE_IE30 . . . . . . . . .        Number           300h 
_WIN32_IE_IE302  . . . . . . . .        Number           302h 
_WIN32_IE_IE40 . . . . . . . . .        Number           400h 
_WIN32_IE_IE401  . . . . . . . .        Number           401h 
_WIN32_IE_IE50 . . . . . . . . .        Number           500h 
_WIN32_IE_IE501  . . . . . . . .        Number           501h 
_WIN32_IE_IE55 . . . . . . . . .        Number           550h 
_WIN32_IE_IE60 . . . . . . . . .        Number           600h 
_WIN32_IE_IE60SP1  . . . . . . .        Number           601h 
_WIN32_IE_IE60SP2  . . . . . . .        Number           603h 
_WIN32_IE_IE70 . . . . . . . . .        Number           700h 
_WIN32_IE_IE80 . . . . . . . . .        Number           800h 
_WIN32_IE_IE90 . . . . . . . . .        Number           900h 
_WIN32_IE_LONGHORN . . . . . . .        Number           700h 
_WIN32_IE_NT4  . . . . . . . . .        Number           200h 
_WIN32_IE_NT4SP1 . . . . . . . .        Number           200h 
_WIN32_IE_NT4SP2 . . . . . . . .        Number           200h 
_WIN32_IE_NT4SP3 . . . . . . . .        Number           302h 
_WIN32_IE_NT4SP4 . . . . . . . .        Number           401h 
_WIN32_IE_NT4SP5 . . . . . . . .        Number           401h 
_WIN32_IE_NT4SP6 . . . . . . . .        Number           500h 
_WIN32_IE_WIN10  . . . . . . . .        Number           A00h 
_WIN32_IE_WIN2K  . . . . . . . .        Number           501h 
_WIN32_IE_WIN2KSP1 . . . . . . .        Number           501h 
_WIN32_IE_WIN2KSP2 . . . . . . .        Number           501h 
_WIN32_IE_WIN2KSP3 . . . . . . .        Number           501h 
_WIN32_IE_WIN2KSP4 . . . . . . .        Number           501h 
_WIN32_IE_WIN6 . . . . . . . . .        Number           700h 
_WIN32_IE_WIN7 . . . . . . . . .        Number           800h 
_WIN32_IE_WIN8 . . . . . . . . .        Number           A00h 
_WIN32_IE_WIN98  . . . . . . . .        Number           401h 
_WIN32_IE_WIN98SE  . . . . . . .        Number           500h 
_WIN32_IE_WINBLUE  . . . . . . .        Number           A00h 
_WIN32_IE_WINME  . . . . . . . .        Number           550h 
_WIN32_IE_WINTHRESHOLD . . . . .        Number           A00h 
_WIN32_IE_WS03 . . . . . . . . .        Number           602h 
_WIN32_IE_WS03SP1  . . . . . . .        Number           603h 
_WIN32_IE_XP . . . . . . . . . .        Number           600h 
_WIN32_IE_XPSP1  . . . . . . . .        Number           601h 
_WIN32_IE_XPSP2  . . . . . . . .        Number           603h 
_WIN32_WINDOWS . . . . . . . . .        Number           410h 
_WIN32_WINNT . . . . . . . . . .        Number           601h 
_WIN32_WINNT_LONGHORN  . . . . .        Number           600h 
_WIN32_WINNT_NT4 . . . . . . . .        Number           400h 
_WIN32_WINNT_VISTA . . . . . . .        Number           600h 
_WIN32_WINNT_WIN10 . . . . . . .        Number           A00h 
_WIN32_WINNT_WIN10_RS1 . . . . .        Number           A02h 
_WIN32_WINNT_WIN10_RS2 . . . . .        Number           A03h 
_WIN32_WINNT_WIN10_RS3 . . . . .        Number           A04h 
_WIN32_WINNT_WIN10_RS4 . . . . .        Number           A05h 
_WIN32_WINNT_WIN10_RS5 . . . . .        Number           A06h 
_WIN32_WINNT_WIN10_TH2 . . . . .        Number           A01h 
_WIN32_WINNT_WIN2K . . . . . . .        Number           500h 
_WIN32_WINNT_WIN6  . . . . . . .        Number           600h 
_WIN32_WINNT_WIN7  . . . . . . .        Number           601h 
_WIN32_WINNT_WIN8  . . . . . . .        Number           602h 
_WIN32_WINNT_WINBLUE . . . . . .        Number           603h 
_WIN32_WINNT_WINTHRESHOLD  . . .        Number           A00h 
_WIN32_WINNT_WINXP . . . . . . .        Number           501h 
_WIN32_WINNT_WS03  . . . . . . .        Number           502h 
_WIN32_WINNT_WS08  . . . . . . .        Number           600h 
_WINNT_WINNT . . . . . . . . . .        Number           601h 
_WRITE_ABORT_MSG . . . . . . . .        Number             1h 
_WSTDIO_DEFINED  . . . . . . . .        Number             0h 
_WSTDLIBP_DEFINED  . . . . . . .        Number             0h 
_WSTDLIB_DEFINED . . . . . . . .        Number             0h 
_WSTRING_DEFINED . . . . . . . .        Number             1h 
__ASMC_INC . . . . . . . . . . .        Number             0h 
__CONDASM_INC  . . . . . . . . .        Number             0h 
__Cdecl  . . . . . . . . . . . .        Text   fastcall
__Ctype  . . . . . . . . . . . .        Text   fastcall
__EQUATE_INC . . . . . . . . . .        Number             0h 
__ERRMSG_INC . . . . . . . . . .        Number             0h 
__EXPREVAL_INC . . . . . . . . .        Number             0h 
__FIXUP_inc  . . . . . . . . . .        Number             0h 
__FLTINTRN_INC . . . . . . . . .        Number             0h 
__INC_VERSION  . . . . . . . . .        Number             0h 
__INPUT_INC  . . . . . . . . . .        Number             0h 
__INTTYPE_INC  . . . . . . . . .        Number             0h 
__LIBC_INC . . . . . . . . . . .        Number             0h 
__LIBC__ . . . . . . . . . . . .        Number            EAh 
__LISTING_INC  . . . . . . . . .        Number             0h 
__LQUEUE_INC . . . . . . . . . .        Number             0h 
__LTYPE_INC  . . . . . . . . . .        Number             0h 
__MACRO_INC  . . . . . . . . . .        Number             0h 
__MEMALLOC_INC . . . . . . . . .        Number             0h 
__NAMESPACE_INC  . . . . . . . .        Number             0h 
__PARSER_INC . . . . . . . . . .        Number             0h 
__PREPROC_INC  . . . . . . . . .        Number             0h 
__QFLOAT_INC . . . . . . . . . .        Number             0h 
__QUEUE_INC  . . . . . . . . . .        Number             0h 
__STDC_WANT_SECURE_LIB__ . . . .        Number             1h 
__STDC__ . . . . . . . . . . . .        Number             0h 
__STDIO_INC  . . . . . . . . . .        Number             0h 
__STDLIB_INC . . . . . . . . . .        Number             0h 
__STRING_INC . . . . . . . . . .        Number             0h 
__SYMBOLS_INC  . . . . . . . . .        Number             0h 
__THREADLOCALEINFO_INC . . . . .        Number             0h 
__TOKENIZE_INC . . . . . . . . .        Number             0h 
__TOKEN_INC  . . . . . . . . . .        Number             0h 
__TYPES_INC  . . . . . . . . . .        Number             0h 
__argc . . . . . . . . . . . . .        DWord              0h *External FASTCALL
__argv . . . . . . . . . . . . .        Near               0h *External FASTCALL
__ccall  . . . . . . . . . . . .        Text   fastcall
__cdecl  . . . . . . . . . . . .        Text   fastcall
__mb_cur_max . . . . . . . . . .        DWord              0h *External FASTCALL
__wargv  . . . . . . . . . . . .        Near               0h *External FASTCALL
_amblksiz  . . . . . . . . . . .        DWord              0h *External FASTCALL
_bufin . . . . . . . . . . . . .        Byte               0h *External FASTCALL
_countof . . . . . . . . . . . .        Text   lengthof
_doserrno  . . . . . . . . . . .        Text   errno_t ptr [__doserrno()]
_environ . . . . . . . . . . . .        Near               0h *External FASTCALL
_fltpowtable . . . . . . . . . .        EXTFLOAT           0h *External FASTCALL
_fmode . . . . . . . . . . . . .        DWord              0h *External FASTCALL
_heap_base . . . . . . . . . . .        Near               0h *External FASTCALL
_heap_free . . . . . . . . . . .        Near               0h *External FASTCALL
_iob . . . . . . . . . . . . . .        _iobuf             0h *External FASTCALL
_ltype . . . . . . . . . . . . .        Byte               0h *External FASTCALL
_osfhnd  . . . . . . . . . . . .        Near               0h *External FASTCALL
_pgmptr  . . . . . . . . . . . .        Near               0h *External FASTCALL
_sys_errlist . . . . . . . . . .        Text   __sys_errlist()
_sys_nerr  . . . . . . . . . . .        Text   [__sys_nerr()]
_wenviron  . . . . . . . . . . .        Near               0h *External FASTCALL
_wpgmptr . . . . . . . . . . . .        Near               0h *External FASTCALL
avxins . . . . . . . . . . . . .        Number             0h Undefined 
errno  . . . . . . . . . . . . .        Text   errno_t ptr [_errno()]
errout . . . . . . . . . . . . .        Text   stdout
false  . . . . . . . . . . . . .        Number             0h 
insa . . . . . . . . . . . . . .        Number             0h Undefined 
insm . . . . . . . . . . . . . .        Number             0h Undefined 
insn . . . . . . . . . . . . . .        Number             0h Undefined 
insv . . . . . . . . . . . . . .        Number             0h Undefined 
insx . . . . . . . . . . . . . .        Number             0h Undefined 
no_RM  . . . . . . . . . . . . .        Number             1h 
no_WDS . . . . . . . . . . . . .        Number             2h 
nullptr  . . . . . . . . . . . .        Number             0h 
optable_idx  . . . . . . . . . .        Word               0h *External FASTCALL
qerrno . . . . . . . . . . . . .        DWord              0h *External FASTCALL
regax  . . . . . . . . . . . . .        DWord              0h *External FASTCALL
res  . . . . . . . . . . . . . .        Number             0h Undefined 
rm_downward  . . . . . . . . . .        Number             1h 
rm_none  . . . . . . . . . . . .        Number             0h 
rm_num_modes . . . . . . . . . .        Number             5h 
rm_tonearest . . . . . . . . . .        Number             2h 
rm_towardzero  . . . . . . . . .        Number             3h 
rm_upward  . . . . . . . . . . .        Number             4h 
stackreg . . . . . . . . . . . .        DWord              0h *External FASTCALL
stderr . . . . . . . . . . . . .        Near               0h *External FASTCALL
stdin  . . . . . . . . . . . . .        Near               0h *External FASTCALL
stdout . . . . . . . . . . . . .        Near               0h *External FASTCALL
szDgroup . . . . . . . . . . . .        Byte               0h *External FASTCALL
true . . . . . . . . . . . . . .        Number             1h 
wcswcs . . . . . . . . . . . . .        Text   wcsstr
write_to_file  . . . . . . . . .        DWord              0h *External FASTCALL

