Asmc Macro Assembler Version 2.34.33  05/12/23 02:03:24 - First Pass
C:\Asmc\source\tools\dz\lib\stdio\_output.asm
                                ; _OUTPUT.ASM--
                                ;
                                ; Copyright (c) The Asmc Contributors. All rights reserved.
                                ; Consult your license regarding permissions and restrictions.
                                ;

                                include stdio.inc
                              C ifndef __STDIO_INC
 = 0                          C define __STDIO_INC
                              C endif
                                include stdlib.inc
                              C 
                                include limits.inc

 = 200                          BUFFERSIZE      equ 512     ; ANSI-specified minimum is 509

 = 1                            FL_SIGN         equ 0x0001  ; put plus or minus in front
 = 2                            FL_SIGNSP       equ 0x0002  ; put space or minus in front
 = 4                            FL_LEFT         equ 0x0004  ; left justify
 = 8                            FL_LEADZERO     equ 0x0008  ; pad with leading zeros
 = 10                           FL_LONG         equ 0x0010  ; long value given
 = 20                           FL_SHORT        equ 0x0020  ; short value given
 = 40                           FL_SIGNED       equ 0x0040  ; signed data given
 = 80                           FL_ALTERNATE    equ 0x0080  ; alternate form requested
 = 100                          FL_NEGATIVE     equ 0x0100  ; value is negative
 = 200                          FL_FORCEOCTAL   equ 0x0200  ; force leading '0' for octals
 = 400                          FL_LONGDOUBLE   equ 0x0400  ; long double
 = 800                          FL_WIDECHAR     equ 0x0800
 = 1000                         FL_LONGLONG     equ 0x1000  ; long long or REAL16 value given
 = 8000                         FL_I64          equ 0x8000  ; 64-bit value given
 = 10000                        FL_CAPEXP       equ 0x10000

 = 0                            ST_NORMAL       equ 0       ; normal state; outputting literal chars
 = 1                            ST_PERCENT      equ 1       ; just read '%'
 = 2                            ST_FLAG         equ 2       ; just read flag character
 = 3                            ST_WIDTH        equ 3       ; just read width specifier
 = 4                            ST_DOT          equ 4       ; just read '.'
 = 5                            ST_PRECIS       equ 5       ; just read precision specifier
 = 6                            ST_SIZE         equ 6       ; just read size specifier
 = 7                            ST_TYPE         equ 7       ; just read type specifier

                                    .data
00000000                    *   _DATA segment
                            *   assume cs:ERROR

00000000                            __nullstring sbyte "(null)",0,0

00000008                            __lookuptable byte  06h, 00h, 00h, 06h, 00h, 01h, 00h, 00h,10h, 00h, 03h, 06h, 00h, 06h, 02h, 10h,04h, 45h, 45h, 45h, 05h, 05h, 05h, 05h,05h, 35h, 30h, 00h, 50h, 00h, 00h, 00h,00h, 28h, 28h, 38h, 50h, 58h, 07h, 08h,00h, 37h, 30h, 30h, 57h, 50h, 07h, 00h,00h, 20h, 20h, 08h, 00h, 00h, 00h, 00h,08h, 60h, 68h, 60h, 60h, 60h, 60h, 00h,00h, 78h, 78h, 78h, 78h, 78h, 78h, 08h,07h, 08h, 00h, 00h, 07h, 00h, 08h, 08h,08h, 00h, 00h, 08h, 00h, 08h, 00h, 07h,08h                                     ; xyz{|}~  78 58

00000000                            .code
                            *   _DATA ends
00000000                    *   _TEXT segment
                            *   assume cs:FLAT

                                    option proc:private

00000000                        write_char proc char:SINT, fp:LPFILE, pnumwritten:LPDWORD

00000000                    *   push ebp
00000001                    *   mov ebp, esp
00000003                            ldr eax,char
00000003                    *    mov eax,char
00000006                            ldr ecx,fp
00000006                    *    mov ecx,fp
00000009                            ldr edx,pnumwritten
00000009                    *    mov edx,pnumwritten
0000000C                            dec [ecx]._iobuf._cnt
0000000F                            .ifl
0000000F                    *   jge @C0001
00000011                                mov eax,-1
00000016                                mov [edx],eax
00000018                            .else
00000018                    *   jmp @C0002
0000001A                    *   @C0001:
0000001A                                inc dword ptr [edx]
0000001C                                mov edx,[ecx]._iobuf._ptr
0000001E                                inc [ecx]._iobuf._ptr
00000020                                mov [edx],al
00000022                                xor eax,eax
00000024                            .endif
00000024                    *   @C0002:
00000024                            ret
00000024                    *   pop ebp
00000025                    *   retn 12

00000028                        write_char endp

00000028                        write_string proc uses esi edi string:LPSTR, len:UINT, fp:LPFILE, pnumwritten:LPDWORD

00000028                    *   push esi
00000029                    *   push edi
0000002A                    *   push ebp
0000002B                    *   mov ebp, esp
0000002D                            .fors ( esi = string, edi = len : edi > 0 : edi-- )
0000002D                    *   mov esi, string
00000030                    *   mov edi, len
00000033                    *   @C0003:
00000033                    *   cmp edi , 0
00000036                    *   jng @C0005

00000038                                movzx eax,BYTE PTR [esi]
0000003B                                inc esi

0000003C                               .break .ifd ( write_char(eax, fp, pnumwritten) == -1 )
0000003C                    *   invoke write_char, eax, fp, pnumwritten
0000003C                    *    push pnumwritten
0000003F                    *    push fp
00000042                    *    push eax
00000043                    *    call write_char
00000048                    *   cmp eax , -1 
0000004B                    *   jz  @C0005
0000004D                            .endf
0000004D                    *   @C0004:
0000004D                    *   dec edi
0000004E                    *   jmp @C0003
00000050                    *   @C0005:
00000050                            ret
00000050                    *   pop ebp
00000051                    *   pop edi
00000052                    *   pop esi
00000053                    *   retn 16

00000056                        write_string endp

00000056                        write_multi_char proc uses edi char:SINT, num:UINT, fp:LPFILE, pnumwritten:LPDWORD

00000056                    *   push edi
00000057                    *   push ebp
00000058                    *   mov ebp, esp
0000005A                            .fors ( edi = num : edi > 0 : edi-- )
0000005A                    *   mov edi, num
0000005D                    *   @C0006:
0000005D                    *   cmp edi , 0
00000060                    *   jng @C0008

00000062                               .break .ifd ( write_char(char, fp, pnumwritten) == -1 )
00000062                    *   invoke write_char, char, fp, pnumwritten
00000062                    *    push pnumwritten
00000065                    *    push fp
00000068                    *    push char
0000006B                    *    call write_char
00000070                    *   cmp eax , -1 
00000073                    *   jz  @C0008
00000075                            .endf
00000075                    *   @C0007:
00000075                    *   dec edi
00000076                    *   jmp @C0006
00000078                    *   @C0008:
00000078                            ret
00000078                    *   pop ebp
00000079                    *   pop edi
0000007A                    *   retn 16

0000007D                        write_multi_char endp

0000007D                        _output proc public uses esi edi ebx fp:LPFILE, format:LPSTR, arglist:ptr

                                  local charsout            : SINT,hexoff              : UINT,state               : UINT,curadix             : UINT,prefix[2]           : BYTE,textlen             : UINT,prefixlen           : UINT,no_output           : UINT,fldwidth            : UINT,bufferiswide        : UINT,padding             : UINT,text                : LPSTR,buffer[BUFFERSIZE]  : char_t

0000007D                    *   push esi
0000007E                    *   push edi
0000007F                    *   push ebx
00000080                    *   push ebp
00000081                    *   mov ebp, esp
00000083                    *   sub esp, 560
00000089                            mov textlen,0
00000090                            mov charsout,0
00000097                            mov state,0

0000009E                            .while 1
0000009E                    *   @C0009:

0000009E                                mov   eax,format
000000A1                                inc   format
000000A4                                movzx eax,byte ptr [eax]
000000A7                                mov   ecx,eax

000000A9                                .break .if ( !eax || charsout > INT_MAX )
000000A9                    *   test eax , eax 
000000AB                    *   jz  @C000A
000000AD                    *   cmp charsout , INT_MAX 
000000B4                    *   jg  @C000A

000000B6                                lea edx,__lookuptable
000000BC                                .if ( eax >= ' ' && eax <= 'x' )
000000BC                    *   cmp eax , ' ' 
000000BF                    *   jb  @C000B
000000C1                    *   cmp eax , 'x' 
000000C4                    *   ja  @C000B

000000C6                                    mov al,[edx+eax-32]
000000CA                                    and eax,0x0F
000000CD                                .else
000000CD                    *   jmp @C000C
000000CF                    *   @C000B:
000000CF                                    xor eax,eax
000000D1                                .endif
000000D1                    *   @C000C:
000000D1                                shl eax,3
000000D4                                add eax,state
000000D7                                mov al,[edx+eax-32]
000000DB                                shr eax,4
000000DE                                and eax,0x0F
000000E1                                mov state,eax

000000E4                                .if eax <= 7
000000E4                    *   cmp eax , 7
000000E7                    *   ja  @C000D

000000E9                                    .switch eax
000000E9                                    .case ST_NORMAL
000000E9                    *    jmp @C000E
000000EB                    *   @C000F:
000000EB                                        mov bufferiswide,0
000000F2                    *   invoke write_char, ecx, fp, addr charsout
000000F2                    *    lea eax, charsout
000000F5                    *    push eax
000000F6                    *    push fp
000000F9                    *    push ecx
000000FA                    *    call write_char
                                invoke write_char(ecx, fp, addr charsout)
000000FF                                       .endc
000000FF                    *    jmp @C0010
00000101                                    .case ST_PERCENT
00000101                    *   @C0011:
00000101                                        xor eax,eax
00000103                                        mov no_output,eax
00000106                                        mov fldwidth,eax
00000109                                        mov prefixlen,eax
0000010C                                        mov bufferiswide,eax
0000010F                                        xor esi,esi ; flags
00000111                                        mov edi,-1  ; precision
00000116                                       .endc
00000116                    *    jmp @C0010
00000118                                    .case ST_FLAG
00000118                    *   @C0012:
00000118                                        movzx eax,cl
0000011B                                        .switch eax
0000011B                                          .case '+': or esi,FL_SIGN:      .endc ; '+' force sign indicator
0000011B                    *    jmp @C0013
0000011D                    *   @C0014:
0000011D                    *   or esi,FL_SIGN
00000120                    *   .endc
00000120                    *    jmp @C0015
00000122                                          .case ' ': or esi,FL_SIGNSP:    .endc ; ' ' force sign or space
00000122                    *   @C0016:
00000122                    *   or esi,FL_SIGNSP
00000125                    *   .endc
00000125                    *    jmp @C0015
00000127                                          .case '#': or esi,FL_ALTERNATE: .endc ; '#' alternate form
00000127                    *   @C0017:
00000127                    *   or esi,FL_ALTERNATE
0000012D                    *   .endc
0000012D                    *    jmp @C0015
0000012F                                          .case '-': or esi,FL_LEFT:      .endc ; '-' left justify
0000012F                    *   @C0018:
0000012F                    *   or esi,FL_LEFT
00000132                    *   .endc
00000132                    *    jmp @C0015
00000134                                          .case '0': or esi,FL_LEADZERO:  .endc ; '0' pad with leading zeros
00000134                    *   @C0019:
00000134                    *   or esi,FL_LEADZERO
00000137                    *   .endc
00000137                    *    jmp @C0015
00000139                                        .endsw
00000139                    *   @C0013:
00000139                    *    cmp eax, '+'
0000013C                    *    je @C0014
0000013E                    *    cmp eax, ' '
00000141                    *    je @C0016
00000143                    *    cmp eax, '#'
00000146                    *    je @C0017
00000148                    *    cmp eax, '-'
0000014B                    *    je @C0018
0000014D                    *    cmp eax, '0'
00000150                    *    je @C0019
00000152                    *   @C0015:
00000152                                        .endc
00000152                    *    jmp @C0010
00000154                                    .case ST_WIDTH
00000154                    *   @C001A:
00000154                                        .if cl == '*'
00000154                    *   cmp cl , '*'
00000157                    *   jnz @C001B
00000159                                            mov eax,arglist
0000015C                                            add arglist,size_t
00000160                                            mov eax,[eax]
00000162                                            .ifs eax < 0
00000162                    *   cmp eax , 0
00000165                    *   jnl @C001C
00000167                                                or  esi,FL_LEFT
0000016A                                                neg eax
0000016C                                            .endif
0000016C                    *   @C001C:
0000016C                                            mov fldwidth,eax
0000016F                                        .else
0000016F                    *   jmp @C001D
00000171                    *   @C001B:
00000171                                            imul eax,fldwidth,10
00000175                                            add eax,ecx
00000177                                            add eax,-48
0000017A                                            mov fldwidth,eax
0000017D                                        .endif
0000017D                    *   @C001D:
0000017D                                        .endc
0000017D                    *    jmp @C0010
0000017F                                    .case ST_DOT
0000017F                    *   @C001E:
0000017F                                        xor edi,edi
00000181                                       .endc
00000181                    *    jmp @C0010
00000183                                    .case ST_PRECIS
00000183                    *   @C001F:
00000183                                        .if cl == '*'
00000183                    *   cmp cl , '*'
00000186                    *   jnz @C0020
00000188                                            mov eax,arglist
0000018B                                            add arglist,size_t
0000018F                                            mov edi,[eax]
00000191                                            .ifs edi < 0
00000191                    *   cmp edi , 0
00000194                    *   jnl @C0021
00000196                                                mov edi,-1
0000019B                                            .endif
0000019B                    *   @C0021:
0000019B                                        .else
0000019B                    *   jmp @C0022
0000019D                    *   @C0020:
0000019D                                            imul eax,edi,10
000001A0                                            movsx edi,cl
000001A3                                            add edi,eax
000001A5                                            add edi,-48
000001A8                                        .endif
000001A8                    *   @C0022:
000001A8                                        .endc
000001A8                    *    jmp @C0010
000001AA                                    .case ST_SIZE
000001AA                    *   @C0023:
000001AA                                        .switch ecx
000001AA                                        .case 'l'
000001AA                    *    jmp @C0024
000001AC                    *   @C0025:
000001AC                                            .if !( esi & FL_LONG )
000001AC                    *   test esi , FL_LONG 
000001B2                    *   jne @C0026
000001B4                                                or esi,FL_LONG
000001B7                                               .endc
000001B7                    *    jmp @C0027
000001B9                                            .endif
000001B9                    *   @C0026:

                                                    ; case ll => long long

000001B9                                            and esi,NOT FL_LONG
000001BC                                            or  esi,FL_LONGLONG
000001C2                                           .endc
000001C2                    *    jmp @C0027
000001C4                                        .case 'L'
000001C4                    *   @C0028:
000001C4                                            or  esi,FL_LONGDOUBLE or FL_I64
000001CA                                           .endc
000001CA                    *    jmp @C0027
000001CC                                        .case 'I'
000001CC                    *   @C0029:
000001CC                                            mov eax,format
000001CF                                            mov cx,[eax]
000001D2                                            .switch cl
000001D2                                            .case '6'
000001D2                    *    jmp @C002A
000001D4                    *   @C002B:
000001D4                                                .gotosw(2:ST_NORMAL) .if ch != '4'
000001D4                    *   cmp ch , '4'
000001D7                    *   jnz @C000F
000001DD                                                or  esi,FL_I64
000001E3                                                add eax,2
000001E6                                                mov format,eax
000001E9                                               .endc
000001E9                    *    jmp @C002C
000001EB                                            .case '3'
000001EB                    *   @C002D:
000001EB                                                .gotosw(2:ST_NORMAL) .if ch != '2'
000001EB                    *   cmp ch , '2'
000001EE                    *   jnz @C000F
000001F4                                                and esi,not FL_I64
000001FA                                                add eax,2
000001FD                                                mov format,eax
00000200                                               .endc
00000200                    *    jmp @C002C
00000202                                            .case 'd'
00000202                    *   @C002E:
00000202                                            .case 'i'
00000202                    *   @C002F:
00000202                                            .case 'o'
00000202                    *   @C0030:
00000202                                            .case 'u'
00000202                    *   @C0031:
00000202                                            .case 'x'
00000202                    *   @C0032:
00000202                                            .case 'X'
00000202                    *   @C0033:
00000202                                                .endc
00000202                    *    jmp @C002C
00000204                                            .default
00000204                    *   @C0034:
00000204                                                .gotosw(2:ST_NORMAL)
00000204                    *    jmp @C000F
00000209                                            .endsw
00000209                    *   @C002A:
00000209                    *    cmp cl, '6'
0000020C                    *    je @C002B
0000020E                    *    cmp cl, '3'
00000211                    *    je @C002D
00000213                    *    cmp cl, 'd'
00000216                    *    je @C002E
00000218                    *    cmp cl, 'i'
0000021B                    *    je @C002F
0000021D                    *    cmp cl, 'o'
00000220                    *    je @C0030
00000222                    *    cmp cl, 'u'
00000225                    *    je @C0031
00000227                    *    cmp cl, 'x'
0000022A                    *    je @C0032
0000022C                    *    cmp cl, 'X'
0000022F                    *    je @C0033
00000231                    *    jmp @C0034
00000233                    *   @C002C:
00000233                                            .endc
00000233                    *    jmp @C0027

00000235                                        .case 'h'
00000235                    *   @C0035:
00000235                                            or esi,FL_SHORT
00000238                                           .endc
00000238                    *    jmp @C0027
0000023A                                        .case 'w'
0000023A                    *   @C0036:
0000023A                                            or esi,FL_WIDECHAR  ; 'w' => wide character
00000240                                           .endc
00000240                    *    jmp @C0027
00000242                                        .endsw
00000245                    *   @C0024:
00000245                    *    cmp ecx, 'l'
00000248                    *    je @C0025
0000024E                    *    cmp ecx, 'L'
00000251                    *    je @C0028
00000257                    *    cmp ecx, 'I'
0000025A                    *    je @C0029
00000260                    *    cmp ecx, 'h'
00000263                    *    je @C0035
00000265                    *    cmp ecx, 'w'
00000268                    *    je @C0036
00000273                    *   @C0027:
00000273                                        .endc
00000273                    *    jmp @C0010

00000275                                    .case ST_TYPE
00000275                    *   @C0037:
00000275                                        mov eax,ecx
00000277                                        .switch eax
00000277                                        .case 'b'
00000277                    *    jmp @C0038
00000279                    *   @C0039:
00000279                                            mov eax,arglist
0000027C                                            add arglist,size_t
00000280                                            mov edx,[eax]
00000282                                            xor ecx,ecx
00000284                                            bsr ecx,edx
00000287                                            inc ecx
00000288                                            mov textlen,ecx
0000028B                                            .repeat
0000028B                    *   @C003A:
0000028B                                                sub eax,eax
0000028D                                                shr edx,1
0000028F                                                adc al,'0'
00000291                                                mov buffer[ecx-1],al
00000298                                            .untilcxz
00000298                    *    dec ecx
00000299                    *    jnz @C003A
0000029B                                            lea eax,buffer
000002A1                                            mov text,eax
000002A4                                           .endc
000002A4                    *    jmp @C003B
000002A6                                        .case 'C'
000002A6                    *   @C003C:
000002A6                                            .if !( esi & ( FL_SHORT or FL_LONG or FL_WIDECHAR ) )
000002A6                    *   test esi , ( FL_SHORT or FL_LONG or FL_WIDECHAR ) 
000002AC                    *   jne @C003D

000002AE                                                or esi,FL_WIDECHAR ; ISO std.
000002B4                                            .endif
000002B4                    *   @C003D:
000002B4                                        .case 'c'
000002B4                    *   @C003E:
000002B4                                            mov bufferiswide,1
000002BB                                            mov eax,arglist
000002BE                                            add arglist,size_t
000002C2                                            mov edx,[eax]
000002C4                                            mov buffer,dl
000002CA                                            mov textlen,1 ; print just a single character
000002D1                                            lea eax,buffer
000002D7                                            mov text,eax
000002DA                                           .endc
000002DA                    *    jmp @C003B
000002DC                                        .case 'S' ; ISO wide character string
000002DC                    *   @C003F:
000002DC                                            .if !( esi & ( FL_SHORT or FL_LONG or FL_WIDECHAR ) )
000002DC                    *   test esi , ( FL_SHORT or FL_LONG or FL_WIDECHAR ) 
000002E2                    *   jne @C0040
000002E4                                                or esi,FL_WIDECHAR
000002EA                                            .endif
000002EA                    *   @C0040:
000002EA                                        .case 's'
000002EA                    *   @C0041:
000002EA                                            mov eax,arglist
000002ED                                            add arglist,size_t
000002F1                                            mov eax,[eax]
000002F3                                            mov ecx,edi
000002F5                                            .if edi == -1
000002F5                    *   cmp edi , -1
000002F8                    *   jnz @C0042
000002FA                                                mov ecx,INT_MAX
000002FF                                            .endif
000002FF                    *   @C0042:
000002FF                                            .if eax == NULL
000002FF                    *   test eax , eax 
00000301                    *   jnz @C0043
00000303                                                lea eax,__nullstring
00000309                                            .endif
00000309                    *   @C0043:
00000309                                            mov text,eax
0000030C                                            .repeat
0000030C                    *   @C0044:
0000030C                                                .break .if BYTE PTR [eax] == 0
0000030C                    *   cmp BYTE PTR [eax] , 0
0000030F                    *   jz  @C0045
00000311                                                inc eax
00000312                                            .untilcxz
00000312                    *    dec ecx
00000313                    *    jnz @C0044
00000315                    *   @C0045:
00000315                                            sub eax,text
00000318                                            mov textlen,eax
0000031B                                           .endc
0000031B                    *    jmp @C003B
0000031D                                        .case 'n'
0000031D                    *   @C0046:
0000031D                                            mov eax,arglist
00000320                                            add arglist,size_t
00000324                                            mov edx,[eax-size_t]
00000327                                            mov eax,charsout
0000032A                                            mov [edx],eax
0000032C                                            .if esi & FL_LONG
0000032C                    *   test esi , FL_LONG
00000332                    *   je  @C0047
00000334                                                mov no_output,1
0000033B                                            .endif
0000033B                    *   @C0047:
0000033B                                            .endc
0000033B                    *    jmp @C003B
0000033D                                        .case 'd'
0000033D                    *   @C0048:
0000033D                                        .case 'i' ; signed decimal output
0000033D                    *   @C0049:
0000033D                                            or  esi,FL_SIGNED
00000340                                        .case 'u'
00000340                    *   @C004A:
00000340                                            mov curadix,10
00000347                                            jmp COMMON_INT
00000349                                        .case 'p'
00000349                    *   @C004B:
00000349                                            mov edi,size_t * 2
0000034E                                        .case 'X'
0000034E                    *   @C004C:
0000034E                                            mov hexoff,'A'-'9'-1
00000355                                            jmp COMMON_HEX
00000357                                        .case 'x'
00000357                    *   @C004D:
00000357                                            mov hexoff,'a'-'9'-1

0000035E                                            COMMON_HEX:

0000035E                                            mov curadix,16
00000365                                            .if esi & FL_ALTERNATE
00000365                    *   test esi , FL_ALTERNATE
0000036B                    *   je  @C004E
0000036D                                                mov eax,'x' - 'a' + '9' + 1
00000372                                                add eax,hexoff
00000375                                                mov prefix,'0'
00000379                                                mov prefix[1],al
0000037C                                                mov prefixlen,2
00000383                                            .endif
00000383                    *   @C004E:
00000383                                            jmp COMMON_INT
00000385                                        .case 'o'
00000385                    *   @C004F:
00000385                                            mov curadix,8
0000038C                                            .if esi & FL_ALTERNATE
0000038C                    *   test esi , FL_ALTERNATE
00000392                    *   je  @C0050
00000394                                                or esi,FL_FORCEOCTAL
0000039A                                            .endif
0000039A                    *   @C0050:

0000039A                                           COMMON_INT:

0000039A                                            mov ecx,arglist
0000039D                                            mov eax,[ecx]
0000039F                                            xor edx,edx
000003A1                                            .if esi & ( FL_I64 or FL_LONGLONG )
000003A1                    *   test esi , ( FL_I64 or FL_LONGLONG )
000003A7                    *   je  @C0051
000003A9                                                mov edx,[edx+4]
                                ifndef _WIN64
000003AC                                                add ecx,size_t
                                endif
000003AF                                            .endif
000003AF                    *   @C0051:
000003AF                                            add ecx,size_t
000003B2                                            mov arglist,ecx
000003B5                                            .if esi & FL_SHORT
000003B5                    *   test esi , FL_SHORT
000003BB                    *   je  @C0052
000003BD                                                .if esi & FL_SIGNED
000003BD                    *   test esi , FL_SIGNED
000003C3                    *   je  @C0053
000003C5                                                    movsx eax,ax
000003C8                                                .else
000003C8                    *   jmp @C0054
000003CA                    *   @C0053:
000003CA                                                    movzx eax,ax
000003CD                                                .endif
000003CD                    *   @C0054:
000003CD                                            .elseif esi & FL_SIGNED
000003CD                    *   jmp @C0055
000003CF                    *   @C0052:
000003CF                    *   test esi , FL_SIGNED
000003D5                    *   je  @C0056
000003D7                                                .if esi & FL_LONGLONG or FL_I64
000003D7                    *   test esi , FL_LONGLONG or FL_I64
000003DD                    *   je  @C0057
000003DF                                                    .ifs edx < 0
000003DF                    *   cmp edx , 0
000003E2                    *   jnl @C0058
000003E4                                                        or  esi,FL_NEGATIVE
000003EA                                                    .endif
000003EA                    *   @C0058:
000003EA                                                .else
000003EA                    *   jmp @C0059
000003EC                    *   @C0057:
000003EC                                                    .ifs eax < 0
000003EC                    *   cmp eax , 0
000003EF                    *   jnl @C005A
000003F1                                                        dec edx
000003F2                                                        or  esi,FL_NEGATIVE
000003F8                                                    .endif
000003F8                    *   @C005A:
000003F8                                                .endif
000003F8                    *   @C0059:
000003F8                                            .endif
000003F8                    *   @C0056:
000003F8                    *   @C0055:
000003F8                                            .ifs edi < 0
000003F8                    *   cmp edi , 0
000003FB                    *   jnl @C005B
000003FD                                                mov edi,1
00000402                                            .else
00000402                    *   jmp @C005C
00000404                    *   @C005B:
00000404                                                and esi,NOT FL_LEADZERO
00000407                                            .endif
00000407                    *   @C005C:
00000407                                            mov ecx,eax
00000409                                            or  ecx,edx
0000040B                                            .ifz
0000040B                    *   jne @C005D
0000040D                                                mov prefixlen,eax
00000410                                            .endif
00000410                    *   @C005D:
00000410                                            .if esi & FL_SIGNED
00000410                    *   test esi , FL_SIGNED
00000416                    *   je  @C005E
00000418                                                test edx,edx
0000041A                                                .ifs
0000041A                    *   jns @C005F
0000041C                                                    neg eax
0000041E                                                    neg edx
00000420                                                    sbb edx,0
00000423                                                    or  esi,FL_NEGATIVE
00000429                                                .endif
00000429                    *   @C005F:
00000429                                            .endif
00000429                    *   @C005E:

00000429                                            lea ebx,buffer[BUFFERSIZE-1]
                                ifdef _WIN64
                                else
0000042C                                            .fors ( : eax || edx || edi > 0 : edi-- )
0000042C                    *   @C0060:
0000042C                    *   test eax , eax 
0000042E                    *   jnz @C0063
00000430                    *   @C0064:
00000430                    *   test edx , edx 
00000432                    *   jnz @C0063
00000434                    *   @C0065:
00000434                    *   cmp edi , 0
00000437                    *   jng @C0062
00000439                    *   @C0063:
00000439                                                .if ( !edx || !curadix )
00000439                    *   test edx , edx 
0000043B                    *   jz  @C0067
0000043D                    *   @C0068:
0000043D                    *   cmp curadix , 0
00000441                    *   jnz @C0066
00000443                    *   @C0067:
00000443                                                    div curadix
00000446                                                    mov ecx,edx
00000448                                                    xor edx,edx
0000044A                                                .else
0000044A                    *   jmp @C0069
0000044C                    *   @C0066:
0000044C                                                    push esi
0000044D                                                    push edi
0000044E                                                    .for ( ecx = 64, esi = 0, edi = 0 : ecx : ecx-- )
0000044E                    *   mov ecx, 64
00000453                    *   xor esi, esi
00000455                    *   xor edi, edi
00000457                    *   @C006A:
00000457                    *   test ecx, ecx
00000459                    *   jz  @C006C
0000045B                                                        add eax,eax
0000045D                                                        adc edx,edx
0000045F                                                        adc esi,esi
00000461                                                        adc edi,edi
00000463                                                        .if ( edi || esi >= curadix )
00000463                    *   test edi , edi 
00000465                    *   jnz @C006E
00000467                    *   @C006F:
00000467                    *   cmp esi , curadix 
0000046A                    *   jb  @C006D
0000046C                    *   @C006E:
0000046C                                                            sub esi,curadix
0000046F                                                            sbb edi,0
00000472                                                            inc eax
00000473                                                        .endif
00000473                    *   @C006D:
00000473                                                    .endf
00000473                    *   @C006B:
00000473                    *   dec ecx
00000474                    *   jmp @C006A
00000476                    *   @C006C:
00000476                                                    mov ecx,esi
00000478                                                    pop edi
00000479                                                    pop esi
0000047A                                                .endif
0000047A                    *   @C0069:
0000047A                                                add ecx,'0'
0000047D                                                .ifs ( ecx > '9' )
0000047D                    *   cmp ecx , '9' 
00000480                    *   jng @C0070
00000482                                                    add ecx,hexoff
00000485                                                .endif
00000485                    *   @C0070:
00000485                                                mov [ebx],cl
00000487                                                dec ebx
00000488                                            .endf
00000488                    *   @C0061:
00000488                    *   dec edi
00000489                    *   jmp @C0060
0000048B                    *   @C0062:
                                endif
0000048B                                            lea eax,buffer[BUFFERSIZE-1]
0000048E                                            sub eax,ebx
00000490                                            add ebx,1

00000493                                            .if esi & FL_FORCEOCTAL
00000493                    *   test esi , FL_FORCEOCTAL
00000499                    *   je  @C0071

0000049B                                                .if byte ptr [ebx] != '0' || eax == 0
0000049B                    *   cmp byte ptr [ebx] , '0' 
0000049E                    *   jnz @C0073
000004A0                    *   @C0074:
000004A0                    *   test eax , eax 
000004A2                    *   jnz @C0072
000004A4                    *   @C0073:

000004A4                                                    dec ebx
000004A5                                                    mov byte ptr [ebx],'0'
000004A8                                                    inc eax
000004A9                                                .endif
000004A9                    *   @C0072:
000004A9                                            .endif
000004A9                    *   @C0071:
000004A9                                            mov text,ebx
000004AC                                            mov textlen,eax
000004AF                                           .endc
000004AF                    *    jmp @C003B
000004B1                                        .endsw
000004B4                    *   @C0038:
000004B4                    *    cmp eax, 'b'
000004B7                    *    je @C0039
000004BD                    *    cmp eax, 'C'
000004C0                    *    je @C003C
000004C6                    *    cmp eax, 'c'
000004C9                    *    je @C003E
000004CF                    *    cmp eax, 'S'
000004D2                    *    je @C003F
000004D8                    *    cmp eax, 's'
000004DB                    *    je @C0041
000004E1                    *    cmp eax, 'n'
000004E4                    *    je @C0046
000004EA                    *    cmp eax, 'd'
000004ED                    *    je @C0048
000004F3                    *    cmp eax, 'i'
000004F6                    *    je @C0049
000004FC                    *    cmp eax, 'u'
000004FF                    *    je @C004A
00000505                    *    cmp eax, 'p'
00000508                    *    je @C004B
0000050E                    *    cmp eax, 'X'
00000511                    *    je @C004C
00000517                    *    cmp eax, 'x'
0000051A                    *    je @C004D
00000520                    *    cmp eax, 'o'
00000523                    *    je @C004F
00000535                    *   @C003B:

00000535                                        .if !no_output
00000535                    *   cmp no_output, 0
00000539                    *   jnz @C0075
0000053B                                            .if esi & FL_SIGNED
0000053B                    *   test esi , FL_SIGNED
00000541                    *   je  @C0076
00000543                                                .if esi & FL_NEGATIVE
00000543                    *   test esi , FL_NEGATIVE
00000549                    *   je  @C0077
0000054B                                                    mov prefix,'-'
0000054F                                                    mov prefixlen,1
00000556                                                .elseif esi & FL_SIGN
00000556                    *   jmp @C0078
00000558                    *   @C0077:
00000558                    *   test esi , FL_SIGN
0000055E                    *   je  @C0079
00000560                                                    mov prefix,'+'
00000564                                                    mov prefixlen,1
0000056B                                                .elseif esi & FL_SIGNSP
0000056B                    *   jmp @C0078
0000056D                    *   @C0079:
0000056D                    *   test esi , FL_SIGNSP
00000573                    *   je  @C007A
00000575                                                    mov prefix,' '
00000579                                                    mov prefixlen,1
00000580                                                .endif
00000580                    *   @C007A:
00000580                    *   @C0078:
00000580                                            .endif
00000580                    *   @C0076:
00000580                                            mov eax,fldwidth
00000583                                            sub eax,textlen
00000586                                            sub eax,prefixlen
00000589                                            mov padding,eax
0000058C                                            .if !( esi & ( FL_LEFT or FL_LEADZERO ) )
0000058C                    *   test esi , ( FL_LEFT or FL_LEADZERO ) 
00000592                    *   jne @C007B
00000594                    *   invoke write_multi_char, ' ', padding, fp, addr charsout
00000594                    *    lea eax, charsout
00000597                    *    push eax
00000598                    *    push fp
0000059B                    *    push padding
0000059E                    *    push ' '
000005A0                    *    call write_multi_char
                                invoke write_multi_char(' ', padding, fp, &charsout)
000005A5                                            .endif
000005A5                    *   @C007B:
000005A5                    *   invoke write_string, addr prefix, prefixlen, fp, addr charsout
000005A5                    *    lea eax, charsout
000005A8                    *    push eax
000005A9                    *    push fp
000005AC                    *    push prefixlen
000005AF                    *    lea eax, prefix
000005B2                    *    push eax
000005B3                    *    call write_string
                                invoke write_string(&prefix, prefixlen, fp, &charsout)
000005B8                                            .if ( ( esi & FL_LEADZERO ) && !( esi & FL_LEFT ) )
000005B8                    *   test esi , FL_LEADZERO 
000005BE                    *   je  @C007C
000005C0                    *   test esi , FL_LEFT 
000005C6                    *   jne @C007C
000005C8                    *   invoke write_multi_char, '0', padding, fp, addr charsout
000005C8                    *    lea eax, charsout
000005CB                    *    push eax
000005CC                    *    push fp
000005CF                    *    push padding
000005D2                    *    push '0'
000005D4                    *    call write_multi_char
                                invoke write_multi_char('0', padding, fp, &charsout)
000005D9                                            .endif
000005D9                    *   @C007C:
000005D9                    *   invoke write_string, text, textlen, fp, addr charsout
000005D9                    *    lea eax, charsout
000005DC                    *    push eax
000005DD                    *    push fp
000005E0                    *    push textlen
000005E3                    *    push text
000005E6                    *    call write_string
                                invoke write_string(text, textlen, fp, &charsout)
000005EB                                            .if esi & FL_LEFT
000005EB                    *   test esi , FL_LEFT
000005F1                    *   je  @C007D
000005F3                    *   invoke write_multi_char, ' ', padding, fp, addr charsout
000005F3                    *    lea eax, charsout
000005F6                    *    push eax
000005F7                    *    push fp
000005FA                    *    push padding
000005FD                    *    push ' '
000005FF                    *    call write_multi_char
                                invoke write_multi_char(' ', padding, fp, &charsout)
00000604                                            .endif
00000604                    *   @C007D:
00000604                                        .endif
00000608                    *   @C0075:
00000608                                        .endc
00000608                    *    jmp @C0010
0000060A                                    .endsw
0000060D                    *   @C000E:
0000060D                    *    cmp eax,0
00000610                    *    jl  @C0010
00000612                    *    cmp eax,7
00000615                    *    jg  @C0010
00000617                    *    jmp [eax*4+@C007E-(0*4)]
0000061E                    *   ALIGN dword
00000620                    *   @C007E:
00000620                    *    dword @C000F
00000624                    *    dword @C0011
00000628                    *    dword @C0012
0000062C                    *    dword @C001A
00000630                    *    dword @C001E
00000634                    *    dword @C001F
00000638                    *    dword @C0023
0000063C                    *    dword @C0037
00000640                    *   @C0010:
00000640                                .endif
00000640                    *   @C000D:
00000640                            .endw
00000640                    *   jmp @C0009
00000645                    *   @C000A:
00000645                            mov eax,charsout ; return value = number of characters written
00000648                            ret
00000648                    *   mov esp, ebp
0000064A                    *   pop ebp
0000064B                    *   pop ebx
0000064C                    *   pop edi
0000064D                    *   pop esi
0000064E                    *   retn 12

00000651                        _output endp

                                    end
                            *   _TEXT ends

Asmc Macro Assembler Version 2.34.33  05/12/23 02:03:24
C:\Asmc\source\tools\dz\lib\stdio\_output.asm

 = 200                          BUFFERSIZE      equ 512
 = 1                            FL_SIGN         equ 0x0001
 = 2                            FL_SIGNSP       equ 0x0002
 = 4                            FL_LEFT         equ 0x0004
 = 8                            FL_LEADZERO     equ 0x0008
 = 10                           FL_LONG         equ 0x0010
 = 20                           FL_SHORT        equ 0x0020
 = 40                           FL_SIGNED       equ 0x0040
 = 80                           FL_ALTERNATE    equ 0x0080
 = 100                          FL_NEGATIVE     equ 0x0100
 = 200                          FL_FORCEOCTAL   equ 0x0200
 = 400                          FL_LONGDOUBLE   equ 0x0400
 = 800                          FL_WIDECHAR     equ 0x0800
 = 1000                         FL_LONGLONG     equ 0x1000
 = 8000                         FL_I64          equ 0x8000
 = 10000                        FL_CAPEXP       equ 0x10000
 = 0                            ST_NORMAL       equ 0
 = 1                            ST_PERCENT      equ 1
 = 2                            ST_FLAG         equ 2
 = 3                            ST_WIDTH        equ 3
 = 4                            ST_DOT          equ 4
 = 5                            ST_PRECIS       equ 5
 = 6                            ST_SIZE         equ 6
 = 7                            ST_TYPE         equ 7
                                    .data
00000000                    *   _DATA segment
                            *   assume cs:ERROR
00000000  286E756C6C290000          __nullstring sbyte "(null)",0,0
00000008  060000060001000010        __lookuptable byte  06h, 00h, 00h, 06h, 00h, 01h, 00h, 00h,10h, 00h, 03h, 06h, 00h, 06h, 02h, 10h,04h, 45h, 45h, 45h, 05h, 05h, 05h, 05h,05h, 35h, 30h, 00h, 50h, 00h, 00h, 00h,00h, 28h, 28h, 38h, 50h, 58h, 07h, 08h,00h, 37h, 30h, 30h, 57h, 50h, 07h, 00h,00h, 20h, 20h, 08h, 00h, 00h, 00h, 00h,08h, 60h, 68h, 60h, 60h, 60h, 60h, 00h,00h, 78h, 78h, 78h, 78h, 78h, 78h, 08h,07h, 08h, 00h, 00h, 07h, 00h, 08h, 08h,08h, 00h, 00h, 08h, 00h, 08h, 00h, 07h,08h
00000000                            .code
00000061                    *   _DATA ends
00000000                    *   _TEXT segment
                            *   assume cs:FLAT
00000000                        write_char proc char:SINT, fp:LPFILE, pnumwritten:LPDWORD
00000000  55                *   push ebp
00000001  8BEC              *   mov ebp, esp
00000003                            ldr eax,char
00000003  8B4508            *    mov eax,char
00000006                            ldr ecx,fp
00000006  8B4D0C            *    mov ecx,fp
00000009                            ldr edx,pnumwritten
00000009  8B5510            *    mov edx,pnumwritten
0000000C  FF4904                    dec [ecx]._iobuf._cnt
0000000F                            .ifl
0000000F  7D09              *   jge @C0001
00000011  B8FFFFFFFF                    mov eax,-1
00000016  8902                          mov [edx],eax
00000018                            .else
00000018  EB0A              *   jmp @C0002
0000001A                    *   @C0001:
0000001A  FF02                          inc dword ptr [edx]
0000001C  8B11                          mov edx,[ecx]._iobuf._ptr
0000001E  FF01                          inc [ecx]._iobuf._ptr
00000020  8802                          mov [edx],al
00000022  33C0                          xor eax,eax
00000024                            .endif
00000024                    *   @C0002:
00000024                            ret
00000024  5D                *   pop ebp
00000025  C20C00            *   retn 12
00000028                        write_char endp
00000028                        write_string proc uses esi edi string:LPSTR, len:UINT, fp:LPFILE, pnumwritten:LPDWORD
00000028  56                *   push esi
00000029  57                *   push edi
0000002A  55                *   push ebp
0000002B  8BEC              *   mov ebp, esp
0000002D                            .fors ( esi = string, edi = len : edi > 0 : edi-- )
0000002D  8B7510            *   mov esi, string
00000030  8B7D14            *   mov edi, len
00000033                    *   @C0003:
00000033  83FF00            *   cmp edi , 0
00000036  7E18              *   jng @C0005
00000038  0FB606                        movzx eax,BYTE PTR [esi]
0000003B  46                            inc esi
0000003C                               .break .ifd ( write_char(eax, fp, pnumwritten) == -1 )
0000003C                    *   invoke write_char, eax, fp, pnumwritten
0000003C  FF751C            *    push pnumwritten
0000003F  FF7518            *    push fp
00000042  50                *    push eax
00000043  E8B8FFFFFF        *    call write_char
00000048  83F8FF            *   cmp eax , -1 
0000004B  7403              *   jz  @C0005
0000004D                            .endf
0000004D                    *   @C0004:
0000004D  4F                *   dec edi
0000004E  EBE3              *   jmp @C0003
00000050                    *   @C0005:
00000050                            ret
00000050  5D                *   pop ebp
00000051  5F                *   pop edi
00000052  5E                *   pop esi
00000053  C21000            *   retn 16
00000056                        write_string endp
00000056                        write_multi_char proc uses edi char:SINT, num:UINT, fp:LPFILE, pnumwritten:LPDWORD
00000056  57                *   push edi
00000057  55                *   push ebp
00000058  8BEC              *   mov ebp, esp
0000005A                            .fors ( edi = num : edi > 0 : edi-- )
0000005A  8B7D10            *   mov edi, num
0000005D                    *   @C0006:
0000005D  83FF00            *   cmp edi , 0
00000060  7E16              *   jng @C0008
00000062                               .break .ifd ( write_char(char, fp, pnumwritten) == -1 )
00000062                    *   invoke write_char, char, fp, pnumwritten
00000062  FF7518            *    push pnumwritten
00000065  FF7514            *    push fp
00000068  FF750C            *    push char
0000006B  E890FFFFFF        *    call write_char
00000070  83F8FF            *   cmp eax , -1 
00000073  7403              *   jz  @C0008
00000075                            .endf
00000075                    *   @C0007:
00000075  4F                *   dec edi
00000076  EBE5              *   jmp @C0006
00000078                    *   @C0008:
00000078                            ret
00000078  5D                *   pop ebp
00000079  5F                *   pop edi
0000007A  C21000            *   retn 16
0000007D                        write_multi_char endp
0000007D                        _output proc public uses esi edi ebx fp:LPFILE, format:LPSTR, arglist:ptr
0000007D  56                *   push esi
0000007E  57                *   push edi
0000007F  53                *   push ebx
00000080  55                *   push ebp
00000081  8BEC              *   mov ebp, esp
00000083  81EC30020000      *   sub esp, 560
00000089  C745E800000000            mov textlen,0
00000090  C745FC00000000            mov charsout,0
00000097  C745F400000000            mov state,0
0000009E                            .while 1
0000009E                    *   @C0009:
0000009E  8B4518                        mov   eax,format
000000A1  FF4518                        inc   format
000000A4  0FB600                        movzx eax,byte ptr [eax]
000000A7  8BC8                          mov   ecx,eax
000000A9                                .break .if ( !eax || charsout > INT_MAX )
000000A9  85C0              *   test eax , eax 
000000AB  0F84B4050000      *   jz  @C000A
000000B1  817DFCFFFFFF7F    *   cmp charsout , INT_MAX 
000000B8  0F8FA7050000      *   jg  @C000A
000000BE  8D1500000000                  lea edx,__lookuptable
000000C4                                .if ( eax >= ' ' && eax <= 'x' )
000000C4  83F820            *   cmp eax , ' ' 
000000C7  720E              *   jb  @C000B
000000C9  83F878            *   cmp eax , 'x' 
000000CC  7709              *   ja  @C000B
000000CE  8A4402E0                          mov al,[edx+eax-32]
000000D2  83E00F                            and eax,0x0F
000000D5                                .else
000000D5  EB02              *   jmp @C000C
000000D7                    *   @C000B:
000000D7  33C0                              xor eax,eax
000000D9                                .endif
000000D9                    *   @C000C:
000000D9  C1E003                        shl eax,3
000000DC  0345F4                        add eax,state
000000DF  8A4402E0                      mov al,[edx+eax-32]
000000E3  C1E804                        shr eax,4
000000E6  83E00F                        and eax,0x0F
000000E9  8945F4                        mov state,eax
000000EC                                .if eax <= 7
000000EC  83F807            *   cmp eax , 7
000000EF  0F876B050000      *   ja  @C000D
000000F5                                    .switch eax
000000F5                                    .case ST_NORMAL
000000F5  E934050000        *    jmp @C000E
000000FA                    *   @C000F:
000000FA  C745D800000000                        mov bufferiswide,0
00000101                    *   invoke write_char, ecx, fp, addr charsout
00000101  8D45FC            *    lea eax, charsout
00000104  50                *    push eax
00000105  FF7514            *    push fp
00000108  51                *    push ecx
00000109  E8F2FEFFFF        *    call write_char
0000010E                                       .endc
0000010E  E94D050000        *    jmp @C0010
00000113                                    .case ST_PERCENT
00000113                    *   @C0011:
00000113  33C0                                  xor eax,eax
00000115  8945E0                                mov no_output,eax
00000118  8945DC                                mov fldwidth,eax
0000011B  8945E4                                mov prefixlen,eax
0000011E  8945D8                                mov bufferiswide,eax
00000121  33F6                                  xor esi,esi
00000123  BFFFFFFFFF                            mov edi,-1
00000128                                       .endc
00000128  E933050000        *    jmp @C0010
0000012D                                    .case ST_FLAG
0000012D                    *   @C0012:
0000012D  0FB6C1                                movzx eax,cl
00000130                                        .switch eax
00000130                                          .case '+': or esi,FL_SIGN:      .endc;; '+' force sign indicator
00000130  EB1C              *    jmp @C0013
00000132                    *   @C0014:
00000132  83CE01            *   or esi,FL_SIGN
00000135                    *   .endc
00000135  EB30              *    jmp @C0015
00000137                                          .case ' ': or esi,FL_SIGNSP:    .endc;; ' ' force sign or space
00000137                    *   @C0016:
00000137  83CE02            *   or esi,FL_SIGNSP
0000013A                    *   .endc
0000013A  EB2B              *    jmp @C0015
0000013C                                          .case '#': or esi,FL_ALTERNATE: .endc;; '#' alternate form
0000013C                    *   @C0017:
0000013C  81CE80000000      *   or esi,FL_ALTERNATE
00000142                    *   .endc
00000142  EB23              *    jmp @C0015
00000144                                          .case '-': or esi,FL_LEFT:      .endc;; '-' left justify
00000144                    *   @C0018:
00000144  83CE04            *   or esi,FL_LEFT
00000147                    *   .endc
00000147  EB1E              *    jmp @C0015
00000149                                          .case '0': or esi,FL_LEADZERO:  .endc;; '0' pad with leading zeros
00000149                    *   @C0019:
00000149  83CE08            *   or esi,FL_LEADZERO
0000014C                    *   .endc
0000014C  EB19              *    jmp @C0015
0000014E                                        .endsw
0000014E                    *   @C0013:
0000014E  83F82B            *    cmp eax, '+'
00000151  74DF              *    je @C0014
00000153  83F820            *    cmp eax, ' '
00000156  74DF              *    je @C0016
00000158  83F823            *    cmp eax, '#'
0000015B  74DF              *    je @C0017
0000015D  83F82D            *    cmp eax, '-'
00000160  74E2              *    je @C0018
00000162  83F830            *    cmp eax, '0'
00000165  74E2              *    je @C0019
00000167                    *   @C0015:
00000167                                        .endc
00000167  E9F4040000        *    jmp @C0010
0000016C                                    .case ST_WIDTH
0000016C                    *   @C001A:
0000016C                                        .if cl == '*'
0000016C  80F92A            *   cmp cl , '*'
0000016F  7518              *   jnz @C001B
00000171  8B451C                                    mov eax,arglist
00000174  83451C04                                  add arglist,size_t
00000178  8B00                                      mov eax,[eax]
0000017A                                            .ifs eax < 0
0000017A  83F800            *   cmp eax , 0
0000017D  7D05              *   jnl @C001C
0000017F  83CE04                                        or  esi,FL_LEFT
00000182  F7D8                                          neg eax
00000184                                            .endif
00000184                    *   @C001C:
00000184  8945DC                                    mov fldwidth,eax
00000187                                        .else
00000187  EB0C              *   jmp @C001D
00000189                    *   @C001B:
00000189  6B45DC0A                                  imul eax,fldwidth,10
0000018D  03C1                                      add eax,ecx
0000018F  83C0D0                                    add eax,-48
00000192  8945DC                                    mov fldwidth,eax
00000195                                        .endif
00000195                    *   @C001D:
00000195                                        .endc
00000195  E9C6040000        *    jmp @C0010
0000019A                                    .case ST_DOT
0000019A                    *   @C001E:
0000019A  33FF                                  xor edi,edi
0000019C                                       .endc
0000019C  E9BF040000        *    jmp @C0010
000001A1                                    .case ST_PRECIS
000001A1                    *   @C001F:
000001A1                                        .if cl == '*'
000001A1  80F92A            *   cmp cl , '*'
000001A4  7515              *   jnz @C0020
000001A6  8B451C                                    mov eax,arglist
000001A9  83451C04                                  add arglist,size_t
000001AD  8B38                                      mov edi,[eax]
000001AF                                            .ifs edi < 0
000001AF  83FF00            *   cmp edi , 0
000001B2  7D05              *   jnl @C0021
000001B4  BFFFFFFFFF                                    mov edi,-1
000001B9                                            .endif
000001B9                    *   @C0021:
000001B9                                        .else
000001B9  EB0B              *   jmp @C0022
000001BB                    *   @C0020:
000001BB  6BC70A                                    imul eax,edi,10
000001BE  0FBEF9                                    movsx edi,cl
000001C1  03F8                                      add edi,eax
000001C3  83C7D0                                    add edi,-48
000001C6                                        .endif
000001C6                    *   @C0022:
000001C6                                        .endc
000001C6  E995040000        *    jmp @C0010
000001CB                                    .case ST_SIZE
000001CB                    *   @C0023:
000001CB                                        .switch ecx
000001CB                                        .case 'l'
000001CB  E99F000000        *    jmp @C0024
000001D0                    *   @C0025:
000001D0                                            .if !( esi & FL_LONG )
000001D0  F7C610000000      *   test esi , FL_LONG 
000001D6  7508              *   jne @C0026
000001D8  83CE10                                        or esi,FL_LONG
000001DB                                               .endc
000001DB  E9B4000000        *    jmp @C0027
000001E0                                            .endif
000001E0                    *   @C0026:
000001E0  83E6EF                                    and esi,NOT FL_LONG
000001E3  81CE00100000                              or  esi,FL_LONGLONG
000001E9                                           .endc
000001E9  E9A6000000        *    jmp @C0027
000001EE                                        .case 'L'
000001EE                    *   @C0028:
000001EE  81CE00840000                              or  esi,FL_LONGDOUBLE or FL_I64
000001F4                                           .endc
000001F4  E99B000000        *    jmp @C0027
000001F9                                        .case 'I'
000001F9                    *   @C0029:
000001F9  8B4518                                    mov eax,format
000001FC  668B08                                    mov cx,[eax]
000001FF                                            .switch cl
000001FF                                            .case '6'
000001FF  EB35              *    jmp @C002A
00000201                    *   @C002B:
00000201                                                .gotosw(2:ST_NORMAL) .if ch != '4'
00000201  80FD34            *   cmp ch , '4'
00000204  0F85F0FEFFFF      *   jnz @C000F
0000020A  81CE00800000                                  or  esi,FL_I64
00000210  83C002                                        add eax,2
00000213  894518                                        mov format,eax
00000216                                               .endc
00000216  EB48              *    jmp @C002C
00000218                                            .case '3'
00000218                    *   @C002D:
00000218                                                .gotosw(2:ST_NORMAL) .if ch != '2'
00000218  80FD32            *   cmp ch , '2'
0000021B  0F85D9FEFFFF      *   jnz @C000F
00000221  81E6FF7FFFFF                                  and esi,not FL_I64
00000227  83C002                                        add eax,2
0000022A  894518                                        mov format,eax
0000022D                                               .endc
0000022D  EB31              *    jmp @C002C
0000022F                                            .case 'd'
0000022F                    *   @C002E:
0000022F                                            .case 'i'
0000022F                    *   @C002F:
0000022F                                            .case 'o'
0000022F                    *   @C0030:
0000022F                                            .case 'u'
0000022F                    *   @C0031:
0000022F                                            .case 'x'
0000022F                    *   @C0032:
0000022F                                            .case 'X'
0000022F                    *   @C0033:
0000022F                                                .endc
0000022F  EB2F              *    jmp @C002C
00000231                                            .default
00000231                    *   @C0034:
00000231                                                .gotosw(2:ST_NORMAL)
00000231  E9C4FEFFFF        *    jmp @C000F
00000236                                            .endsw
00000236                    *   @C002A:
00000236  80F936            *    cmp cl, '6'
00000239  74C6              *    je @C002B
0000023B  80F933            *    cmp cl, '3'
0000023E  74D8              *    je @C002D
00000240  80F964            *    cmp cl, 'd'
00000243  74EA              *    je @C002E
00000245  80F969            *    cmp cl, 'i'
00000248  74E5              *    je @C002F
0000024A  80F96F            *    cmp cl, 'o'
0000024D  74E0              *    je @C0030
0000024F  80F975            *    cmp cl, 'u'
00000252  74DB              *    je @C0031
00000254  80F978            *    cmp cl, 'x'
00000257  74D6              *    je @C0032
00000259  80F958            *    cmp cl, 'X'
0000025C  74D1              *    je @C0033
0000025E  EBD1              *    jmp @C0034
00000260                    *   @C002C:
00000260                                            .endc
00000260  EB32              *    jmp @C0027
00000262                                        .case 'h'
00000262                    *   @C0035:
00000262  83CE20                                    or esi,FL_SHORT
00000265                                           .endc
00000265  EB2D              *    jmp @C0027
00000267                                        .case 'w'
00000267                    *   @C0036:
00000267  81CE00080000                              or esi,FL_WIDECHAR
0000026D                                           .endc
0000026D  EB25              *    jmp @C0027
0000026F                                        .endsw
0000026F                    *   @C0024:
0000026F  83F96C            *    cmp ecx, 'l'
00000272  0F8458FFFFFF      *    je @C0025
00000278  83F94C            *    cmp ecx, 'L'
0000027B  0F846DFFFFFF      *    je @C0028
00000281  83F949            *    cmp ecx, 'I'
00000284  0F846FFFFFFF      *    je @C0029
0000028A  83F968            *    cmp ecx, 'h'
0000028D  74D3              *    je @C0035
0000028F  83F977            *    cmp ecx, 'w'
00000292  74D3              *    je @C0036
00000294                    *   @C0027:
00000294                                        .endc
00000294  E9C7030000        *    jmp @C0010
00000299                                    .case ST_TYPE
00000299                    *   @C0037:
00000299  8BC1                                  mov eax,ecx
0000029B                                        .switch eax
0000029B                                        .case 'b'
0000029B  E944020000        *    jmp @C0038
000002A0                    *   @C0039:
000002A0  8B451C                                    mov eax,arglist
000002A3  83451C04                                  add arglist,size_t
000002A7  8B10                                      mov edx,[eax]
000002A9  33C9                                      xor ecx,ecx
000002AB  0FBDCA                                    bsr ecx,edx
000002AE  41                                        inc ecx
000002AF  894DE8                                    mov textlen,ecx
000002B2                                            .repeat
000002B2                    *   @C003A:
000002B2  2BC0                                          sub eax,eax
000002B4  D1EA                                          shr edx,1
000002B6  1430                                          adc al,'0'
000002B8  88840DCFFDFFFF                                mov buffer[ecx-1],al
000002BF                                            .untilcxz
000002BF  49                *    dec ecx
000002C0  75F0              *    jnz @C003A
000002C2  8D85D0FDFFFF                              lea eax,buffer
000002C8  8945D0                                    mov text,eax
000002CB                                           .endc
000002CB  E989020000        *    jmp @C003B
000002D0                                        .case 'C'
000002D0                    *   @C003C:
000002D0                                            .if !( esi & ( FL_SHORT or FL_LONG or FL_WIDECHAR ) )
000002D0  F7C630080000      *   test esi , ( FL_SHORT or FL_LONG or FL_WIDECHAR ) 
000002D6  7506              *   jne @C003D
000002D8  81CE00080000                                  or esi,FL_WIDECHAR
000002DE                                            .endif
000002DE                    *   @C003D:
000002DE                                        .case 'c'
000002DE                    *   @C003E:
000002DE  C745D801000000                            mov bufferiswide,1
000002E5  8B451C                                    mov eax,arglist
000002E8  83451C04                                  add arglist,size_t
000002EC  8B10                                      mov edx,[eax]
000002EE  8895D0FDFFFF                              mov buffer,dl
000002F4  C745E801000000                            mov textlen,1
000002FB  8D85D0FDFFFF                              lea eax,buffer
00000301  8945D0                                    mov text,eax
00000304                                           .endc
00000304  E950020000        *    jmp @C003B
00000309                                        .case 'S';; ISO wide character string
00000309                    *   @C003F:
00000309                                            .if !( esi & ( FL_SHORT or FL_LONG or FL_WIDECHAR ) )
00000309  F7C630080000      *   test esi , ( FL_SHORT or FL_LONG or FL_WIDECHAR ) 
0000030F  7506              *   jne @C0040
00000311  81CE00080000                                  or esi,FL_WIDECHAR
00000317                                            .endif
00000317                    *   @C0040:
00000317                                        .case 's'
00000317                    *   @C0041:
00000317  8B451C                                    mov eax,arglist
0000031A  83451C04                                  add arglist,size_t
0000031E  8B00                                      mov eax,[eax]
00000320  8BCF                                      mov ecx,edi
00000322                                            .if edi == -1
00000322  83FFFF            *   cmp edi , -1
00000325  7505              *   jnz @C0042
00000327  B9FFFFFF7F                                    mov ecx,INT_MAX
0000032C                                            .endif
0000032C                    *   @C0042:
0000032C                                            .if eax == NULL
0000032C  85C0              *   test eax , eax 
0000032E  7506              *   jnz @C0043
00000330  8D0500000000                                  lea eax,__nullstring
00000336                                            .endif
00000336                    *   @C0043:
00000336  8945D0                                    mov text,eax
00000339                                            .repeat
00000339                    *   @C0044:
00000339                                                .break .if BYTE PTR [eax] == 0
00000339  803800            *   cmp BYTE PTR [eax] , 0
0000033C  7404              *   jz  @C0045
0000033E  40                                            inc eax
0000033F                                            .untilcxz
0000033F  49                *    dec ecx
00000340  75F7              *    jnz @C0044
00000342                    *   @C0045:
00000342  2B45D0                                    sub eax,text
00000345  8945E8                                    mov textlen,eax
00000348                                           .endc
00000348  E90C020000        *    jmp @C003B
0000034D                                        .case 'n'
0000034D                    *   @C0046:
0000034D  8B451C                                    mov eax,arglist
00000350  83451C04                                  add arglist,size_t
00000354  8B50FC                                    mov edx,[eax-size_t]
00000357  8B45FC                                    mov eax,charsout
0000035A  8902                                      mov [edx],eax
0000035C                                            .if esi & FL_LONG
0000035C  F7C610000000      *   test esi , FL_LONG
00000362  7407              *   je  @C0047
00000364  C745E001000000                                mov no_output,1
0000036B                                            .endif
0000036B                    *   @C0047:
0000036B                                            .endc
0000036B  E9E9010000        *    jmp @C003B
00000370                                        .case 'd'
00000370                    *   @C0048:
00000370                                        .case 'i';; signed decimal output
00000370                    *   @C0049:
00000370  83CE40                                    or  esi,FL_SIGNED
00000373                                        .case 'u'
00000373                    *   @C004A:
00000373  C745F00A000000                            mov curadix,10
0000037A  EB51                                      jmp COMMON_INT
0000037C                                        .case 'p'
0000037C                    *   @C004B:
0000037C  BF08000000                                mov edi,size_t * 2
00000381                                        .case 'X'
00000381                    *   @C004C:
00000381  C745F807000000                            mov hexoff,'A'-'9'-1
00000388  EB07                                      jmp COMMON_HEX
0000038A                                        .case 'x'
0000038A                    *   @C004D:
0000038A  C745F827000000                            mov hexoff,'a'-'9'-1
00000391                                            COMMON_HEX:
00000391  C745F010000000                            mov curadix,16
00000398                                            .if esi & FL_ALTERNATE
00000398  F7C680000000      *   test esi , FL_ALTERNATE
0000039E  7416              *   je  @C004E
000003A0  B851000000                                    mov eax,'x' - 'a' + '9' + 1
000003A5  0345F8                                        add eax,hexoff
000003A8  C645EE30                                      mov prefix,'0'
000003AC  8845EF                                        mov prefix[1],al
000003AF  C745E402000000                                mov prefixlen,2
000003B6                                            .endif
000003B6                    *   @C004E:
000003B6  EB15                                      jmp COMMON_INT
000003B8                                        .case 'o'
000003B8                    *   @C004F:
000003B8  C745F008000000                            mov curadix,8
000003BF                                            .if esi & FL_ALTERNATE
000003BF  F7C680000000      *   test esi , FL_ALTERNATE
000003C5  7406              *   je  @C0050
000003C7  81CE00020000                                  or esi,FL_FORCEOCTAL
000003CD                                            .endif
000003CD                    *   @C0050:
000003CD                                           COMMON_INT:
000003CD  8B4D1C                                    mov ecx,arglist
000003D0  8B01                                      mov eax,[ecx]
000003D2  33D2                                      xor edx,edx
000003D4                                            .if esi & ( FL_I64 or FL_LONGLONG )
000003D4  F7C600900000      *   test esi , ( FL_I64 or FL_LONGLONG )
000003DA  7406              *   je  @C0051
000003DC  8B5204                                        mov edx,[edx+4]
000003DF  83C104                                        add ecx,size_t
000003E2                                            .endif
000003E2                    *   @C0051:
000003E2  83C104                                    add ecx,size_t
000003E5  894D1C                                    mov arglist,ecx
000003E8                                            .if esi & FL_SHORT
000003E8  F7C620000000      *   test esi , FL_SHORT
000003EE  7412              *   je  @C0052
000003F0                                                .if esi & FL_SIGNED
000003F0  F7C640000000      *   test esi , FL_SIGNED
000003F6  7405              *   je  @C0053
000003F8  0FBFC0                                            movsx eax,ax
000003FB                                                .else
000003FB  EB03              *   jmp @C0054
000003FD                    *   @C0053:
000003FD  0FB7C0                                            movzx eax,ax
00000400                                                .endif
00000400                    *   @C0054:
00000400                                            .elseif esi & FL_SIGNED
00000400  EB29              *   jmp @C0055
00000402                    *   @C0052:
00000402  F7C640000000      *   test esi , FL_SIGNED
00000408  7421              *   je  @C0056
0000040A                                                .if esi & FL_LONGLONG or FL_I64
0000040A  F7C600900000      *   test esi , FL_LONGLONG or FL_I64
00000410  740D              *   je  @C0057
00000412                                                    .ifs edx < 0
00000412  83FA00            *   cmp edx , 0
00000415  7D06              *   jnl @C0058
00000417  81CE00010000                                          or  esi,FL_NEGATIVE
0000041D                                                    .endif
0000041D                    *   @C0058:
0000041D                                                .else
0000041D  EB0C              *   jmp @C0059
0000041F                    *   @C0057:
0000041F                                                    .ifs eax < 0
0000041F  83F800            *   cmp eax , 0
00000422  7D07              *   jnl @C005A
00000424  4A                                                    dec edx
00000425  81CE00010000                                          or  esi,FL_NEGATIVE
0000042B                                                    .endif
0000042B                    *   @C005A:
0000042B                                                .endif
0000042B                    *   @C0059:
0000042B                                            .endif
0000042B                    *   @C0056:
0000042B                    *   @C0055:
0000042B                                            .ifs edi < 0
0000042B  83FF00            *   cmp edi , 0
0000042E  7D07              *   jnl @C005B
00000430  BF01000000                                    mov edi,1
00000435                                            .else
00000435  EB03              *   jmp @C005C
00000437                    *   @C005B:
00000437  83E6F7                                        and esi,NOT FL_LEADZERO
0000043A                                            .endif
0000043A                    *   @C005C:
0000043A  8BC8                                      mov ecx,eax
0000043C  0BCA                                      or  ecx,edx
0000043E                                            .ifz
0000043E  7503              *   jne @C005D
00000440  8945E4                                        mov prefixlen,eax
00000443                                            .endif
00000443                    *   @C005D:
00000443                                            .if esi & FL_SIGNED
00000443  F7C640000000      *   test esi , FL_SIGNED
00000449  7411              *   je  @C005E
0000044B  85D2                                          test edx,edx
0000044D                                                .ifs
0000044D  790D              *   jns @C005F
0000044F  F7D8                                              neg eax
00000451  F7DA                                              neg edx
00000453  83DA00                                            sbb edx,0
00000456  81CE00010000                                      or  esi,FL_NEGATIVE
0000045C                                                .endif
0000045C                    *   @C005F:
0000045C                                            .endif
0000045C                    *   @C005E:
0000045C  8D5DCF                                    lea ebx,buffer[BUFFERSIZE-1]
0000045F                                            .fors ( : eax || edx || edi > 0 : edi-- )
0000045F                    *   @C0060:
0000045F  85C0              *   test eax , eax 
00000461  7509              *   jnz @C0063
00000463                    *   @C0064:
00000463  85D2              *   test edx , edx 
00000465  7505              *   jnz @C0063
00000467                    *   @C0065:
00000467  83FF00            *   cmp edi , 0
0000046A  7E52              *   jng @C0062
0000046C                    *   @C0063:
0000046C                                                .if ( !edx || !curadix )
0000046C  85D2              *   test edx , edx 
0000046E  7406              *   jz  @C0067
00000470                    *   @C0068:
00000470  837DF000          *   cmp curadix , 0
00000474  7509              *   jnz @C0066
00000476                    *   @C0067:
00000476  F775F0                                            div curadix
00000479  8BCA                                              mov ecx,edx
0000047B  33D2                                              xor edx,edx
0000047D                                                .else
0000047D  EB2E              *   jmp @C0069
0000047F                    *   @C0066:
0000047F  56                                                push esi
00000480  57                                                push edi
00000481                                                    .for ( ecx = 64, esi = 0, edi = 0 : ecx : ecx-- )
00000481  B940000000        *   mov ecx, 64
00000486  33F6              *   xor esi, esi
00000488  33FF              *   xor edi, edi
0000048A                    *   @C006A:
0000048A  85C9              *   test ecx, ecx
0000048C  741B              *   jz  @C006C
0000048E  03C0                                                  add eax,eax
00000490  13D2                                                  adc edx,edx
00000492  13F6                                                  adc esi,esi
00000494  13FF                                                  adc edi,edi
00000496                                                        .if ( edi || esi >= curadix )
00000496  85FF              *   test edi , edi 
00000498  7505              *   jnz @C006E
0000049A                    *   @C006F:
0000049A  3B75F0            *   cmp esi , curadix 
0000049D  7207              *   jb  @C006D
0000049F                    *   @C006E:
0000049F  2B75F0                                                    sub esi,curadix
000004A2  83DF00                                                    sbb edi,0
000004A5  40                                                        inc eax
000004A6                                                        .endif
000004A6                    *   @C006D:
000004A6                                                    .endf
000004A6                    *   @C006B:
000004A6  49                *   dec ecx
000004A7  EBE1              *   jmp @C006A
000004A9                    *   @C006C:
000004A9  8BCE                                              mov ecx,esi
000004AB  5F                                                pop edi
000004AC  5E                                                pop esi
000004AD                                                .endif
000004AD                    *   @C0069:
000004AD  83C130                                        add ecx,'0'
000004B0                                                .ifs ( ecx > '9' )
000004B0  83F939            *   cmp ecx , '9' 
000004B3  7E03              *   jng @C0070
000004B5  034DF8                                            add ecx,hexoff
000004B8                                                .endif
000004B8                    *   @C0070:
000004B8  880B                                          mov [ebx],cl
000004BA  4B                                            dec ebx
000004BB                                            .endf
000004BB                    *   @C0061:
000004BB  4F                *   dec edi
000004BC  EBA1              *   jmp @C0060
000004BE                    *   @C0062:
000004BE  8D45CF                                    lea eax,buffer[BUFFERSIZE-1]
000004C1  2BC3                                      sub eax,ebx
000004C3  83C301                                    add ebx,1
000004C6                                            .if esi & FL_FORCEOCTAL
000004C6  F7C600020000      *   test esi , FL_FORCEOCTAL
000004CC  740E              *   je  @C0071
000004CE                                                .if byte ptr [ebx] != '0' || eax == 0
000004CE  803B30            *   cmp byte ptr [ebx] , '0' 
000004D1  7504              *   jnz @C0073
000004D3                    *   @C0074:
000004D3  85C0              *   test eax , eax 
000004D5  7505              *   jnz @C0072
000004D7                    *   @C0073:
000004D7  4B                                                dec ebx
000004D8  C60330                                            mov byte ptr [ebx],'0'
000004DB  40                                                inc eax
000004DC                                                .endif
000004DC                    *   @C0072:
000004DC                                            .endif
000004DC                    *   @C0071:
000004DC  895DD0                                    mov text,ebx
000004DF  8945E8                                    mov textlen,eax
000004E2                                           .endc
000004E2  EB75              *    jmp @C003B
000004E4                                        .endsw
000004E4                    *   @C0038:
000004E4  83F862            *    cmp eax, 'b'
000004E7  0F84B3FDFFFF      *    je @C0039
000004ED  83F843            *    cmp eax, 'C'
000004F0  0F84DAFDFFFF      *    je @C003C
000004F6  83F863            *    cmp eax, 'c'
000004F9  0F84DFFDFFFF      *    je @C003E
000004FF  83F853            *    cmp eax, 'S'
00000502  0F8401FEFFFF      *    je @C003F
00000508  83F873            *    cmp eax, 's'
0000050B  0F8406FEFFFF      *    je @C0041
00000511  83F86E            *    cmp eax, 'n'
00000514  0F8433FEFFFF      *    je @C0046
0000051A  83F864            *    cmp eax, 'd'
0000051D  0F844DFEFFFF      *    je @C0048
00000523  83F869            *    cmp eax, 'i'
00000526  0F8444FEFFFF      *    je @C0049
0000052C  83F875            *    cmp eax, 'u'
0000052F  0F843EFEFFFF      *    je @C004A
00000535  83F870            *    cmp eax, 'p'
00000538  0F843EFEFFFF      *    je @C004B
0000053E  83F858            *    cmp eax, 'X'
00000541  0F843AFEFFFF      *    je @C004C
00000547  83F878            *    cmp eax, 'x'
0000054A  0F843AFEFFFF      *    je @C004D
00000550  83F86F            *    cmp eax, 'o'
00000553  0F845FFEFFFF      *    je @C004F
00000559                    *   @C003B:
00000559                                        .if !no_output
00000559  837DE000          *   cmp no_output, 0
0000055D  0F85C9000000      *   jnz @C0075
00000563                                            .if esi & FL_SIGNED
00000563  F7C640000000      *   test esi , FL_SIGNED
00000569  743D              *   je  @C0076
0000056B                                                .if esi & FL_NEGATIVE
0000056B  F7C600010000      *   test esi , FL_NEGATIVE
00000571  740D              *   je  @C0077
00000573  C645EE2D                                          mov prefix,'-'
00000577  C745E401000000                                    mov prefixlen,1
0000057E                                                .elseif esi & FL_SIGN
0000057E  EB28              *   jmp @C0078
00000580                    *   @C0077:
00000580  F7C601000000      *   test esi , FL_SIGN
00000586  740D              *   je  @C0079
00000588  C645EE2B                                          mov prefix,'+'
0000058C  C745E401000000                                    mov prefixlen,1
00000593                                                .elseif esi & FL_SIGNSP
00000593  EB13              *   jmp @C0078
00000595                    *   @C0079:
00000595  F7C602000000      *   test esi , FL_SIGNSP
0000059B  740B              *   je  @C007A
0000059D  C645EE20                                          mov prefix,' '
000005A1  C745E401000000                                    mov prefixlen,1
000005A8                                                .endif
000005A8                    *   @C007A:
000005A8                    *   @C0078:
000005A8                                            .endif
000005A8                    *   @C0076:
000005A8  8B45DC                                    mov eax,fldwidth
000005AB  2B45E8                                    sub eax,textlen
000005AE  2B45E4                                    sub eax,prefixlen
000005B1  8945D4                                    mov padding,eax
000005B4                                            .if !( esi & ( FL_LEFT or FL_LEADZERO ) )
000005B4  F7C60C000000      *   test esi , ( FL_LEFT or FL_LEADZERO ) 
000005BA  7511              *   jne @C007B
000005BC                    *   invoke write_multi_char, ' ', padding, fp, addr charsout
000005BC  8D45FC            *    lea eax, charsout
000005BF  50                *    push eax
000005C0  FF7514            *    push fp
000005C3  FF75D4            *    push padding
000005C6  6A20              *    push ' '
000005C8  E889FAFFFF        *    call write_multi_char
000005CD                                            .endif
000005CD                    *   @C007B:
000005CD                    *   invoke write_string, addr prefix, prefixlen, fp, addr charsout
000005CD  8D45FC            *    lea eax, charsout
000005D0  50                *    push eax
000005D1  FF7514            *    push fp
000005D4  FF75E4            *    push prefixlen
000005D7  8D45EE            *    lea eax, prefix
000005DA  50                *    push eax
000005DB  E848FAFFFF        *    call write_string
000005E0                                            .if ( ( esi & FL_LEADZERO ) && !( esi & FL_LEFT ) )
000005E0  F7C608000000      *   test esi , FL_LEADZERO 
000005E6  7419              *   je  @C007C
000005E8  F7C604000000      *   test esi , FL_LEFT 
000005EE  7511              *   jne @C007C
000005F0                    *   invoke write_multi_char, '0', padding, fp, addr charsout
000005F0  8D45FC            *    lea eax, charsout
000005F3  50                *    push eax
000005F4  FF7514            *    push fp
000005F7  FF75D4            *    push padding
000005FA  6A30              *    push '0'
000005FC  E855FAFFFF        *    call write_multi_char
00000601                                            .endif
00000601                    *   @C007C:
00000601                    *   invoke write_string, text, textlen, fp, addr charsout
00000601  8D45FC            *    lea eax, charsout
00000604  50                *    push eax
00000605  FF7514            *    push fp
00000608  FF75E8            *    push textlen
0000060B  FF75D0            *    push text
0000060E  E815FAFFFF        *    call write_string
00000613                                            .if esi & FL_LEFT
00000613  F7C604000000      *   test esi , FL_LEFT
00000619  7411              *   je  @C007D
0000061B                    *   invoke write_multi_char, ' ', padding, fp, addr charsout
0000061B  8D45FC            *    lea eax, charsout
0000061E  50                *    push eax
0000061F  FF7514            *    push fp
00000622  FF75D4            *    push padding
00000625  6A20              *    push ' '
00000627  E82AFAFFFF        *    call write_multi_char
0000062C                                            .endif
0000062C                    *   @C007D:
0000062C                                        .endif
0000062C                    *   @C0075:
0000062C                                        .endc
0000062C  EB32              *    jmp @C0010
0000062E                                    .endsw
0000062E                    *   @C000E:
0000062E  83F800            *    cmp eax,0
00000631  7C2D              *    jl  @C0010
00000633  83F807            *    cmp eax,7
00000636  7F28              *    jg  @C0010
00000638  FF248500000000    *    jmp [eax*4+@C007E-(0*4)]
0000063F  90                *   ALIGN dword
00000640                    *   @C007E:
00000640  00000000          *    dword @C000F
00000644  00000000          *    dword @C0011
00000648  00000000          *    dword @C0012
0000064C  00000000          *    dword @C001A
00000650  00000000          *    dword @C001E
00000654  00000000          *    dword @C001F
00000658  00000000          *    dword @C0023
0000065C  00000000          *    dword @C0037
00000660                    *   @C0010:
00000660                                .endif
00000660                    *   @C000D:
00000660                            .endw
00000660  E939FAFFFF        *   jmp @C0009
00000665                    *   @C000A:
00000665  8B45FC                    mov eax,charsout
00000668                            ret
00000668  8BE5              *   mov esp, ebp
0000066A  5D                *   pop ebp
0000066B  5B                *   pop ebx
0000066C  5F                *   pop edi
0000066D  5E                *   pop esi
0000066E  C20C00            *   retn 12
00000671                        _output endp
                                    end
00000671                    *   _TEXT ends


Macros:

                N a m e                 Type

@Environ . . . . . . . . . . . .        Func
CALLBACK . . . . . . . . . . . .        Func
CALLBACKC  . . . . . . . . . . .        Func
OSVER  . . . . . . . . . . . . .        Func
SPVER  . . . . . . . . . . . . .        Func
SUBVER . . . . . . . . . . . . .        Func
UNREFERENCED_PARAMETER . . . . .        Func
_PTR_LD  . . . . . . . . . . . .        Func


Structures and Unions:

                N a m e                 Size/Ofs   Type

_CRT_DOUBLE  . . . . . . . . . .               8 (4)
  x  . . . . . . . . . . . . . .               0   QWord
_CRT_FLOAT . . . . . . . . . . .               4 (4)
  f  . . . . . . . . . . . . . .               0   DWord
_LDBL12  . . . . . . . . . . . .               C (4)
  ld12 . . . . . . . . . . . . .               0   Byte[12]
_LDOUBLE . . . . . . . . . . . .               A (4)
  ld . . . . . . . . . . . . . .               0   Byte[10]
_LONGDOUBLE  . . . . . . . . . .               C (4)
  x  . . . . . . . . . . . . . .               0   TByte
_div_t . . . . . . . . . . . . .               8 (4)
  quot . . . . . . . . . . . . .               0   int_t
  rem  . . . . . . . . . . . . .               4   int_t
_iobuf . . . . . . . . . . . . .              20 (4)
  _ptr . . . . . . . . . . . . .               0   LPTSTR
  _cnt . . . . . . . . . . . . .               4   SINT
  _base  . . . . . . . . . . . .               8   LPSTR
  _flag  . . . . . . . . . . . .               C   SINT
  _file  . . . . . . . . . . . .              10   SINT
  _charbuf . . . . . . . . . . .              14   SINT
  _bufsiz  . . . . . . . . . . .              18   SINT
  _tmpfname  . . . . . . . . . .              1C   LPTSTR
_ldiv_t  . . . . . . . . . . . .               8 (4)
  quot . . . . . . . . . . . . .               0   long_t
  rem  . . . . . . . . . . . . .               4   long_t
_lldiv_t . . . . . . . . . . . .              10 (4)
  quot . . . . . . . . . . . . .               0   int64_t
  rem  . . . . . . . . . . . . .               8   int64_t
_locale_tstruct  . . . . . . . .               8 (4)
  locinfo  . . . . . . . . . . .               0   pthreadlocinfo
  mbcinfo  . . . . . . . . . . .               4   pthreadmbcinfo
array_type . . . . . . . . . . .              20 (4)
  base . . . . . . . . . . . . .               0   string_t
  argv . . . . . . . . . . . . .               4   string_t[7]
locrefcount  . . . . . . . . . .              10 (4)
  locale . . . . . . . . . . . .               0   LPSTR
  wlocale  . . . . . . . . . . .               4   LPWSTR
  refcount . . . . . . . . . . .               8   LPINT
  wrefcount  . . . . . . . . . .               C   LPINT
threadlocinfo  . . . . . . . . .              B8 (4)
  refcount . . . . . . . . . . .               0   SINT
  lc_codepage  . . . . . . . . .               4   UINT
  lc_collate_cp  . . . . . . . .               8   UINT
  lc_time_cp . . . . . . . . . .               C   UINT
  lc_category  . . . . . . . . .              10   locrefcount[6]
  lc_clike . . . . . . . . . . .              70   SINT
  mb_cur_max . . . . . . . . . .              74   SINT
  lconv_intl_refcount  . . . . .              78   LPINT
  lconv_num_refcount . . . . . .              7C   LPINT
  lconv_mon_refcount . . . . . .              80   LPINT
  lconvp . . . . . . . . . . . .              84   PVOID
  ctype1_refcount  . . . . . . .              88   LPINT
  ctype1 . . . . . . . . . . . .              8C   LPSHORT
  pctype . . . . . . . . . . . .              90   LPSHORT
  pclmap . . . . . . . . . . . .              94   LPSTR
  pcumap . . . . . . . . . . . .              98   LPSTR
  lc_time_curr . . . . . . . . .              9C   PVOID
  locale_name  . . . . . . . . .              A0   LPWSTR[6]
threadmbcinfo  . . . . . . . . .             220 (4)
  refcount . . . . . . . . . . .               0   int_t
  mbcodepage . . . . . . . . . .               4   int_t
  ismbcodepage . . . . . . . . .               8   int_t
  mbulinfo . . . . . . . . . . .               C   Word[6]
  mbctype  . . . . . . . . . . .              18   Byte[257]
  mbcasemap  . . . . . . . . . .             119   Byte[256]
  mblocalename . . . . . . . . .             21C   wstring_t
warray_type  . . . . . . . . . .              20 (4)
  base . . . . . . . . . . . . .               0   wstring_t
  argv . . . . . . . . . . . . .               4   wstring_t[7]


Types:

                N a m e                 Size    Attr

?LPQSORTCMD  . . . . . . . . . .           4  Proc L Near32 STDCALL
?_PtFuncCompare  . . . . . . . .           4  Proc L Near32 STDCALL
?_PtFuncCompare_s  . . . . . . .           4  Proc L Near32 STDCALL
?_invalid_parameter_handler  . .           4  Proc L Near32 STDCALL
?_onexit_t . . . . . . . . . . .           4  Proc L Near32 STDCALL
?_purecall_handler . . . . . . .           4  Proc L Near32 STDCALL
FILE . . . . . . . . . . . . . .          32  _iobuf
HANDLE . . . . . . . . . . . . .           4  Near32 Ptr 
LPBYTE . . . . . . . . . . . . .           4  Near32 Ptr Byte
LPDWORD  . . . . . . . . . . . .           4  Near32 Ptr DWord
LPFILE . . . . . . . . . . . . .           4  Near32 Ptr _iobuf
LPINT  . . . . . . . . . . . . .           4  Near32 Ptr DWord
LPQSORTCMD . . . . . . . . . . .           4  Near32 Ptr 
LPQWORD  . . . . . . . . . . . .           4  Near32 Ptr QWord
LPSHORT  . . . . . . . . . . . .           4  Near32 Ptr Word
LPSTR  . . . . . . . . . . . . .           4  Near32 Ptr Byte
LPTSTR . . . . . . . . . . . . .           4  Near32 Ptr Byte
LPWORD . . . . . . . . . . . . .           4  Near32 Ptr Word
LPWSTR . . . . . . . . . . . . .           4  Near32 Ptr Word
PTBYTE . . . . . . . . . . . . .           4  Near32 Ptr Byte
PTCHAR . . . . . . . . . . . . .           4  Near32 Ptr Byte
PVOID  . . . . . . . . . . . . .           4  Near32 Ptr 
SINT . . . . . . . . . . . . . .           4  DWord
SIZE_T . . . . . . . . . . . . .           4  DWord
TCHAR  . . . . . . . . . . . . .           1  Byte
UINT . . . . . . . . . . . . . .           4  DWord
ULONG  . . . . . . . . . . . . .           4  DWord
_PtFuncCompare . . . . . . . . .           4  Near32 Ptr 
_PtFuncCompare_s . . . . . . . .           4  Near32 Ptr 
_invalid_parameter_handler . . .           4  Near32 Ptr 
_locale_t  . . . . . . . . . . .           4  Near32 Ptr _locale_tstruct
_onexit_t  . . . . . . . . . . .           4  Near32 Ptr 
_purecall_handler  . . . . . . .           4  Near32 Ptr 
array_t  . . . . . . . . . . . .           4  Near32 Ptr array_type
bool . . . . . . . . . . . . . .           4  DWord
char_t . . . . . . . . . . . . .           1  Byte
double_t . . . . . . . . . . . .           8  QWord
errno_t  . . . . . . . . . . . .           4  DWord
float_t  . . . . . . . . . . . .           4  DWord
half_t . . . . . . . . . . . . .           2  Word
int128_t . . . . . . . . . . . .          16  XmmWord
int16_t  . . . . . . . . . . . .           2  Word
int32_t  . . . . . . . . . . . .           4  DWord
int64_t  . . . . . . . . . . . .           8  QWord
int8_t . . . . . . . . . . . . .           1  Byte
int_t  . . . . . . . . . . . . .           4  DWord
intptr_t . . . . . . . . . . . .           4  DWord
ldouble_t  . . . . . . . . . . .          10  TByte
long_t . . . . . . . . . . . . .           4  DWord
onexit_t . . . . . . . . . . . .           4  Near32 Ptr 
pthreadlocinfo . . . . . . . . .           4  Near32 Ptr threadlocinfo
pthreadmbcinfo . . . . . . . . .           4  Near32 Ptr threadmbcinfo
ptr_t  . . . . . . . . . . . . .           4  Near32 Ptr 
qfloat_t . . . . . . . . . . . .          16  XmmWord
short_t  . . . . . . . . . . . .           2  Word
size_t . . . . . . . . . . . . .           4  DWord
string_t . . . . . . . . . . . .           4  Near32 Ptr Byte
uchar_t  . . . . . . . . . . . .           1  Byte
uint128_t  . . . . . . . . . . .          16  XmmWord
uint16_t . . . . . . . . . . . .           2  Word
uint32_t . . . . . . . . . . . .           4  DWord
uint64_t . . . . . . . . . . . .           8  QWord
uint8_t  . . . . . . . . . . . .           1  Byte
uint_t . . . . . . . . . . . . .           4  DWord
uintptr_t  . . . . . . . . . . .           4  DWord
ulong_t  . . . . . . . . . . . .           4  DWord
ushort_t . . . . . . . . . . . .           2  Word
ustring_t  . . . . . . . . . . .           4  Near32 Ptr Byte
warray_t . . . . . . . . . . . .           4  Near32 Ptr warray_type
wchar_t  . . . . . . . . . . . .           2  Word
wctype_t . . . . . . . . . . . .           2  Word
wint_t . . . . . . . . . . . . .           2  Word
wstring_t  . . . . . . . . . . .           4  Near32 Ptr Word


Segments and Groups:

                N a m e                 Size     Length   Align   Combine Class

.debug$S . . . . . . . . . . . .        32 Bit   0000149C Byte    Private 'CODE'
.debug$T . . . . . . . . . . . .        32 Bit   0000095C Byte    Private 'CODE'
FLAT . . . . . . . . . . . . . .        GROUP
_DATA  . . . . . . . . . . . . .        32 Bit   00000061 Para    Public  'DATA'
_TEXT  . . . . . . . . . . . . .        32 Bit   00000671 Para    Public  'CODE'


Procedures, parameters and locals:

                N a m e                 Type     Value    Segment  Length

___mb_cur_max_func . . . . . . .        P Near32 00000000 No Seg   *X *External STDCALL
___mb_cur_max_l_func . . . . . .        P Near32 00000000 No Seg   *X *External STDCALL
__acrt_iob_func  . . . . . . . .        P Near32 00000000 No Seg   *X *External STDCALL
__doserrno . . . . . . . . . . .        P Near32 00000000 No Seg   *X *External STDCALL
__getmainargs  . . . . . . . . .        P Near32 00000000 No Seg   *X *External STDCALL
__iob_func . . . . . . . . . . .        P Near32 00000000 No Seg   *X *External STDCALL
__sys_errlist  . . . . . . . . .        P Near32 00000000 No Seg   *X *External STDCALL
__sys_nerr . . . . . . . . . . .        P Near32 00000000 No Seg   *X *External STDCALL
__wgetmainargs . . . . . . . . .        P Near32 00000000 No Seg   *X *External STDCALL
_abs64 . . . . . . . . . . . . .        P Near32 00000000 No Seg   *X *External STDCALL
_aligned_free  . . . . . . . . .        P Near32 00000000 No Seg   *X *External STDCALL
_aligned_malloc  . . . . . . . .        P Near32 00000000 No Seg   *X *External STDCALL
_aligned_msize . . . . . . . . .        P Near32 00000000 No Seg   *X *External STDCALL
_aligned_offset_malloc . . . . .        P Near32 00000000 No Seg   *X *External STDCALL
_aligned_offset_realloc  . . . .        P Near32 00000000 No Seg   *X *External STDCALL
_aligned_offset_recalloc . . . .        P Near32 00000000 No Seg   *X *External STDCALL
_aligned_realloc . . . . . . . .        P Near32 00000000 No Seg   *X *External STDCALL
_aligned_recalloc  . . . . . . .        P Near32 00000000 No Seg   *X *External STDCALL
_atodbl  . . . . . . . . . . . .        P Near32 00000000 No Seg   *X *External STDCALL
_atodbl_l  . . . . . . . . . . .        P Near32 00000000 No Seg   *X *External STDCALL
_atof_l  . . . . . . . . . . . .        P Near32 00000000 No Seg   *X *External STDCALL
_atoflt  . . . . . . . . . . . .        P Near32 00000000 No Seg   *X *External STDCALL
_atoflt_l  . . . . . . . . . . .        P Near32 00000000 No Seg   *X *External STDCALL
_atoi128 . . . . . . . . . . . .        P Near32 00000000 No Seg   *X *External STDCALL
_atoi64  . . . . . . . . . . . .        P Near32 00000000 No Seg   *X *External STDCALL
_atoi64_l  . . . . . . . . . . .        P Near32 00000000 No Seg   *X *External STDCALL
_atoi_l  . . . . . . . . . . . .        P Near32 00000000 No Seg   *X *External STDCALL
_atol_l  . . . . . . . . . . . .        P Near32 00000000 No Seg   *X *External STDCALL
_atoldbl . . . . . . . . . . . .        P Near32 00000000 No Seg   *X *External STDCALL
_atoldbl_l . . . . . . . . . . .        P Near32 00000000 No Seg   *X *External STDCALL
_atoll_l . . . . . . . . . . . .        P Near32 00000000 No Seg   *X *External STDCALL
_beep  . . . . . . . . . . . . .        P Near32 00000000 No Seg   *X *External STDCALL
_dosmaperr . . . . . . . . . . .        P Near32 00000000 No Seg   *X *External STDCALL
_dupenv_s  . . . . . . . . . . .        P Near32 00000000 No Seg   *X *External STDCALL
_ecvt  . . . . . . . . . . . . .        P Near32 00000000 No Seg   *X *External STDCALL
_ecvt_s  . . . . . . . . . . . .        P Near32 00000000 No Seg   *X *External STDCALL
_errno . . . . . . . . . . . . .        P Near32 00000000 No Seg   *X *External STDCALL
_exit  . . . . . . . . . . . . .        P Near32 00000000 No Seg   *X *External STDCALL
_fcvt  . . . . . . . . . . . . .        P Near32 00000000 No Seg   *X *External STDCALL
_fcvt_s  . . . . . . . . . . . .        P Near32 00000000 No Seg   *X *External STDCALL
_fgetwchar . . . . . . . . . . .        P Near32 00000000 No Seg   *X *External STDCALL
_filbuf  . . . . . . . . . . . .        P Near32 00000000 No Seg   *X *External STDCALL
_fileno  . . . . . . . . . . . .        P Near32 00000000 No Seg   *X *External STDCALL
_filwbuf . . . . . . . . . . . .        P Near32 00000000 No Seg   *X *External STDCALL
_flsbuf  . . . . . . . . . . . .        P Near32 00000000 No Seg   *X *External STDCALL
_flswbuf . . . . . . . . . . . .        P Near32 00000000 No Seg   *X *External STDCALL
_flushall  . . . . . . . . . . .        P Near32 00000000 No Seg   *X *External STDCALL
_fputchar  . . . . . . . . . . .        P Near32 00000000 No Seg   *X *External STDCALL
_fputwchar . . . . . . . . . . .        P Near32 00000000 No Seg   *X *External STDCALL
_freebuf . . . . . . . . . . . .        P Near32 00000000 No Seg   *X *External STDCALL
_ftbuf . . . . . . . . . . . . .        P Near32 00000000 No Seg   *X *External STDCALL
_fullpath  . . . . . . . . . . .        P Near32 00000000 No Seg   *X *External STDCALL
_gcvt  . . . . . . . . . . . . .        P Near32 00000000 No Seg   *X *External STDCALL
_gcvt_s  . . . . . . . . . . . .        P Near32 00000000 No Seg   *X *External STDCALL
_get_doserrno  . . . . . . . . .        P Near32 00000000 No Seg   *X *External STDCALL
_get_errno . . . . . . . . . . .        P Near32 00000000 No Seg   *X *External STDCALL
_get_fmode . . . . . . . . . . .        P Near32 00000000 No Seg   *X *External STDCALL
_get_invalid_parameter_handler .        P Near32 00000000 No Seg   *X *External STDCALL
_get_pgmptr  . . . . . . . . . .        P Near32 00000000 No Seg   *X *External STDCALL
_get_purecall_handler  . . . . .        P Near32 00000000 No Seg   *X *External STDCALL
_get_wpgmptr . . . . . . . . . .        P Near32 00000000 No Seg   *X *External STDCALL
_getbuf  . . . . . . . . . . . .        P Near32 00000000 No Seg   *X *External STDCALL
_getst . . . . . . . . . . . . .        P Near32 00000000 No Seg   *X *External STDCALL
_getws . . . . . . . . . . . . .        P Near32 00000000 No Seg   *X *External STDCALL
_i64toa  . . . . . . . . . . . .        P Near32 00000000 No Seg   *X *External STDCALL
_i64toa_s  . . . . . . . . . . .        P Near32 00000000 No Seg   *X *External STDCALL
_i64tow  . . . . . . . . . . . .        P Near32 00000000 No Seg   *X *External STDCALL
_i64tow_s  . . . . . . . . . . .        P Near32 00000000 No Seg   *X *External STDCALL
_itoa  . . . . . . . . . . . . .        P Near32 00000000 No Seg   *X *External STDCALL
_itoa_s  . . . . . . . . . . . .        P Near32 00000000 No Seg   *X *External STDCALL
_itow  . . . . . . . . . . . . .        P Near32 00000000 No Seg   *X *External STDCALL
_itow_s  . . . . . . . . . . . .        P Near32 00000000 No Seg   *X *External STDCALL
_ltoa  . . . . . . . . . . . . .        P Near32 00000000 No Seg   *X *External STDCALL
_ltoa_s  . . . . . . . . . . . .        P Near32 00000000 No Seg   *X *External STDCALL
_ltow  . . . . . . . . . . . . .        P Near32 00000000 No Seg   *X *External STDCALL
_ltow_s  . . . . . . . . . . . .        P Near32 00000000 No Seg   *X *External STDCALL
_makepath  . . . . . . . . . . .        P Near32 00000000 No Seg   *X *External STDCALL
_makepath_s  . . . . . . . . . .        P Near32 00000000 No Seg   *X *External STDCALL
_mblen_l . . . . . . . . . . . .        P Near32 00000000 No Seg   *X *External STDCALL
_mbstowcs_s_l  . . . . . . . . .        P Near32 00000000 No Seg   *X *External STDCALL
_mbstrlen  . . . . . . . . . . .        P Near32 00000000 No Seg   *X *External STDCALL
_mbstrlen_l  . . . . . . . . . .        P Near32 00000000 No Seg   *X *External STDCALL
_mbstrnlen . . . . . . . . . . .        P Near32 00000000 No Seg   *X *External STDCALL
_mbstrnlen_l . . . . . . . . . .        P Near32 00000000 No Seg   *X *External STDCALL
_mbtowc_l  . . . . . . . . . . .        P Near32 00000000 No Seg   *X *External STDCALL
_onexit  . . . . . . . . . . . .        P Near32 00000000 No Seg   *X *External STDCALL
_openfile  . . . . . . . . . . .        P Near32 00000000 No Seg   *X *External STDCALL
_output  . . . . . . . . . . . .        P Near   0000007D _TEXT    *X Public   STDCALL
  fp . . . . . . . . . . . . . .        Near32            ebp + 0014
  format . . . . . . . . . . . .        Near32            ebp + 0018
  arglist  . . . . . . . . . . .        Near32            ebp + 001C
  charsout . . . . . . . . . . .        DWord             ebp - 0004
  hexoff . . . . . . . . . . . .        DWord             ebp - 0008
  state  . . . . . . . . . . . .        DWord             ebp - 000C
  curadix  . . . . . . . . . . .        DWord             ebp - 0010
  prefix . . . . . . . . . . . .        Byte[2]           ebp - 0012
  textlen  . . . . . . . . . . .        DWord             ebp - 0018
  prefixlen  . . . . . . . . . .        DWord             ebp - 001C
  no_output  . . . . . . . . . .        DWord             ebp - 0020
  fldwidth . . . . . . . . . . .        DWord             ebp - 0024
  bufferiswide . . . . . . . . .        DWord             ebp - 0028
  padding  . . . . . . . . . . .        DWord             ebp - 002C
  text . . . . . . . . . . . . .        Near32            ebp - 0030
  buffer . . . . . . . . . . . .        Byte[512]         ebp - 0230
  @C0028 . . . . . . . . . . . .        L Near   000001EE _TEXT
  @C0029 . . . . . . . . . . . .        L Near   000001F9 _TEXT
  @C0059 . . . . . . . . . . . .        L Near   0000042B _TEXT
  @C0058 . . . . . . . . . . . .        L Near   0000041D _TEXT
  @C0020 . . . . . . . . . . . .        L Near   000001BB _TEXT
  @C0055 . . . . . . . . . . . .        L Near   0000042B _TEXT
  @C0021 . . . . . . . . . . . .        L Near   000001B9 _TEXT
  @C0054 . . . . . . . . . . . .        L Near   00000400 _TEXT
  @C0022 . . . . . . . . . . . .        L Near   000001C6 _TEXT
  @C0057 . . . . . . . . . . . .        L Near   0000041F _TEXT
  @C0023 . . . . . . . . . . . . . .        L Near   000001CB _TEXT
  @C0056 . . . . . . . . . . . . . .        L Near   0000042B _TEXT
  @C0024 . . . . . . . . . . . .        L Near   0000026F _TEXT
  @C0051 . . . . . . . . . . . .        L Near   000003E2 _TEXT
  @C0025 . . . . . . . . . . . .        L Near   000001D0 _TEXT
  @C0050 . . . . . . . . . . . .        L Near   000003CD _TEXT
  @C0026 . . . . . . . . . . . .        L Near   000001E0 _TEXT
  @C0053 . . . . . . . . . . . .        L Near   000003FD _TEXT
  @C0027 . . . . . . . . . . . .        L Near   00000294 _TEXT
  @C0052 . . . . . . . . . . . .        L Near   00000402 _TEXT
  @C0077 . . . . . . . . . . .        L Near   00000580 _TEXT
  @C0076 . . . . . . . . . . . .        L Near   000005A8 _TEXT
  @C0075 . . . . . . . . . . . .        L Near   0000062C _TEXT
  @C0074 . . . . . . . . . . . .        L Near   000004D3 _TEXT
  @C0073 . . . . . . . . . . . .        L Near   000004D7 _TEXT
  @C0072  . . . . . . . . . . .        L Near   000004DC _TEXT
  @C0071 . . . . . . . . . . . .        L Near   000004DC _TEXT
  @C0070 . . . . . . . . . . . .        L Near   000004B8 _TEXT
  @C0079 . . . . . . . . . . . .        L Near   00000595 _TEXT
  @C0078 . . . . . . . . . . . .        L Near   000005A8 _TEXT
  @C000F . . . . . . . . . . . . .        L Near   000000FA _TEXT
  @C000D . . . . . . . . . . . .        L Near   00000660 _TEXT
  @C000E . . . . . . . . . . . .        L Near   0000062E _TEXT
  @C000B . . . . . . . . . . . .        L Near   000000D7 _TEXT
  COMMON_INT . . . . . . . . . . . .        L Near   000003CD _TEXT
  @C000C . . . . . . . . . . . .        L Near   000000D9 _TEXT
  @C000A . . . . . . . . . . . .        L Near   00000665 _TEXT
  @C005E . . . . . . . . . . . .        L Near   0000045C _TEXT
  @C002A . . . . . . . . . . . .        L Near   00000236 _TEXT
  @C005D . . . . . . . . . . . .        L Near   00000443 _TEXT
  @C002B . . . . . . . . . . . .        L Near   00000201 _TEXT
  @C002C . . . . . . . . . . . .        L Near   00000260 _TEXT
  @C005F . . . . . . . . . . . .        L Near   0000045C _TEXT
  @C002D . . . . . . . . . . . .        L Near   00000218 _TEXT
  @C005A . . . . . . . . . . . .        L Near   0000042B _TEXT
  @C002E . . . . . . . . . . . .        L Near   0000022F _TEXT
  @C002F . . . . . . . . . . . .        L Near   0000022F _TEXT
  @C005C . . . . . . . . . . . .        L Near   0000043A _TEXT
  @C005B . . . . . . . . . . . .        L Near   00000437 _TEXT
  @C0009 . . . . . . . . . . . .        L Near   0000009E _TEXT
  @C007E . . . . . . . . . . . .        L Near   00000640 _TEXT
  @C007D . . . . . . . . . . . .        L Near   0000062C _TEXT
  @C007C . . . . . . . . . . . .        L Near   00000601 _TEXT
  @C007B . . . . . . . . . . . .        L Near   000005CD _TEXT
  @C007A . . . . . . . . . . . .        L Near   000005A8 _TEXT
  @C001A  . . . . . . . . . . . .        L Near   0000016C _TEXT
  @C001C . . . . . . . . . . . .        L Near   00000184 _TEXT
  @C0048 . . . . . . . . . . . .        L Near   00000370 _TEXT
  @C001B . . . . . . . . . . . .        L Near   00000189 _TEXT
  @C0049 . . . . . . . . . . . .        L Near   00000370 _TEXT
  @C001E . . . . . . . . . . . .        L Near   0000019A _TEXT
  @C001D . . . . . . . . . . . .        L Near   00000195 _TEXT
  @C001F . . . . . . . . . . .        L Near   000001A1 _TEXT
  @C0042 . . . . . . . . . . . .        L Near   0000032C _TEXT
  @C0043 . . . . . . . . . . . .        L Near   00000336 _TEXT
  @C0040 . . . . . . . . . . . .        L Near   00000317 _TEXT
  @C0041 . . . . . . . . . . . .        L Near   00000317 _TEXT
  @C0046 . . . . . . . . . . . .        L Near   0000034D _TEXT
  @C0047 . . . . . . . . . . . .        L Near   0000036B _TEXT
  @C0044 . . . . . . . . . . . .        L Near   00000339 _TEXT
  @C0045 . . . . . . . . . . . .        L Near   00000342 _TEXT
  @C003C . . . . . . . . . . . .        L Near   000002D0 _TEXT
  @C003B . . . . . . . . . . . .        L Near   00000559 _TEXT
  @C003A . . . . . . . . . . . .        L Near   000002B2 _TEXT
  @C003F . . . . . . . . . . . .        L Near   00000309 _TEXT
  @C003E . . . . . . . . .        L Near   000002DE _TEXT
  @C003D . . . . . . . . . . . .        L Near   000002DE _TEXT
  @C0064 . . . . . . . . . . . .        L Near   00000463 _TEXT
  @C0065 . . . . . . . . . . . .        L Near   00000467 _TEXT
  @C0066 . . . . . . . . . . . .        L Near   0000047F _TEXT
  @C0067 . . . . . . . . . . . .        L Near   00000476 _TEXT
  @C0060 . . . . . . . . . . . .        L Near   0000045F _TEXT
  @C0061 . . . . . . . . . . . .        L Near   000004BB _TEXT
  @C0062 . . . . . . . . . . . .        L Near   000004BE _TEXT
  @C0063 . . . . . . . . . . . .        L Near   0000046C _TEXT
  @C0068 . . . . . . . . . . . .        L Near   00000470 _TEXT
  @C0069 . . . . . . . . . . . .        L Near   000004AD _TEXT
  @C0011 . . . . . . . . . . . .        L Near   00000113 _TEXT
  @C0010 . . . . . . . . . . . .        L Near   00000660 _TEXT
  @C0013 . . . . . . . . . . . .        L Near   0000014E _TEXT
  @C0012 . . . . . . . . . . . .        L Near   0000012D _TEXT
  @C0015 . . . . . . . . . . . .        L Near   00000167 _TEXT
  @C0014 . . . . . . . . . . . .        L Near   00000132 _TEXT
  @C0017 . . . . . . . . . . . .        L Near   0000013C _TEXT
  @C0016 . . . . . . . . . . . .        L Near   00000137 _TEXT
  @C0019 . . . . . . . . . . . .        L Near   00000149 _TEXT
  @C004B . . . . . . . . . . . .        L Near   0000037C _TEXT
  @C0018 . . . . . . . . . . . .        L Near   00000144 _TEXT
  @C004C . . . . . . . . . . . .        L Near   00000381 _TEXT
  @C004A . . . . . . . . . . . .        L Near   00000373 _TEXT
  @C004F . . . . . . . . . . . .        L Near   000003B8 _TEXT
  @C004D . . . . . . . . . . . .        L Near   0000038A _TEXT
  @C004E . . . . . . . . . . . .        L Near   000003B6 _TEXT
  @C006D . . . . . . . . . . . .        L Near   000004A6 _TEXT
  @C006E . . . . . . . . . . . .        L Near   0000049F _TEXT
  @C006F . . . . . . . . . . . .        L Near   0000049A _TEXT
  @C006A . . . . . . . . . . . .        L Near   0000048A _TEXT
  @C006B . . . . . . . . . . . .        L Near   000004A6 _TEXT
  @C006C . . . . . . . . . . . .        L Near   000004A9 _TEXT
  @C0039 . . . . . . . . . . . .        L Near   000002A0 _TEXT
  @C0038 . . . . . . . . . . . .        L Near   000004E4 _TEXT
  @C0033 . . . . . . . . . . . .        L Near   0000022F _TEXT
  @C0032 . . . . . . . . . . . .        L Near   0000022F _TEXT
  @C0031 . . . . . . . . . . . .        L Near   0000022F _TEXT
  @C0030 . . . . . . . . . . . .        L Near   0000022F _TEXT
  @C0037 . . . . . . . . . . . .        L Near   00000299 _TEXT
  COMMON_HEX . . . . . . . . . . . .        L Near   00000391 _TEXT
  @C0036 . . . . . . . . . . . .        L Near   00000267 _TEXT
  @C0035 . . . . . . . . . . . .        L Near   00000262 _TEXT
  @C0034 . . . . . . . . . . . .        L Near   00000231 _TEXT
_putenv  . . . . . . . . . . . .        P Near32 00000000 No Seg   *X *External STDCALL
_putenv_s  . . . . . . . . . . .        P Near32 00000000 No Seg   *X *External STDCALL
_putws . . . . . . . . . . . . .        P Near32 00000000 No Seg   *X *External STDCALL
_recalloc  . . . . . . . . . . .        P Near32 00000000 No Seg   *X *External STDCALL
_searchenv_s . . . . . . . . . .        P Near32 00000000 No Seg   *X *External STDCALL
_set_abort_behavior  . . . . . .        P Near32 00000000 No Seg   *X *External STDCALL
_set_doserrno  . . . . . . . . .        P Near32 00000000 No Seg   *X *External STDCALL
_set_errno . . . . . . . . . . .        P Near32 00000000 No Seg   *X *External STDCALL
_set_error_mode  . . . . . . . .        P Near32 00000000 No Seg   *X *External STDCALL
_set_fmode . . . . . . . . . . .        P Near32 00000000 No Seg   *X *External STDCALL
_set_invalid_parameter_handler .        P Near32 00000000 No Seg   *X *External STDCALL
_set_purecall_handler  . . . . .        P Near32 00000000 No Seg   *X *External STDCALL
_seterrormode  . . . . . . . . .        P Near32 00000000 No Seg   *X *External STDCALL
_sleep . . . . . . . . . . . . .        P Near32 00000000 No Seg   *X *External STDCALL
_snwprintf . . . . . . . . . . .        P Near32 00000000 No Seg   *X *External C
_splitpath . . . . . . . . . . .        P Near32 00000000 No Seg   *X *External STDCALL
_splitpath_s . . . . . . . . . .        P Near32 00000000 No Seg   *X *External STDCALL
_stbuf . . . . . . . . . . . . .        P Near32 00000000 No Seg   *X *External STDCALL
_strtod_l  . . . . . . . . . . .        P Near32 00000000 No Seg   *X *External STDCALL
_strtof_l  . . . . . . . . . . .        P Near32 00000000 No Seg   *X *External STDCALL
_strtoi64  . . . . . . . . . . .        P Near32 00000000 No Seg   *X *External STDCALL
_strtoi64_l  . . . . . . . . . .        P Near32 00000000 No Seg   *X *External STDCALL
_strtol_l  . . . . . . . . . . .        P Near32 00000000 No Seg   *X *External STDCALL
_strtold . . . . . . . . . . . .        P Near32 00000000 No Seg   *X *External STDCALL
_strtold_l . . . . . . . . . . .        P Near32 00000000 No Seg   *X *External STDCALL
_strtoll_l . . . . . . . . . . .        P Near32 00000000 No Seg   *X *External STDCALL
_strtoq  . . . . . . . . . . . .        P Near32 00000000 No Seg   *X *External STDCALL
_strtoui64 . . . . . . . . . . .        P Near32 00000000 No Seg   *X *External STDCALL
_strtoui64_l . . . . . . . . . .        P Near32 00000000 No Seg   *X *External STDCALL
_strtoul_l . . . . . . . . . . .        P Near32 00000000 No Seg   *X *External STDCALL
_strtoull_l  . . . . . . . . . .        P Near32 00000000 No Seg   *X *External STDCALL
_swab  . . . . . . . . . . . . .        P Near32 00000000 No Seg   *X *External STDCALL
_ui64toa . . . . . . . . . . . .        P Near32 00000000 No Seg   *X *External STDCALL
_ui64toa_s . . . . . . . . . . .        P Near32 00000000 No Seg   *X *External STDCALL
_ui64tow . . . . . . . . . . . .        P Near32 00000000 No Seg   *X *External STDCALL
_ui64tow_s . . . . . . . . . . .        P Near32 00000000 No Seg   *X *External STDCALL
_ultoa . . . . . . . . . . . . .        P Near32 00000000 No Seg   *X *External STDCALL
_ultoa_s . . . . . . . . . . . .        P Near32 00000000 No Seg   *X *External STDCALL
_ultow . . . . . . . . . . . . .        P Near32 00000000 No Seg   *X *External STDCALL
_ultow_s . . . . . . . . . . . .        P Near32 00000000 No Seg   *X *External STDCALL
_vsnprintf . . . . . . . . . . .        P Near32 00000000 No Seg   *X *External STDCALL
_vsnwprintf  . . . . . . . . . .        P Near32 00000000 No Seg   *X *External STDCALL
_wcstod_l  . . . . . . . . . . .        P Near32 00000000 No Seg   *X *External STDCALL
_wcstof_l  . . . . . . . . . . .        P Near32 00000000 No Seg   *X *External STDCALL
_wcstoi64  . . . . . . . . . . .        P Near32 00000000 No Seg   *X *External STDCALL
_wcstoi64_l  . . . . . . . . . .        P Near32 00000000 No Seg   *X *External STDCALL
_wcstol_l  . . . . . . . . . . .        P Near32 00000000 No Seg   *X *External STDCALL
_wcstold_l . . . . . . . . . . .        P Near32 00000000 No Seg   *X *External STDCALL
_wcstoll_l . . . . . . . . . . .        P Near32 00000000 No Seg   *X *External STDCALL
_wcstombs_s_l  . . . . . . . . .        P Near32 00000000 No Seg   *X *External STDCALL
_wcstoui64 . . . . . . . . . . .        P Near32 00000000 No Seg   *X *External STDCALL
_wcstoui64_l . . . . . . . . . .        P Near32 00000000 No Seg   *X *External STDCALL
_wcstoul_l . . . . . . . . . . .        P Near32 00000000 No Seg   *X *External STDCALL
_wcstoull_l  . . . . . . . . . .        P Near32 00000000 No Seg   *X *External STDCALL
_wctomb_l  . . . . . . . . . . .        P Near32 00000000 No Seg   *X *External STDCALL
_wctomb_s_l  . . . . . . . . . .        P Near32 00000000 No Seg   *X *External STDCALL
_wdupenv_s . . . . . . . . . . .        P Near32 00000000 No Seg   *X *External STDCALL
_wfdopen . . . . . . . . . . . .        P Near32 00000000 No Seg   *X *External STDCALL
_wfopen  . . . . . . . . . . . .        P Near32 00000000 No Seg   *X *External STDCALL
_wfreopen  . . . . . . . . . . .        P Near32 00000000 No Seg   *X *External STDCALL
_wfsopenproto  . . . . . . . . .        P Near32 00000000 No Seg   *X *External STDCALL
_wfullpath . . . . . . . . . . .        P Near32 00000000 No Seg   *X *External STDCALL
_wgetenv . . . . . . . . . . . .        P Near32 00000000 No Seg   *X *External STDCALL
_wgetenv_s . . . . . . . . . . .        P Near32 00000000 No Seg   *X *External STDCALL
_wmakepath_s . . . . . . . . . .        P Near32 00000000 No Seg   *X *External STDCALL
_woutput . . . . . . . . . . . .        P Near32 00000000 No Seg   *X *External STDCALL
_wperror . . . . . . . . . . . .        P Near32 00000000 No Seg   *X *External STDCALL
_wpopen  . . . . . . . . . . . .        P Near32 00000000 No Seg   *X *External STDCALL
_wputenv . . . . . . . . . . . .        P Near32 00000000 No Seg   *X *External STDCALL
_wputenv_s . . . . . . . . . . .        P Near32 00000000 No Seg   *X *External STDCALL
_wremove . . . . . . . . . . . .        P Near32 00000000 No Seg   *X *External STDCALL
_wsearchenv_s  . . . . . . . . .        P Near32 00000000 No Seg   *X *External STDCALL
_wsplitpath  . . . . . . . . . .        P Near32 00000000 No Seg   *X *External STDCALL
_wsplitpath_s  . . . . . . . . .        P Near32 00000000 No Seg   *X *External STDCALL
_wsystem . . . . . . . . . . . .        P Near32 00000000 No Seg   *X *External STDCALL
_wtempnam  . . . . . . . . . . .        P Near32 00000000 No Seg   *X *External STDCALL
_wtmpnam . . . . . . . . . . . .        P Near32 00000000 No Seg   *X *External STDCALL
_wtof  . . . . . . . . . . . . .        P Near32 00000000 No Seg   *X *External STDCALL
_wtof_l  . . . . . . . . . . . .        P Near32 00000000 No Seg   *X *External STDCALL
_wtoi  . . . . . . . . . . . . .        P Near32 00000000 No Seg   *X *External STDCALL
_wtoi64  . . . . . . . . . . . .        P Near32 00000000 No Seg   *X *External STDCALL
_wtoi64_l  . . . . . . . . . . .        P Near32 00000000 No Seg   *X *External STDCALL
_wtoi_l  . . . . . . . . . . . .        P Near32 00000000 No Seg   *X *External STDCALL
_wtol  . . . . . . . . . . . . .        P Near32 00000000 No Seg   *X *External STDCALL
_wtol_l  . . . . . . . . . . . .        P Near32 00000000 No Seg   *X *External STDCALL
_wtoll . . . . . . . . . . . . .        P Near32 00000000 No Seg   *X *External STDCALL
_wtoll_l . . . . . . . . . . . .        P Near32 00000000 No Seg   *X *External STDCALL
_xtoa  . . . . . . . . . . . . .        P Near32 00000000 No Seg   *X *External STDCALL
_xtoa_s  . . . . . . . . . . . .        P Near32 00000000 No Seg   *X *External STDCALL
_xtow  . . . . . . . . . . . . .        P Near32 00000000 No Seg   *X *External STDCALL
_xtow_s  . . . . . . . . . . . .        P Near32 00000000 No Seg   *X *External STDCALL
abort  . . . . . . . . . . . . .        P Near32 00000000 No Seg   *X *External STDCALL
abs  . . . . . . . . . . . . . .        P Near32 00000000 No Seg   *X *External STDCALL
atexit . . . . . . . . . . . . .        P Near32 00000000 No Seg   *X *External STDCALL
atof . . . . . . . . . . . . . .        P Near32 00000000 No Seg   *X *External STDCALL
atoi . . . . . . . . . . . . . .        P Near32 00000000 No Seg   *X *External STDCALL
atol . . . . . . . . . . . . . .        P Near32 00000000 No Seg   *X *External STDCALL
atoll  . . . . . . . . . . . . .        P Near32 00000000 No Seg   *X *External STDCALL
bsearch  . . . . . . . . . . . .        P Near32 00000000 No Seg   *X *External STDCALL
bsearch_s  . . . . . . . . . . .        P Near32 00000000 No Seg   *X *External STDCALL
calloc . . . . . . . . . . . . .        P Near32 00000000 No Seg   *X *External STDCALL
ecvt . . . . . . . . . . . . . .        P Near32 00000000 No Seg   *X *External STDCALL
exit . . . . . . . . . . . . . .        P Near32 00000000 No Seg   *X *External STDCALL
fclose . . . . . . . . . . . . .        P Near32 00000000 No Seg   *X *External STDCALL
fcvt . . . . . . . . . . . . . .        P Near32 00000000 No Seg   *X *External STDCALL
feof . . . . . . . . . . . . . .        P Near32 00000000 No Seg   *X *External STDCALL
fflush . . . . . . . . . . . . .        P Near32 00000000 No Seg   *X *External STDCALL
fgetc  . . . . . . . . . . . . .        P Near32 00000000 No Seg   *X *External STDCALL
fgets  . . . . . . . . . . . . .        P Near32 00000000 No Seg   *X *External STDCALL
fgetwc . . . . . . . . . . . . .        P Near32 00000000 No Seg   *X *External STDCALL
fgetws . . . . . . . . . . . . .        P Near32 00000000 No Seg   *X *External STDCALL
fopen  . . . . . . . . . . . . .        P Near32 00000000 No Seg   *X *External STDCALL
fopen_s  . . . . . . . . . . . .        P Near32 00000000 No Seg   *X *External STDCALL
fprintf  . . . . . . . . . . . .        P Near32 00000000 No Seg   *X *External C
fputc  . . . . . . . . . . . . .        P Near32 00000000 No Seg   *X *External STDCALL
fputs  . . . . . . . . . . . . .        P Near32 00000000 No Seg   *X *External STDCALL
fputwc . . . . . . . . . . . . .        P Near32 00000000 No Seg   *X *External STDCALL
fputws . . . . . . . . . . . . .        P Near32 00000000 No Seg   *X *External STDCALL
fread  . . . . . . . . . . . . .        P Near32 00000000 No Seg   *X *External STDCALL
free . . . . . . . . . . . . . .        P Near32 00000000 No Seg   *X *External STDCALL
fseek  . . . . . . . . . . . . .        P Near32 00000000 No Seg   *X *External STDCALL
ftell  . . . . . . . . . . . . .        P Near32 00000000 No Seg   *X *External STDCALL
ftobufin . . . . . . . . . . . .        P Near32 00000000 No Seg   *X *External C
fwprintf . . . . . . . . . . . .        P Near32 00000000 No Seg   *X *External C
fwrite . . . . . . . . . . . . .        P Near32 00000000 No Seg   *X *External STDCALL
fwscanf  . . . . . . . . . . . .        P Near32 00000000 No Seg   *X *External C
gcvt . . . . . . . . . . . . . .        P Near32 00000000 No Seg   *X *External STDCALL
getc . . . . . . . . . . . . . .        P Near32 00000000 No Seg   *X *External STDCALL
getchar  . . . . . . . . . . . .        P Near32 00000000 No Seg   *X *External STDCALL
getenv . . . . . . . . . . . . .        P Near32 00000000 No Seg   *X *External STDCALL
getenv_s . . . . . . . . . . . .        P Near32 00000000 No Seg   *X *External STDCALL
getwc  . . . . . . . . . . . . .        P Near32 00000000 No Seg   *X *External STDCALL
getwchar . . . . . . . . . . . .        P Near32 00000000 No Seg   *X *External STDCALL
itoa . . . . . . . . . . . . . .        P Near32 00000000 No Seg   *X *External STDCALL
labs . . . . . . . . . . . . . .        P Near32 00000000 No Seg   *X *External STDCALL
ldiv . . . . . . . . . . . . . .        P Near32 00000000 No Seg   *X *External STDCALL
llabs  . . . . . . . . . . . . .        P Near32 00000000 No Seg   *X *External STDCALL
lldiv  . . . . . . . . . . . . .        P Near32 00000000 No Seg   *X *External STDCALL
ltoa . . . . . . . . . . . . . .        P Near32 00000000 No Seg   *X *External STDCALL
malloc . . . . . . . . . . . . .        P Near32 00000000 No Seg   *X *External STDCALL
mblen  . . . . . . . . . . . . .        P Near32 00000000 No Seg   *X *External STDCALL
mbstowcs . . . . . . . . . . . .        P Near32 00000000 No Seg   *X *External STDCALL
mbstowcs_s . . . . . . . . . . .        P Near32 00000000 No Seg   *X *External STDCALL
mbtowc . . . . . . . . . . . . .        P Near32 00000000 No Seg   *X *External STDCALL
onexit . . . . . . . . . . . . .        P Near32 00000000 No Seg   *X *External STDCALL
osmaperr . . . . . . . . . . . .        P Near32 00000000 No Seg   *X *External STDCALL
perror . . . . . . . . . . . . .        P Near32 00000000 No Seg   *X *External STDCALL
printf . . . . . . . . . . . . .        P Near32 00000000 No Seg   *X *External C
putenv . . . . . . . . . . . . .        P Near32 00000000 No Seg   *X *External STDCALL
puts . . . . . . . . . . . . . .        P Near32 00000000 No Seg   *X *External STDCALL
putwc  . . . . . . . . . . . . .        P Near32 00000000 No Seg   *X *External STDCALL
putwchar . . . . . . . . . . . .        P Near32 00000000 No Seg   *X *External STDCALL
qsort  . . . . . . . . . . . . .        P Near32 00000000 No Seg   *X *External STDCALL
qsort_s  . . . . . . . . . . . .        P Near32 00000000 No Seg   *X *External STDCALL
rand . . . . . . . . . . . . . .        P Near32 00000000 No Seg   *X *External STDCALL
realloc  . . . . . . . . . . . .        P Near32 00000000 No Seg   *X *External STDCALL
rewind . . . . . . . . . . . . .        P Near32 00000000 No Seg   *X *External STDCALL
scanf  . . . . . . . . . . . . .        P Near32 00000000 No Seg   *X *External C
setargv  . . . . . . . . . . . .        P Near32 00000000 No Seg   *X *External STDCALL
setbuf . . . . . . . . . . . . .        P Near32 00000000 No Seg   *X *External STDCALL
setvbuf  . . . . . . . . . . . .        P Near32 00000000 No Seg   *X *External STDCALL
setwargv . . . . . . . . . . . .        P Near32 00000000 No Seg   *X *External STDCALL
sprintf  . . . . . . . . . . . .        P Near32 00000000 No Seg   *X *External C
srand  . . . . . . . . . . . . .        P Near32 00000000 No Seg   *X *External STDCALL
strtod . . . . . . . . . . . . .        P Near32 00000000 No Seg   *X *External STDCALL
strtof . . . . . . . . . . . . .        P Near32 00000000 No Seg   *X *External STDCALL
strtol . . . . . . . . . . . . .        P Near32 00000000 No Seg   *X *External STDCALL
strtold  . . . . . . . . . . . .        P Near32 00000000 No Seg   *X *External STDCALL
strtoll  . . . . . . . . . . . .        P Near32 00000000 No Seg   *X *External STDCALL
strtoqd  . . . . . . . . . . . .        P Near32 00000000 No Seg   *X *External STDCALL
strtoul  . . . . . . . . . . . .        P Near32 00000000 No Seg   *X *External STDCALL
strtoull . . . . . . . . . . . .        P Near32 00000000 No Seg   *X *External STDCALL
swab . . . . . . . . . . . . . .        P Near32 00000000 No Seg   *X *External STDCALL
swprintf . . . . . . . . . . . .        P Near32 00000000 No Seg   *X *External C
swprintf_s . . . . . . . . . . .        P Near32 00000000 No Seg   *X *External C
swscanf  . . . . . . . . . . . .        P Near32 00000000 No Seg   *X *External C
swscanf_s  . . . . . . . . . . .        P Near32 00000000 No Seg   *X *External C
system . . . . . . . . . . . . .        P Near32 00000000 No Seg   *X *External STDCALL
ultoa  . . . . . . . . . . . . .        P Near32 00000000 No Seg   *X *External STDCALL
ungetc . . . . . . . . . . . . .        P Near32 00000000 No Seg   *X *External STDCALL
ungetwc  . . . . . . . . . . . .        P Near32 00000000 No Seg   *X *External STDCALL
vfprintf . . . . . . . . . . . .        P Near32 00000000 No Seg   *X *External STDCALL
vfwprintf  . . . . . . . . . . .        P Near32 00000000 No Seg   *X *External STDCALL
vsprintf . . . . . . . . . . . .        P Near32 00000000 No Seg   *X *External STDCALL
vswprintf  . . . . . . . . . . .        P Near32 00000000 No Seg   *X *External STDCALL
vwprintf . . . . . . . . . . . .        P Near32 00000000 No Seg   *X *External STDCALL
wcstod . . . . . . . . . . . . .        P Near32 00000000 No Seg   *X *External STDCALL
wcstof . . . . . . . . . . . . .        P Near32 00000000 No Seg   *X *External STDCALL
wcstol . . . . . . . . . . . . .        P Near32 00000000 No Seg   *X *External STDCALL
wcstold  . . . . . . . . . . . .        P Near32 00000000 No Seg   *X *External STDCALL
wcstoll  . . . . . . . . . . . .        P Near32 00000000 No Seg   *X *External STDCALL
wcstombs_s . . . . . . . . . . .        P Near32 00000000 No Seg   *X *External STDCALL
wcstoul  . . . . . . . . . . . .        P Near32 00000000 No Seg   *X *External STDCALL
wcstoull . . . . . . . . . . . .        P Near32 00000000 No Seg   *X *External STDCALL
wctomb . . . . . . . . . . . . .        P Near32 00000000 No Seg   *X *External STDCALL
wctomb_s . . . . . . . . . . . .        P Near32 00000000 No Seg   *X *External STDCALL
wprintf  . . . . . . . . . . . .        P Near32 00000000 No Seg   *X *External C
write_char . . . . . . . . . . .        P Near   00000000 _TEXT    *X Private  STDCALL
  char . . . . . . . . . . . . .        DWord             ebp + 0008
  fp . . . . . . . . . . . . . .        Near32            ebp + 000C
  pnumwritten  . . . . . . . . .        Near32            ebp + 0010
  @C0002 . . . . . . . . . . . .        L Near   00000024 _TEXT
  @C0001 . . . . . . . . . . . .        L Near   0000001A _TEXT
write_multi_char . . . . . . . .        P Near   00000056 _TEXT    *X Private  STDCALL
  char . . . . . . . . . . . . .        DWord             ebp + 000C
  num  . . . . . . . . . . . . .        DWord             ebp + 0010
  fp . . . . . . . . . . . . . .        Near32            ebp + 0014
  pnumwritten  . . . . . . . . .        Near32            ebp + 0018
  @C0008 . . . . . . . . . . . .        L Near   00000078 _TEXT
  @C0006 . . . . . . . . . . . .        L Near   0000005D _TEXT
  @C0007 . . . . . . . . . . . .        L Near   00000075 _TEXT
write_string . . . . . . . . . .        P Near   00000028 _TEXT    *X Private  STDCALL
  string . . . . . . . . . . . .        Near32            ebp + 0010
  len  . . . . . . . . . . . . .        DWord             ebp + 0014
  fp . . . . . . . . . . . . . .        Near32            ebp + 0018
  pnumwritten  . . . . . . . . .        Near32            ebp + 001C
  @C0004  . . . . . . . . . . . . .        L Near   0000004D _TEXT
  @C0005 . . . . . . . . . . . .        L Near   00000050 _TEXT
  @C0003 . . . . . . . . . . . .        L Near   00000033 _TEXT
wscanf . . . . . . . . . . . . .        P Near32 00000000 No Seg   *X *External C


Symbols:

                N a m e                 Type       Value     Attr

$$000000 . . . . . . . . . . . .        Byte               0h _TEXT STDCALL
@CodeSize  . . . . . . . . . . .        Number             0h 
@DataSize  . . . . . . . . . . .        Number             0h 
@Interface . . . . . . . . . . .        Number             3h 
@Model . . . . . . . . . . . . .        Number             7h 
@code  . . . . . . . . . . . . .        Text   _TEXT
@data  . . . . . . . . . . . . .        Text   FLAT
@stack . . . . . . . . . . . . .        Text   FLAT
BUFFERSIZE . . . . . . . . . . .        Number           200h 
CHAR_BIT . . . . . . . . . . . .        Number             8h 
CHAR_MAX . . . . . . . . . . . .        Number            7Fh 
CHAR_MIN . . . . . . . . . . . .        Number     -00000080h 
DBG_UNREFERENCED_LOCAL_VARIABLE         Text   UNREFERENCED_PARAMETER
DBG_UNREFERENCED_PARAMETER . . .        Text   UNREFERENCED_PARAMETER
EOF  . . . . . . . . . . . . . .        Number     -00000001h 
FALSE  . . . . . . . . . . . . .        Number             0h 
FILENAME_MAX . . . . . . . . . .        Number           104h 
FL_ALTERNATE . . . . . . . . . .        Number            80h 
FL_CAPEXP  . . . . . . . . . . .        Number         10000h 
FL_FORCEOCTAL  . . . . . . . . .        Number           200h 
FL_I64 . . . . . . . . . . . . .        Number          8000h 
FL_LEADZERO  . . . . . . . . . .        Number             8h 
FL_LEFT  . . . . . . . . . . . .        Number             4h 
FL_LONG  . . . . . . . . . . . .        Number            10h 
FL_LONGDOUBLE  . . . . . . . . .        Number           400h 
FL_LONGLONG  . . . . . . . . . .        Number          1000h 
FL_NEGATIVE  . . . . . . . . . .        Number           100h 
FL_SHORT . . . . . . . . . . . .        Number            20h 
FL_SIGN  . . . . . . . . . . . .        Number             1h 
FL_SIGNED  . . . . . . . . . . .        Number            40h 
FL_SIGNSP  . . . . . . . . . . .        Number             2h 
FL_WIDECHAR  . . . . . . . . . .        Number           800h 
INT_MAX  . . . . . . . . . . . .        Number      7FFFFFFFh 
INT_MIN  . . . . . . . . . . . .        Number     -80000000h 
LLONG_MAX  . . . . . . . . . . .        Text   9223372036854775807
LLONG_MIN  . . . . . . . . . . .        Number      8000000000000000h 
LONGDOUBLE_IS_DOUBLE . . . . . .        Number             0h 
LONG_IS_INT  . . . . . . . . . .        Number             1h 
LONG_MAX . . . . . . . . . . . .        Number      7FFFFFFFh 
LONG_MIN . . . . . . . . . . . .        Number     -80000000h 
MB_CUR_MAX . . . . . . . . . . .        Text   __mb_cur_max
MB_LEN_MAX . . . . . . . . . . .        Number             2h 
NTDDI_LONGHORN . . . . . . . . .        Number       6000000h 
NTDDI_VERSION  . . . . . . . . .        Number       6010000h 
NTDDI_VISTA  . . . . . . . . . .        Number       6000000h 
NTDDI_VISTASP1 . . . . . . . . .        Number       6000100h 
NTDDI_VISTASP2 . . . . . . . . .        Number       6000200h 
NTDDI_VISTASP3 . . . . . . . . .        Number       6000300h 
NTDDI_VISTASP4 . . . . . . . . .        Number       6000400h 
NTDDI_WIN10  . . . . . . . . . .        Number       A000000h 
NTDDI_WIN10_19H1 . . . . . . . .        Number       A000007h 
NTDDI_WIN10_MN . . . . . . . . .        Number       A000009h 
NTDDI_WIN10_RS1  . . . . . . . .        Number       A000002h 
NTDDI_WIN10_RS2  . . . . . . . .        Number       A000003h 
NTDDI_WIN10_RS3  . . . . . . . .        Number       A000004h 
NTDDI_WIN10_RS4  . . . . . . . .        Number       A000005h 
NTDDI_WIN10_RS5  . . . . . . . .        Number       A000006h 
NTDDI_WIN10_TH2  . . . . . . . .        Number       A000001h 
NTDDI_WIN10_VB . . . . . . . . .        Number       A000008h 
NTDDI_WIN2003  . . . . . . . . .        Number       5000000h 
NTDDI_WIN2K  . . . . . . . . . .        Number       5000000h 
NTDDI_WIN2KSP1 . . . . . . . . .        Number       5000100h 
NTDDI_WIN2KSP2 . . . . . . . . .        Number       5000200h 
NTDDI_WIN2KSP3 . . . . . . . . .        Number       5000300h 
NTDDI_WIN2KSP4 . . . . . . . . .        Number       5000400h 
NTDDI_WIN6 . . . . . . . . . . .        Number       6000000h 
NTDDI_WIN6SP1  . . . . . . . . .        Number       6000100h 
NTDDI_WIN6SP2  . . . . . . . . .        Number       6000200h 
NTDDI_WIN6SP3  . . . . . . . . .        Number       6000300h 
NTDDI_WIN6SP4  . . . . . . . . .        Number       6000400h 
NTDDI_WIN7 . . . . . . . . . . .        Number       6010000h 
NTDDI_WIN7SP1  . . . . . . . . .        Number       6010100h 
NTDDI_WIN8 . . . . . . . . . . .        Number       6020000h 
NTDDI_WINBLUE  . . . . . . . . .        Number       6030000h 
NTDDI_WINTHRESHOLD . . . . . . .        Number       A000000h 
NTDDI_WINXP  . . . . . . . . . .        Number       5010000h 
NTDDI_WINXPSP1 . . . . . . . . .        Number       5010100h 
NTDDI_WINXPSP2 . . . . . . . . .        Number       5010200h 
NTDDI_WINXPSP3 . . . . . . . . .        Number       5010300h 
NTDDI_WINXPSP4 . . . . . . . . .        Number       5010400h 
NTDDI_WS03 . . . . . . . . . . .        Number       5020000h 
NTDDI_WS03SP1  . . . . . . . . .        Number       5020100h 
NTDDI_WS03SP2  . . . . . . . . .        Number       5020200h 
NTDDI_WS03SP3  . . . . . . . . .        Number       5020300h 
NTDDI_WS03SP4  . . . . . . . . .        Number       5020400h 
NTDDI_WS08 . . . . . . . . . . .        Number       6000100h 
NTDDI_WS08SP2  . . . . . . . . .        Number       6000200h 
NTDDI_WS08SP3  . . . . . . . . .        Number       6000300h 
NTDDI_WS08SP4  . . . . . . . . .        Number       6000400h 
NULL . . . . . . . . . . . . . .        Number             0h 
OSVERSION_MASK . . . . . . . . .        Number      FFFF0000h 
PSAPI_VERSION  . . . . . . . . .        Number             0h 
PTR_IS_INT . . . . . . . . . . .        Number             1h 
PTR_IS_LONG  . . . . . . . . . .        Number             1h 
RAND_MAX . . . . . . . . . . . .        Number          7FFFh 
SCHAR_MAX  . . . . . . . . . . .        Number            7Fh 
SCHAR_MIN  . . . . . . . . . . .        Number     -00000080h 
SEEK_CUR . . . . . . . . . . . .        Number             1h 
SEEK_END . . . . . . . . . . . .        Number             2h 
SEEK_SET . . . . . . . . . . . .        Number             0h 
SHORT_IS_INT . . . . . . . . . .        Number             0h 
SHRT_MAX . . . . . . . . . . . .        Number          7FFFh 
SHRT_MIN . . . . . . . . . . . .        Number     -00008000h 
SIZE_MAX . . . . . . . . . . . .        Number      FFFFFFFFh 
SPVERSION_MASK . . . . . . . . .        Number          FF00h 
ST_DOT . . . . . . . . . . . . .        Number             4h 
ST_FLAG  . . . . . . . . . . . .        Number             2h 
ST_NORMAL  . . . . . . . . . . .        Number             0h 
ST_PERCENT . . . . . . . . . . .        Number             1h 
ST_PRECIS  . . . . . . . . . . .        Number             5h 
ST_SIZE  . . . . . . . . . . . .        Number             6h 
ST_TYPE  . . . . . . . . . . . .        Number             7h 
ST_WIDTH . . . . . . . . . . . .        Number             3h 
SUBVERSION_MASK  . . . . . . . .        Number            FFh 
TRUE . . . . . . . . . . . . . .        Number             1h 
UCHAR_MAX  . . . . . . . . . . .        Number            FFh 
UINT_MAX . . . . . . . . . . . .        Number      FFFFFFFFh 
ULLONG_MAX . . . . . . . . . . .        Number     -00000001h 
ULONG_MAX  . . . . . . . . . . .        Number      FFFFFFFFh 
USHRT_MAX  . . . . . . . . . . .        Number          FFFFh 
WDK_NTDDI_VERSION  . . . . . . .        Number       A000008h 
WINAPI . . . . . . . . . . . . .        Text   stdcall
WINVER . . . . . . . . . . . . .        Number           601h 
_CALLBACK_DEFINED  . . . . . . .        Number             0h 
_CALL_REPORTFAULT  . . . . . . .        Number             2h 
_CRT_ALGO_DEFINED  . . . . . . .        Number             0h 
_CRT_ALLOCATION_DEFINED  . . . .        Number             0h 
_CRT_DOUBLE_DEC  . . . . . . . .        Number             0h 
_CRT_ERRNO_DEFINED . . . . . . .        Number             0h 
_CRT_PERROR_DEFINED  . . . . . .        Number             0h 
_CRT_SYSTEM_DEFINED  . . . . . .        Number             0h 
_CRT_TERMINATE_DEFINED . . . . .        Number             0h 
_CRT_WPERROR_DEFINED . . . . . .        Number             0h 
_CRT_WSYSTEM_DEFINED . . . . . .        Number             0h 
_CVTBUFSIZE  . . . . . . . . . .        Number           15Dh 
_DIV_T_DEFINED . . . . . . . . .        Number             0h 
_ERRNO_T_DEFINED . . . . . . . .        Number             0h 
_FILE_DEFINED  . . . . . . . . .        Number             0h 
_I16_MAX . . . . . . . . . . . .        Number          7FFFh 
_I16_MIN . . . . . . . . . . . .        Number     -00008000h 
_I32_MAX . . . . . . . . . . . .        Number      7FFFFFFFh 
_I32_MIN . . . . . . . . . . . .        Number     -80000000h 
_I64_MAX . . . . . . . . . . . .        Text   9223372036854775807
_I64_MIN . . . . . . . . . . . .        Number      8000000000000000h 
_I8_MAX  . . . . . . . . . . . .        Number            7Fh 
_I8_MIN  . . . . . . . . . . . .        Number     -00000080h 
_INC_SDKDDKVER . . . . . . . . .        Number             0h 
_INTEGRAL_MAX_BITS . . . . . . .        Number            40h 
_INTIOBUF  . . . . . . . . . . .        Number          1000h 
_INTPTR_T_DEFINED  . . . . . . .        Number             0h 
_IOCOMMIT  . . . . . . . . . . .        Number          4000h 
_IOCTRLZ . . . . . . . . . . . .        Number          2000h 
_IOEOF . . . . . . . . . . . . .        Number            10h 
_IOERR . . . . . . . . . . . . .        Number            20h 
_IOFBF . . . . . . . . . . . . .        Number             0h 
_IOFEOF  . . . . . . . . . . . .        Number           800h 
_IOFLRTN . . . . . . . . . . . .        Number          1000h 
_IOLBF . . . . . . . . . . . . .        Number            40h 
_IOMYBUF . . . . . . . . . . . .        Number             8h 
_IONBF . . . . . . . . . . . . .        Number             4h 
_IOREAD  . . . . . . . . . . . .        Number             1h 
_IORW  . . . . . . . . . . . . .        Number            80h 
_IOSETVBUF . . . . . . . . . . .        Number           400h 
_IOSTRG  . . . . . . . . . . . .        Number            40h 
_IOWRT . . . . . . . . . . . . .        Number             2h 
_IOYOURBUF . . . . . . . . . . .        Number           100h 
_MAXIOBUF  . . . . . . . . . . .        Number          4000h 
_MAX_DIR . . . . . . . . . . . .        Number           100h 
_MAX_DRIVE . . . . . . . . . . .        Number             3h 
_MAX_ENV . . . . . . . . . . . .        Number          7FFFh 
_MAX_EXT . . . . . . . . . . . .        Number           100h 
_MAX_FNAME . . . . . . . . . . .        Number           100h 
_MAX_PATH  . . . . . . . . . . .        Number           104h 
_MINIOBUF  . . . . . . . . . . .        Number           200h 
_MSC_FULL_VER  . . . . . . . . .        Number       A21FE80h 
_MSC_VER . . . . . . . . . . . .        Number           6A4h 
_M_IX86  . . . . . . . . . . . .        Number           258h 
_NSTREAM_  . . . . . . . . . . .        Number            14h 
_NT_TARGET_VERSION_WIN10_RS4 . .        Number           A05h 
_ONEXIT_T_DEFINED  . . . . . . .        Number             0h 
_OUT_TO_DEFAULT  . . . . . . . .        Number             0h 
_OUT_TO_MSGBOX . . . . . . . . .        Number             2h 
_OUT_TO_STDERR . . . . . . . . .        Number             1h 
_REGS6432  . . . . . . . . . . .        Number             0h 
_REPORT_ERRMODE  . . . . . . . .        Number             3h 
_TCHAR_DEFINED . . . . . . . . .        Number             0h 
_THREADLOCALEINFO  . . . . . . .        Number             0h 
_THREADMBCINFO . . . . . . . . .        Number             0h 
_UI16_MAX  . . . . . . . . . . .        Number          FFFFh 
_UI32_MAX  . . . . . . . . . . .        Number      FFFFFFFFh 
_UI64_MAX  . . . . . . . . . . .        Number     -00000001h 
_UI8_MAX . . . . . . . . . . . .        Number            FFh 
_UINTPTR_T_DEFINED . . . . . . .        Number             0h 
_WCHAR_T_DEFINED . . . . . . . .        Number             0h 
_WCTYPE_T_DEFINED  . . . . . . .        Number             0h 
_WIN32 . . . . . . . . . . . . .        Number             0h 
_WIN32_IE  . . . . . . . . . . .        Number           800h 
_WIN32_IE_IE100  . . . . . . . .        Number           A00h 
_WIN32_IE_IE110  . . . . . . . .        Number           A00h 
_WIN32_IE_IE20 . . . . . . . . .        Number           200h 
_WIN32_IE_IE30 . . . . . . . . .        Number           300h 
_WIN32_IE_IE302  . . . . . . . .        Number           302h 
_WIN32_IE_IE40 . . . . . . . . .        Number           400h 
_WIN32_IE_IE401  . . . . . . . .        Number           401h 
_WIN32_IE_IE50 . . . . . . . . .        Number           500h 
_WIN32_IE_IE501  . . . . . . . .        Number           501h 
_WIN32_IE_IE55 . . . . . . . . .        Number           550h 
_WIN32_IE_IE60 . . . . . . . . .        Number           600h 
_WIN32_IE_IE60SP1  . . . . . . .        Number           601h 
_WIN32_IE_IE60SP2  . . . . . . .        Number           603h 
_WIN32_IE_IE70 . . . . . . . . .        Number           700h 
_WIN32_IE_IE80 . . . . . . . . .        Number           800h 
_WIN32_IE_IE90 . . . . . . . . .        Number           900h 
_WIN32_IE_LONGHORN . . . . . . .        Number           700h 
_WIN32_IE_NT4  . . . . . . . . .        Number           200h 
_WIN32_IE_NT4SP1 . . . . . . . .        Number           200h 
_WIN32_IE_NT4SP2 . . . . . . . .        Number           200h 
_WIN32_IE_NT4SP3 . . . . . . . .        Number           302h 
_WIN32_IE_NT4SP4 . . . . . . . .        Number           401h 
_WIN32_IE_NT4SP5 . . . . . . . .        Number           401h 
_WIN32_IE_NT4SP6 . . . . . . . .        Number           500h 
_WIN32_IE_WIN10  . . . . . . . .        Number           A00h 
_WIN32_IE_WIN2K  . . . . . . . .        Number           501h 
_WIN32_IE_WIN2KSP1 . . . . . . .        Number           501h 
_WIN32_IE_WIN2KSP2 . . . . . . .        Number           501h 
_WIN32_IE_WIN2KSP3 . . . . . . .        Number           501h 
_WIN32_IE_WIN2KSP4 . . . . . . .        Number           501h 
_WIN32_IE_WIN6 . . . . . . . . .        Number           700h 
_WIN32_IE_WIN7 . . . . . . . . .        Number           800h 
_WIN32_IE_WIN8 . . . . . . . . .        Number           A00h 
_WIN32_IE_WIN98  . . . . . . . .        Number           401h 
_WIN32_IE_WIN98SE  . . . . . . .        Number           500h 
_WIN32_IE_WINBLUE  . . . . . . .        Number           A00h 
_WIN32_IE_WINME  . . . . . . . .        Number           550h 
_WIN32_IE_WINTHRESHOLD . . . . .        Number           A00h 
_WIN32_IE_WS03 . . . . . . . . .        Number           602h 
_WIN32_IE_WS03SP1  . . . . . . .        Number           603h 
_WIN32_IE_XP . . . . . . . . . .        Number           600h 
_WIN32_IE_XPSP1  . . . . . . . .        Number           601h 
_WIN32_IE_XPSP2  . . . . . . . .        Number           603h 
_WIN32_WINDOWS . . . . . . . . .        Number           410h 
_WIN32_WINNT . . . . . . . . . .        Number           601h 
_WIN32_WINNT_LONGHORN  . . . . .        Number           600h 
_WIN32_WINNT_NT4 . . . . . . . .        Number           400h 
_WIN32_WINNT_VISTA . . . . . . .        Number           600h 
_WIN32_WINNT_WIN10 . . . . . . .        Number           A00h 
_WIN32_WINNT_WIN10_RS1 . . . . .        Number           A02h 
_WIN32_WINNT_WIN10_RS2 . . . . .        Number           A03h 
_WIN32_WINNT_WIN10_RS3 . . . . .        Number           A04h 
_WIN32_WINNT_WIN10_RS4 . . . . .        Number           A05h 
_WIN32_WINNT_WIN10_RS5 . . . . .        Number           A06h 
_WIN32_WINNT_WIN10_TH2 . . . . .        Number           A01h 
_WIN32_WINNT_WIN2K . . . . . . .        Number           500h 
_WIN32_WINNT_WIN6  . . . . . . .        Number           600h 
_WIN32_WINNT_WIN7  . . . . . . .        Number           601h 
_WIN32_WINNT_WIN8  . . . . . . .        Number           602h 
_WIN32_WINNT_WINBLUE . . . . . .        Number           603h 
_WIN32_WINNT_WINTHRESHOLD  . . .        Number           A00h 
_WIN32_WINNT_WINXP . . . . . . .        Number           501h 
_WIN32_WINNT_WS03  . . . . . . .        Number           502h 
_WIN32_WINNT_WS08  . . . . . . .        Number           600h 
_WINNT_WINNT . . . . . . . . . .        Number           601h 
_WRITE_ABORT_MSG . . . . . . . .        Number             1h 
_WSTDIO_DEFINED  . . . . . . . .        Number             0h 
_WSTDLIBP_DEFINED  . . . . . . .        Number             0h 
_WSTDLIB_DEFINED . . . . . . . .        Number             0h 
_X86_  . . . . . . . . . . . . .        Number             0h 
__BMP__  . . . . . . . . . . . .        Text   
__Cdecl  . . . . . . . . . . . .        Text   c
__Ctype  . . . . . . . . . . . .        Text   stdcall
__LIBC_INC . . . . . . . . . . .        Number             0h 
__LIBC__ . . . . . . . . . . . .        Number            EAh 
__STDC_WANT_SECURE_LIB__ . . . .        Number             1h 
__STDC__ . . . . . . . . . . . .        Number             0h 
__STDIO_INC  . . . . . . . . . .        Number             0h 
__STDLIB_INC . . . . . . . . . .        Number             0h 
__THREADLOCALEINFO_INC . . . . .        Number             0h 
__argc . . . . . . . . . . . . .        DWord              0h *External STDCALL
__argv . . . . . . . . . . . . .        Near32             0h *External STDCALL
__cdecl  . . . . . . . . . . . .        Text   stdcall
__lookuptable  . . . . . . . . .        Byte[89]           8h _DATA STDCALL
__mb_cur_max . . . . . . . . . .        DWord              0h *External STDCALL
__nullstring . . . . . . . . . .        Byte[8]            0h _DATA STDCALL
__wargv  . . . . . . . . . . . .        Near32             0h *External STDCALL
_bufin . . . . . . . . . . . . .        Byte               0h *External STDCALL
_countof . . . . . . . . . . . .        Text   lengthof
_doserrno  . . . . . . . . . . .        DWord              0h *External STDCALL
_environ . . . . . . . . . . . .        Near32             0h *External STDCALL
_fmode . . . . . . . . . . . . .        DWord              0h *External STDCALL
_iob . . . . . . . . . . . . . .        _iobuf             0h *External STDCALL
_osfhnd  . . . . . . . . . . . .        Near32             0h *External STDCALL
_pgmptr  . . . . . . . . . . . .        Near32             0h *External STDCALL
_sys_errlist . . . . . . . . . .        Near32             0h *External STDCALL
_sys_nerr  . . . . . . . . . . .        DWord              0h *External STDCALL
_wenviron  . . . . . . . . . . .        Near32             0h *External STDCALL
_wpgmptr . . . . . . . . . . . .        Near32             0h *External STDCALL
errno  . . . . . . . . . . . . .        DWord              0h *External STDCALL
false  . . . . . . . . . . . . .        Number             0h 
nullptr  . . . . . . . . . . . .        Number             0h 
rax  . . . . . . . . . . . . . .        Text   eax
rbp  . . . . . . . . . . . . . .        Text   ebp
rbx  . . . . . . . . . . . . . .        Text   ebx
rcx  . . . . . . . . . . . . . .        Text   ecx
rdi  . . . . . . . . . . . . . .        Text   edi
rdx  . . . . . . . . . . . . . .        Text   edx
rsi  . . . . . . . . . . . . . .        Text   esi
rsp  . . . . . . . . . . . . . .        Text   esp
stderr . . . . . . . . . . . . .        Near32             0h *External STDCALL
stdin  . . . . . . . . . . . . .        Near32             0h *External STDCALL
stdout . . . . . . . . . . . . .        Near32             0h *External STDCALL
true . . . . . . . . . . . . . .        Number             1h 

